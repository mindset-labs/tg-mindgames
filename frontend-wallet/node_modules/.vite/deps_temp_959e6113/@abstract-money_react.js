import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

"use client";
import {
  ABSTRACT_API_URL,
  createAccountPublicClient,
  createAccountWalletClient,
  createApiClient,
  createPublicClient,
  createWalletClient
} from "./chunk-JH756577.js";
import "./chunk-SRYYQMNN.js";
import "./chunk-2UWQKCBJ.js";
import {
  require_react_dom
} from "./chunk-L7VLXREM.js";
import {
  require_react
} from "./chunk-DSZNLTBY.js";
import "./chunk-74XJBDQG.js";
import "./chunk-UZFJ3OFM.js";
import "./chunk-UTLST3TL.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-OAZWPZDP.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js
var require_use_sync_external_store_shim_production = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js"(exports) {
    "use strict";
    var import_dist121 = __toESM(require_dist());
    var import_dist122 = __toESM(require_dist2());
    var import_dist123 = __toESM(require_dist3());
    var React25 = require_react();
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is;
    var useState5 = React25.useState;
    var useEffect6 = React25.useEffect;
    var useLayoutEffect = React25.useLayoutEffect;
    var useDebugValue = React25.useDebugValue;
    function useSyncExternalStore$2(subscribe, getSnapshot) {
      var value = getSnapshot(), _useState = useState5({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
      useLayoutEffect(
        function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        },
        [subscribe, value, getSnapshot]
      );
      useEffect6(
        function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          });
        },
        [subscribe]
      );
      useDebugValue(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function useSyncExternalStore$12(subscribe, getSnapshot) {
      return getSnapshot();
    }
    var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$12 : useSyncExternalStore$2;
    exports.useSyncExternalStore = void 0 !== React25.useSyncExternalStore ? React25.useSyncExternalStore : shim;
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    var import_dist121 = __toESM(require_dist());
    var import_dist122 = __toESM(require_dist2());
    var import_dist123 = __toESM(require_dist3());
    "production" !== process.env.NODE_ENV && function() {
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React25.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState5({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect6(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$12(subscribe, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React25 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState5 = React25.useState, useEffect6 = React25.useEffect, useLayoutEffect = React25.useLayoutEffect, useDebugValue = React25.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$12 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React25.useSyncExternalStore ? React25.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    var import_dist121 = __toESM(require_dist());
    var import_dist122 = __toESM(require_dist2());
    var import_dist123 = __toESM(require_dist3());
    if (process.env.NODE_ENV === "production") {
      module.exports = require_use_sync_external_store_shim_production();
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/@abstract-money/react/dist/index.js
var import_dist118 = __toESM(require_dist());
var import_dist119 = __toESM(require_dist2());
var import_dist120 = __toESM(require_dist3());

// node_modules/@abstract-money/react/dist/chunk-2MJQ2BBI.js
var import_dist115 = __toESM(require_dist(), 1);
var import_dist116 = __toESM(require_dist2(), 1);
var import_dist117 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/react-query/build/lib/index.mjs
var import_dist112 = __toESM(require_dist(), 1);
var import_dist113 = __toESM(require_dist2(), 1);
var import_dist114 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/react-query/build/lib/setBatchUpdatesFn.mjs
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/index.mjs
var import_dist58 = __toESM(require_dist(), 1);
var import_dist59 = __toESM(require_dist2(), 1);
var import_dist60 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/retryer.mjs
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/focusManager.mjs
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/subscribable.mjs
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    const identity = {
      listener
    };
    this.listeners.add(identity);
    this.onSubscribe();
    return () => {
      this.listeners.delete(identity);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// node_modules/@tanstack/query-core/build/lib/utils.mjs
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var isServer = typeof window === "undefined" || "Deno" in window;
function noop() {
  return void 0;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs(arg1, arg2, arg3) {
  if (!isQueryKey(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return {
      ...arg3,
      queryKey: arg1,
      queryFn: arg2
    };
  }
  return {
    ...arg2,
    queryKey: arg1
  };
}
function parseMutationArgs(arg1, arg2, arg3) {
  if (isQueryKey(arg1)) {
    if (typeof arg2 === "function") {
      return {
        ...arg3,
        mutationKey: arg1,
        mutationFn: arg2
      };
    }
    return {
      ...arg2,
      mutationKey: arg1
    };
  }
  if (typeof arg1 === "function") {
    return {
      ...arg2,
      mutationFn: arg1
    };
  }
  return {
    ...arg1
  };
}
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b);
  if (array || isPlainObject(a) && isPlainObject(b)) {
    const aSize = array ? a.length : Object.keys(a).length;
    const bItems = array ? b : Object.keys(b);
    const bSize = bItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array ? i : bItems[i];
      copy[key] = replaceEqualDeep(a[key], b[key]);
      if (copy[key] === a[key]) {
        equalItems++;
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy;
  }
  return b;
}
function shallowEqualObjects(a, b) {
  if (a && !b || b && !a) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isQueryKey(value) {
  return Array.isArray(value);
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function scheduleMicrotask(callback) {
  sleep(0).then(callback);
}
function replaceData(prevData, data, options) {
  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {
    return prevData;
  } else if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}

// node_modules/@tanstack/query-core/build/lib/focusManager.mjs
var FocusManager = class extends Subscribable {
  constructor() {
    super();
    this.setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        window.addEventListener("focus", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
          window.removeEventListener("focus", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    const changed = this.focused !== focused;
    if (changed) {
      this.focused = focused;
      this.onFocus();
    }
  }
  onFocus() {
    this.listeners.forEach(({
      listener
    }) => {
      listener();
    });
  }
  isFocused() {
    if (typeof this.focused === "boolean") {
      return this.focused;
    }
    if (typeof document === "undefined") {
      return true;
    }
    return [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
};
var focusManager = new FocusManager();

// node_modules/@tanstack/query-core/build/lib/onlineManager.mjs
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
var onlineEvents = ["online", "offline"];
var OnlineManager = class extends Subscribable {
  constructor() {
    super();
    this.setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onOnline();
        onlineEvents.forEach((event) => {
          window.addEventListener(event, listener, false);
        });
        return () => {
          onlineEvents.forEach((event) => {
            window.removeEventListener(event, listener);
          });
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((online) => {
      if (typeof online === "boolean") {
        this.setOnline(online);
      } else {
        this.onOnline();
      }
    });
  }
  setOnline(online) {
    const changed = this.online !== online;
    if (changed) {
      this.online = online;
      this.onOnline();
    }
  }
  onOnline() {
    this.listeners.forEach(({
      listener
    }) => {
      listener();
    });
  }
  isOnline() {
    if (typeof this.online === "boolean") {
      return this.online;
    }
    if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
      return true;
    }
    return navigator.onLine;
  }
};
var onlineManager = new OnlineManager();

// node_modules/@tanstack/query-core/build/lib/retryer.mjs
function canFetch(networkMode) {
  return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class {
  constructor(options) {
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}

// node_modules/@tanstack/query-core/build/lib/queryCache.mjs
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/query.mjs
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/logger.mjs
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/notifyManager.mjs
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  const batch = (callback) => {
    let result;
    transactions++;
    try {
      result = callback();
    } finally {
      transactions--;
      if (!transactions) {
        flush();
      }
    }
    return result;
  };
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleMicrotask(() => {
        notifyFn(callback);
      });
    }
  };
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleMicrotask(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn) => {
    notifyFn = fn;
  };
  const setBatchNotifyFunction = (fn) => {
    batchNotifyFn = fn;
  };
  return {
    batch,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction
  };
}
var notifyManager = createNotifyManager();

// node_modules/@tanstack/query-core/build/lib/removable.mjs
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/queryClient.mjs
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/mutationCache.mjs
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/mutation.mjs
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}

// node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/queryObserver.mjs
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);
var QueryObserver = class extends Subscribable {
  constructor(client, options) {
    super();
    this.client = client;
    this.options = options;
    this.trackedProps = /* @__PURE__ */ new Set();
    this.selectError = null;
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.remove = this.remove.bind(this);
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      this.currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.currentQuery, this.options)) {
        this.executeFetch();
      }
      this.updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    this.clearStaleTimeout();
    this.clearRefetchInterval();
    this.currentQuery.removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = this.currentQuery;
    this.options = this.client.defaultQueryOptions(options);
    if (process.env.NODE_ENV !== "production" && typeof (options == null ? void 0 : options.isDataEqual) !== "undefined") {
      this.client.getLogger().error("The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option");
    }
    if (!shallowEqualObjects(prevOptions, this.options)) {
      this.client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.currentQuery,
        observer: this
      });
    }
    if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
      throw new Error("Expected enabled to be a boolean");
    }
    if (!this.options.queryKey) {
      this.options.queryKey = prevOptions.queryKey;
    }
    this.updateQuery();
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
      this.executeFetch();
    }
    this.updateResult(notifyOptions);
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
      this.updateStaleTimeout();
    }
    const nextRefetchInterval = this.computeRefetchInterval();
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
      this.updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.client.getQueryCache().build(this.client, options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result, options)) {
      this.currentResult = result;
      this.currentResultOptions = this.options;
      this.currentResultState = this.currentQuery.state;
    }
    return result;
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(result) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackedProps.add(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({
    refetchPage,
    ...options
  } = {}) {
    return this.fetch({
      ...options,
      meta: {
        refetchPage
      }
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.client.defaultQueryOptions(options);
    const query = this.client.getQueryCache().build(this.client, defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    var _fetchOptions$cancelR;
    return this.executeFetch({
      ...fetchOptions,
      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
    }).then(() => {
      this.updateResult();
      return this.currentResult;
    });
  }
  executeFetch(fetchOptions) {
    this.updateQuery();
    let promise = this.currentQuery.fetch(this.options, fetchOptions);
    if (!(fetchOptions != null && fetchOptions.throwOnError)) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  updateStaleTimeout() {
    this.clearStaleTimeout();
    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
      return;
    }
    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
    const timeout = time + 1;
    this.staleTimeoutId = setTimeout(() => {
      if (!this.currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  computeRefetchInterval() {
    var _this$options$refetch;
    return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
  }
  updateRefetchInterval(nextInterval) {
    this.clearRefetchInterval();
    this.currentRefetchInterval = nextInterval;
    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
      return;
    }
    this.refetchIntervalId = setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.executeFetch();
      }
    }, this.currentRefetchInterval);
  }
  updateTimers() {
    this.updateStaleTimeout();
    this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    if (this.staleTimeoutId) {
      clearTimeout(this.staleTimeoutId);
      this.staleTimeoutId = void 0;
    }
  }
  clearRefetchInterval() {
    if (this.refetchIntervalId) {
      clearInterval(this.refetchIntervalId);
      this.refetchIntervalId = void 0;
    }
  }
  createResult(query, options) {
    const prevQuery = this.currentQuery;
    const prevOptions = this.options;
    const prevResult = this.currentResult;
    const prevResultState = this.currentResultState;
    const prevResultOptions = this.currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
    const {
      state
    } = query;
    let {
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      fetchStatus,
      status
    } = state;
    let isPreviousData = false;
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
        if (!dataUpdatedAt) {
          status = "loading";
        }
      }
      if (options._optimisticResults === "isRestoring") {
        fetchStatus = "idle";
      }
    }
    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
      data = prevQueryResult.data;
      dataUpdatedAt = prevQueryResult.dataUpdatedAt;
      status = prevQueryResult.status;
      isPreviousData = true;
    } else if (options.select && typeof state.data !== "undefined") {
      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
        data = this.selectResult;
      } else {
        try {
          this.selectFn = options.select;
          data = options.select(state.data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          this.selectResult = data;
          this.selectError = null;
        } catch (selectError) {
          if (process.env.NODE_ENV !== "production") {
            this.client.getLogger().error(selectError);
          }
          this.selectError = selectError;
        }
      }
    } else {
      data = state.data;
    }
    if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && status === "loading") {
      let placeholderData;
      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
        if (options.select && typeof placeholderData !== "undefined") {
          try {
            placeholderData = options.select(placeholderData);
            this.selectError = null;
          } catch (selectError) {
            if (process.env.NODE_ENV !== "production") {
              this.client.getLogger().error(selectError);
            }
            this.selectError = selectError;
          }
        }
      }
      if (typeof placeholderData !== "undefined") {
        status = "success";
        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
        isPlaceholderData = true;
      }
    }
    if (this.selectError) {
      error = this.selectError;
      data = this.selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = fetchStatus === "fetching";
    const isLoading = status === "loading";
    const isError2 = status === "error";
    const result = {
      status,
      fetchStatus,
      isLoading,
      isSuccess: status === "success",
      isError: isError2,
      isInitialLoading: isLoading && isFetching,
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: state.fetchFailureCount,
      failureReason: state.fetchFailureReason,
      errorUpdateCount: state.errorUpdateCount,
      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isLoading,
      isLoadingError: isError2 && state.dataUpdatedAt === 0,
      isPaused: fetchStatus === "paused",
      isPlaceholderData,
      isPreviousData,
      isRefetchError: isError2 && state.dataUpdatedAt !== 0,
      isStale: isStale(query, options),
      refetch: this.refetch,
      remove: this.remove
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = this.currentResult;
    const nextResult = this.createResult(this.currentQuery, this.options);
    this.currentResultState = this.currentQuery.state;
    this.currentResultOptions = this.options;
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.currentResult = nextResult;
    const defaultNotifyOptions = {
      cache: true
    };
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const {
        notifyOnChangeProps
      } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.trackedProps.size) {
        return true;
      }
      const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);
      if (this.options.useErrorBoundary) {
        includedProps.add("error");
      }
      return Object.keys(this.currentResult).some((key) => {
        const typedKey = key;
        const changed = this.currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    this.notify({
      ...defaultNotifyOptions,
      ...notifyOptions
    });
  }
  updateQuery() {
    const query = this.client.getQueryCache().build(this.client, this.options);
    if (query === this.currentQuery) {
      return;
    }
    const prevQuery = this.currentQuery;
    this.currentQuery = query;
    this.currentQueryInitialState = query.state;
    this.previousQueryResult = this.currentResult;
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate(action) {
    const notifyOptions = {};
    if (action.type === "success") {
      notifyOptions.onSuccess = !action.manual;
    } else if (action.type === "error" && !isCancelledError(action.error)) {
      notifyOptions.onError = true;
    }
    this.updateResult(notifyOptions);
    if (this.hasListeners()) {
      this.updateTimers();
    }
  }
  notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.onSuccess) {
        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
      } else if (notifyOptions.onError) {
        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
      }
      if (notifyOptions.listeners) {
        this.listeners.forEach(({
          listener
        }) => {
          listener(this.currentResult);
        });
      }
      if (notifyOptions.cache) {
        this.client.getQueryCache().notify({
          query: this.currentQuery,
          type: "observerResultsUpdated"
        });
      }
    });
  }
};
function shouldLoadOnMount(query, options) {
  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (options.enabled !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return query.isStaleByTime(options.staleTime);
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {
  if (options.keepPreviousData) {
    return false;
  }
  if (options.placeholderData !== void 0) {
    return optimisticResult.isPlaceholderData;
  }
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}

// node_modules/@tanstack/query-core/build/lib/queriesObserver.mjs
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/infiniteQueryObserver.mjs
var import_dist49 = __toESM(require_dist(), 1);
var import_dist50 = __toESM(require_dist2(), 1);
var import_dist51 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/query-core/build/lib/mutationObserver.mjs
var import_dist52 = __toESM(require_dist(), 1);
var import_dist53 = __toESM(require_dist2(), 1);
var import_dist54 = __toESM(require_dist3(), 1);
var MutationObserver = class extends Subscribable {
  constructor(client, options) {
    super();
    this.client = client;
    this.setOptions(options);
    this.bindMethods();
    this.updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _this$currentMutation;
    const prevOptions = this.options;
    this.options = this.client.defaultMutationOptions(options);
    if (!shallowEqualObjects(prevOptions, this.options)) {
      this.client.getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: this.currentMutation,
        observer: this
      });
    }
    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$currentMutation2;
      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.updateResult();
    const notifyOptions = {
      listeners: true
    };
    if (action.type === "success") {
      notifyOptions.onSuccess = true;
    } else if (action.type === "error") {
      notifyOptions.onError = true;
    }
    this.notify(notifyOptions);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  reset() {
    this.currentMutation = void 0;
    this.updateResult();
    this.notify({
      listeners: true
    });
  }
  mutate(variables, options) {
    this.mutateOptions = options;
    if (this.currentMutation) {
      this.currentMutation.removeObserver(this);
    }
    this.currentMutation = this.client.getMutationCache().build(this.client, {
      ...this.options,
      variables: typeof variables !== "undefined" ? variables : this.options.variables
    });
    this.currentMutation.addObserver(this);
    return this.currentMutation.execute();
  }
  updateResult() {
    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();
    const result = {
      ...state,
      isLoading: state.status === "loading",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
    this.currentResult = result;
  }
  notify(options) {
    notifyManager.batch(() => {
      if (this.mutateOptions && this.hasListeners()) {
        if (options.onSuccess) {
          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
        } else if (options.onError) {
          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
        }
      }
      if (options.listeners) {
        this.listeners.forEach(({
          listener
        }) => {
          listener(this.currentResult);
        });
      }
    });
  }
};

// node_modules/@tanstack/query-core/build/lib/hydration.mjs
var import_dist55 = __toESM(require_dist(), 1);
var import_dist56 = __toESM(require_dist2(), 1);
var import_dist57 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/react-query/build/lib/reactBatchedUpdates.mjs
var import_dist61 = __toESM(require_dist(), 1);
var import_dist62 = __toESM(require_dist2(), 1);
var import_dist63 = __toESM(require_dist3(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var unstable_batchedUpdates2 = ReactDOM.unstable_batchedUpdates;

// node_modules/@tanstack/react-query/build/lib/setBatchUpdatesFn.mjs
notifyManager.setBatchNotifyFunction(unstable_batchedUpdates2);

// node_modules/@tanstack/react-query/build/lib/useQueries.mjs
var import_dist88 = __toESM(require_dist(), 1);
var import_dist89 = __toESM(require_dist2(), 1);
var import_dist90 = __toESM(require_dist3(), 1);
var React5 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs
var import_dist67 = __toESM(require_dist(), 1);
var import_dist68 = __toESM(require_dist2(), 1);
var import_dist69 = __toESM(require_dist3(), 1);
var import_shim = __toESM(require_shim(), 1);
var useSyncExternalStore = import_shim.useSyncExternalStore;

// node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);
var React = __toESM(require_react(), 1);
var defaultContext = React.createContext(void 0);
var QueryClientSharingContext = React.createContext(false);
function getQueryClientContext(context, contextSharing) {
  if (context) {
    return context;
  }
  if (contextSharing && typeof window !== "undefined") {
    if (!window.ReactQueryClientContext) {
      window.ReactQueryClientContext = defaultContext;
    }
    return window.ReactQueryClientContext;
  }
  return defaultContext;
}
var useQueryClient = ({
  context
} = {}) => {
  const queryClient = React.useContext(getQueryClientContext(context, React.useContext(QueryClientSharingContext)));
  if (!queryClient) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return queryClient;
};

// node_modules/@tanstack/react-query/build/lib/isRestoring.mjs
var import_dist73 = __toESM(require_dist(), 1);
var import_dist74 = __toESM(require_dist2(), 1);
var import_dist75 = __toESM(require_dist3(), 1);
var React2 = __toESM(require_react(), 1);
var IsRestoringContext = React2.createContext(false);
var useIsRestoring = () => React2.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.mjs
var import_dist76 = __toESM(require_dist(), 1);
var import_dist77 = __toESM(require_dist2(), 1);
var import_dist78 = __toESM(require_dist3(), 1);
var React3 = __toESM(require_react(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React3.createContext(createValue());
var useQueryErrorResetBoundary = () => React3.useContext(QueryErrorResetBoundaryContext);

// node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);
var React4 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/lib/utils.mjs
var import_dist79 = __toESM(require_dist(), 1);
var import_dist80 = __toESM(require_dist2(), 1);
var import_dist81 = __toESM(require_dist3(), 1);
function shouldThrowError(_useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary(...params);
  }
  return !!_useErrorBoundary;
}

// node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.useErrorBoundary) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  React4.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  useErrorBoundary,
  query
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);
};

// node_modules/@tanstack/react-query/build/lib/suspense.mjs
var import_dist85 = __toESM(require_dist(), 1);
var import_dist86 = __toESM(require_dist2(), 1);
var import_dist87 = __toESM(require_dist3(), 1);
var ensureStaleTime = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({
  data
}) => {
  defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
}).catch((error) => {
  errorResetBoundary.clearReset();
  defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error);
});

// node_modules/@tanstack/react-query/build/lib/useQuery.mjs
var import_dist94 = __toESM(require_dist(), 1);
var import_dist95 = __toESM(require_dist2(), 1);
var import_dist96 = __toESM(require_dist3(), 1);

// node_modules/@tanstack/react-query/build/lib/useBaseQuery.mjs
var import_dist91 = __toESM(require_dist(), 1);
var import_dist92 = __toESM(require_dist2(), 1);
var import_dist93 = __toESM(require_dist3(), 1);
var React6 = __toESM(require_react(), 1);
function useBaseQuery(options, Observer) {
  const queryClient = useQueryClient({
    context: options.context
  });
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = queryClient.defaultQueryOptions(options);
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  if (defaultedOptions.onError) {
    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
  }
  if (defaultedOptions.onSuccess) {
    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
  }
  if (defaultedOptions.onSettled) {
    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
  }
  ensureStaleTime(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = React6.useState(() => new Observer(queryClient, defaultedOptions));
  const result = observer.getOptimisticResult(defaultedOptions);
  useSyncExternalStore(React6.useCallback((onStoreChange) => {
    const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
    observer.updateResult();
    return unsubscribe;
  }, [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  React6.useEffect(() => {
    observer.setOptions(defaultedOptions, {
      listeners: false
    });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result, isRestoring)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    useErrorBoundary: defaultedOptions.useErrorBoundary,
    query: observer.getCurrentQuery()
  })) {
    throw result.error;
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// node_modules/@tanstack/react-query/build/lib/useQuery.mjs
function useQuery(arg1, arg2, arg3) {
  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
  return useBaseQuery(parsedOptions, QueryObserver);
}

// node_modules/@tanstack/react-query/build/lib/Hydrate.mjs
var import_dist97 = __toESM(require_dist(), 1);
var import_dist98 = __toESM(require_dist2(), 1);
var import_dist99 = __toESM(require_dist3(), 1);
var React7 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/lib/useIsFetching.mjs
var import_dist100 = __toESM(require_dist(), 1);
var import_dist101 = __toESM(require_dist2(), 1);
var import_dist102 = __toESM(require_dist3(), 1);
var React8 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/lib/useIsMutating.mjs
var import_dist103 = __toESM(require_dist(), 1);
var import_dist104 = __toESM(require_dist2(), 1);
var import_dist105 = __toESM(require_dist3(), 1);
var React9 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/lib/useMutation.mjs
var import_dist106 = __toESM(require_dist(), 1);
var import_dist107 = __toESM(require_dist2(), 1);
var import_dist108 = __toESM(require_dist3(), 1);
var React10 = __toESM(require_react(), 1);
function useMutation(arg1, arg2, arg3) {
  const options = parseMutationArgs(arg1, arg2, arg3);
  const queryClient = useQueryClient({
    context: options.context
  });
  const [observer] = React10.useState(() => new MutationObserver(queryClient, options));
  React10.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = useSyncExternalStore(React10.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  const mutate = React10.useCallback((variables, mutateOptions) => {
    observer.mutate(variables, mutateOptions).catch(noop2);
  }, [observer]);
  if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
    throw result.error;
  }
  return {
    ...result,
    mutate,
    mutateAsync: result.mutate
  };
}
function noop2() {
}

// node_modules/@tanstack/react-query/build/lib/useInfiniteQuery.mjs
var import_dist109 = __toESM(require_dist(), 1);
var import_dist110 = __toESM(require_dist2(), 1);
var import_dist111 = __toESM(require_dist3(), 1);

// node_modules/@abstract-money/react/dist/chunk-2MJQ2BBI.js
var React22 = __toESM(require_react(), 1);
var React11 = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
var import_react15 = __toESM(require_react(), 1);
var import_react16 = __toESM(require_react(), 1);
var import_react17 = __toESM(require_react(), 1);
var import_react18 = __toESM(require_react(), 1);
var import_react19 = __toESM(require_react(), 1);
var import_react20 = __toESM(require_react(), 1);
var ConfigContext = React11.createContext(void 0);
function AbstractConfigContext({
  children,
  config
}) {
  return React11.createElement(ConfigContext.Provider, {
    children,
    value: config
  });
}
function useConfig() {
  const config = React11.useContext(ConfigContext);
  if (!config)
    throw new Error("`useConfig` must be used within `AbstractConfigContext`.");
  return config;
}
function AbstractProvider({
  children,
  config
}) {
  return React22.createElement(React22.Fragment, {
    // biome-ignore lint/correctness/noChildrenProp: <explanation>
    children: React22.createElement(AbstractConfigContext, {
      config,
      children
    })
  });
}
function useClaimNamespace({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["claimNamespace", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("client is not defined");
      return accountClient.claimNamespace({ ...cosmWasmSignOptions, ...args });
    },
    mutation
  );
}
function useCreateRemoteAccount({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["createRemoteAccount", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.createRemoteAccount({
        ...cosmWasmSignOptions,
        ...args
      });
    },
    mutation
  );
}
function useCreateSubAccount({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["createSubAccount", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.createSubAccount({ ...cosmWasmSignOptions, ...args });
    },
    mutation
  );
}
function useDeposit({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    accountId,
    chainName
  });
  return useMutation(
    ["deposit", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("client is not defined");
      return accountClient.deposit({ ...args, ...cosmWasmSignOptions });
    },
    mutation
  );
}
function useEnableIbc({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["enableIbc", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      if (!args.ibcEnabled) {
        throw new Error("no action");
      }
      return accountClient.enableIbc({ ...cosmWasmSignOptions, ...args });
    },
    mutation
  );
}
function useExecute({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["execute", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("client is not defined");
      return accountClient.execute({ ...cosmWasmSignOptions, ...args });
    },
    mutation
  );
}
function useExecuteOnRemote({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    accountId,
    chainName
  });
  return useMutation(
    ["executeOnRemote", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.executeOnRemote({ ...cosmWasmSignOptions, ...args });
    },
    mutation
  );
}
function useExecuteOnRemoteModule({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    accountId,
    chainName
  });
  return useMutation(
    ["executeOnRemoteModule", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.executeOnRemoteModule({
        ...cosmWasmSignOptions,
        ...args
      });
    },
    mutation
  );
}
function useExecuteRemote({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    accountId,
    chainName
  });
  return useMutation(
    ["executeRemote", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.executeRemote({ ...cosmWasmSignOptions, ...args });
    },
    mutation
  );
}
function useInstallModules({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["installModules", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("client is not defined");
      return accountClient.installModules({ ...cosmWasmSignOptions, ...args });
    },
    mutation
  );
}
function useRequestRemoteFunds({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["requestRemoteFunds", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.requestFundsFromRemote({
        ...cosmWasmSignOptions,
        ...args
      });
    },
    mutation
  );
}
function useSendFundsToRemote({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["sendFundsToRemote", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.sendFundsToRemote({
        ...cosmWasmSignOptions,
        ...args
      });
    },
    mutation
  );
}
var useUseSendFundsToRemote = useSendFundsToRemote;
function useUpdateInfo({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["updateInfo", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.updateInfo({ ...cosmWasmSignOptions, ...args });
    },
    mutation
  );
}
function useUpdateSettings({
  accountId,
  chainName,
  mutation
}) {
  const { mutateAsync } = useEnableIbc({
    accountId,
    chainName,
    mutation
  });
  return useMutation(
    ["updateSettings", chainName, accountId],
    async ({ args, ...cosmWasmSignOptions }) => {
      return await mutateAsync({ ...cosmWasmSignOptions, args });
    },
    mutation
  );
}
function useUpdateStatus({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["updateStatus", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.updateStatus({ ...cosmWasmSignOptions, ...args });
    },
    mutation
  );
}
function useUpgradeModules({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["upgradeModules", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.upgradeModules({ ...cosmWasmSignOptions, ...args });
    },
    mutation
  );
}
var useUpgradeModule = useUpgradeModules;
function useSendFunds({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountWalletClient({
    chainName,
    accountId
  });
  return useMutation(
    ["sendFunds", chainName, accountId],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.sendFunds({ ...args, ...cosmWasmSignOptions });
    },
    mutation
  );
}
var useWithdraw = useSendFunds;
function useQuery2(parameters) {
  const result = useQuery({
    ...parameters
    // queryKeyHashFn: hashFn, // for bigint support
  });
  result.queryKey = parameters.queryKey;
  return result;
}
function useAccountAddressFromApi({
  accountId,
  chainName,
  extra,
  query = {}
}) {
  const config = useConfig();
  const accountPublicClient = config.useAccountPublicClient({
    accountId,
    chainName
  });
  const queryKey = import_react.default.useMemo(
    () => ["accountAddress", accountPublicClient, extra],
    [accountPublicClient, extra]
  );
  const enabled = Boolean(accountPublicClient && (query.enabled ?? true));
  const queryFn = import_react.default.useCallback(
    ({ queryKey: [_, accountPublicClient2, extra2] }) => {
      if (!accountPublicClient2)
        throw new Error("No client");
      return accountPublicClient2.getAccountAddress(
        extra2 ? { extra: extra2 } : void 0
      );
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
var useAccountAddress = useAccountAddressFromApi;
function useAccountSettings({
  accountId,
  extra,
  chainName,
  query = {}
}) {
  const config = useConfig();
  const accountPublicClient = config.useAccountPublicClient({
    accountId,
    chainName
  });
  const queryKey = import_react2.default.useMemo(
    () => ["accountSettings", accountPublicClient, extra],
    [accountPublicClient, extra]
  );
  const enabled = Boolean(accountPublicClient && (query.enabled ?? true));
  const queryFn = import_react2.default.useCallback(
    ({ queryKey: [_, accountPublicClient2, extra2] }) => {
      if (!accountPublicClient2)
        throw new Error("No client");
      return accountPublicClient2.getAccountSettings(
        extra2 ? { extra: extra2 } : void 0
      );
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function usePredictModuleAddress({
  args,
  accountId,
  chainName,
  extra,
  query = {}
}) {
  const config = useConfig();
  const accountPublicClient = config.useAccountPublicClient({
    accountId,
    chainName
  });
  const queryKey = import_react3.default.useMemo(
    () => ["predictModuleAddress", accountPublicClient, args, extra],
    [accountPublicClient, args, extra]
  );
  const enabled = Boolean(
    accountPublicClient && args && (query.enabled ?? true)
  );
  const queryFn = import_react3.default.useCallback(
    ({ queryKey: [_, accountPublicClient2, args2, extra2] }) => {
      if (!accountPublicClient2)
        throw new Error("No client");
      if (!args2)
        throw new Error("No args");
      return accountPublicClient2.predictModuleAddress({
        ...args2,
        ...extra2
      });
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
var useModuleInstantiate2AddressFromApi = usePredictModuleAddress;
var useModuleInstantiate2Address = usePredictModuleAddress;
function useModules({
  accountId,
  chainName,
  extra,
  query = {}
}) {
  const config = useConfig();
  const accountPublicClient = config.useAccountPublicClient({
    accountId,
    chainName
  });
  const queryKey = import_react4.default.useMemo(
    () => ["modules", accountPublicClient, extra],
    [accountPublicClient, extra]
  );
  const enabled = Boolean(accountPublicClient && (query.enabled ?? true));
  const queryFn = import_react4.default.useCallback(
    ({ queryKey: [_, accountPublicClient2, extra2] }) => {
      if (!accountPublicClient2)
        throw new Error("No client");
      return accountPublicClient2.getModules(extra2 ? { extra: extra2 } : void 0);
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useRemoteAccountIds({
  accountId,
  extra,
  chainName,
  query = {}
}) {
  const config = useConfig();
  const accountPublicClient = config.useAccountPublicClient({
    accountId,
    chainName
  });
  const queryKey = import_react5.default.useMemo(
    () => ["getRemoteAccountIds", accountPublicClient, extra],
    [accountPublicClient, extra]
  );
  const enabled = import_react5.default.useMemo(
    () => Boolean(
      accountPublicClient && (query.enabled ?? true)
    ),
    [query.enabled, accountPublicClient]
  );
  const queryFn = import_react5.default.useCallback(
    ({ queryKey: [_, accountPublicClient2, extra2] }) => {
      if (!accountPublicClient2)
        throw new Error("No client");
      return accountPublicClient2.getRemoteAccountIds(
        extra2 ? {
          extra: extra2
        } : void 0
      );
    },
    []
  );
  return useQuery({ queryKey, queryFn, ...query, enabled });
}
function useRemoteAccounts({
  accountId,
  extra,
  chainName,
  query = {}
}) {
  const config = useConfig();
  const accountPublicClient = config.useAccountPublicClient({
    accountId,
    chainName
  });
  const queryKey = import_react6.default.useMemo(
    () => ["getRemoteAccounts", accountPublicClient, extra],
    [accountPublicClient, extra]
  );
  const enabled = import_react6.default.useMemo(
    () => Boolean(accountPublicClient && (query.enabled ?? true)),
    [query.enabled, accountPublicClient]
  );
  const queryFn = import_react6.default.useCallback(
    ({ queryKey: [_, accountPublicClient2, extra2] }) => {
      if (!accountPublicClient2)
        throw new Error("No client");
      return accountPublicClient2.getRemoteAccounts(
        extra2 ? {
          extra: extra2
        } : void 0
      );
    },
    []
  );
  return useQuery({ queryKey, queryFn, ...query, enabled });
}
function useSimulateExecuteRemoteAccount({
  accountId,
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.useAccountPublicClient({
    chainName,
    accountId
  });
  return useMutation(
    ["simulateExecuteRemoteAccount", chainName, accountId],
    ({ ...params }) => {
      if (!accountClient)
        throw new Error("client is not defined");
      return accountClient.simulateExecuteRemoteAccount({ ...params });
    },
    mutation
  );
}
function useSubAccountIdsFromApi({
  accountId,
  chainName,
  extra,
  query = {}
}) {
  const config = useConfig();
  const accountPublicClient = config.useAccountPublicClient({
    accountId,
    chainName
  });
  const queryKey = import_react7.default.useMemo(
    () => ["getSubAccountIdsFromApi", accountPublicClient, extra],
    [accountPublicClient, extra]
  );
  const enabled = Boolean(accountPublicClient && (query.enabled ?? true));
  const queryFn = import_react7.default.useCallback(
    ({ queryKey: [_, accountPublicClient2, extra2] }) => {
      if (!accountPublicClient2)
        throw new Error("No client");
      return accountPublicClient2.getSubAccountIds(extra2 ? { extra: extra2 } : void 0);
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useCosmWasmClient({
  chainName,
  query = {}
}) {
  const config = useConfig();
  const publicClient = config.usePublicClient({ chainName });
  const queryKey = import_react8.default.useMemo(
    () => ["cosmWasmClient", chainName, publicClient],
    [chainName, publicClient]
  );
  const queryFn = import_react8.default.useCallback(
    ({ queryKey: [_, chainName2, publicClient2] }) => {
      if (!publicClient2)
        throw new Error(`client is not defined for ${chainName2}`);
      return publicClient2.getCosmWasmClient();
    },
    []
  );
  const enabled = Boolean(publicClient && (query.enabled ?? true));
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useSmartQuery({
  chainName,
  query = {},
  address,
  queryMsg
}) {
  const { data: cosmWasmClient, isSuccess } = useCosmWasmClient({ chainName });
  const queryKey = import_react9.default.useMemo(
    () => ["smartQuery", chainName, cosmWasmClient, address, queryMsg],
    [cosmWasmClient, chainName, address, queryMsg]
  );
  const queryFn = import_react9.default.useCallback(
    async ({ queryKey: [_, _chainName, cosmWasmClient2] }) => {
      if (!cosmWasmClient2) {
        throw new Error(`client is not defined for ${chainName}`);
      }
      return cosmWasmClient2.queryContractSmart(address, queryMsg);
    },
    []
  );
  const enabled = Boolean(isSuccess && (query.enabled ?? true));
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useAbstractModuleVersion({
  args,
  extra,
  chainName,
  query = {}
}) {
  const config = useConfig();
  const publicClient = config.usePublicClient({
    chainName
  });
  const queryKey = import_react10.default.useMemo(
    () => ["abstractModuleVersion", chainName, publicClient, args, extra],
    [publicClient, chainName, args, extra]
  );
  const enabled = Boolean(publicClient && args && (query.enabled ?? true));
  const queryFn = import_react10.default.useCallback(
    ({ queryKey: [_, _chainName, publicClient2, args2, extra2] }) => {
      if (!publicClient2)
        throw new Error("No client");
      if (!args2)
        throw new Error("No args");
      return publicClient2.getAbstractModuleVersion({ ...args2, extra: extra2 });
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useAccountsAddressesFromApi({
  chainName,
  args,
  extra,
  query = {}
}) {
  const config = useConfig();
  const accountPublicClient = config.usePublicClient({
    chainName
  });
  const queryKey = import_react11.default.useMemo(
    () => ["accountAddress", chainName, accountPublicClient, args, extra],
    [accountPublicClient, chainName, args, extra]
  );
  const enabled = Boolean(
    accountPublicClient && args && (query.enabled ?? true)
  );
  const queryFn = import_react11.default.useCallback(
    ({ queryKey: [_, _chainName, accountPublicClient2, args2, extra2] }) => {
      if (!accountPublicClient2 || !args2)
        throw new Error("No client or args");
      return accountPublicClient2.getAccountsAddresses({ extra: extra2, ...args2 });
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useRemoteHosts({
  chainName,
  extra,
  query = {}
}) {
  const config = useConfig();
  const publicClient = config.usePublicClient({
    chainName
  });
  const queryKey = import_react12.default.useMemo(
    () => ["getRemoteHosts", chainName, publicClient, extra],
    [chainName, publicClient, extra]
  );
  const enabled = Boolean(publicClient && (query.enabled ?? true));
  const queryFn = import_react12.default.useCallback(
    ({ queryKey: [_, _chainName, publicClient2, extra2] }) => {
      if (!publicClient2)
        throw new Error("No client");
      return publicClient2.getRemoteHosts(extra2 ? { extra: extra2 } : void 0);
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useSimulateRemoteMsg({
  chainName,
  mutation
}) {
  const config = useConfig();
  const accountClient = config.usePublicClient({
    chainName
  });
  return useMutation(
    ["simulateRemoteCosmosMsg", chainName],
    ({ ...params }) => {
      if (!accountClient)
        throw new Error("accountClient is not defined");
      return accountClient.simulateRemoteCosmosMsg({
        ...params
      });
    },
    mutation
  );
}
function usePredictAccountAddress({
  chainName,
  args,
  extra,
  query = {}
}) {
  const config = useConfig();
  const publicClient = config.usePublicClient({
    chainName
  });
  const queryKey = import_react13.default.useMemo(
    () => ["predictAccountAddress", publicClient, args, extra],
    [publicClient, extra]
  );
  const enabled = Boolean(publicClient && (query.enabled ?? true));
  const queryFn = import_react13.default.useCallback(
    ({ queryKey: [_, publicClient2, args2, extra2] }) => {
      if (!publicClient2)
        throw new Error("No client");
      if (!args2)
        throw new Error("No args");
      return publicClient2.predictAccountAddress({ extra: extra2, ...args2 });
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useSigningCosmWasmClient(parameters) {
  const { chainName, query = {} } = parameters ?? {};
  const config = useConfig();
  const walletClient = config.useWalletClient({ chainName });
  const queryKey = import_react14.default.useMemo(
    () => ["signing-cosm-wasm-client", walletClient],
    [walletClient]
  );
  const queryFn = import_react14.default.useCallback(() => {
    if (!walletClient)
      throw new Error("client is not defined");
    return walletClient.getSigningCosmWasmClient();
  }, [walletClient]);
  const enabled = Boolean(walletClient && (query.enabled ?? true));
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useCreateAccount({ chainName, mutation }) {
  const config = useConfig();
  const walletClient = config.useWalletClient({ chainName });
  return useMutation(
    ["createAccount", chainName],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!walletClient)
        throw new Error("walletClient is not defined");
      return walletClient.createAccount({ ...args, ...cosmWasmSignOptions });
    },
    mutation
  );
}
function useCreateAccountMonarchy({
  chainName,
  mutation
}) {
  const config = useConfig();
  const walletClient = config.useWalletClient({ chainName });
  return useMutation(
    ["createAccountMonarchy", chainName],
    ({ args, ...cosmWasmSignOptions }) => {
      if (!walletClient)
        throw new Error("walletClient is not defined");
      return walletClient.createAccountMonarchy({
        ...args,
        ...cosmWasmSignOptions
      });
    },
    mutation
  );
}
function useSenderAddress(parameters) {
  const { query = {}, chainName } = parameters ?? {};
  const config = useConfig();
  const walletClient = config.useWalletClient({ chainName });
  const queryKey = import_react15.default.useMemo(
    () => ["sender-address", walletClient],
    [walletClient]
  );
  const queryFn = import_react15.default.useCallback(() => {
    if (!walletClient)
      throw new Error("client is not defined");
    return walletClient.getSenderAddress();
  }, [walletClient]);
  const enabled = Boolean(walletClient && (query.enabled ?? true));
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useSignAndBroadcast({ args: { chainName } }, options) {
  const { data: signingCosmWasmClient } = useSigningCosmWasmClient({
    chainName
  });
  const { data: senderAddress } = useSenderAddress({ chainName });
  return useMutation(
    ["signAndBroadcast", chainName, senderAddress],
    ({ args, fee, memo }) => {
      if (!signingCosmWasmClient || !senderAddress)
        throw new Error(
          "signingCosmWasmClient or senderAddress are not defined"
        );
      return signingCosmWasmClient == null ? void 0 : signingCosmWasmClient.signAndBroadcast(
        senderAddress,
        args.messages,
        fee,
        memo
      );
    },
    options
  );
}
function useAccounts({
  args,
  extra,
  query = {}
}) {
  const config = useConfig();
  const client = config.useApiClient();
  const queryKey = import_react16.default.useMemo(
    () => ["accountsOf", client, args, extra],
    [client, args, extra]
  );
  const enabled = Boolean(client && args && (query.enabled ?? true));
  const queryFn = import_react16.default.useCallback(
    ({ queryKey: [_, client2, args2, extra2] }) => {
      if (!client2 || !args2)
        throw new Error("No client or owner or chain");
      return client2.getAccountsByOwnerFromApi({
        ...args2,
        ...extra2
      });
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useAnsTokenFromApi({
  args,
  extra,
  query = {}
}) {
  const config = useConfig();
  const client = config.useApiClient();
  const queryKey = import_react17.default.useMemo(
    () => ["ansTokenFromApi", client, args, extra],
    [args, client, extra]
  );
  const enabled = Boolean(client && args && (query.enabled ?? true));
  const queryFn = import_react17.default.useCallback(
    ({ queryKey: [_, client2, args2, extra2] }) => {
      if (!client2 || !args2)
        throw new Error("No client or owner or chain");
      return client2.getAnsTokenFromApi({ ...args2, ...extra2 });
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useAccountBalancesFromApi({
  args,
  extra,
  query = {}
}) {
  const config = useConfig();
  const client = config.useApiClient();
  const queryKey = import_react18.default.useMemo(
    () => ["accountBalancesFromApi", client, args, extra],
    [args, client, extra]
  );
  const enabled = Boolean(client && args && (query.enabled ?? true));
  const queryFn = import_react18.default.useCallback(
    ({ queryKey: [_, client2, args2, extra2] }) => {
      if (!client2 || !args2)
        throw new Error("No client or accountid");
      return client2.getAccountBalancesFromApi({ ...args2, ...extra2 });
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useModulesFromApi({
  args,
  extra,
  query = {}
}) {
  const config = useConfig();
  const client = config.useApiClient();
  const queryKey = import_react19.default.useMemo(
    () => ["modulesFromApi", client, args, extra],
    [args, client, extra]
  );
  const enabled = Boolean(client && args && (query.enabled ?? true));
  const queryFn = import_react19.default.useCallback(() => {
    if (!client || !args)
      throw new Error("No client or owner or chain");
    return client.getModulesFromApi({
      ...args,
      ...extra
    });
  }, []);
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}
function useSubAccountIdsByModuleIdFromApi({
  args,
  extra,
  query = {}
}) {
  const config = useConfig();
  const client = config.useApiClient();
  const queryKey = import_react20.default.useMemo(
    () => ["subAccountIdsByModuleIdFromApi", client, args, extra],
    [args, client, extra]
  );
  const enabled = Boolean(client && args && (query.enabled ?? true));
  const queryFn = import_react20.default.useCallback(
    ({ queryKey: [_, client2, args2, extra2] }) => {
      if (!client2 || !args2)
        throw new Error("No client or accountid");
      return client2.getSubAccountIdsByModuleIdFromApi({
        ...args2,
        ...extra2
      });
    },
    []
  );
  return useQuery2({ queryKey, queryFn, ...query, enabled });
}

// node_modules/@abstract-money/react/dist/index.js
var React23 = __toESM(require_react());
var React24 = __toESM(require_react());
var React33 = __toESM(require_react());
var React43 = __toESM(require_react());
var import_react21 = __toESM(require_react());
async function getAbstractModuleClient({
  accountPublicClient,
  accountWalletClient,
  moduleId,
  Module
}) {
  return new Module({
    accountPublicClient,
    accountWalletClient,
    moduleId
  });
}
function useAbstractModuleClient({
  accountId,
  moduleId,
  chainName,
  Module,
  query = {},
  sender: _sender
}) {
  const { useAccountWalletClient, useAccountPublicClient } = useConfig();
  const accountPublicClient = useAccountPublicClient({
    accountId,
    chainName
  });
  const accountWalletClient = useAccountWalletClient({
    accountId,
    chainName
  });
  const queryKey = React23.useMemo(
    () => ["module-mutation-client", moduleId, accountId, Module],
    [moduleId, accountId, Module]
  );
  const queryFn = React23.useCallback(() => {
    if (!accountPublicClient)
      throw new Error("accountPublicClient is not defined");
    if (!accountWalletClient)
      throw new Error("accountWalletClient is not defined");
    return getAbstractModuleClient({
      accountPublicClient,
      accountWalletClient,
      moduleId,
      Module
    });
  }, [accountPublicClient, accountWalletClient, moduleId, Module]);
  const enabled = Boolean(accountWalletClient && (query.enabled ?? true));
  const {
    data,
    isLoading: isAbstractModuleClientLoading,
    isError: isAbstractModuleClientError,
    error: abstractModuleClientError
  } = useQuery2({ queryKey, queryFn, ...query, enabled });
  if (!enabled)
    return {
      data: void 0,
      isLoading: true,
      isError: false,
      isSuccess: false,
      error: void 0
    };
  if (isAbstractModuleClientError)
    return {
      data: void 0,
      isLoading: false,
      isError: true,
      isSuccess: false,
      error: abstractModuleClientError
    };
  if (isAbstractModuleClientLoading)
    return {
      data: void 0,
      isLoading: true,
      isError: false,
      isSuccess: false
    };
  return {
    data,
    isLoading: false,
    isError: false,
    isSuccess: true
  };
}
async function getAbstractModuleQueryClient({
  accountPublicClient,
  moduleId,
  Module
}) {
  return new Module({
    accountPublicClient,
    moduleId
  });
}
function useAbstractModuleQueryClient({
  accountId,
  chainName,
  moduleId,
  Module,
  query = {}
}) {
  const { apiUrl, useAccountPublicClient } = useConfig();
  const accountPublicClient = useAccountPublicClient({
    accountId,
    chainName
  });
  const queryKey = React24.useMemo(
    () => ["module-query-client", moduleId, Module, accountPublicClient],
    [moduleId, accountId, accountPublicClient]
  );
  const queryFn = React24.useCallback(() => {
    if (!accountPublicClient)
      throw new Error("client is not defined");
    return getAbstractModuleQueryClient({
      accountPublicClient,
      overrideApiUrl: apiUrl,
      moduleId,
      Module
    });
  }, [accountPublicClient, apiUrl, accountId, moduleId, Module]);
  const enabled = Boolean(
    accountPublicClient && accountId && (query.enabled ?? true)
  );
  const {
    data,
    isLoading: isAbstractModuleQueryClientLoading,
    isError: isAbstractModuleQueryClientError,
    error: abstractModuleQueryClientError
  } = useQuery2({ queryKey, queryFn, ...query, enabled });
  if (!enabled)
    return {
      data: void 0,
      isLoading: true,
      isError: false,
      isSuccess: false,
      error: void 0
    };
  if (isAbstractModuleQueryClientError)
    return {
      data: void 0,
      isLoading: false,
      isError: true,
      isSuccess: false,
      error: abstractModuleQueryClientError
    };
  if (isAbstractModuleQueryClientLoading)
    return {
      data: void 0,
      isLoading: true,
      isError: false,
      isSuccess: false
    };
  return {
    data,
    isLoading: false,
    isError: false,
    isSuccess: true
  };
}
function useModuleClient(parameters) {
  const { contractAddress, Module, chainName, sender: sender_ } = parameters;
  const {
    data: client,
    isLoading: isSigningCosmWasmClientLoading,
    isError: isSigningCosmWasmClientError,
    error: signingCosmWasmClientError
  } = useSigningCosmWasmClient({ chainName });
  const {
    data: sender,
    isLoading: isSenderAddressLoading,
    isError: isSenderAddressError,
    error: senderAddressError
  } = useSenderAddress({ chainName });
  const data = React33.useMemo(() => {
    if (!client || !contractAddress)
      return void 0;
    if (!sender_ && !sender || !sender)
      return void 0;
    return new Module(
      client,
      sender_ ?? sender,
      contractAddress
    );
  }, [client, contractAddress]);
  if (isSigningCosmWasmClientError)
    return {
      data: void 0,
      isLoading: false,
      isError: true,
      isSuccess: false,
      error: signingCosmWasmClientError
    };
  if (isSenderAddressError)
    return {
      data: void 0,
      isLoading: false,
      isError: true,
      isSuccess: false,
      error: senderAddressError
    };
  if (isSigningCosmWasmClientLoading || isSenderAddressLoading)
    return {
      data: void 0,
      isLoading: true,
      isError: false,
      isSuccess: false
    };
  return {
    data,
    isLoading: false,
    isError: false,
    isSuccess: true
  };
}
function useModuleQueryClient(parameters) {
  const { contractAddress, Module, chainName } = parameters;
  const { data: client, ...rest } = useCosmWasmClient({ chainName });
  const queryClient = React43.useMemo(() => {
    if (!client || !contractAddress)
      return void 0;
    return new Module(client, contractAddress);
  }, [client, contractAddress]);
  return { data: queryClient, ...rest };
}
function createConfig(parameters) {
  const { apiUrl = ABSTRACT_API_URL, provider } = parameters;
  function useApiClient() {
    return (0, import_react21.useMemo)(
      () => createApiClient({
        apiUrl
      }),
      [apiUrl]
    );
  }
  function usePublicClient(...args) {
    const cosmWasmClient = provider.useCosmWasmClient(...args);
    return (0, import_react21.useMemo)(() => {
      if (!cosmWasmClient) {
        console.debug("usePublicClient: no cosmWasmClient");
        return void 0;
      }
      return createPublicClient({
        apiUrl,
        cosmWasmClient
      });
    }, [apiUrl, cosmWasmClient]);
  }
  function useWalletClient(...args) {
    const signingCosmWasmClient = provider.useSigningCosmWasmClient(...args);
    const sender = provider.useSenderAddress(...args);
    return (0, import_react21.useMemo)(() => {
      if (!signingCosmWasmClient || !sender) {
        console.debug("useWalletClient: no signingCosmWasmClient or sender", {
          signingCosmWasmClient,
          sender
        });
        return void 0;
      }
      return createWalletClient({
        apiUrl,
        sender,
        signingCosmWasmClient
      });
    }, [apiUrl, signingCosmWasmClient, sender]);
  }
  function useAccountPublicClient({
    accountId,
    ...rest
  }) {
    const cosmWasmClient = provider.useCosmWasmClient(rest);
    return (0, import_react21.useMemo)(() => {
      if (!cosmWasmClient || !accountId) {
        console.debug(
          "useAccountPublicClient: no cosmWasmClient or accountId",
          {
            cosmWasmClient,
            accountId
          }
        );
        return void 0;
      }
      return createAccountPublicClient({
        apiUrl,
        cosmWasmClient,
        accountId
      });
    }, [apiUrl, cosmWasmClient, accountId]);
  }
  function useAccountWalletClient({
    accountId,
    ...rest
  }) {
    const signingCosmWasmClient = provider.useSigningCosmWasmClient(rest);
    const sender = provider.useSenderAddress(rest);
    return (0, import_react21.useMemo)(() => {
      if (!signingCosmWasmClient || !sender || !accountId) {
        console.debug(
          "useAccountWalletClient: no signingCosmWasmClient, sender, or accountId",
          {
            signingCosmWasmClient,
            sender,
            accountId
          }
        );
        return void 0;
      }
      return createAccountWalletClient({
        apiUrl,
        sender,
        signingCosmWasmClient,
        accountId
      });
    }, [apiUrl, signingCosmWasmClient, sender, accountId]);
  }
  return {
    apiUrl,
    provider,
    useApiClient,
    usePublicClient,
    useWalletClient,
    useAccountPublicClient,
    useAccountWalletClient
  };
}
export {
  AbstractProvider,
  createConfig,
  useAbstractModuleClient,
  useAbstractModuleQueryClient,
  useAbstractModuleVersion,
  useAccountAddress,
  useAccountAddressFromApi,
  useAccountBalancesFromApi,
  useAccountSettings,
  useAccounts,
  useAccountsAddressesFromApi,
  useAnsTokenFromApi,
  useClaimNamespace,
  useConfig,
  useCosmWasmClient,
  useCreateAccount,
  useCreateAccountMonarchy,
  useCreateRemoteAccount,
  useCreateSubAccount,
  useDeposit,
  useEnableIbc,
  useExecute,
  useExecuteOnRemote,
  useExecuteOnRemoteModule,
  useExecuteRemote,
  useInstallModules,
  useModuleClient,
  useModuleInstantiate2Address,
  useModuleInstantiate2AddressFromApi,
  useModuleQueryClient,
  useModules,
  useModulesFromApi,
  usePredictAccountAddress,
  usePredictModuleAddress,
  useRemoteAccountIds,
  useRemoteAccounts,
  useRemoteHosts,
  useRequestRemoteFunds,
  useSendFunds,
  useSendFundsToRemote,
  useSenderAddress,
  useSignAndBroadcast,
  useSigningCosmWasmClient,
  useSimulateExecuteRemoteAccount,
  useSimulateRemoteMsg,
  useSmartQuery,
  useSubAccountIdsByModuleIdFromApi,
  useSubAccountIdsFromApi,
  useUpdateInfo,
  useUpdateSettings,
  useUpdateStatus,
  useUpgradeModule,
  useUpgradeModules,
  useUseSendFundsToRemote,
  useWithdraw
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.production.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@abstract-money_react.js.map
