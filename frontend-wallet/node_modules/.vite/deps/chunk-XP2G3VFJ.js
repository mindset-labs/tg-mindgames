import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_jsx_runtime
} from "./chunk-SUSXYKI3.js";
import {
  BREAK,
  Kind,
  isSelectionNode,
  parse,
  print,
  require_build as require_build9,
  require_pako,
  require_tx,
  visit
} from "./chunk-QUSKWHT5.js";
import {
  require_dist as require_dist4
} from "./chunk-RWX4E3DT.js";
import {
  require_react_dom
} from "./chunk-J34VLEW3.js";
import {
  require_react
} from "./chunk-U2TW4ELY.js";
import {
  require_accounts,
  require_build as require_build5,
  require_build2 as require_build6,
  require_build3 as require_build8,
  require_minimal,
  require_service,
  require_signing,
  require_tx as require_tx2,
  require_tx3,
  require_wallet
} from "./chunk-GHUP3OSQ.js";
import {
  require_bn,
  require_build,
  require_build2,
  require_build3,
  require_build4,
  require_build6 as require_build7,
  require_elliptic,
  require_events,
  require_inherits_browser,
  require_pbkdf2,
  require_ripemd160,
  require_sha256,
  require_sha3,
  require_sha512,
  require_stream_browserify,
  require_string_decoder,
  require_util,
  require_utils
} from "./chunk-BIG3E5R2.js";
import {
  Buffer$1,
  dist_exports,
  init_dist
} from "./chunk-4MCTL4HW.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-DJIQL57M.js";

// node_modules/rehackt/index.js
var require_rehackt = __commonJS({
  "node_modules/rehackt/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    if (0) {
      module2.exports = null;
    }
    module2.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = void 0;
    module2.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0;
    module2.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0;
    Object.assign(module2.exports, require_react());
  }
});

// node_modules/bip39/src/wordlists/czech.json
var require_czech = __commonJS({
  "node_modules/bip39/src/wordlists/czech.json"(exports2, module2) {
    module2.exports = [
      "abdikace",
      "abeceda",
      "adresa",
      "agrese",
      "akce",
      "aktovka",
      "alej",
      "alkohol",
      "amputace",
      "ananas",
      "andulka",
      "anekdota",
      "anketa",
      "antika",
      "anulovat",
      "archa",
      "arogance",
      "asfalt",
      "asistent",
      "aspirace",
      "astma",
      "astronom",
      "atlas",
      "atletika",
      "atol",
      "autobus",
      "azyl",
      "babka",
      "bachor",
      "bacil",
      "baculka",
      "badatel",
      "bageta",
      "bagr",
      "bahno",
      "bakterie",
      "balada",
      "baletka",
      "balkon",
      "balonek",
      "balvan",
      "balza",
      "bambus",
      "bankomat",
      "barbar",
      "baret",
      "barman",
      "baroko",
      "barva",
      "baterka",
      "batoh",
      "bavlna",
      "bazalka",
      "bazilika",
      "bazuka",
      "bedna",
      "beran",
      "beseda",
      "bestie",
      "beton",
      "bezinka",
      "bezmoc",
      "beztak",
      "bicykl",
      "bidlo",
      "biftek",
      "bikiny",
      "bilance",
      "biograf",
      "biolog",
      "bitva",
      "bizon",
      "blahobyt",
      "blatouch",
      "blecha",
      "bledule",
      "blesk",
      "blikat",
      "blizna",
      "blokovat",
      "bloudit",
      "blud",
      "bobek",
      "bobr",
      "bodlina",
      "bodnout",
      "bohatost",
      "bojkot",
      "bojovat",
      "bokorys",
      "bolest",
      "borec",
      "borovice",
      "bota",
      "boubel",
      "bouchat",
      "bouda",
      "boule",
      "bourat",
      "boxer",
      "bradavka",
      "brambora",
      "branka",
      "bratr",
      "brepta",
      "briketa",
      "brko",
      "brloh",
      "bronz",
      "broskev",
      "brunetka",
      "brusinka",
      "brzda",
      "brzy",
      "bublina",
      "bubnovat",
      "buchta",
      "buditel",
      "budka",
      "budova",
      "bufet",
      "bujarost",
      "bukvice",
      "buldok",
      "bulva",
      "bunda",
      "bunkr",
      "burza",
      "butik",
      "buvol",
      "buzola",
      "bydlet",
      "bylina",
      "bytovka",
      "bzukot",
      "capart",
      "carevna",
      "cedr",
      "cedule",
      "cejch",
      "cejn",
      "cela",
      "celer",
      "celkem",
      "celnice",
      "cenina",
      "cennost",
      "cenovka",
      "centrum",
      "cenzor",
      "cestopis",
      "cetka",
      "chalupa",
      "chapadlo",
      "charita",
      "chata",
      "chechtat",
      "chemie",
      "chichot",
      "chirurg",
      "chlad",
      "chleba",
      "chlubit",
      "chmel",
      "chmura",
      "chobot",
      "chochol",
      "chodba",
      "cholera",
      "chomout",
      "chopit",
      "choroba",
      "chov",
      "chrapot",
      "chrlit",
      "chrt",
      "chrup",
      "chtivost",
      "chudina",
      "chutnat",
      "chvat",
      "chvilka",
      "chvost",
      "chyba",
      "chystat",
      "chytit",
      "cibule",
      "cigareta",
      "cihelna",
      "cihla",
      "cinkot",
      "cirkus",
      "cisterna",
      "citace",
      "citrus",
      "cizinec",
      "cizost",
      "clona",
      "cokoliv",
      "couvat",
      "ctitel",
      "ctnost",
      "cudnost",
      "cuketa",
      "cukr",
      "cupot",
      "cvaknout",
      "cval",
      "cvik",
      "cvrkot",
      "cyklista",
      "daleko",
      "dareba",
      "datel",
      "datum",
      "dcera",
      "debata",
      "dechovka",
      "decibel",
      "deficit",
      "deflace",
      "dekl",
      "dekret",
      "demokrat",
      "deprese",
      "derby",
      "deska",
      "detektiv",
      "dikobraz",
      "diktovat",
      "dioda",
      "diplom",
      "disk",
      "displej",
      "divadlo",
      "divoch",
      "dlaha",
      "dlouho",
      "dluhopis",
      "dnes",
      "dobro",
      "dobytek",
      "docent",
      "dochutit",
      "dodnes",
      "dohled",
      "dohoda",
      "dohra",
      "dojem",
      "dojnice",
      "doklad",
      "dokola",
      "doktor",
      "dokument",
      "dolar",
      "doleva",
      "dolina",
      "doma",
      "dominant",
      "domluvit",
      "domov",
      "donutit",
      "dopad",
      "dopis",
      "doplnit",
      "doposud",
      "doprovod",
      "dopustit",
      "dorazit",
      "dorost",
      "dort",
      "dosah",
      "doslov",
      "dostatek",
      "dosud",
      "dosyta",
      "dotaz",
      "dotek",
      "dotknout",
      "doufat",
      "doutnat",
      "dovozce",
      "dozadu",
      "doznat",
      "dozorce",
      "drahota",
      "drak",
      "dramatik",
      "dravec",
      "draze",
      "drdol",
      "drobnost",
      "drogerie",
      "drozd",
      "drsnost",
      "drtit",
      "drzost",
      "duben",
      "duchovno",
      "dudek",
      "duha",
      "duhovka",
      "dusit",
      "dusno",
      "dutost",
      "dvojice",
      "dvorec",
      "dynamit",
      "ekolog",
      "ekonomie",
      "elektron",
      "elipsa",
      "email",
      "emise",
      "emoce",
      "empatie",
      "epizoda",
      "epocha",
      "epopej",
      "epos",
      "esej",
      "esence",
      "eskorta",
      "eskymo",
      "etiketa",
      "euforie",
      "evoluce",
      "exekuce",
      "exkurze",
      "expedice",
      "exploze",
      "export",
      "extrakt",
      "facka",
      "fajfka",
      "fakulta",
      "fanatik",
      "fantazie",
      "farmacie",
      "favorit",
      "fazole",
      "federace",
      "fejeton",
      "fenka",
      "fialka",
      "figurant",
      "filozof",
      "filtr",
      "finance",
      "finta",
      "fixace",
      "fjord",
      "flanel",
      "flirt",
      "flotila",
      "fond",
      "fosfor",
      "fotbal",
      "fotka",
      "foton",
      "frakce",
      "freska",
      "fronta",
      "fukar",
      "funkce",
      "fyzika",
      "galeje",
      "garant",
      "genetika",
      "geolog",
      "gilotina",
      "glazura",
      "glejt",
      "golem",
      "golfista",
      "gotika",
      "graf",
      "gramofon",
      "granule",
      "grep",
      "gril",
      "grog",
      "groteska",
      "guma",
      "hadice",
      "hadr",
      "hala",
      "halenka",
      "hanba",
      "hanopis",
      "harfa",
      "harpuna",
      "havran",
      "hebkost",
      "hejkal",
      "hejno",
      "hejtman",
      "hektar",
      "helma",
      "hematom",
      "herec",
      "herna",
      "heslo",
      "hezky",
      "historik",
      "hladovka",
      "hlasivky",
      "hlava",
      "hledat",
      "hlen",
      "hlodavec",
      "hloh",
      "hloupost",
      "hltat",
      "hlubina",
      "hluchota",
      "hmat",
      "hmota",
      "hmyz",
      "hnis",
      "hnojivo",
      "hnout",
      "hoblina",
      "hoboj",
      "hoch",
      "hodiny",
      "hodlat",
      "hodnota",
      "hodovat",
      "hojnost",
      "hokej",
      "holinka",
      "holka",
      "holub",
      "homole",
      "honitba",
      "honorace",
      "horal",
      "horda",
      "horizont",
      "horko",
      "horlivec",
      "hormon",
      "hornina",
      "horoskop",
      "horstvo",
      "hospoda",
      "hostina",
      "hotovost",
      "houba",
      "houf",
      "houpat",
      "houska",
      "hovor",
      "hradba",
      "hranice",
      "hravost",
      "hrazda",
      "hrbolek",
      "hrdina",
      "hrdlo",
      "hrdost",
      "hrnek",
      "hrobka",
      "hromada",
      "hrot",
      "hrouda",
      "hrozen",
      "hrstka",
      "hrubost",
      "hryzat",
      "hubenost",
      "hubnout",
      "hudba",
      "hukot",
      "humr",
      "husita",
      "hustota",
      "hvozd",
      "hybnost",
      "hydrant",
      "hygiena",
      "hymna",
      "hysterik",
      "idylka",
      "ihned",
      "ikona",
      "iluze",
      "imunita",
      "infekce",
      "inflace",
      "inkaso",
      "inovace",
      "inspekce",
      "internet",
      "invalida",
      "investor",
      "inzerce",
      "ironie",
      "jablko",
      "jachta",
      "jahoda",
      "jakmile",
      "jakost",
      "jalovec",
      "jantar",
      "jarmark",
      "jaro",
      "jasan",
      "jasno",
      "jatka",
      "javor",
      "jazyk",
      "jedinec",
      "jedle",
      "jednatel",
      "jehlan",
      "jekot",
      "jelen",
      "jelito",
      "jemnost",
      "jenom",
      "jepice",
      "jeseter",
      "jevit",
      "jezdec",
      "jezero",
      "jinak",
      "jindy",
      "jinoch",
      "jiskra",
      "jistota",
      "jitrnice",
      "jizva",
      "jmenovat",
      "jogurt",
      "jurta",
      "kabaret",
      "kabel",
      "kabinet",
      "kachna",
      "kadet",
      "kadidlo",
      "kahan",
      "kajak",
      "kajuta",
      "kakao",
      "kaktus",
      "kalamita",
      "kalhoty",
      "kalibr",
      "kalnost",
      "kamera",
      "kamkoliv",
      "kamna",
      "kanibal",
      "kanoe",
      "kantor",
      "kapalina",
      "kapela",
      "kapitola",
      "kapka",
      "kaple",
      "kapota",
      "kapr",
      "kapusta",
      "kapybara",
      "karamel",
      "karotka",
      "karton",
      "kasa",
      "katalog",
      "katedra",
      "kauce",
      "kauza",
      "kavalec",
      "kazajka",
      "kazeta",
      "kazivost",
      "kdekoliv",
      "kdesi",
      "kedluben",
      "kemp",
      "keramika",
      "kino",
      "klacek",
      "kladivo",
      "klam",
      "klapot",
      "klasika",
      "klaun",
      "klec",
      "klenba",
      "klepat",
      "klesnout",
      "klid",
      "klima",
      "klisna",
      "klobouk",
      "klokan",
      "klopa",
      "kloub",
      "klubovna",
      "klusat",
      "kluzkost",
      "kmen",
      "kmitat",
      "kmotr",
      "kniha",
      "knot",
      "koalice",
      "koberec",
      "kobka",
      "kobliha",
      "kobyla",
      "kocour",
      "kohout",
      "kojenec",
      "kokos",
      "koktejl",
      "kolaps",
      "koleda",
      "kolize",
      "kolo",
      "komando",
      "kometa",
      "komik",
      "komnata",
      "komora",
      "kompas",
      "komunita",
      "konat",
      "koncept",
      "kondice",
      "konec",
      "konfese",
      "kongres",
      "konina",
      "konkurs",
      "kontakt",
      "konzerva",
      "kopanec",
      "kopie",
      "kopnout",
      "koprovka",
      "korbel",
      "korektor",
      "kormidlo",
      "koroptev",
      "korpus",
      "koruna",
      "koryto",
      "korzet",
      "kosatec",
      "kostka",
      "kotel",
      "kotleta",
      "kotoul",
      "koukat",
      "koupelna",
      "kousek",
      "kouzlo",
      "kovboj",
      "koza",
      "kozoroh",
      "krabice",
      "krach",
      "krajina",
      "kralovat",
      "krasopis",
      "kravata",
      "kredit",
      "krejcar",
      "kresba",
      "kreveta",
      "kriket",
      "kritik",
      "krize",
      "krkavec",
      "krmelec",
      "krmivo",
      "krocan",
      "krok",
      "kronika",
      "kropit",
      "kroupa",
      "krovka",
      "krtek",
      "kruhadlo",
      "krupice",
      "krutost",
      "krvinka",
      "krychle",
      "krypta",
      "krystal",
      "kryt",
      "kudlanka",
      "kufr",
      "kujnost",
      "kukla",
      "kulajda",
      "kulich",
      "kulka",
      "kulomet",
      "kultura",
      "kuna",
      "kupodivu",
      "kurt",
      "kurzor",
      "kutil",
      "kvalita",
      "kvasinka",
      "kvestor",
      "kynolog",
      "kyselina",
      "kytara",
      "kytice",
      "kytka",
      "kytovec",
      "kyvadlo",
      "labrador",
      "lachtan",
      "ladnost",
      "laik",
      "lakomec",
      "lamela",
      "lampa",
      "lanovka",
      "lasice",
      "laso",
      "lastura",
      "latinka",
      "lavina",
      "lebka",
      "leckdy",
      "leden",
      "lednice",
      "ledovka",
      "ledvina",
      "legenda",
      "legie",
      "legrace",
      "lehce",
      "lehkost",
      "lehnout",
      "lektvar",
      "lenochod",
      "lentilka",
      "lepenka",
      "lepidlo",
      "letadlo",
      "letec",
      "letmo",
      "letokruh",
      "levhart",
      "levitace",
      "levobok",
      "libra",
      "lichotka",
      "lidojed",
      "lidskost",
      "lihovina",
      "lijavec",
      "lilek",
      "limetka",
      "linie",
      "linka",
      "linoleum",
      "listopad",
      "litina",
      "litovat",
      "lobista",
      "lodivod",
      "logika",
      "logoped",
      "lokalita",
      "loket",
      "lomcovat",
      "lopata",
      "lopuch",
      "lord",
      "losos",
      "lotr",
      "loudal",
      "louh",
      "louka",
      "louskat",
      "lovec",
      "lstivost",
      "lucerna",
      "lucifer",
      "lump",
      "lusk",
      "lustrace",
      "lvice",
      "lyra",
      "lyrika",
      "lysina",
      "madam",
      "madlo",
      "magistr",
      "mahagon",
      "majetek",
      "majitel",
      "majorita",
      "makak",
      "makovice",
      "makrela",
      "malba",
      "malina",
      "malovat",
      "malvice",
      "maminka",
      "mandle",
      "manko",
      "marnost",
      "masakr",
      "maskot",
      "masopust",
      "matice",
      "matrika",
      "maturita",
      "mazanec",
      "mazivo",
      "mazlit",
      "mazurka",
      "mdloba",
      "mechanik",
      "meditace",
      "medovina",
      "melasa",
      "meloun",
      "mentolka",
      "metla",
      "metoda",
      "metr",
      "mezera",
      "migrace",
      "mihnout",
      "mihule",
      "mikina",
      "mikrofon",
      "milenec",
      "milimetr",
      "milost",
      "mimika",
      "mincovna",
      "minibar",
      "minomet",
      "minulost",
      "miska",
      "mistr",
      "mixovat",
      "mladost",
      "mlha",
      "mlhovina",
      "mlok",
      "mlsat",
      "mluvit",
      "mnich",
      "mnohem",
      "mobil",
      "mocnost",
      "modelka",
      "modlitba",
      "mohyla",
      "mokro",
      "molekula",
      "momentka",
      "monarcha",
      "monokl",
      "monstrum",
      "montovat",
      "monzun",
      "mosaz",
      "moskyt",
      "most",
      "motivace",
      "motorka",
      "motyka",
      "moucha",
      "moudrost",
      "mozaika",
      "mozek",
      "mozol",
      "mramor",
      "mravenec",
      "mrkev",
      "mrtvola",
      "mrzet",
      "mrzutost",
      "mstitel",
      "mudrc",
      "muflon",
      "mulat",
      "mumie",
      "munice",
      "muset",
      "mutace",
      "muzeum",
      "muzikant",
      "myslivec",
      "mzda",
      "nabourat",
      "nachytat",
      "nadace",
      "nadbytek",
      "nadhoz",
      "nadobro",
      "nadpis",
      "nahlas",
      "nahnat",
      "nahodile",
      "nahradit",
      "naivita",
      "najednou",
      "najisto",
      "najmout",
      "naklonit",
      "nakonec",
      "nakrmit",
      "nalevo",
      "namazat",
      "namluvit",
      "nanometr",
      "naoko",
      "naopak",
      "naostro",
      "napadat",
      "napevno",
      "naplnit",
      "napnout",
      "naposled",
      "naprosto",
      "narodit",
      "naruby",
      "narychlo",
      "nasadit",
      "nasekat",
      "naslepo",
      "nastat",
      "natolik",
      "navenek",
      "navrch",
      "navzdory",
      "nazvat",
      "nebe",
      "nechat",
      "necky",
      "nedaleko",
      "nedbat",
      "neduh",
      "negace",
      "nehet",
      "nehoda",
      "nejen",
      "nejprve",
      "neklid",
      "nelibost",
      "nemilost",
      "nemoc",
      "neochota",
      "neonka",
      "nepokoj",
      "nerost",
      "nerv",
      "nesmysl",
      "nesoulad",
      "netvor",
      "neuron",
      "nevina",
      "nezvykle",
      "nicota",
      "nijak",
      "nikam",
      "nikdy",
      "nikl",
      "nikterak",
      "nitro",
      "nocleh",
      "nohavice",
      "nominace",
      "nora",
      "norek",
      "nositel",
      "nosnost",
      "nouze",
      "noviny",
      "novota",
      "nozdra",
      "nuda",
      "nudle",
      "nuget",
      "nutit",
      "nutnost",
      "nutrie",
      "nymfa",
      "obal",
      "obarvit",
      "obava",
      "obdiv",
      "obec",
      "obehnat",
      "obejmout",
      "obezita",
      "obhajoba",
      "obilnice",
      "objasnit",
      "objekt",
      "obklopit",
      "oblast",
      "oblek",
      "obliba",
      "obloha",
      "obluda",
      "obnos",
      "obohatit",
      "obojek",
      "obout",
      "obrazec",
      "obrna",
      "obruba",
      "obrys",
      "obsah",
      "obsluha",
      "obstarat",
      "obuv",
      "obvaz",
      "obvinit",
      "obvod",
      "obvykle",
      "obyvatel",
      "obzor",
      "ocas",
      "ocel",
      "ocenit",
      "ochladit",
      "ochota",
      "ochrana",
      "ocitnout",
      "odboj",
      "odbyt",
      "odchod",
      "odcizit",
      "odebrat",
      "odeslat",
      "odevzdat",
      "odezva",
      "odhadce",
      "odhodit",
      "odjet",
      "odjinud",
      "odkaz",
      "odkoupit",
      "odliv",
      "odluka",
      "odmlka",
      "odolnost",
      "odpad",
      "odpis",
      "odplout",
      "odpor",
      "odpustit",
      "odpykat",
      "odrazka",
      "odsoudit",
      "odstup",
      "odsun",
      "odtok",
      "odtud",
      "odvaha",
      "odveta",
      "odvolat",
      "odvracet",
      "odznak",
      "ofina",
      "ofsajd",
      "ohlas",
      "ohnisko",
      "ohrada",
      "ohrozit",
      "ohryzek",
      "okap",
      "okenice",
      "oklika",
      "okno",
      "okouzlit",
      "okovy",
      "okrasa",
      "okres",
      "okrsek",
      "okruh",
      "okupant",
      "okurka",
      "okusit",
      "olejnina",
      "olizovat",
      "omak",
      "omeleta",
      "omezit",
      "omladina",
      "omlouvat",
      "omluva",
      "omyl",
      "onehdy",
      "opakovat",
      "opasek",
      "operace",
      "opice",
      "opilost",
      "opisovat",
      "opora",
      "opozice",
      "opravdu",
      "oproti",
      "orbital",
      "orchestr",
      "orgie",
      "orlice",
      "orloj",
      "ortel",
      "osada",
      "oschnout",
      "osika",
      "osivo",
      "oslava",
      "oslepit",
      "oslnit",
      "oslovit",
      "osnova",
      "osoba",
      "osolit",
      "ospalec",
      "osten",
      "ostraha",
      "ostuda",
      "ostych",
      "osvojit",
      "oteplit",
      "otisk",
      "otop",
      "otrhat",
      "otrlost",
      "otrok",
      "otruby",
      "otvor",
      "ovanout",
      "ovar",
      "oves",
      "ovlivnit",
      "ovoce",
      "oxid",
      "ozdoba",
      "pachatel",
      "pacient",
      "padouch",
      "pahorek",
      "pakt",
      "palanda",
      "palec",
      "palivo",
      "paluba",
      "pamflet",
      "pamlsek",
      "panenka",
      "panika",
      "panna",
      "panovat",
      "panstvo",
      "pantofle",
      "paprika",
      "parketa",
      "parodie",
      "parta",
      "paruka",
      "paryba",
      "paseka",
      "pasivita",
      "pastelka",
      "patent",
      "patrona",
      "pavouk",
      "pazneht",
      "pazourek",
      "pecka",
      "pedagog",
      "pejsek",
      "peklo",
      "peloton",
      "penalta",
      "pendrek",
      "penze",
      "periskop",
      "pero",
      "pestrost",
      "petarda",
      "petice",
      "petrolej",
      "pevnina",
      "pexeso",
      "pianista",
      "piha",
      "pijavice",
      "pikle",
      "piknik",
      "pilina",
      "pilnost",
      "pilulka",
      "pinzeta",
      "pipeta",
      "pisatel",
      "pistole",
      "pitevna",
      "pivnice",
      "pivovar",
      "placenta",
      "plakat",
      "plamen",
      "planeta",
      "plastika",
      "platit",
      "plavidlo",
      "plaz",
      "plech",
      "plemeno",
      "plenta",
      "ples",
      "pletivo",
      "plevel",
      "plivat",
      "plnit",
      "plno",
      "plocha",
      "plodina",
      "plomba",
      "plout",
      "pluk",
      "plyn",
      "pobavit",
      "pobyt",
      "pochod",
      "pocit",
      "poctivec",
      "podat",
      "podcenit",
      "podepsat",
      "podhled",
      "podivit",
      "podklad",
      "podmanit",
      "podnik",
      "podoba",
      "podpora",
      "podraz",
      "podstata",
      "podvod",
      "podzim",
      "poezie",
      "pohanka",
      "pohnutka",
      "pohovor",
      "pohroma",
      "pohyb",
      "pointa",
      "pojistka",
      "pojmout",
      "pokazit",
      "pokles",
      "pokoj",
      "pokrok",
      "pokuta",
      "pokyn",
      "poledne",
      "polibek",
      "polknout",
      "poloha",
      "polynom",
      "pomalu",
      "pominout",
      "pomlka",
      "pomoc",
      "pomsta",
      "pomyslet",
      "ponechat",
      "ponorka",
      "ponurost",
      "popadat",
      "popel",
      "popisek",
      "poplach",
      "poprosit",
      "popsat",
      "popud",
      "poradce",
      "porce",
      "porod",
      "porucha",
      "poryv",
      "posadit",
      "posed",
      "posila",
      "poskok",
      "poslanec",
      "posoudit",
      "pospolu",
      "postava",
      "posudek",
      "posyp",
      "potah",
      "potkan",
      "potlesk",
      "potomek",
      "potrava",
      "potupa",
      "potvora",
      "poukaz",
      "pouto",
      "pouzdro",
      "povaha",
      "povidla",
      "povlak",
      "povoz",
      "povrch",
      "povstat",
      "povyk",
      "povzdech",
      "pozdrav",
      "pozemek",
      "poznatek",
      "pozor",
      "pozvat",
      "pracovat",
      "prahory",
      "praktika",
      "prales",
      "praotec",
      "praporek",
      "prase",
      "pravda",
      "princip",
      "prkno",
      "probudit",
      "procento",
      "prodej",
      "profese",
      "prohra",
      "projekt",
      "prolomit",
      "promile",
      "pronikat",
      "propad",
      "prorok",
      "prosba",
      "proton",
      "proutek",
      "provaz",
      "prskavka",
      "prsten",
      "prudkost",
      "prut",
      "prvek",
      "prvohory",
      "psanec",
      "psovod",
      "pstruh",
      "ptactvo",
      "puberta",
      "puch",
      "pudl",
      "pukavec",
      "puklina",
      "pukrle",
      "pult",
      "pumpa",
      "punc",
      "pupen",
      "pusa",
      "pusinka",
      "pustina",
      "putovat",
      "putyka",
      "pyramida",
      "pysk",
      "pytel",
      "racek",
      "rachot",
      "radiace",
      "radnice",
      "radon",
      "raft",
      "ragby",
      "raketa",
      "rakovina",
      "rameno",
      "rampouch",
      "rande",
      "rarach",
      "rarita",
      "rasovna",
      "rastr",
      "ratolest",
      "razance",
      "razidlo",
      "reagovat",
      "reakce",
      "recept",
      "redaktor",
      "referent",
      "reflex",
      "rejnok",
      "reklama",
      "rekord",
      "rekrut",
      "rektor",
      "reputace",
      "revize",
      "revma",
      "revolver",
      "rezerva",
      "riskovat",
      "riziko",
      "robotika",
      "rodokmen",
      "rohovka",
      "rokle",
      "rokoko",
      "romaneto",
      "ropovod",
      "ropucha",
      "rorejs",
      "rosol",
      "rostlina",
      "rotmistr",
      "rotoped",
      "rotunda",
      "roubenka",
      "roucho",
      "roup",
      "roura",
      "rovina",
      "rovnice",
      "rozbor",
      "rozchod",
      "rozdat",
      "rozeznat",
      "rozhodce",
      "rozinka",
      "rozjezd",
      "rozkaz",
      "rozloha",
      "rozmar",
      "rozpad",
      "rozruch",
      "rozsah",
      "roztok",
      "rozum",
      "rozvod",
      "rubrika",
      "ruchadlo",
      "rukavice",
      "rukopis",
      "ryba",
      "rybolov",
      "rychlost",
      "rydlo",
      "rypadlo",
      "rytina",
      "ryzost",
      "sadista",
      "sahat",
      "sako",
      "samec",
      "samizdat",
      "samota",
      "sanitka",
      "sardinka",
      "sasanka",
      "satelit",
      "sazba",
      "sazenice",
      "sbor",
      "schovat",
      "sebranka",
      "secese",
      "sedadlo",
      "sediment",
      "sedlo",
      "sehnat",
      "sejmout",
      "sekera",
      "sekta",
      "sekunda",
      "sekvoje",
      "semeno",
      "seno",
      "servis",
      "sesadit",
      "seshora",
      "seskok",
      "seslat",
      "sestra",
      "sesuv",
      "sesypat",
      "setba",
      "setina",
      "setkat",
      "setnout",
      "setrvat",
      "sever",
      "seznam",
      "shoda",
      "shrnout",
      "sifon",
      "silnice",
      "sirka",
      "sirotek",
      "sirup",
      "situace",
      "skafandr",
      "skalisko",
      "skanzen",
      "skaut",
      "skeptik",
      "skica",
      "skladba",
      "sklenice",
      "sklo",
      "skluz",
      "skoba",
      "skokan",
      "skoro",
      "skripta",
      "skrz",
      "skupina",
      "skvost",
      "skvrna",
      "slabika",
      "sladidlo",
      "slanina",
      "slast",
      "slavnost",
      "sledovat",
      "slepec",
      "sleva",
      "slezina",
      "slib",
      "slina",
      "sliznice",
      "slon",
      "sloupek",
      "slovo",
      "sluch",
      "sluha",
      "slunce",
      "slupka",
      "slza",
      "smaragd",
      "smetana",
      "smilstvo",
      "smlouva",
      "smog",
      "smrad",
      "smrk",
      "smrtka",
      "smutek",
      "smysl",
      "snad",
      "snaha",
      "snob",
      "sobota",
      "socha",
      "sodovka",
      "sokol",
      "sopka",
      "sotva",
      "souboj",
      "soucit",
      "soudce",
      "souhlas",
      "soulad",
      "soumrak",
      "souprava",
      "soused",
      "soutok",
      "souviset",
      "spalovna",
      "spasitel",
      "spis",
      "splav",
      "spodek",
      "spojenec",
      "spolu",
      "sponzor",
      "spornost",
      "spousta",
      "sprcha",
      "spustit",
      "sranda",
      "sraz",
      "srdce",
      "srna",
      "srnec",
      "srovnat",
      "srpen",
      "srst",
      "srub",
      "stanice",
      "starosta",
      "statika",
      "stavba",
      "stehno",
      "stezka",
      "stodola",
      "stolek",
      "stopa",
      "storno",
      "stoupat",
      "strach",
      "stres",
      "strhnout",
      "strom",
      "struna",
      "studna",
      "stupnice",
      "stvol",
      "styk",
      "subjekt",
      "subtropy",
      "suchar",
      "sudost",
      "sukno",
      "sundat",
      "sunout",
      "surikata",
      "surovina",
      "svah",
      "svalstvo",
      "svetr",
      "svatba",
      "svazek",
      "svisle",
      "svitek",
      "svoboda",
      "svodidlo",
      "svorka",
      "svrab",
      "sykavka",
      "sykot",
      "synek",
      "synovec",
      "sypat",
      "sypkost",
      "syrovost",
      "sysel",
      "sytost",
      "tabletka",
      "tabule",
      "tahoun",
      "tajemno",
      "tajfun",
      "tajga",
      "tajit",
      "tajnost",
      "taktika",
      "tamhle",
      "tampon",
      "tancovat",
      "tanec",
      "tanker",
      "tapeta",
      "tavenina",
      "tazatel",
      "technika",
      "tehdy",
      "tekutina",
      "telefon",
      "temnota",
      "tendence",
      "tenista",
      "tenor",
      "teplota",
      "tepna",
      "teprve",
      "terapie",
      "termoska",
      "textil",
      "ticho",
      "tiskopis",
      "titulek",
      "tkadlec",
      "tkanina",
      "tlapka",
      "tleskat",
      "tlukot",
      "tlupa",
      "tmel",
      "toaleta",
      "topinka",
      "topol",
      "torzo",
      "touha",
      "toulec",
      "tradice",
      "traktor",
      "tramp",
      "trasa",
      "traverza",
      "trefit",
      "trest",
      "trezor",
      "trhavina",
      "trhlina",
      "trochu",
      "trojice",
      "troska",
      "trouba",
      "trpce",
      "trpitel",
      "trpkost",
      "trubec",
      "truchlit",
      "truhlice",
      "trus",
      "trvat",
      "tudy",
      "tuhnout",
      "tuhost",
      "tundra",
      "turista",
      "turnaj",
      "tuzemsko",
      "tvaroh",
      "tvorba",
      "tvrdost",
      "tvrz",
      "tygr",
      "tykev",
      "ubohost",
      "uboze",
      "ubrat",
      "ubrousek",
      "ubrus",
      "ubytovna",
      "ucho",
      "uctivost",
      "udivit",
      "uhradit",
      "ujednat",
      "ujistit",
      "ujmout",
      "ukazatel",
      "uklidnit",
      "uklonit",
      "ukotvit",
      "ukrojit",
      "ulice",
      "ulita",
      "ulovit",
      "umyvadlo",
      "unavit",
      "uniforma",
      "uniknout",
      "upadnout",
      "uplatnit",
      "uplynout",
      "upoutat",
      "upravit",
      "uran",
      "urazit",
      "usednout",
      "usilovat",
      "usmrtit",
      "usnadnit",
      "usnout",
      "usoudit",
      "ustlat",
      "ustrnout",
      "utahovat",
      "utkat",
      "utlumit",
      "utonout",
      "utopenec",
      "utrousit",
      "uvalit",
      "uvolnit",
      "uvozovka",
      "uzdravit",
      "uzel",
      "uzenina",
      "uzlina",
      "uznat",
      "vagon",
      "valcha",
      "valoun",
      "vana",
      "vandal",
      "vanilka",
      "varan",
      "varhany",
      "varovat",
      "vcelku",
      "vchod",
      "vdova",
      "vedro",
      "vegetace",
      "vejce",
      "velbloud",
      "veletrh",
      "velitel",
      "velmoc",
      "velryba",
      "venkov",
      "veranda",
      "verze",
      "veselka",
      "veskrze",
      "vesnice",
      "vespodu",
      "vesta",
      "veterina",
      "veverka",
      "vibrace",
      "vichr",
      "videohra",
      "vidina",
      "vidle",
      "vila",
      "vinice",
      "viset",
      "vitalita",
      "vize",
      "vizitka",
      "vjezd",
      "vklad",
      "vkus",
      "vlajka",
      "vlak",
      "vlasec",
      "vlevo",
      "vlhkost",
      "vliv",
      "vlnovka",
      "vloupat",
      "vnucovat",
      "vnuk",
      "voda",
      "vodivost",
      "vodoznak",
      "vodstvo",
      "vojensky",
      "vojna",
      "vojsko",
      "volant",
      "volba",
      "volit",
      "volno",
      "voskovka",
      "vozidlo",
      "vozovna",
      "vpravo",
      "vrabec",
      "vracet",
      "vrah",
      "vrata",
      "vrba",
      "vrcholek",
      "vrhat",
      "vrstva",
      "vrtule",
      "vsadit",
      "vstoupit",
      "vstup",
      "vtip",
      "vybavit",
      "vybrat",
      "vychovat",
      "vydat",
      "vydra",
      "vyfotit",
      "vyhledat",
      "vyhnout",
      "vyhodit",
      "vyhradit",
      "vyhubit",
      "vyjasnit",
      "vyjet",
      "vyjmout",
      "vyklopit",
      "vykonat",
      "vylekat",
      "vymazat",
      "vymezit",
      "vymizet",
      "vymyslet",
      "vynechat",
      "vynikat",
      "vynutit",
      "vypadat",
      "vyplatit",
      "vypravit",
      "vypustit",
      "vyrazit",
      "vyrovnat",
      "vyrvat",
      "vyslovit",
      "vysoko",
      "vystavit",
      "vysunout",
      "vysypat",
      "vytasit",
      "vytesat",
      "vytratit",
      "vyvinout",
      "vyvolat",
      "vyvrhel",
      "vyzdobit",
      "vyznat",
      "vzadu",
      "vzbudit",
      "vzchopit",
      "vzdor",
      "vzduch",
      "vzdychat",
      "vzestup",
      "vzhledem",
      "vzkaz",
      "vzlykat",
      "vznik",
      "vzorek",
      "vzpoura",
      "vztah",
      "vztek",
      "xylofon",
      "zabrat",
      "zabydlet",
      "zachovat",
      "zadarmo",
      "zadusit",
      "zafoukat",
      "zahltit",
      "zahodit",
      "zahrada",
      "zahynout",
      "zajatec",
      "zajet",
      "zajistit",
      "zaklepat",
      "zakoupit",
      "zalepit",
      "zamezit",
      "zamotat",
      "zamyslet",
      "zanechat",
      "zanikat",
      "zaplatit",
      "zapojit",
      "zapsat",
      "zarazit",
      "zastavit",
      "zasunout",
      "zatajit",
      "zatemnit",
      "zatknout",
      "zaujmout",
      "zavalit",
      "zavelet",
      "zavinit",
      "zavolat",
      "zavrtat",
      "zazvonit",
      "zbavit",
      "zbrusu",
      "zbudovat",
      "zbytek",
      "zdaleka",
      "zdarma",
      "zdatnost",
      "zdivo",
      "zdobit",
      "zdroj",
      "zdvih",
      "zdymadlo",
      "zelenina",
      "zeman",
      "zemina",
      "zeptat",
      "zezadu",
      "zezdola",
      "zhatit",
      "zhltnout",
      "zhluboka",
      "zhotovit",
      "zhruba",
      "zima",
      "zimnice",
      "zjemnit",
      "zklamat",
      "zkoumat",
      "zkratka",
      "zkumavka",
      "zlato",
      "zlehka",
      "zloba",
      "zlom",
      "zlost",
      "zlozvyk",
      "zmapovat",
      "zmar",
      "zmatek",
      "zmije",
      "zmizet",
      "zmocnit",
      "zmodrat",
      "zmrzlina",
      "zmutovat",
      "znak",
      "znalost",
      "znamenat",
      "znovu",
      "zobrazit",
      "zotavit",
      "zoubek",
      "zoufale",
      "zplodit",
      "zpomalit",
      "zprava",
      "zprostit",
      "zprudka",
      "zprvu",
      "zrada",
      "zranit",
      "zrcadlo",
      "zrnitost",
      "zrno",
      "zrovna",
      "zrychlit",
      "zrzavost",
      "zticha",
      "ztratit",
      "zubovina",
      "zubr",
      "zvednout",
      "zvenku",
      "zvesela",
      "zvon",
      "zvrat",
      "zvukovod",
      "zvyk"
    ];
  }
});

// node_modules/bip39/src/wordlists/chinese_simplified.json
var require_chinese_simplified = __commonJS({
  "node_modules/bip39/src/wordlists/chinese_simplified.json"(exports2, module2) {
    module2.exports = [
      "的",
      "一",
      "是",
      "在",
      "不",
      "了",
      "有",
      "和",
      "人",
      "这",
      "中",
      "大",
      "为",
      "上",
      "个",
      "国",
      "我",
      "以",
      "要",
      "他",
      "时",
      "来",
      "用",
      "们",
      "生",
      "到",
      "作",
      "地",
      "于",
      "出",
      "就",
      "分",
      "对",
      "成",
      "会",
      "可",
      "主",
      "发",
      "年",
      "动",
      "同",
      "工",
      "也",
      "能",
      "下",
      "过",
      "子",
      "说",
      "产",
      "种",
      "面",
      "而",
      "方",
      "后",
      "多",
      "定",
      "行",
      "学",
      "法",
      "所",
      "民",
      "得",
      "经",
      "十",
      "三",
      "之",
      "进",
      "着",
      "等",
      "部",
      "度",
      "家",
      "电",
      "力",
      "里",
      "如",
      "水",
      "化",
      "高",
      "自",
      "二",
      "理",
      "起",
      "小",
      "物",
      "现",
      "实",
      "加",
      "量",
      "都",
      "两",
      "体",
      "制",
      "机",
      "当",
      "使",
      "点",
      "从",
      "业",
      "本",
      "去",
      "把",
      "性",
      "好",
      "应",
      "开",
      "它",
      "合",
      "还",
      "因",
      "由",
      "其",
      "些",
      "然",
      "前",
      "外",
      "天",
      "政",
      "四",
      "日",
      "那",
      "社",
      "义",
      "事",
      "平",
      "形",
      "相",
      "全",
      "表",
      "间",
      "样",
      "与",
      "关",
      "各",
      "重",
      "新",
      "线",
      "内",
      "数",
      "正",
      "心",
      "反",
      "你",
      "明",
      "看",
      "原",
      "又",
      "么",
      "利",
      "比",
      "或",
      "但",
      "质",
      "气",
      "第",
      "向",
      "道",
      "命",
      "此",
      "变",
      "条",
      "只",
      "没",
      "结",
      "解",
      "问",
      "意",
      "建",
      "月",
      "公",
      "无",
      "系",
      "军",
      "很",
      "情",
      "者",
      "最",
      "立",
      "代",
      "想",
      "已",
      "通",
      "并",
      "提",
      "直",
      "题",
      "党",
      "程",
      "展",
      "五",
      "果",
      "料",
      "象",
      "员",
      "革",
      "位",
      "入",
      "常",
      "文",
      "总",
      "次",
      "品",
      "式",
      "活",
      "设",
      "及",
      "管",
      "特",
      "件",
      "长",
      "求",
      "老",
      "头",
      "基",
      "资",
      "边",
      "流",
      "路",
      "级",
      "少",
      "图",
      "山",
      "统",
      "接",
      "知",
      "较",
      "将",
      "组",
      "见",
      "计",
      "别",
      "她",
      "手",
      "角",
      "期",
      "根",
      "论",
      "运",
      "农",
      "指",
      "几",
      "九",
      "区",
      "强",
      "放",
      "决",
      "西",
      "被",
      "干",
      "做",
      "必",
      "战",
      "先",
      "回",
      "则",
      "任",
      "取",
      "据",
      "处",
      "队",
      "南",
      "给",
      "色",
      "光",
      "门",
      "即",
      "保",
      "治",
      "北",
      "造",
      "百",
      "规",
      "热",
      "领",
      "七",
      "海",
      "口",
      "东",
      "导",
      "器",
      "压",
      "志",
      "世",
      "金",
      "增",
      "争",
      "济",
      "阶",
      "油",
      "思",
      "术",
      "极",
      "交",
      "受",
      "联",
      "什",
      "认",
      "六",
      "共",
      "权",
      "收",
      "证",
      "改",
      "清",
      "美",
      "再",
      "采",
      "转",
      "更",
      "单",
      "风",
      "切",
      "打",
      "白",
      "教",
      "速",
      "花",
      "带",
      "安",
      "场",
      "身",
      "车",
      "例",
      "真",
      "务",
      "具",
      "万",
      "每",
      "目",
      "至",
      "达",
      "走",
      "积",
      "示",
      "议",
      "声",
      "报",
      "斗",
      "完",
      "类",
      "八",
      "离",
      "华",
      "名",
      "确",
      "才",
      "科",
      "张",
      "信",
      "马",
      "节",
      "话",
      "米",
      "整",
      "空",
      "元",
      "况",
      "今",
      "集",
      "温",
      "传",
      "土",
      "许",
      "步",
      "群",
      "广",
      "石",
      "记",
      "需",
      "段",
      "研",
      "界",
      "拉",
      "林",
      "律",
      "叫",
      "且",
      "究",
      "观",
      "越",
      "织",
      "装",
      "影",
      "算",
      "低",
      "持",
      "音",
      "众",
      "书",
      "布",
      "复",
      "容",
      "儿",
      "须",
      "际",
      "商",
      "非",
      "验",
      "连",
      "断",
      "深",
      "难",
      "近",
      "矿",
      "千",
      "周",
      "委",
      "素",
      "技",
      "备",
      "半",
      "办",
      "青",
      "省",
      "列",
      "习",
      "响",
      "约",
      "支",
      "般",
      "史",
      "感",
      "劳",
      "便",
      "团",
      "往",
      "酸",
      "历",
      "市",
      "克",
      "何",
      "除",
      "消",
      "构",
      "府",
      "称",
      "太",
      "准",
      "精",
      "值",
      "号",
      "率",
      "族",
      "维",
      "划",
      "选",
      "标",
      "写",
      "存",
      "候",
      "毛",
      "亲",
      "快",
      "效",
      "斯",
      "院",
      "查",
      "江",
      "型",
      "眼",
      "王",
      "按",
      "格",
      "养",
      "易",
      "置",
      "派",
      "层",
      "片",
      "始",
      "却",
      "专",
      "状",
      "育",
      "厂",
      "京",
      "识",
      "适",
      "属",
      "圆",
      "包",
      "火",
      "住",
      "调",
      "满",
      "县",
      "局",
      "照",
      "参",
      "红",
      "细",
      "引",
      "听",
      "该",
      "铁",
      "价",
      "严",
      "首",
      "底",
      "液",
      "官",
      "德",
      "随",
      "病",
      "苏",
      "失",
      "尔",
      "死",
      "讲",
      "配",
      "女",
      "黄",
      "推",
      "显",
      "谈",
      "罪",
      "神",
      "艺",
      "呢",
      "席",
      "含",
      "企",
      "望",
      "密",
      "批",
      "营",
      "项",
      "防",
      "举",
      "球",
      "英",
      "氧",
      "势",
      "告",
      "李",
      "台",
      "落",
      "木",
      "帮",
      "轮",
      "破",
      "亚",
      "师",
      "围",
      "注",
      "远",
      "字",
      "材",
      "排",
      "供",
      "河",
      "态",
      "封",
      "另",
      "施",
      "减",
      "树",
      "溶",
      "怎",
      "止",
      "案",
      "言",
      "士",
      "均",
      "武",
      "固",
      "叶",
      "鱼",
      "波",
      "视",
      "仅",
      "费",
      "紧",
      "爱",
      "左",
      "章",
      "早",
      "朝",
      "害",
      "续",
      "轻",
      "服",
      "试",
      "食",
      "充",
      "兵",
      "源",
      "判",
      "护",
      "司",
      "足",
      "某",
      "练",
      "差",
      "致",
      "板",
      "田",
      "降",
      "黑",
      "犯",
      "负",
      "击",
      "范",
      "继",
      "兴",
      "似",
      "余",
      "坚",
      "曲",
      "输",
      "修",
      "故",
      "城",
      "夫",
      "够",
      "送",
      "笔",
      "船",
      "占",
      "右",
      "财",
      "吃",
      "富",
      "春",
      "职",
      "觉",
      "汉",
      "画",
      "功",
      "巴",
      "跟",
      "虽",
      "杂",
      "飞",
      "检",
      "吸",
      "助",
      "升",
      "阳",
      "互",
      "初",
      "创",
      "抗",
      "考",
      "投",
      "坏",
      "策",
      "古",
      "径",
      "换",
      "未",
      "跑",
      "留",
      "钢",
      "曾",
      "端",
      "责",
      "站",
      "简",
      "述",
      "钱",
      "副",
      "尽",
      "帝",
      "射",
      "草",
      "冲",
      "承",
      "独",
      "令",
      "限",
      "阿",
      "宣",
      "环",
      "双",
      "请",
      "超",
      "微",
      "让",
      "控",
      "州",
      "良",
      "轴",
      "找",
      "否",
      "纪",
      "益",
      "依",
      "优",
      "顶",
      "础",
      "载",
      "倒",
      "房",
      "突",
      "坐",
      "粉",
      "敌",
      "略",
      "客",
      "袁",
      "冷",
      "胜",
      "绝",
      "析",
      "块",
      "剂",
      "测",
      "丝",
      "协",
      "诉",
      "念",
      "陈",
      "仍",
      "罗",
      "盐",
      "友",
      "洋",
      "错",
      "苦",
      "夜",
      "刑",
      "移",
      "频",
      "逐",
      "靠",
      "混",
      "母",
      "短",
      "皮",
      "终",
      "聚",
      "汽",
      "村",
      "云",
      "哪",
      "既",
      "距",
      "卫",
      "停",
      "烈",
      "央",
      "察",
      "烧",
      "迅",
      "境",
      "若",
      "印",
      "洲",
      "刻",
      "括",
      "激",
      "孔",
      "搞",
      "甚",
      "室",
      "待",
      "核",
      "校",
      "散",
      "侵",
      "吧",
      "甲",
      "游",
      "久",
      "菜",
      "味",
      "旧",
      "模",
      "湖",
      "货",
      "损",
      "预",
      "阻",
      "毫",
      "普",
      "稳",
      "乙",
      "妈",
      "植",
      "息",
      "扩",
      "银",
      "语",
      "挥",
      "酒",
      "守",
      "拿",
      "序",
      "纸",
      "医",
      "缺",
      "雨",
      "吗",
      "针",
      "刘",
      "啊",
      "急",
      "唱",
      "误",
      "训",
      "愿",
      "审",
      "附",
      "获",
      "茶",
      "鲜",
      "粮",
      "斤",
      "孩",
      "脱",
      "硫",
      "肥",
      "善",
      "龙",
      "演",
      "父",
      "渐",
      "血",
      "欢",
      "械",
      "掌",
      "歌",
      "沙",
      "刚",
      "攻",
      "谓",
      "盾",
      "讨",
      "晚",
      "粒",
      "乱",
      "燃",
      "矛",
      "乎",
      "杀",
      "药",
      "宁",
      "鲁",
      "贵",
      "钟",
      "煤",
      "读",
      "班",
      "伯",
      "香",
      "介",
      "迫",
      "句",
      "丰",
      "培",
      "握",
      "兰",
      "担",
      "弦",
      "蛋",
      "沉",
      "假",
      "穿",
      "执",
      "答",
      "乐",
      "谁",
      "顺",
      "烟",
      "缩",
      "征",
      "脸",
      "喜",
      "松",
      "脚",
      "困",
      "异",
      "免",
      "背",
      "星",
      "福",
      "买",
      "染",
      "井",
      "概",
      "慢",
      "怕",
      "磁",
      "倍",
      "祖",
      "皇",
      "促",
      "静",
      "补",
      "评",
      "翻",
      "肉",
      "践",
      "尼",
      "衣",
      "宽",
      "扬",
      "棉",
      "希",
      "伤",
      "操",
      "垂",
      "秋",
      "宜",
      "氢",
      "套",
      "督",
      "振",
      "架",
      "亮",
      "末",
      "宪",
      "庆",
      "编",
      "牛",
      "触",
      "映",
      "雷",
      "销",
      "诗",
      "座",
      "居",
      "抓",
      "裂",
      "胞",
      "呼",
      "娘",
      "景",
      "威",
      "绿",
      "晶",
      "厚",
      "盟",
      "衡",
      "鸡",
      "孙",
      "延",
      "危",
      "胶",
      "屋",
      "乡",
      "临",
      "陆",
      "顾",
      "掉",
      "呀",
      "灯",
      "岁",
      "措",
      "束",
      "耐",
      "剧",
      "玉",
      "赵",
      "跳",
      "哥",
      "季",
      "课",
      "凯",
      "胡",
      "额",
      "款",
      "绍",
      "卷",
      "齐",
      "伟",
      "蒸",
      "殖",
      "永",
      "宗",
      "苗",
      "川",
      "炉",
      "岩",
      "弱",
      "零",
      "杨",
      "奏",
      "沿",
      "露",
      "杆",
      "探",
      "滑",
      "镇",
      "饭",
      "浓",
      "航",
      "怀",
      "赶",
      "库",
      "夺",
      "伊",
      "灵",
      "税",
      "途",
      "灭",
      "赛",
      "归",
      "召",
      "鼓",
      "播",
      "盘",
      "裁",
      "险",
      "康",
      "唯",
      "录",
      "菌",
      "纯",
      "借",
      "糖",
      "盖",
      "横",
      "符",
      "私",
      "努",
      "堂",
      "域",
      "枪",
      "润",
      "幅",
      "哈",
      "竟",
      "熟",
      "虫",
      "泽",
      "脑",
      "壤",
      "碳",
      "欧",
      "遍",
      "侧",
      "寨",
      "敢",
      "彻",
      "虑",
      "斜",
      "薄",
      "庭",
      "纳",
      "弹",
      "饲",
      "伸",
      "折",
      "麦",
      "湿",
      "暗",
      "荷",
      "瓦",
      "塞",
      "床",
      "筑",
      "恶",
      "户",
      "访",
      "塔",
      "奇",
      "透",
      "梁",
      "刀",
      "旋",
      "迹",
      "卡",
      "氯",
      "遇",
      "份",
      "毒",
      "泥",
      "退",
      "洗",
      "摆",
      "灰",
      "彩",
      "卖",
      "耗",
      "夏",
      "择",
      "忙",
      "铜",
      "献",
      "硬",
      "予",
      "繁",
      "圈",
      "雪",
      "函",
      "亦",
      "抽",
      "篇",
      "阵",
      "阴",
      "丁",
      "尺",
      "追",
      "堆",
      "雄",
      "迎",
      "泛",
      "爸",
      "楼",
      "避",
      "谋",
      "吨",
      "野",
      "猪",
      "旗",
      "累",
      "偏",
      "典",
      "馆",
      "索",
      "秦",
      "脂",
      "潮",
      "爷",
      "豆",
      "忽",
      "托",
      "惊",
      "塑",
      "遗",
      "愈",
      "朱",
      "替",
      "纤",
      "粗",
      "倾",
      "尚",
      "痛",
      "楚",
      "谢",
      "奋",
      "购",
      "磨",
      "君",
      "池",
      "旁",
      "碎",
      "骨",
      "监",
      "捕",
      "弟",
      "暴",
      "割",
      "贯",
      "殊",
      "释",
      "词",
      "亡",
      "壁",
      "顿",
      "宝",
      "午",
      "尘",
      "闻",
      "揭",
      "炮",
      "残",
      "冬",
      "桥",
      "妇",
      "警",
      "综",
      "招",
      "吴",
      "付",
      "浮",
      "遭",
      "徐",
      "您",
      "摇",
      "谷",
      "赞",
      "箱",
      "隔",
      "订",
      "男",
      "吹",
      "园",
      "纷",
      "唐",
      "败",
      "宋",
      "玻",
      "巨",
      "耕",
      "坦",
      "荣",
      "闭",
      "湾",
      "键",
      "凡",
      "驻",
      "锅",
      "救",
      "恩",
      "剥",
      "凝",
      "碱",
      "齿",
      "截",
      "炼",
      "麻",
      "纺",
      "禁",
      "废",
      "盛",
      "版",
      "缓",
      "净",
      "睛",
      "昌",
      "婚",
      "涉",
      "筒",
      "嘴",
      "插",
      "岸",
      "朗",
      "庄",
      "街",
      "藏",
      "姑",
      "贸",
      "腐",
      "奴",
      "啦",
      "惯",
      "乘",
      "伙",
      "恢",
      "匀",
      "纱",
      "扎",
      "辩",
      "耳",
      "彪",
      "臣",
      "亿",
      "璃",
      "抵",
      "脉",
      "秀",
      "萨",
      "俄",
      "网",
      "舞",
      "店",
      "喷",
      "纵",
      "寸",
      "汗",
      "挂",
      "洪",
      "贺",
      "闪",
      "柬",
      "爆",
      "烯",
      "津",
      "稻",
      "墙",
      "软",
      "勇",
      "像",
      "滚",
      "厘",
      "蒙",
      "芳",
      "肯",
      "坡",
      "柱",
      "荡",
      "腿",
      "仪",
      "旅",
      "尾",
      "轧",
      "冰",
      "贡",
      "登",
      "黎",
      "削",
      "钻",
      "勒",
      "逃",
      "障",
      "氨",
      "郭",
      "峰",
      "币",
      "港",
      "伏",
      "轨",
      "亩",
      "毕",
      "擦",
      "莫",
      "刺",
      "浪",
      "秘",
      "援",
      "株",
      "健",
      "售",
      "股",
      "岛",
      "甘",
      "泡",
      "睡",
      "童",
      "铸",
      "汤",
      "阀",
      "休",
      "汇",
      "舍",
      "牧",
      "绕",
      "炸",
      "哲",
      "磷",
      "绩",
      "朋",
      "淡",
      "尖",
      "启",
      "陷",
      "柴",
      "呈",
      "徒",
      "颜",
      "泪",
      "稍",
      "忘",
      "泵",
      "蓝",
      "拖",
      "洞",
      "授",
      "镜",
      "辛",
      "壮",
      "锋",
      "贫",
      "虚",
      "弯",
      "摩",
      "泰",
      "幼",
      "廷",
      "尊",
      "窗",
      "纲",
      "弄",
      "隶",
      "疑",
      "氏",
      "宫",
      "姐",
      "震",
      "瑞",
      "怪",
      "尤",
      "琴",
      "循",
      "描",
      "膜",
      "违",
      "夹",
      "腰",
      "缘",
      "珠",
      "穷",
      "森",
      "枝",
      "竹",
      "沟",
      "催",
      "绳",
      "忆",
      "邦",
      "剩",
      "幸",
      "浆",
      "栏",
      "拥",
      "牙",
      "贮",
      "礼",
      "滤",
      "钠",
      "纹",
      "罢",
      "拍",
      "咱",
      "喊",
      "袖",
      "埃",
      "勤",
      "罚",
      "焦",
      "潜",
      "伍",
      "墨",
      "欲",
      "缝",
      "姓",
      "刊",
      "饱",
      "仿",
      "奖",
      "铝",
      "鬼",
      "丽",
      "跨",
      "默",
      "挖",
      "链",
      "扫",
      "喝",
      "袋",
      "炭",
      "污",
      "幕",
      "诸",
      "弧",
      "励",
      "梅",
      "奶",
      "洁",
      "灾",
      "舟",
      "鉴",
      "苯",
      "讼",
      "抱",
      "毁",
      "懂",
      "寒",
      "智",
      "埔",
      "寄",
      "届",
      "跃",
      "渡",
      "挑",
      "丹",
      "艰",
      "贝",
      "碰",
      "拔",
      "爹",
      "戴",
      "码",
      "梦",
      "芽",
      "熔",
      "赤",
      "渔",
      "哭",
      "敬",
      "颗",
      "奔",
      "铅",
      "仲",
      "虎",
      "稀",
      "妹",
      "乏",
      "珍",
      "申",
      "桌",
      "遵",
      "允",
      "隆",
      "螺",
      "仓",
      "魏",
      "锐",
      "晓",
      "氮",
      "兼",
      "隐",
      "碍",
      "赫",
      "拨",
      "忠",
      "肃",
      "缸",
      "牵",
      "抢",
      "博",
      "巧",
      "壳",
      "兄",
      "杜",
      "讯",
      "诚",
      "碧",
      "祥",
      "柯",
      "页",
      "巡",
      "矩",
      "悲",
      "灌",
      "龄",
      "伦",
      "票",
      "寻",
      "桂",
      "铺",
      "圣",
      "恐",
      "恰",
      "郑",
      "趣",
      "抬",
      "荒",
      "腾",
      "贴",
      "柔",
      "滴",
      "猛",
      "阔",
      "辆",
      "妻",
      "填",
      "撤",
      "储",
      "签",
      "闹",
      "扰",
      "紫",
      "砂",
      "递",
      "戏",
      "吊",
      "陶",
      "伐",
      "喂",
      "疗",
      "瓶",
      "婆",
      "抚",
      "臂",
      "摸",
      "忍",
      "虾",
      "蜡",
      "邻",
      "胸",
      "巩",
      "挤",
      "偶",
      "弃",
      "槽",
      "劲",
      "乳",
      "邓",
      "吉",
      "仁",
      "烂",
      "砖",
      "租",
      "乌",
      "舰",
      "伴",
      "瓜",
      "浅",
      "丙",
      "暂",
      "燥",
      "橡",
      "柳",
      "迷",
      "暖",
      "牌",
      "秧",
      "胆",
      "详",
      "簧",
      "踏",
      "瓷",
      "谱",
      "呆",
      "宾",
      "糊",
      "洛",
      "辉",
      "愤",
      "竞",
      "隙",
      "怒",
      "粘",
      "乃",
      "绪",
      "肩",
      "籍",
      "敏",
      "涂",
      "熙",
      "皆",
      "侦",
      "悬",
      "掘",
      "享",
      "纠",
      "醒",
      "狂",
      "锁",
      "淀",
      "恨",
      "牲",
      "霸",
      "爬",
      "赏",
      "逆",
      "玩",
      "陵",
      "祝",
      "秒",
      "浙",
      "貌",
      "役",
      "彼",
      "悉",
      "鸭",
      "趋",
      "凤",
      "晨",
      "畜",
      "辈",
      "秩",
      "卵",
      "署",
      "梯",
      "炎",
      "滩",
      "棋",
      "驱",
      "筛",
      "峡",
      "冒",
      "啥",
      "寿",
      "译",
      "浸",
      "泉",
      "帽",
      "迟",
      "硅",
      "疆",
      "贷",
      "漏",
      "稿",
      "冠",
      "嫩",
      "胁",
      "芯",
      "牢",
      "叛",
      "蚀",
      "奥",
      "鸣",
      "岭",
      "羊",
      "凭",
      "串",
      "塘",
      "绘",
      "酵",
      "融",
      "盆",
      "锡",
      "庙",
      "筹",
      "冻",
      "辅",
      "摄",
      "袭",
      "筋",
      "拒",
      "僚",
      "旱",
      "钾",
      "鸟",
      "漆",
      "沈",
      "眉",
      "疏",
      "添",
      "棒",
      "穗",
      "硝",
      "韩",
      "逼",
      "扭",
      "侨",
      "凉",
      "挺",
      "碗",
      "栽",
      "炒",
      "杯",
      "患",
      "馏",
      "劝",
      "豪",
      "辽",
      "勃",
      "鸿",
      "旦",
      "吏",
      "拜",
      "狗",
      "埋",
      "辊",
      "掩",
      "饮",
      "搬",
      "骂",
      "辞",
      "勾",
      "扣",
      "估",
      "蒋",
      "绒",
      "雾",
      "丈",
      "朵",
      "姆",
      "拟",
      "宇",
      "辑",
      "陕",
      "雕",
      "偿",
      "蓄",
      "崇",
      "剪",
      "倡",
      "厅",
      "咬",
      "驶",
      "薯",
      "刷",
      "斥",
      "番",
      "赋",
      "奉",
      "佛",
      "浇",
      "漫",
      "曼",
      "扇",
      "钙",
      "桃",
      "扶",
      "仔",
      "返",
      "俗",
      "亏",
      "腔",
      "鞋",
      "棱",
      "覆",
      "框",
      "悄",
      "叔",
      "撞",
      "骗",
      "勘",
      "旺",
      "沸",
      "孤",
      "吐",
      "孟",
      "渠",
      "屈",
      "疾",
      "妙",
      "惜",
      "仰",
      "狠",
      "胀",
      "谐",
      "抛",
      "霉",
      "桑",
      "岗",
      "嘛",
      "衰",
      "盗",
      "渗",
      "脏",
      "赖",
      "涌",
      "甜",
      "曹",
      "阅",
      "肌",
      "哩",
      "厉",
      "烃",
      "纬",
      "毅",
      "昨",
      "伪",
      "症",
      "煮",
      "叹",
      "钉",
      "搭",
      "茎",
      "笼",
      "酷",
      "偷",
      "弓",
      "锥",
      "恒",
      "杰",
      "坑",
      "鼻",
      "翼",
      "纶",
      "叙",
      "狱",
      "逮",
      "罐",
      "络",
      "棚",
      "抑",
      "膨",
      "蔬",
      "寺",
      "骤",
      "穆",
      "冶",
      "枯",
      "册",
      "尸",
      "凸",
      "绅",
      "坯",
      "牺",
      "焰",
      "轰",
      "欣",
      "晋",
      "瘦",
      "御",
      "锭",
      "锦",
      "丧",
      "旬",
      "锻",
      "垄",
      "搜",
      "扑",
      "邀",
      "亭",
      "酯",
      "迈",
      "舒",
      "脆",
      "酶",
      "闲",
      "忧",
      "酚",
      "顽",
      "羽",
      "涨",
      "卸",
      "仗",
      "陪",
      "辟",
      "惩",
      "杭",
      "姚",
      "肚",
      "捉",
      "飘",
      "漂",
      "昆",
      "欺",
      "吾",
      "郎",
      "烷",
      "汁",
      "呵",
      "饰",
      "萧",
      "雅",
      "邮",
      "迁",
      "燕",
      "撒",
      "姻",
      "赴",
      "宴",
      "烦",
      "债",
      "帐",
      "斑",
      "铃",
      "旨",
      "醇",
      "董",
      "饼",
      "雏",
      "姿",
      "拌",
      "傅",
      "腹",
      "妥",
      "揉",
      "贤",
      "拆",
      "歪",
      "葡",
      "胺",
      "丢",
      "浩",
      "徽",
      "昂",
      "垫",
      "挡",
      "览",
      "贪",
      "慰",
      "缴",
      "汪",
      "慌",
      "冯",
      "诺",
      "姜",
      "谊",
      "凶",
      "劣",
      "诬",
      "耀",
      "昏",
      "躺",
      "盈",
      "骑",
      "乔",
      "溪",
      "丛",
      "卢",
      "抹",
      "闷",
      "咨",
      "刮",
      "驾",
      "缆",
      "悟",
      "摘",
      "铒",
      "掷",
      "颇",
      "幻",
      "柄",
      "惠",
      "惨",
      "佳",
      "仇",
      "腊",
      "窝",
      "涤",
      "剑",
      "瞧",
      "堡",
      "泼",
      "葱",
      "罩",
      "霍",
      "捞",
      "胎",
      "苍",
      "滨",
      "俩",
      "捅",
      "湘",
      "砍",
      "霞",
      "邵",
      "萄",
      "疯",
      "淮",
      "遂",
      "熊",
      "粪",
      "烘",
      "宿",
      "档",
      "戈",
      "驳",
      "嫂",
      "裕",
      "徙",
      "箭",
      "捐",
      "肠",
      "撑",
      "晒",
      "辨",
      "殿",
      "莲",
      "摊",
      "搅",
      "酱",
      "屏",
      "疫",
      "哀",
      "蔡",
      "堵",
      "沫",
      "皱",
      "畅",
      "叠",
      "阁",
      "莱",
      "敲",
      "辖",
      "钩",
      "痕",
      "坝",
      "巷",
      "饿",
      "祸",
      "丘",
      "玄",
      "溜",
      "曰",
      "逻",
      "彭",
      "尝",
      "卿",
      "妨",
      "艇",
      "吞",
      "韦",
      "怨",
      "矮",
      "歇"
    ];
  }
});

// node_modules/bip39/src/wordlists/chinese_traditional.json
var require_chinese_traditional = __commonJS({
  "node_modules/bip39/src/wordlists/chinese_traditional.json"(exports2, module2) {
    module2.exports = [
      "的",
      "一",
      "是",
      "在",
      "不",
      "了",
      "有",
      "和",
      "人",
      "這",
      "中",
      "大",
      "為",
      "上",
      "個",
      "國",
      "我",
      "以",
      "要",
      "他",
      "時",
      "來",
      "用",
      "們",
      "生",
      "到",
      "作",
      "地",
      "於",
      "出",
      "就",
      "分",
      "對",
      "成",
      "會",
      "可",
      "主",
      "發",
      "年",
      "動",
      "同",
      "工",
      "也",
      "能",
      "下",
      "過",
      "子",
      "說",
      "產",
      "種",
      "面",
      "而",
      "方",
      "後",
      "多",
      "定",
      "行",
      "學",
      "法",
      "所",
      "民",
      "得",
      "經",
      "十",
      "三",
      "之",
      "進",
      "著",
      "等",
      "部",
      "度",
      "家",
      "電",
      "力",
      "裡",
      "如",
      "水",
      "化",
      "高",
      "自",
      "二",
      "理",
      "起",
      "小",
      "物",
      "現",
      "實",
      "加",
      "量",
      "都",
      "兩",
      "體",
      "制",
      "機",
      "當",
      "使",
      "點",
      "從",
      "業",
      "本",
      "去",
      "把",
      "性",
      "好",
      "應",
      "開",
      "它",
      "合",
      "還",
      "因",
      "由",
      "其",
      "些",
      "然",
      "前",
      "外",
      "天",
      "政",
      "四",
      "日",
      "那",
      "社",
      "義",
      "事",
      "平",
      "形",
      "相",
      "全",
      "表",
      "間",
      "樣",
      "與",
      "關",
      "各",
      "重",
      "新",
      "線",
      "內",
      "數",
      "正",
      "心",
      "反",
      "你",
      "明",
      "看",
      "原",
      "又",
      "麼",
      "利",
      "比",
      "或",
      "但",
      "質",
      "氣",
      "第",
      "向",
      "道",
      "命",
      "此",
      "變",
      "條",
      "只",
      "沒",
      "結",
      "解",
      "問",
      "意",
      "建",
      "月",
      "公",
      "無",
      "系",
      "軍",
      "很",
      "情",
      "者",
      "最",
      "立",
      "代",
      "想",
      "已",
      "通",
      "並",
      "提",
      "直",
      "題",
      "黨",
      "程",
      "展",
      "五",
      "果",
      "料",
      "象",
      "員",
      "革",
      "位",
      "入",
      "常",
      "文",
      "總",
      "次",
      "品",
      "式",
      "活",
      "設",
      "及",
      "管",
      "特",
      "件",
      "長",
      "求",
      "老",
      "頭",
      "基",
      "資",
      "邊",
      "流",
      "路",
      "級",
      "少",
      "圖",
      "山",
      "統",
      "接",
      "知",
      "較",
      "將",
      "組",
      "見",
      "計",
      "別",
      "她",
      "手",
      "角",
      "期",
      "根",
      "論",
      "運",
      "農",
      "指",
      "幾",
      "九",
      "區",
      "強",
      "放",
      "決",
      "西",
      "被",
      "幹",
      "做",
      "必",
      "戰",
      "先",
      "回",
      "則",
      "任",
      "取",
      "據",
      "處",
      "隊",
      "南",
      "給",
      "色",
      "光",
      "門",
      "即",
      "保",
      "治",
      "北",
      "造",
      "百",
      "規",
      "熱",
      "領",
      "七",
      "海",
      "口",
      "東",
      "導",
      "器",
      "壓",
      "志",
      "世",
      "金",
      "增",
      "爭",
      "濟",
      "階",
      "油",
      "思",
      "術",
      "極",
      "交",
      "受",
      "聯",
      "什",
      "認",
      "六",
      "共",
      "權",
      "收",
      "證",
      "改",
      "清",
      "美",
      "再",
      "採",
      "轉",
      "更",
      "單",
      "風",
      "切",
      "打",
      "白",
      "教",
      "速",
      "花",
      "帶",
      "安",
      "場",
      "身",
      "車",
      "例",
      "真",
      "務",
      "具",
      "萬",
      "每",
      "目",
      "至",
      "達",
      "走",
      "積",
      "示",
      "議",
      "聲",
      "報",
      "鬥",
      "完",
      "類",
      "八",
      "離",
      "華",
      "名",
      "確",
      "才",
      "科",
      "張",
      "信",
      "馬",
      "節",
      "話",
      "米",
      "整",
      "空",
      "元",
      "況",
      "今",
      "集",
      "溫",
      "傳",
      "土",
      "許",
      "步",
      "群",
      "廣",
      "石",
      "記",
      "需",
      "段",
      "研",
      "界",
      "拉",
      "林",
      "律",
      "叫",
      "且",
      "究",
      "觀",
      "越",
      "織",
      "裝",
      "影",
      "算",
      "低",
      "持",
      "音",
      "眾",
      "書",
      "布",
      "复",
      "容",
      "兒",
      "須",
      "際",
      "商",
      "非",
      "驗",
      "連",
      "斷",
      "深",
      "難",
      "近",
      "礦",
      "千",
      "週",
      "委",
      "素",
      "技",
      "備",
      "半",
      "辦",
      "青",
      "省",
      "列",
      "習",
      "響",
      "約",
      "支",
      "般",
      "史",
      "感",
      "勞",
      "便",
      "團",
      "往",
      "酸",
      "歷",
      "市",
      "克",
      "何",
      "除",
      "消",
      "構",
      "府",
      "稱",
      "太",
      "準",
      "精",
      "值",
      "號",
      "率",
      "族",
      "維",
      "劃",
      "選",
      "標",
      "寫",
      "存",
      "候",
      "毛",
      "親",
      "快",
      "效",
      "斯",
      "院",
      "查",
      "江",
      "型",
      "眼",
      "王",
      "按",
      "格",
      "養",
      "易",
      "置",
      "派",
      "層",
      "片",
      "始",
      "卻",
      "專",
      "狀",
      "育",
      "廠",
      "京",
      "識",
      "適",
      "屬",
      "圓",
      "包",
      "火",
      "住",
      "調",
      "滿",
      "縣",
      "局",
      "照",
      "參",
      "紅",
      "細",
      "引",
      "聽",
      "該",
      "鐵",
      "價",
      "嚴",
      "首",
      "底",
      "液",
      "官",
      "德",
      "隨",
      "病",
      "蘇",
      "失",
      "爾",
      "死",
      "講",
      "配",
      "女",
      "黃",
      "推",
      "顯",
      "談",
      "罪",
      "神",
      "藝",
      "呢",
      "席",
      "含",
      "企",
      "望",
      "密",
      "批",
      "營",
      "項",
      "防",
      "舉",
      "球",
      "英",
      "氧",
      "勢",
      "告",
      "李",
      "台",
      "落",
      "木",
      "幫",
      "輪",
      "破",
      "亞",
      "師",
      "圍",
      "注",
      "遠",
      "字",
      "材",
      "排",
      "供",
      "河",
      "態",
      "封",
      "另",
      "施",
      "減",
      "樹",
      "溶",
      "怎",
      "止",
      "案",
      "言",
      "士",
      "均",
      "武",
      "固",
      "葉",
      "魚",
      "波",
      "視",
      "僅",
      "費",
      "緊",
      "愛",
      "左",
      "章",
      "早",
      "朝",
      "害",
      "續",
      "輕",
      "服",
      "試",
      "食",
      "充",
      "兵",
      "源",
      "判",
      "護",
      "司",
      "足",
      "某",
      "練",
      "差",
      "致",
      "板",
      "田",
      "降",
      "黑",
      "犯",
      "負",
      "擊",
      "范",
      "繼",
      "興",
      "似",
      "餘",
      "堅",
      "曲",
      "輸",
      "修",
      "故",
      "城",
      "夫",
      "夠",
      "送",
      "筆",
      "船",
      "佔",
      "右",
      "財",
      "吃",
      "富",
      "春",
      "職",
      "覺",
      "漢",
      "畫",
      "功",
      "巴",
      "跟",
      "雖",
      "雜",
      "飛",
      "檢",
      "吸",
      "助",
      "昇",
      "陽",
      "互",
      "初",
      "創",
      "抗",
      "考",
      "投",
      "壞",
      "策",
      "古",
      "徑",
      "換",
      "未",
      "跑",
      "留",
      "鋼",
      "曾",
      "端",
      "責",
      "站",
      "簡",
      "述",
      "錢",
      "副",
      "盡",
      "帝",
      "射",
      "草",
      "衝",
      "承",
      "獨",
      "令",
      "限",
      "阿",
      "宣",
      "環",
      "雙",
      "請",
      "超",
      "微",
      "讓",
      "控",
      "州",
      "良",
      "軸",
      "找",
      "否",
      "紀",
      "益",
      "依",
      "優",
      "頂",
      "礎",
      "載",
      "倒",
      "房",
      "突",
      "坐",
      "粉",
      "敵",
      "略",
      "客",
      "袁",
      "冷",
      "勝",
      "絕",
      "析",
      "塊",
      "劑",
      "測",
      "絲",
      "協",
      "訴",
      "念",
      "陳",
      "仍",
      "羅",
      "鹽",
      "友",
      "洋",
      "錯",
      "苦",
      "夜",
      "刑",
      "移",
      "頻",
      "逐",
      "靠",
      "混",
      "母",
      "短",
      "皮",
      "終",
      "聚",
      "汽",
      "村",
      "雲",
      "哪",
      "既",
      "距",
      "衛",
      "停",
      "烈",
      "央",
      "察",
      "燒",
      "迅",
      "境",
      "若",
      "印",
      "洲",
      "刻",
      "括",
      "激",
      "孔",
      "搞",
      "甚",
      "室",
      "待",
      "核",
      "校",
      "散",
      "侵",
      "吧",
      "甲",
      "遊",
      "久",
      "菜",
      "味",
      "舊",
      "模",
      "湖",
      "貨",
      "損",
      "預",
      "阻",
      "毫",
      "普",
      "穩",
      "乙",
      "媽",
      "植",
      "息",
      "擴",
      "銀",
      "語",
      "揮",
      "酒",
      "守",
      "拿",
      "序",
      "紙",
      "醫",
      "缺",
      "雨",
      "嗎",
      "針",
      "劉",
      "啊",
      "急",
      "唱",
      "誤",
      "訓",
      "願",
      "審",
      "附",
      "獲",
      "茶",
      "鮮",
      "糧",
      "斤",
      "孩",
      "脫",
      "硫",
      "肥",
      "善",
      "龍",
      "演",
      "父",
      "漸",
      "血",
      "歡",
      "械",
      "掌",
      "歌",
      "沙",
      "剛",
      "攻",
      "謂",
      "盾",
      "討",
      "晚",
      "粒",
      "亂",
      "燃",
      "矛",
      "乎",
      "殺",
      "藥",
      "寧",
      "魯",
      "貴",
      "鐘",
      "煤",
      "讀",
      "班",
      "伯",
      "香",
      "介",
      "迫",
      "句",
      "豐",
      "培",
      "握",
      "蘭",
      "擔",
      "弦",
      "蛋",
      "沉",
      "假",
      "穿",
      "執",
      "答",
      "樂",
      "誰",
      "順",
      "煙",
      "縮",
      "徵",
      "臉",
      "喜",
      "松",
      "腳",
      "困",
      "異",
      "免",
      "背",
      "星",
      "福",
      "買",
      "染",
      "井",
      "概",
      "慢",
      "怕",
      "磁",
      "倍",
      "祖",
      "皇",
      "促",
      "靜",
      "補",
      "評",
      "翻",
      "肉",
      "踐",
      "尼",
      "衣",
      "寬",
      "揚",
      "棉",
      "希",
      "傷",
      "操",
      "垂",
      "秋",
      "宜",
      "氫",
      "套",
      "督",
      "振",
      "架",
      "亮",
      "末",
      "憲",
      "慶",
      "編",
      "牛",
      "觸",
      "映",
      "雷",
      "銷",
      "詩",
      "座",
      "居",
      "抓",
      "裂",
      "胞",
      "呼",
      "娘",
      "景",
      "威",
      "綠",
      "晶",
      "厚",
      "盟",
      "衡",
      "雞",
      "孫",
      "延",
      "危",
      "膠",
      "屋",
      "鄉",
      "臨",
      "陸",
      "顧",
      "掉",
      "呀",
      "燈",
      "歲",
      "措",
      "束",
      "耐",
      "劇",
      "玉",
      "趙",
      "跳",
      "哥",
      "季",
      "課",
      "凱",
      "胡",
      "額",
      "款",
      "紹",
      "卷",
      "齊",
      "偉",
      "蒸",
      "殖",
      "永",
      "宗",
      "苗",
      "川",
      "爐",
      "岩",
      "弱",
      "零",
      "楊",
      "奏",
      "沿",
      "露",
      "桿",
      "探",
      "滑",
      "鎮",
      "飯",
      "濃",
      "航",
      "懷",
      "趕",
      "庫",
      "奪",
      "伊",
      "靈",
      "稅",
      "途",
      "滅",
      "賽",
      "歸",
      "召",
      "鼓",
      "播",
      "盤",
      "裁",
      "險",
      "康",
      "唯",
      "錄",
      "菌",
      "純",
      "借",
      "糖",
      "蓋",
      "橫",
      "符",
      "私",
      "努",
      "堂",
      "域",
      "槍",
      "潤",
      "幅",
      "哈",
      "竟",
      "熟",
      "蟲",
      "澤",
      "腦",
      "壤",
      "碳",
      "歐",
      "遍",
      "側",
      "寨",
      "敢",
      "徹",
      "慮",
      "斜",
      "薄",
      "庭",
      "納",
      "彈",
      "飼",
      "伸",
      "折",
      "麥",
      "濕",
      "暗",
      "荷",
      "瓦",
      "塞",
      "床",
      "築",
      "惡",
      "戶",
      "訪",
      "塔",
      "奇",
      "透",
      "梁",
      "刀",
      "旋",
      "跡",
      "卡",
      "氯",
      "遇",
      "份",
      "毒",
      "泥",
      "退",
      "洗",
      "擺",
      "灰",
      "彩",
      "賣",
      "耗",
      "夏",
      "擇",
      "忙",
      "銅",
      "獻",
      "硬",
      "予",
      "繁",
      "圈",
      "雪",
      "函",
      "亦",
      "抽",
      "篇",
      "陣",
      "陰",
      "丁",
      "尺",
      "追",
      "堆",
      "雄",
      "迎",
      "泛",
      "爸",
      "樓",
      "避",
      "謀",
      "噸",
      "野",
      "豬",
      "旗",
      "累",
      "偏",
      "典",
      "館",
      "索",
      "秦",
      "脂",
      "潮",
      "爺",
      "豆",
      "忽",
      "托",
      "驚",
      "塑",
      "遺",
      "愈",
      "朱",
      "替",
      "纖",
      "粗",
      "傾",
      "尚",
      "痛",
      "楚",
      "謝",
      "奮",
      "購",
      "磨",
      "君",
      "池",
      "旁",
      "碎",
      "骨",
      "監",
      "捕",
      "弟",
      "暴",
      "割",
      "貫",
      "殊",
      "釋",
      "詞",
      "亡",
      "壁",
      "頓",
      "寶",
      "午",
      "塵",
      "聞",
      "揭",
      "炮",
      "殘",
      "冬",
      "橋",
      "婦",
      "警",
      "綜",
      "招",
      "吳",
      "付",
      "浮",
      "遭",
      "徐",
      "您",
      "搖",
      "谷",
      "贊",
      "箱",
      "隔",
      "訂",
      "男",
      "吹",
      "園",
      "紛",
      "唐",
      "敗",
      "宋",
      "玻",
      "巨",
      "耕",
      "坦",
      "榮",
      "閉",
      "灣",
      "鍵",
      "凡",
      "駐",
      "鍋",
      "救",
      "恩",
      "剝",
      "凝",
      "鹼",
      "齒",
      "截",
      "煉",
      "麻",
      "紡",
      "禁",
      "廢",
      "盛",
      "版",
      "緩",
      "淨",
      "睛",
      "昌",
      "婚",
      "涉",
      "筒",
      "嘴",
      "插",
      "岸",
      "朗",
      "莊",
      "街",
      "藏",
      "姑",
      "貿",
      "腐",
      "奴",
      "啦",
      "慣",
      "乘",
      "夥",
      "恢",
      "勻",
      "紗",
      "扎",
      "辯",
      "耳",
      "彪",
      "臣",
      "億",
      "璃",
      "抵",
      "脈",
      "秀",
      "薩",
      "俄",
      "網",
      "舞",
      "店",
      "噴",
      "縱",
      "寸",
      "汗",
      "掛",
      "洪",
      "賀",
      "閃",
      "柬",
      "爆",
      "烯",
      "津",
      "稻",
      "牆",
      "軟",
      "勇",
      "像",
      "滾",
      "厘",
      "蒙",
      "芳",
      "肯",
      "坡",
      "柱",
      "盪",
      "腿",
      "儀",
      "旅",
      "尾",
      "軋",
      "冰",
      "貢",
      "登",
      "黎",
      "削",
      "鑽",
      "勒",
      "逃",
      "障",
      "氨",
      "郭",
      "峰",
      "幣",
      "港",
      "伏",
      "軌",
      "畝",
      "畢",
      "擦",
      "莫",
      "刺",
      "浪",
      "秘",
      "援",
      "株",
      "健",
      "售",
      "股",
      "島",
      "甘",
      "泡",
      "睡",
      "童",
      "鑄",
      "湯",
      "閥",
      "休",
      "匯",
      "舍",
      "牧",
      "繞",
      "炸",
      "哲",
      "磷",
      "績",
      "朋",
      "淡",
      "尖",
      "啟",
      "陷",
      "柴",
      "呈",
      "徒",
      "顏",
      "淚",
      "稍",
      "忘",
      "泵",
      "藍",
      "拖",
      "洞",
      "授",
      "鏡",
      "辛",
      "壯",
      "鋒",
      "貧",
      "虛",
      "彎",
      "摩",
      "泰",
      "幼",
      "廷",
      "尊",
      "窗",
      "綱",
      "弄",
      "隸",
      "疑",
      "氏",
      "宮",
      "姐",
      "震",
      "瑞",
      "怪",
      "尤",
      "琴",
      "循",
      "描",
      "膜",
      "違",
      "夾",
      "腰",
      "緣",
      "珠",
      "窮",
      "森",
      "枝",
      "竹",
      "溝",
      "催",
      "繩",
      "憶",
      "邦",
      "剩",
      "幸",
      "漿",
      "欄",
      "擁",
      "牙",
      "貯",
      "禮",
      "濾",
      "鈉",
      "紋",
      "罷",
      "拍",
      "咱",
      "喊",
      "袖",
      "埃",
      "勤",
      "罰",
      "焦",
      "潛",
      "伍",
      "墨",
      "欲",
      "縫",
      "姓",
      "刊",
      "飽",
      "仿",
      "獎",
      "鋁",
      "鬼",
      "麗",
      "跨",
      "默",
      "挖",
      "鏈",
      "掃",
      "喝",
      "袋",
      "炭",
      "污",
      "幕",
      "諸",
      "弧",
      "勵",
      "梅",
      "奶",
      "潔",
      "災",
      "舟",
      "鑑",
      "苯",
      "訟",
      "抱",
      "毀",
      "懂",
      "寒",
      "智",
      "埔",
      "寄",
      "屆",
      "躍",
      "渡",
      "挑",
      "丹",
      "艱",
      "貝",
      "碰",
      "拔",
      "爹",
      "戴",
      "碼",
      "夢",
      "芽",
      "熔",
      "赤",
      "漁",
      "哭",
      "敬",
      "顆",
      "奔",
      "鉛",
      "仲",
      "虎",
      "稀",
      "妹",
      "乏",
      "珍",
      "申",
      "桌",
      "遵",
      "允",
      "隆",
      "螺",
      "倉",
      "魏",
      "銳",
      "曉",
      "氮",
      "兼",
      "隱",
      "礙",
      "赫",
      "撥",
      "忠",
      "肅",
      "缸",
      "牽",
      "搶",
      "博",
      "巧",
      "殼",
      "兄",
      "杜",
      "訊",
      "誠",
      "碧",
      "祥",
      "柯",
      "頁",
      "巡",
      "矩",
      "悲",
      "灌",
      "齡",
      "倫",
      "票",
      "尋",
      "桂",
      "鋪",
      "聖",
      "恐",
      "恰",
      "鄭",
      "趣",
      "抬",
      "荒",
      "騰",
      "貼",
      "柔",
      "滴",
      "猛",
      "闊",
      "輛",
      "妻",
      "填",
      "撤",
      "儲",
      "簽",
      "鬧",
      "擾",
      "紫",
      "砂",
      "遞",
      "戲",
      "吊",
      "陶",
      "伐",
      "餵",
      "療",
      "瓶",
      "婆",
      "撫",
      "臂",
      "摸",
      "忍",
      "蝦",
      "蠟",
      "鄰",
      "胸",
      "鞏",
      "擠",
      "偶",
      "棄",
      "槽",
      "勁",
      "乳",
      "鄧",
      "吉",
      "仁",
      "爛",
      "磚",
      "租",
      "烏",
      "艦",
      "伴",
      "瓜",
      "淺",
      "丙",
      "暫",
      "燥",
      "橡",
      "柳",
      "迷",
      "暖",
      "牌",
      "秧",
      "膽",
      "詳",
      "簧",
      "踏",
      "瓷",
      "譜",
      "呆",
      "賓",
      "糊",
      "洛",
      "輝",
      "憤",
      "競",
      "隙",
      "怒",
      "粘",
      "乃",
      "緒",
      "肩",
      "籍",
      "敏",
      "塗",
      "熙",
      "皆",
      "偵",
      "懸",
      "掘",
      "享",
      "糾",
      "醒",
      "狂",
      "鎖",
      "淀",
      "恨",
      "牲",
      "霸",
      "爬",
      "賞",
      "逆",
      "玩",
      "陵",
      "祝",
      "秒",
      "浙",
      "貌",
      "役",
      "彼",
      "悉",
      "鴨",
      "趨",
      "鳳",
      "晨",
      "畜",
      "輩",
      "秩",
      "卵",
      "署",
      "梯",
      "炎",
      "灘",
      "棋",
      "驅",
      "篩",
      "峽",
      "冒",
      "啥",
      "壽",
      "譯",
      "浸",
      "泉",
      "帽",
      "遲",
      "矽",
      "疆",
      "貸",
      "漏",
      "稿",
      "冠",
      "嫩",
      "脅",
      "芯",
      "牢",
      "叛",
      "蝕",
      "奧",
      "鳴",
      "嶺",
      "羊",
      "憑",
      "串",
      "塘",
      "繪",
      "酵",
      "融",
      "盆",
      "錫",
      "廟",
      "籌",
      "凍",
      "輔",
      "攝",
      "襲",
      "筋",
      "拒",
      "僚",
      "旱",
      "鉀",
      "鳥",
      "漆",
      "沈",
      "眉",
      "疏",
      "添",
      "棒",
      "穗",
      "硝",
      "韓",
      "逼",
      "扭",
      "僑",
      "涼",
      "挺",
      "碗",
      "栽",
      "炒",
      "杯",
      "患",
      "餾",
      "勸",
      "豪",
      "遼",
      "勃",
      "鴻",
      "旦",
      "吏",
      "拜",
      "狗",
      "埋",
      "輥",
      "掩",
      "飲",
      "搬",
      "罵",
      "辭",
      "勾",
      "扣",
      "估",
      "蔣",
      "絨",
      "霧",
      "丈",
      "朵",
      "姆",
      "擬",
      "宇",
      "輯",
      "陝",
      "雕",
      "償",
      "蓄",
      "崇",
      "剪",
      "倡",
      "廳",
      "咬",
      "駛",
      "薯",
      "刷",
      "斥",
      "番",
      "賦",
      "奉",
      "佛",
      "澆",
      "漫",
      "曼",
      "扇",
      "鈣",
      "桃",
      "扶",
      "仔",
      "返",
      "俗",
      "虧",
      "腔",
      "鞋",
      "棱",
      "覆",
      "框",
      "悄",
      "叔",
      "撞",
      "騙",
      "勘",
      "旺",
      "沸",
      "孤",
      "吐",
      "孟",
      "渠",
      "屈",
      "疾",
      "妙",
      "惜",
      "仰",
      "狠",
      "脹",
      "諧",
      "拋",
      "黴",
      "桑",
      "崗",
      "嘛",
      "衰",
      "盜",
      "滲",
      "臟",
      "賴",
      "湧",
      "甜",
      "曹",
      "閱",
      "肌",
      "哩",
      "厲",
      "烴",
      "緯",
      "毅",
      "昨",
      "偽",
      "症",
      "煮",
      "嘆",
      "釘",
      "搭",
      "莖",
      "籠",
      "酷",
      "偷",
      "弓",
      "錐",
      "恆",
      "傑",
      "坑",
      "鼻",
      "翼",
      "綸",
      "敘",
      "獄",
      "逮",
      "罐",
      "絡",
      "棚",
      "抑",
      "膨",
      "蔬",
      "寺",
      "驟",
      "穆",
      "冶",
      "枯",
      "冊",
      "屍",
      "凸",
      "紳",
      "坯",
      "犧",
      "焰",
      "轟",
      "欣",
      "晉",
      "瘦",
      "禦",
      "錠",
      "錦",
      "喪",
      "旬",
      "鍛",
      "壟",
      "搜",
      "撲",
      "邀",
      "亭",
      "酯",
      "邁",
      "舒",
      "脆",
      "酶",
      "閒",
      "憂",
      "酚",
      "頑",
      "羽",
      "漲",
      "卸",
      "仗",
      "陪",
      "闢",
      "懲",
      "杭",
      "姚",
      "肚",
      "捉",
      "飄",
      "漂",
      "昆",
      "欺",
      "吾",
      "郎",
      "烷",
      "汁",
      "呵",
      "飾",
      "蕭",
      "雅",
      "郵",
      "遷",
      "燕",
      "撒",
      "姻",
      "赴",
      "宴",
      "煩",
      "債",
      "帳",
      "斑",
      "鈴",
      "旨",
      "醇",
      "董",
      "餅",
      "雛",
      "姿",
      "拌",
      "傅",
      "腹",
      "妥",
      "揉",
      "賢",
      "拆",
      "歪",
      "葡",
      "胺",
      "丟",
      "浩",
      "徽",
      "昂",
      "墊",
      "擋",
      "覽",
      "貪",
      "慰",
      "繳",
      "汪",
      "慌",
      "馮",
      "諾",
      "姜",
      "誼",
      "兇",
      "劣",
      "誣",
      "耀",
      "昏",
      "躺",
      "盈",
      "騎",
      "喬",
      "溪",
      "叢",
      "盧",
      "抹",
      "悶",
      "諮",
      "刮",
      "駕",
      "纜",
      "悟",
      "摘",
      "鉺",
      "擲",
      "頗",
      "幻",
      "柄",
      "惠",
      "慘",
      "佳",
      "仇",
      "臘",
      "窩",
      "滌",
      "劍",
      "瞧",
      "堡",
      "潑",
      "蔥",
      "罩",
      "霍",
      "撈",
      "胎",
      "蒼",
      "濱",
      "倆",
      "捅",
      "湘",
      "砍",
      "霞",
      "邵",
      "萄",
      "瘋",
      "淮",
      "遂",
      "熊",
      "糞",
      "烘",
      "宿",
      "檔",
      "戈",
      "駁",
      "嫂",
      "裕",
      "徙",
      "箭",
      "捐",
      "腸",
      "撐",
      "曬",
      "辨",
      "殿",
      "蓮",
      "攤",
      "攪",
      "醬",
      "屏",
      "疫",
      "哀",
      "蔡",
      "堵",
      "沫",
      "皺",
      "暢",
      "疊",
      "閣",
      "萊",
      "敲",
      "轄",
      "鉤",
      "痕",
      "壩",
      "巷",
      "餓",
      "禍",
      "丘",
      "玄",
      "溜",
      "曰",
      "邏",
      "彭",
      "嘗",
      "卿",
      "妨",
      "艇",
      "吞",
      "韋",
      "怨",
      "矮",
      "歇"
    ];
  }
});

// node_modules/bip39/src/wordlists/korean.json
var require_korean = __commonJS({
  "node_modules/bip39/src/wordlists/korean.json"(exports2, module2) {
    module2.exports = [
      "가격",
      "가끔",
      "가난",
      "가능",
      "가득",
      "가르침",
      "가뭄",
      "가방",
      "가상",
      "가슴",
      "가운데",
      "가을",
      "가이드",
      "가입",
      "가장",
      "가정",
      "가족",
      "가죽",
      "각오",
      "각자",
      "간격",
      "간부",
      "간섭",
      "간장",
      "간접",
      "간판",
      "갈등",
      "갈비",
      "갈색",
      "갈증",
      "감각",
      "감기",
      "감소",
      "감수성",
      "감자",
      "감정",
      "갑자기",
      "강남",
      "강당",
      "강도",
      "강력히",
      "강변",
      "강북",
      "강사",
      "강수량",
      "강아지",
      "강원도",
      "강의",
      "강제",
      "강조",
      "같이",
      "개구리",
      "개나리",
      "개방",
      "개별",
      "개선",
      "개성",
      "개인",
      "객관적",
      "거실",
      "거액",
      "거울",
      "거짓",
      "거품",
      "걱정",
      "건강",
      "건물",
      "건설",
      "건조",
      "건축",
      "걸음",
      "검사",
      "검토",
      "게시판",
      "게임",
      "겨울",
      "견해",
      "결과",
      "결국",
      "결론",
      "결석",
      "결승",
      "결심",
      "결정",
      "결혼",
      "경계",
      "경고",
      "경기",
      "경력",
      "경복궁",
      "경비",
      "경상도",
      "경영",
      "경우",
      "경쟁",
      "경제",
      "경주",
      "경찰",
      "경치",
      "경향",
      "경험",
      "계곡",
      "계단",
      "계란",
      "계산",
      "계속",
      "계약",
      "계절",
      "계층",
      "계획",
      "고객",
      "고구려",
      "고궁",
      "고급",
      "고등학생",
      "고무신",
      "고민",
      "고양이",
      "고장",
      "고전",
      "고집",
      "고춧가루",
      "고통",
      "고향",
      "곡식",
      "골목",
      "골짜기",
      "골프",
      "공간",
      "공개",
      "공격",
      "공군",
      "공급",
      "공기",
      "공동",
      "공무원",
      "공부",
      "공사",
      "공식",
      "공업",
      "공연",
      "공원",
      "공장",
      "공짜",
      "공책",
      "공통",
      "공포",
      "공항",
      "공휴일",
      "과목",
      "과일",
      "과장",
      "과정",
      "과학",
      "관객",
      "관계",
      "관광",
      "관념",
      "관람",
      "관련",
      "관리",
      "관습",
      "관심",
      "관점",
      "관찰",
      "광경",
      "광고",
      "광장",
      "광주",
      "괴로움",
      "굉장히",
      "교과서",
      "교문",
      "교복",
      "교실",
      "교양",
      "교육",
      "교장",
      "교직",
      "교통",
      "교환",
      "교훈",
      "구경",
      "구름",
      "구멍",
      "구별",
      "구분",
      "구석",
      "구성",
      "구속",
      "구역",
      "구입",
      "구청",
      "구체적",
      "국가",
      "국기",
      "국내",
      "국립",
      "국물",
      "국민",
      "국수",
      "국어",
      "국왕",
      "국적",
      "국제",
      "국회",
      "군대",
      "군사",
      "군인",
      "궁극적",
      "권리",
      "권위",
      "권투",
      "귀국",
      "귀신",
      "규정",
      "규칙",
      "균형",
      "그날",
      "그냥",
      "그늘",
      "그러나",
      "그룹",
      "그릇",
      "그림",
      "그제서야",
      "그토록",
      "극복",
      "극히",
      "근거",
      "근교",
      "근래",
      "근로",
      "근무",
      "근본",
      "근원",
      "근육",
      "근처",
      "글씨",
      "글자",
      "금강산",
      "금고",
      "금년",
      "금메달",
      "금액",
      "금연",
      "금요일",
      "금지",
      "긍정적",
      "기간",
      "기관",
      "기념",
      "기능",
      "기독교",
      "기둥",
      "기록",
      "기름",
      "기법",
      "기본",
      "기분",
      "기쁨",
      "기숙사",
      "기술",
      "기억",
      "기업",
      "기온",
      "기운",
      "기원",
      "기적",
      "기준",
      "기침",
      "기혼",
      "기획",
      "긴급",
      "긴장",
      "길이",
      "김밥",
      "김치",
      "김포공항",
      "깍두기",
      "깜빡",
      "깨달음",
      "깨소금",
      "껍질",
      "꼭대기",
      "꽃잎",
      "나들이",
      "나란히",
      "나머지",
      "나물",
      "나침반",
      "나흘",
      "낙엽",
      "난방",
      "날개",
      "날씨",
      "날짜",
      "남녀",
      "남대문",
      "남매",
      "남산",
      "남자",
      "남편",
      "남학생",
      "낭비",
      "낱말",
      "내년",
      "내용",
      "내일",
      "냄비",
      "냄새",
      "냇물",
      "냉동",
      "냉면",
      "냉방",
      "냉장고",
      "넥타이",
      "넷째",
      "노동",
      "노란색",
      "노력",
      "노인",
      "녹음",
      "녹차",
      "녹화",
      "논리",
      "논문",
      "논쟁",
      "놀이",
      "농구",
      "농담",
      "농민",
      "농부",
      "농업",
      "농장",
      "농촌",
      "높이",
      "눈동자",
      "눈물",
      "눈썹",
      "뉴욕",
      "느낌",
      "늑대",
      "능동적",
      "능력",
      "다방",
      "다양성",
      "다음",
      "다이어트",
      "다행",
      "단계",
      "단골",
      "단독",
      "단맛",
      "단순",
      "단어",
      "단위",
      "단점",
      "단체",
      "단추",
      "단편",
      "단풍",
      "달걀",
      "달러",
      "달력",
      "달리",
      "닭고기",
      "담당",
      "담배",
      "담요",
      "담임",
      "답변",
      "답장",
      "당근",
      "당분간",
      "당연히",
      "당장",
      "대규모",
      "대낮",
      "대단히",
      "대답",
      "대도시",
      "대략",
      "대량",
      "대륙",
      "대문",
      "대부분",
      "대신",
      "대응",
      "대장",
      "대전",
      "대접",
      "대중",
      "대책",
      "대출",
      "대충",
      "대통령",
      "대학",
      "대한민국",
      "대합실",
      "대형",
      "덩어리",
      "데이트",
      "도대체",
      "도덕",
      "도둑",
      "도망",
      "도서관",
      "도심",
      "도움",
      "도입",
      "도자기",
      "도저히",
      "도전",
      "도중",
      "도착",
      "독감",
      "독립",
      "독서",
      "독일",
      "독창적",
      "동화책",
      "뒷모습",
      "뒷산",
      "딸아이",
      "마누라",
      "마늘",
      "마당",
      "마라톤",
      "마련",
      "마무리",
      "마사지",
      "마약",
      "마요네즈",
      "마을",
      "마음",
      "마이크",
      "마중",
      "마지막",
      "마찬가지",
      "마찰",
      "마흔",
      "막걸리",
      "막내",
      "막상",
      "만남",
      "만두",
      "만세",
      "만약",
      "만일",
      "만점",
      "만족",
      "만화",
      "많이",
      "말기",
      "말씀",
      "말투",
      "맘대로",
      "망원경",
      "매년",
      "매달",
      "매력",
      "매번",
      "매스컴",
      "매일",
      "매장",
      "맥주",
      "먹이",
      "먼저",
      "먼지",
      "멀리",
      "메일",
      "며느리",
      "며칠",
      "면담",
      "멸치",
      "명단",
      "명령",
      "명예",
      "명의",
      "명절",
      "명칭",
      "명함",
      "모금",
      "모니터",
      "모델",
      "모든",
      "모범",
      "모습",
      "모양",
      "모임",
      "모조리",
      "모집",
      "모퉁이",
      "목걸이",
      "목록",
      "목사",
      "목소리",
      "목숨",
      "목적",
      "목표",
      "몰래",
      "몸매",
      "몸무게",
      "몸살",
      "몸속",
      "몸짓",
      "몸통",
      "몹시",
      "무관심",
      "무궁화",
      "무더위",
      "무덤",
      "무릎",
      "무슨",
      "무엇",
      "무역",
      "무용",
      "무조건",
      "무지개",
      "무척",
      "문구",
      "문득",
      "문법",
      "문서",
      "문제",
      "문학",
      "문화",
      "물가",
      "물건",
      "물결",
      "물고기",
      "물론",
      "물리학",
      "물음",
      "물질",
      "물체",
      "미국",
      "미디어",
      "미사일",
      "미술",
      "미역",
      "미용실",
      "미움",
      "미인",
      "미팅",
      "미혼",
      "민간",
      "민족",
      "민주",
      "믿음",
      "밀가루",
      "밀리미터",
      "밑바닥",
      "바가지",
      "바구니",
      "바나나",
      "바늘",
      "바닥",
      "바닷가",
      "바람",
      "바이러스",
      "바탕",
      "박물관",
      "박사",
      "박수",
      "반대",
      "반드시",
      "반말",
      "반발",
      "반성",
      "반응",
      "반장",
      "반죽",
      "반지",
      "반찬",
      "받침",
      "발가락",
      "발걸음",
      "발견",
      "발달",
      "발레",
      "발목",
      "발바닥",
      "발생",
      "발음",
      "발자국",
      "발전",
      "발톱",
      "발표",
      "밤하늘",
      "밥그릇",
      "밥맛",
      "밥상",
      "밥솥",
      "방금",
      "방면",
      "방문",
      "방바닥",
      "방법",
      "방송",
      "방식",
      "방안",
      "방울",
      "방지",
      "방학",
      "방해",
      "방향",
      "배경",
      "배꼽",
      "배달",
      "배드민턴",
      "백두산",
      "백색",
      "백성",
      "백인",
      "백제",
      "백화점",
      "버릇",
      "버섯",
      "버튼",
      "번개",
      "번역",
      "번지",
      "번호",
      "벌금",
      "벌레",
      "벌써",
      "범위",
      "범인",
      "범죄",
      "법률",
      "법원",
      "법적",
      "법칙",
      "베이징",
      "벨트",
      "변경",
      "변동",
      "변명",
      "변신",
      "변호사",
      "변화",
      "별도",
      "별명",
      "별일",
      "병실",
      "병아리",
      "병원",
      "보관",
      "보너스",
      "보라색",
      "보람",
      "보름",
      "보상",
      "보안",
      "보자기",
      "보장",
      "보전",
      "보존",
      "보통",
      "보편적",
      "보험",
      "복도",
      "복사",
      "복숭아",
      "복습",
      "볶음",
      "본격적",
      "본래",
      "본부",
      "본사",
      "본성",
      "본인",
      "본질",
      "볼펜",
      "봉사",
      "봉지",
      "봉투",
      "부근",
      "부끄러움",
      "부담",
      "부동산",
      "부문",
      "부분",
      "부산",
      "부상",
      "부엌",
      "부인",
      "부작용",
      "부장",
      "부정",
      "부족",
      "부지런히",
      "부친",
      "부탁",
      "부품",
      "부회장",
      "북부",
      "북한",
      "분노",
      "분량",
      "분리",
      "분명",
      "분석",
      "분야",
      "분위기",
      "분필",
      "분홍색",
      "불고기",
      "불과",
      "불교",
      "불꽃",
      "불만",
      "불법",
      "불빛",
      "불안",
      "불이익",
      "불행",
      "브랜드",
      "비극",
      "비난",
      "비닐",
      "비둘기",
      "비디오",
      "비로소",
      "비만",
      "비명",
      "비밀",
      "비바람",
      "비빔밥",
      "비상",
      "비용",
      "비율",
      "비중",
      "비타민",
      "비판",
      "빌딩",
      "빗물",
      "빗방울",
      "빗줄기",
      "빛깔",
      "빨간색",
      "빨래",
      "빨리",
      "사건",
      "사계절",
      "사나이",
      "사냥",
      "사람",
      "사랑",
      "사립",
      "사모님",
      "사물",
      "사방",
      "사상",
      "사생활",
      "사설",
      "사슴",
      "사실",
      "사업",
      "사용",
      "사월",
      "사장",
      "사전",
      "사진",
      "사촌",
      "사춘기",
      "사탕",
      "사투리",
      "사흘",
      "산길",
      "산부인과",
      "산업",
      "산책",
      "살림",
      "살인",
      "살짝",
      "삼계탕",
      "삼국",
      "삼십",
      "삼월",
      "삼촌",
      "상관",
      "상금",
      "상대",
      "상류",
      "상반기",
      "상상",
      "상식",
      "상업",
      "상인",
      "상자",
      "상점",
      "상처",
      "상추",
      "상태",
      "상표",
      "상품",
      "상황",
      "새벽",
      "색깔",
      "색연필",
      "생각",
      "생명",
      "생물",
      "생방송",
      "생산",
      "생선",
      "생신",
      "생일",
      "생활",
      "서랍",
      "서른",
      "서명",
      "서민",
      "서비스",
      "서양",
      "서울",
      "서적",
      "서점",
      "서쪽",
      "서클",
      "석사",
      "석유",
      "선거",
      "선물",
      "선배",
      "선생",
      "선수",
      "선원",
      "선장",
      "선전",
      "선택",
      "선풍기",
      "설거지",
      "설날",
      "설렁탕",
      "설명",
      "설문",
      "설사",
      "설악산",
      "설치",
      "설탕",
      "섭씨",
      "성공",
      "성당",
      "성명",
      "성별",
      "성인",
      "성장",
      "성적",
      "성질",
      "성함",
      "세금",
      "세미나",
      "세상",
      "세월",
      "세종대왕",
      "세탁",
      "센터",
      "센티미터",
      "셋째",
      "소규모",
      "소극적",
      "소금",
      "소나기",
      "소년",
      "소득",
      "소망",
      "소문",
      "소설",
      "소속",
      "소아과",
      "소용",
      "소원",
      "소음",
      "소중히",
      "소지품",
      "소질",
      "소풍",
      "소형",
      "속담",
      "속도",
      "속옷",
      "손가락",
      "손길",
      "손녀",
      "손님",
      "손등",
      "손목",
      "손뼉",
      "손실",
      "손질",
      "손톱",
      "손해",
      "솔직히",
      "솜씨",
      "송아지",
      "송이",
      "송편",
      "쇠고기",
      "쇼핑",
      "수건",
      "수년",
      "수단",
      "수돗물",
      "수동적",
      "수면",
      "수명",
      "수박",
      "수상",
      "수석",
      "수술",
      "수시로",
      "수업",
      "수염",
      "수영",
      "수입",
      "수준",
      "수집",
      "수출",
      "수컷",
      "수필",
      "수학",
      "수험생",
      "수화기",
      "숙녀",
      "숙소",
      "숙제",
      "순간",
      "순서",
      "순수",
      "순식간",
      "순위",
      "숟가락",
      "술병",
      "술집",
      "숫자",
      "스님",
      "스물",
      "스스로",
      "스승",
      "스웨터",
      "스위치",
      "스케이트",
      "스튜디오",
      "스트레스",
      "스포츠",
      "슬쩍",
      "슬픔",
      "습관",
      "습기",
      "승객",
      "승리",
      "승부",
      "승용차",
      "승진",
      "시각",
      "시간",
      "시골",
      "시금치",
      "시나리오",
      "시댁",
      "시리즈",
      "시멘트",
      "시민",
      "시부모",
      "시선",
      "시설",
      "시스템",
      "시아버지",
      "시어머니",
      "시월",
      "시인",
      "시일",
      "시작",
      "시장",
      "시절",
      "시점",
      "시중",
      "시즌",
      "시집",
      "시청",
      "시합",
      "시험",
      "식구",
      "식기",
      "식당",
      "식량",
      "식료품",
      "식물",
      "식빵",
      "식사",
      "식생활",
      "식초",
      "식탁",
      "식품",
      "신고",
      "신규",
      "신념",
      "신문",
      "신발",
      "신비",
      "신사",
      "신세",
      "신용",
      "신제품",
      "신청",
      "신체",
      "신화",
      "실감",
      "실내",
      "실력",
      "실례",
      "실망",
      "실수",
      "실습",
      "실시",
      "실장",
      "실정",
      "실질적",
      "실천",
      "실체",
      "실컷",
      "실태",
      "실패",
      "실험",
      "실현",
      "심리",
      "심부름",
      "심사",
      "심장",
      "심정",
      "심판",
      "쌍둥이",
      "씨름",
      "씨앗",
      "아가씨",
      "아나운서",
      "아드님",
      "아들",
      "아쉬움",
      "아스팔트",
      "아시아",
      "아울러",
      "아저씨",
      "아줌마",
      "아직",
      "아침",
      "아파트",
      "아프리카",
      "아픔",
      "아홉",
      "아흔",
      "악기",
      "악몽",
      "악수",
      "안개",
      "안경",
      "안과",
      "안내",
      "안녕",
      "안동",
      "안방",
      "안부",
      "안주",
      "알루미늄",
      "알코올",
      "암시",
      "암컷",
      "압력",
      "앞날",
      "앞문",
      "애인",
      "애정",
      "액수",
      "앨범",
      "야간",
      "야단",
      "야옹",
      "약간",
      "약국",
      "약속",
      "약수",
      "약점",
      "약품",
      "약혼녀",
      "양념",
      "양력",
      "양말",
      "양배추",
      "양주",
      "양파",
      "어둠",
      "어려움",
      "어른",
      "어젯밤",
      "어쨌든",
      "어쩌다가",
      "어쩐지",
      "언니",
      "언덕",
      "언론",
      "언어",
      "얼굴",
      "얼른",
      "얼음",
      "얼핏",
      "엄마",
      "업무",
      "업종",
      "업체",
      "엉덩이",
      "엉망",
      "엉터리",
      "엊그제",
      "에너지",
      "에어컨",
      "엔진",
      "여건",
      "여고생",
      "여관",
      "여군",
      "여권",
      "여대생",
      "여덟",
      "여동생",
      "여든",
      "여론",
      "여름",
      "여섯",
      "여성",
      "여왕",
      "여인",
      "여전히",
      "여직원",
      "여학생",
      "여행",
      "역사",
      "역시",
      "역할",
      "연결",
      "연구",
      "연극",
      "연기",
      "연락",
      "연설",
      "연세",
      "연속",
      "연습",
      "연애",
      "연예인",
      "연인",
      "연장",
      "연주",
      "연출",
      "연필",
      "연합",
      "연휴",
      "열기",
      "열매",
      "열쇠",
      "열심히",
      "열정",
      "열차",
      "열흘",
      "염려",
      "엽서",
      "영국",
      "영남",
      "영상",
      "영양",
      "영역",
      "영웅",
      "영원히",
      "영하",
      "영향",
      "영혼",
      "영화",
      "옆구리",
      "옆방",
      "옆집",
      "예감",
      "예금",
      "예방",
      "예산",
      "예상",
      "예선",
      "예술",
      "예습",
      "예식장",
      "예약",
      "예전",
      "예절",
      "예정",
      "예컨대",
      "옛날",
      "오늘",
      "오락",
      "오랫동안",
      "오렌지",
      "오로지",
      "오른발",
      "오븐",
      "오십",
      "오염",
      "오월",
      "오전",
      "오직",
      "오징어",
      "오페라",
      "오피스텔",
      "오히려",
      "옥상",
      "옥수수",
      "온갖",
      "온라인",
      "온몸",
      "온종일",
      "온통",
      "올가을",
      "올림픽",
      "올해",
      "옷차림",
      "와이셔츠",
      "와인",
      "완성",
      "완전",
      "왕비",
      "왕자",
      "왜냐하면",
      "왠지",
      "외갓집",
      "외국",
      "외로움",
      "외삼촌",
      "외출",
      "외침",
      "외할머니",
      "왼발",
      "왼손",
      "왼쪽",
      "요금",
      "요일",
      "요즘",
      "요청",
      "용기",
      "용서",
      "용어",
      "우산",
      "우선",
      "우승",
      "우연히",
      "우정",
      "우체국",
      "우편",
      "운동",
      "운명",
      "운반",
      "운전",
      "운행",
      "울산",
      "울음",
      "움직임",
      "웃어른",
      "웃음",
      "워낙",
      "원고",
      "원래",
      "원서",
      "원숭이",
      "원인",
      "원장",
      "원피스",
      "월급",
      "월드컵",
      "월세",
      "월요일",
      "웨이터",
      "위반",
      "위법",
      "위성",
      "위원",
      "위험",
      "위협",
      "윗사람",
      "유난히",
      "유럽",
      "유명",
      "유물",
      "유산",
      "유적",
      "유치원",
      "유학",
      "유행",
      "유형",
      "육군",
      "육상",
      "육십",
      "육체",
      "은행",
      "음력",
      "음료",
      "음반",
      "음성",
      "음식",
      "음악",
      "음주",
      "의견",
      "의논",
      "의문",
      "의복",
      "의식",
      "의심",
      "의외로",
      "의욕",
      "의원",
      "의학",
      "이것",
      "이곳",
      "이념",
      "이놈",
      "이달",
      "이대로",
      "이동",
      "이렇게",
      "이력서",
      "이론적",
      "이름",
      "이민",
      "이발소",
      "이별",
      "이불",
      "이빨",
      "이상",
      "이성",
      "이슬",
      "이야기",
      "이용",
      "이웃",
      "이월",
      "이윽고",
      "이익",
      "이전",
      "이중",
      "이튿날",
      "이틀",
      "이혼",
      "인간",
      "인격",
      "인공",
      "인구",
      "인근",
      "인기",
      "인도",
      "인류",
      "인물",
      "인생",
      "인쇄",
      "인연",
      "인원",
      "인재",
      "인종",
      "인천",
      "인체",
      "인터넷",
      "인하",
      "인형",
      "일곱",
      "일기",
      "일단",
      "일대",
      "일등",
      "일반",
      "일본",
      "일부",
      "일상",
      "일생",
      "일손",
      "일요일",
      "일월",
      "일정",
      "일종",
      "일주일",
      "일찍",
      "일체",
      "일치",
      "일행",
      "일회용",
      "임금",
      "임무",
      "입대",
      "입력",
      "입맛",
      "입사",
      "입술",
      "입시",
      "입원",
      "입장",
      "입학",
      "자가용",
      "자격",
      "자극",
      "자동",
      "자랑",
      "자부심",
      "자식",
      "자신",
      "자연",
      "자원",
      "자율",
      "자전거",
      "자정",
      "자존심",
      "자판",
      "작가",
      "작년",
      "작성",
      "작업",
      "작용",
      "작은딸",
      "작품",
      "잔디",
      "잔뜩",
      "잔치",
      "잘못",
      "잠깐",
      "잠수함",
      "잠시",
      "잠옷",
      "잠자리",
      "잡지",
      "장관",
      "장군",
      "장기간",
      "장래",
      "장례",
      "장르",
      "장마",
      "장면",
      "장모",
      "장미",
      "장비",
      "장사",
      "장소",
      "장식",
      "장애인",
      "장인",
      "장점",
      "장차",
      "장학금",
      "재능",
      "재빨리",
      "재산",
      "재생",
      "재작년",
      "재정",
      "재채기",
      "재판",
      "재학",
      "재활용",
      "저것",
      "저고리",
      "저곳",
      "저녁",
      "저런",
      "저렇게",
      "저번",
      "저울",
      "저절로",
      "저축",
      "적극",
      "적당히",
      "적성",
      "적용",
      "적응",
      "전개",
      "전공",
      "전기",
      "전달",
      "전라도",
      "전망",
      "전문",
      "전반",
      "전부",
      "전세",
      "전시",
      "전용",
      "전자",
      "전쟁",
      "전주",
      "전철",
      "전체",
      "전통",
      "전혀",
      "전후",
      "절대",
      "절망",
      "절반",
      "절약",
      "절차",
      "점검",
      "점수",
      "점심",
      "점원",
      "점점",
      "점차",
      "접근",
      "접시",
      "접촉",
      "젓가락",
      "정거장",
      "정도",
      "정류장",
      "정리",
      "정말",
      "정면",
      "정문",
      "정반대",
      "정보",
      "정부",
      "정비",
      "정상",
      "정성",
      "정오",
      "정원",
      "정장",
      "정지",
      "정치",
      "정확히",
      "제공",
      "제과점",
      "제대로",
      "제목",
      "제발",
      "제법",
      "제삿날",
      "제안",
      "제일",
      "제작",
      "제주도",
      "제출",
      "제품",
      "제한",
      "조각",
      "조건",
      "조금",
      "조깅",
      "조명",
      "조미료",
      "조상",
      "조선",
      "조용히",
      "조절",
      "조정",
      "조직",
      "존댓말",
      "존재",
      "졸업",
      "졸음",
      "종교",
      "종로",
      "종류",
      "종소리",
      "종업원",
      "종종",
      "종합",
      "좌석",
      "죄인",
      "주관적",
      "주름",
      "주말",
      "주머니",
      "주먹",
      "주문",
      "주민",
      "주방",
      "주변",
      "주식",
      "주인",
      "주일",
      "주장",
      "주전자",
      "주택",
      "준비",
      "줄거리",
      "줄기",
      "줄무늬",
      "중간",
      "중계방송",
      "중국",
      "중년",
      "중단",
      "중독",
      "중반",
      "중부",
      "중세",
      "중소기업",
      "중순",
      "중앙",
      "중요",
      "중학교",
      "즉석",
      "즉시",
      "즐거움",
      "증가",
      "증거",
      "증권",
      "증상",
      "증세",
      "지각",
      "지갑",
      "지경",
      "지극히",
      "지금",
      "지급",
      "지능",
      "지름길",
      "지리산",
      "지방",
      "지붕",
      "지식",
      "지역",
      "지우개",
      "지원",
      "지적",
      "지점",
      "지진",
      "지출",
      "직선",
      "직업",
      "직원",
      "직장",
      "진급",
      "진동",
      "진로",
      "진료",
      "진리",
      "진짜",
      "진찰",
      "진출",
      "진통",
      "진행",
      "질문",
      "질병",
      "질서",
      "짐작",
      "집단",
      "집안",
      "집중",
      "짜증",
      "찌꺼기",
      "차남",
      "차라리",
      "차량",
      "차림",
      "차별",
      "차선",
      "차츰",
      "착각",
      "찬물",
      "찬성",
      "참가",
      "참기름",
      "참새",
      "참석",
      "참여",
      "참외",
      "참조",
      "찻잔",
      "창가",
      "창고",
      "창구",
      "창문",
      "창밖",
      "창작",
      "창조",
      "채널",
      "채점",
      "책가방",
      "책방",
      "책상",
      "책임",
      "챔피언",
      "처벌",
      "처음",
      "천국",
      "천둥",
      "천장",
      "천재",
      "천천히",
      "철도",
      "철저히",
      "철학",
      "첫날",
      "첫째",
      "청년",
      "청바지",
      "청소",
      "청춘",
      "체계",
      "체력",
      "체온",
      "체육",
      "체중",
      "체험",
      "초등학생",
      "초반",
      "초밥",
      "초상화",
      "초순",
      "초여름",
      "초원",
      "초저녁",
      "초점",
      "초청",
      "초콜릿",
      "촛불",
      "총각",
      "총리",
      "총장",
      "촬영",
      "최근",
      "최상",
      "최선",
      "최신",
      "최악",
      "최종",
      "추석",
      "추억",
      "추진",
      "추천",
      "추측",
      "축구",
      "축소",
      "축제",
      "축하",
      "출근",
      "출발",
      "출산",
      "출신",
      "출연",
      "출입",
      "출장",
      "출판",
      "충격",
      "충고",
      "충돌",
      "충분히",
      "충청도",
      "취업",
      "취직",
      "취향",
      "치약",
      "친구",
      "친척",
      "칠십",
      "칠월",
      "칠판",
      "침대",
      "침묵",
      "침실",
      "칫솔",
      "칭찬",
      "카메라",
      "카운터",
      "칼국수",
      "캐릭터",
      "캠퍼스",
      "캠페인",
      "커튼",
      "컨디션",
      "컬러",
      "컴퓨터",
      "코끼리",
      "코미디",
      "콘서트",
      "콜라",
      "콤플렉스",
      "콩나물",
      "쾌감",
      "쿠데타",
      "크림",
      "큰길",
      "큰딸",
      "큰소리",
      "큰아들",
      "큰어머니",
      "큰일",
      "큰절",
      "클래식",
      "클럽",
      "킬로",
      "타입",
      "타자기",
      "탁구",
      "탁자",
      "탄생",
      "태권도",
      "태양",
      "태풍",
      "택시",
      "탤런트",
      "터널",
      "터미널",
      "테니스",
      "테스트",
      "테이블",
      "텔레비전",
      "토론",
      "토마토",
      "토요일",
      "통계",
      "통과",
      "통로",
      "통신",
      "통역",
      "통일",
      "통장",
      "통제",
      "통증",
      "통합",
      "통화",
      "퇴근",
      "퇴원",
      "퇴직금",
      "튀김",
      "트럭",
      "특급",
      "특별",
      "특성",
      "특수",
      "특징",
      "특히",
      "튼튼히",
      "티셔츠",
      "파란색",
      "파일",
      "파출소",
      "판결",
      "판단",
      "판매",
      "판사",
      "팔십",
      "팔월",
      "팝송",
      "패션",
      "팩스",
      "팩시밀리",
      "팬티",
      "퍼센트",
      "페인트",
      "편견",
      "편의",
      "편지",
      "편히",
      "평가",
      "평균",
      "평생",
      "평소",
      "평양",
      "평일",
      "평화",
      "포스터",
      "포인트",
      "포장",
      "포함",
      "표면",
      "표정",
      "표준",
      "표현",
      "품목",
      "품질",
      "풍경",
      "풍속",
      "풍습",
      "프랑스",
      "프린터",
      "플라스틱",
      "피곤",
      "피망",
      "피아노",
      "필름",
      "필수",
      "필요",
      "필자",
      "필통",
      "핑계",
      "하느님",
      "하늘",
      "하드웨어",
      "하룻밤",
      "하반기",
      "하숙집",
      "하순",
      "하여튼",
      "하지만",
      "하천",
      "하품",
      "하필",
      "학과",
      "학교",
      "학급",
      "학기",
      "학년",
      "학력",
      "학번",
      "학부모",
      "학비",
      "학생",
      "학술",
      "학습",
      "학용품",
      "학원",
      "학위",
      "학자",
      "학점",
      "한계",
      "한글",
      "한꺼번에",
      "한낮",
      "한눈",
      "한동안",
      "한때",
      "한라산",
      "한마디",
      "한문",
      "한번",
      "한복",
      "한식",
      "한여름",
      "한쪽",
      "할머니",
      "할아버지",
      "할인",
      "함께",
      "함부로",
      "합격",
      "합리적",
      "항공",
      "항구",
      "항상",
      "항의",
      "해결",
      "해군",
      "해답",
      "해당",
      "해물",
      "해석",
      "해설",
      "해수욕장",
      "해안",
      "핵심",
      "핸드백",
      "햄버거",
      "햇볕",
      "햇살",
      "행동",
      "행복",
      "행사",
      "행운",
      "행위",
      "향기",
      "향상",
      "향수",
      "허락",
      "허용",
      "헬기",
      "현관",
      "현금",
      "현대",
      "현상",
      "현실",
      "현장",
      "현재",
      "현지",
      "혈액",
      "협력",
      "형부",
      "형사",
      "형수",
      "형식",
      "형제",
      "형태",
      "형편",
      "혜택",
      "호기심",
      "호남",
      "호랑이",
      "호박",
      "호텔",
      "호흡",
      "혹시",
      "홀로",
      "홈페이지",
      "홍보",
      "홍수",
      "홍차",
      "화면",
      "화분",
      "화살",
      "화요일",
      "화장",
      "화학",
      "확보",
      "확인",
      "확장",
      "확정",
      "환갑",
      "환경",
      "환영",
      "환율",
      "환자",
      "활기",
      "활동",
      "활발히",
      "활용",
      "활짝",
      "회견",
      "회관",
      "회복",
      "회색",
      "회원",
      "회장",
      "회전",
      "횟수",
      "횡단보도",
      "효율적",
      "후반",
      "후춧가루",
      "훈련",
      "훨씬",
      "휴식",
      "휴일",
      "흉내",
      "흐름",
      "흑백",
      "흑인",
      "흔적",
      "흔히",
      "흥미",
      "흥분",
      "희곡",
      "희망",
      "희생",
      "흰색",
      "힘껏"
    ];
  }
});

// node_modules/bip39/src/wordlists/french.json
var require_french = __commonJS({
  "node_modules/bip39/src/wordlists/french.json"(exports2, module2) {
    module2.exports = [
      "abaisser",
      "abandon",
      "abdiquer",
      "abeille",
      "abolir",
      "aborder",
      "aboutir",
      "aboyer",
      "abrasif",
      "abreuver",
      "abriter",
      "abroger",
      "abrupt",
      "absence",
      "absolu",
      "absurde",
      "abusif",
      "abyssal",
      "académie",
      "acajou",
      "acarien",
      "accabler",
      "accepter",
      "acclamer",
      "accolade",
      "accroche",
      "accuser",
      "acerbe",
      "achat",
      "acheter",
      "aciduler",
      "acier",
      "acompte",
      "acquérir",
      "acronyme",
      "acteur",
      "actif",
      "actuel",
      "adepte",
      "adéquat",
      "adhésif",
      "adjectif",
      "adjuger",
      "admettre",
      "admirer",
      "adopter",
      "adorer",
      "adoucir",
      "adresse",
      "adroit",
      "adulte",
      "adverbe",
      "aérer",
      "aéronef",
      "affaire",
      "affecter",
      "affiche",
      "affreux",
      "affubler",
      "agacer",
      "agencer",
      "agile",
      "agiter",
      "agrafer",
      "agréable",
      "agrume",
      "aider",
      "aiguille",
      "ailier",
      "aimable",
      "aisance",
      "ajouter",
      "ajuster",
      "alarmer",
      "alchimie",
      "alerte",
      "algèbre",
      "algue",
      "aliéner",
      "aliment",
      "alléger",
      "alliage",
      "allouer",
      "allumer",
      "alourdir",
      "alpaga",
      "altesse",
      "alvéole",
      "amateur",
      "ambigu",
      "ambre",
      "aménager",
      "amertume",
      "amidon",
      "amiral",
      "amorcer",
      "amour",
      "amovible",
      "amphibie",
      "ampleur",
      "amusant",
      "analyse",
      "anaphore",
      "anarchie",
      "anatomie",
      "ancien",
      "anéantir",
      "angle",
      "angoisse",
      "anguleux",
      "animal",
      "annexer",
      "annonce",
      "annuel",
      "anodin",
      "anomalie",
      "anonyme",
      "anormal",
      "antenne",
      "antidote",
      "anxieux",
      "apaiser",
      "apéritif",
      "aplanir",
      "apologie",
      "appareil",
      "appeler",
      "apporter",
      "appuyer",
      "aquarium",
      "aqueduc",
      "arbitre",
      "arbuste",
      "ardeur",
      "ardoise",
      "argent",
      "arlequin",
      "armature",
      "armement",
      "armoire",
      "armure",
      "arpenter",
      "arracher",
      "arriver",
      "arroser",
      "arsenic",
      "artériel",
      "article",
      "aspect",
      "asphalte",
      "aspirer",
      "assaut",
      "asservir",
      "assiette",
      "associer",
      "assurer",
      "asticot",
      "astre",
      "astuce",
      "atelier",
      "atome",
      "atrium",
      "atroce",
      "attaque",
      "attentif",
      "attirer",
      "attraper",
      "aubaine",
      "auberge",
      "audace",
      "audible",
      "augurer",
      "aurore",
      "automne",
      "autruche",
      "avaler",
      "avancer",
      "avarice",
      "avenir",
      "averse",
      "aveugle",
      "aviateur",
      "avide",
      "avion",
      "aviser",
      "avoine",
      "avouer",
      "avril",
      "axial",
      "axiome",
      "badge",
      "bafouer",
      "bagage",
      "baguette",
      "baignade",
      "balancer",
      "balcon",
      "baleine",
      "balisage",
      "bambin",
      "bancaire",
      "bandage",
      "banlieue",
      "bannière",
      "banquier",
      "barbier",
      "baril",
      "baron",
      "barque",
      "barrage",
      "bassin",
      "bastion",
      "bataille",
      "bateau",
      "batterie",
      "baudrier",
      "bavarder",
      "belette",
      "bélier",
      "belote",
      "bénéfice",
      "berceau",
      "berger",
      "berline",
      "bermuda",
      "besace",
      "besogne",
      "bétail",
      "beurre",
      "biberon",
      "bicycle",
      "bidule",
      "bijou",
      "bilan",
      "bilingue",
      "billard",
      "binaire",
      "biologie",
      "biopsie",
      "biotype",
      "biscuit",
      "bison",
      "bistouri",
      "bitume",
      "bizarre",
      "blafard",
      "blague",
      "blanchir",
      "blessant",
      "blinder",
      "blond",
      "bloquer",
      "blouson",
      "bobard",
      "bobine",
      "boire",
      "boiser",
      "bolide",
      "bonbon",
      "bondir",
      "bonheur",
      "bonifier",
      "bonus",
      "bordure",
      "borne",
      "botte",
      "boucle",
      "boueux",
      "bougie",
      "boulon",
      "bouquin",
      "bourse",
      "boussole",
      "boutique",
      "boxeur",
      "branche",
      "brasier",
      "brave",
      "brebis",
      "brèche",
      "breuvage",
      "bricoler",
      "brigade",
      "brillant",
      "brioche",
      "brique",
      "brochure",
      "broder",
      "bronzer",
      "brousse",
      "broyeur",
      "brume",
      "brusque",
      "brutal",
      "bruyant",
      "buffle",
      "buisson",
      "bulletin",
      "bureau",
      "burin",
      "bustier",
      "butiner",
      "butoir",
      "buvable",
      "buvette",
      "cabanon",
      "cabine",
      "cachette",
      "cadeau",
      "cadre",
      "caféine",
      "caillou",
      "caisson",
      "calculer",
      "calepin",
      "calibre",
      "calmer",
      "calomnie",
      "calvaire",
      "camarade",
      "caméra",
      "camion",
      "campagne",
      "canal",
      "caneton",
      "canon",
      "cantine",
      "canular",
      "capable",
      "caporal",
      "caprice",
      "capsule",
      "capter",
      "capuche",
      "carabine",
      "carbone",
      "caresser",
      "caribou",
      "carnage",
      "carotte",
      "carreau",
      "carton",
      "cascade",
      "casier",
      "casque",
      "cassure",
      "causer",
      "caution",
      "cavalier",
      "caverne",
      "caviar",
      "cédille",
      "ceinture",
      "céleste",
      "cellule",
      "cendrier",
      "censurer",
      "central",
      "cercle",
      "cérébral",
      "cerise",
      "cerner",
      "cerveau",
      "cesser",
      "chagrin",
      "chaise",
      "chaleur",
      "chambre",
      "chance",
      "chapitre",
      "charbon",
      "chasseur",
      "chaton",
      "chausson",
      "chavirer",
      "chemise",
      "chenille",
      "chéquier",
      "chercher",
      "cheval",
      "chien",
      "chiffre",
      "chignon",
      "chimère",
      "chiot",
      "chlorure",
      "chocolat",
      "choisir",
      "chose",
      "chouette",
      "chrome",
      "chute",
      "cigare",
      "cigogne",
      "cimenter",
      "cinéma",
      "cintrer",
      "circuler",
      "cirer",
      "cirque",
      "citerne",
      "citoyen",
      "citron",
      "civil",
      "clairon",
      "clameur",
      "claquer",
      "classe",
      "clavier",
      "client",
      "cligner",
      "climat",
      "clivage",
      "cloche",
      "clonage",
      "cloporte",
      "cobalt",
      "cobra",
      "cocasse",
      "cocotier",
      "coder",
      "codifier",
      "coffre",
      "cogner",
      "cohésion",
      "coiffer",
      "coincer",
      "colère",
      "colibri",
      "colline",
      "colmater",
      "colonel",
      "combat",
      "comédie",
      "commande",
      "compact",
      "concert",
      "conduire",
      "confier",
      "congeler",
      "connoter",
      "consonne",
      "contact",
      "convexe",
      "copain",
      "copie",
      "corail",
      "corbeau",
      "cordage",
      "corniche",
      "corpus",
      "correct",
      "cortège",
      "cosmique",
      "costume",
      "coton",
      "coude",
      "coupure",
      "courage",
      "couteau",
      "couvrir",
      "coyote",
      "crabe",
      "crainte",
      "cravate",
      "crayon",
      "créature",
      "créditer",
      "crémeux",
      "creuser",
      "crevette",
      "cribler",
      "crier",
      "cristal",
      "critère",
      "croire",
      "croquer",
      "crotale",
      "crucial",
      "cruel",
      "crypter",
      "cubique",
      "cueillir",
      "cuillère",
      "cuisine",
      "cuivre",
      "culminer",
      "cultiver",
      "cumuler",
      "cupide",
      "curatif",
      "curseur",
      "cyanure",
      "cycle",
      "cylindre",
      "cynique",
      "daigner",
      "damier",
      "danger",
      "danseur",
      "dauphin",
      "débattre",
      "débiter",
      "déborder",
      "débrider",
      "débutant",
      "décaler",
      "décembre",
      "déchirer",
      "décider",
      "déclarer",
      "décorer",
      "décrire",
      "décupler",
      "dédale",
      "déductif",
      "déesse",
      "défensif",
      "défiler",
      "défrayer",
      "dégager",
      "dégivrer",
      "déglutir",
      "dégrafer",
      "déjeuner",
      "délice",
      "déloger",
      "demander",
      "demeurer",
      "démolir",
      "dénicher",
      "dénouer",
      "dentelle",
      "dénuder",
      "départ",
      "dépenser",
      "déphaser",
      "déplacer",
      "déposer",
      "déranger",
      "dérober",
      "désastre",
      "descente",
      "désert",
      "désigner",
      "désobéir",
      "dessiner",
      "destrier",
      "détacher",
      "détester",
      "détourer",
      "détresse",
      "devancer",
      "devenir",
      "deviner",
      "devoir",
      "diable",
      "dialogue",
      "diamant",
      "dicter",
      "différer",
      "digérer",
      "digital",
      "digne",
      "diluer",
      "dimanche",
      "diminuer",
      "dioxyde",
      "directif",
      "diriger",
      "discuter",
      "disposer",
      "dissiper",
      "distance",
      "divertir",
      "diviser",
      "docile",
      "docteur",
      "dogme",
      "doigt",
      "domaine",
      "domicile",
      "dompter",
      "donateur",
      "donjon",
      "donner",
      "dopamine",
      "dortoir",
      "dorure",
      "dosage",
      "doseur",
      "dossier",
      "dotation",
      "douanier",
      "double",
      "douceur",
      "douter",
      "doyen",
      "dragon",
      "draper",
      "dresser",
      "dribbler",
      "droiture",
      "duperie",
      "duplexe",
      "durable",
      "durcir",
      "dynastie",
      "éblouir",
      "écarter",
      "écharpe",
      "échelle",
      "éclairer",
      "éclipse",
      "éclore",
      "écluse",
      "école",
      "économie",
      "écorce",
      "écouter",
      "écraser",
      "écrémer",
      "écrivain",
      "écrou",
      "écume",
      "écureuil",
      "édifier",
      "éduquer",
      "effacer",
      "effectif",
      "effigie",
      "effort",
      "effrayer",
      "effusion",
      "égaliser",
      "égarer",
      "éjecter",
      "élaborer",
      "élargir",
      "électron",
      "élégant",
      "éléphant",
      "élève",
      "éligible",
      "élitisme",
      "éloge",
      "élucider",
      "éluder",
      "emballer",
      "embellir",
      "embryon",
      "émeraude",
      "émission",
      "emmener",
      "émotion",
      "émouvoir",
      "empereur",
      "employer",
      "emporter",
      "emprise",
      "émulsion",
      "encadrer",
      "enchère",
      "enclave",
      "encoche",
      "endiguer",
      "endosser",
      "endroit",
      "enduire",
      "énergie",
      "enfance",
      "enfermer",
      "enfouir",
      "engager",
      "engin",
      "englober",
      "énigme",
      "enjamber",
      "enjeu",
      "enlever",
      "ennemi",
      "ennuyeux",
      "enrichir",
      "enrobage",
      "enseigne",
      "entasser",
      "entendre",
      "entier",
      "entourer",
      "entraver",
      "énumérer",
      "envahir",
      "enviable",
      "envoyer",
      "enzyme",
      "éolien",
      "épaissir",
      "épargne",
      "épatant",
      "épaule",
      "épicerie",
      "épidémie",
      "épier",
      "épilogue",
      "épine",
      "épisode",
      "épitaphe",
      "époque",
      "épreuve",
      "éprouver",
      "épuisant",
      "équerre",
      "équipe",
      "ériger",
      "érosion",
      "erreur",
      "éruption",
      "escalier",
      "espadon",
      "espèce",
      "espiègle",
      "espoir",
      "esprit",
      "esquiver",
      "essayer",
      "essence",
      "essieu",
      "essorer",
      "estime",
      "estomac",
      "estrade",
      "étagère",
      "étaler",
      "étanche",
      "étatique",
      "éteindre",
      "étendoir",
      "éternel",
      "éthanol",
      "éthique",
      "ethnie",
      "étirer",
      "étoffer",
      "étoile",
      "étonnant",
      "étourdir",
      "étrange",
      "étroit",
      "étude",
      "euphorie",
      "évaluer",
      "évasion",
      "éventail",
      "évidence",
      "éviter",
      "évolutif",
      "évoquer",
      "exact",
      "exagérer",
      "exaucer",
      "exceller",
      "excitant",
      "exclusif",
      "excuse",
      "exécuter",
      "exemple",
      "exercer",
      "exhaler",
      "exhorter",
      "exigence",
      "exiler",
      "exister",
      "exotique",
      "expédier",
      "explorer",
      "exposer",
      "exprimer",
      "exquis",
      "extensif",
      "extraire",
      "exulter",
      "fable",
      "fabuleux",
      "facette",
      "facile",
      "facture",
      "faiblir",
      "falaise",
      "fameux",
      "famille",
      "farceur",
      "farfelu",
      "farine",
      "farouche",
      "fasciner",
      "fatal",
      "fatigue",
      "faucon",
      "fautif",
      "faveur",
      "favori",
      "fébrile",
      "féconder",
      "fédérer",
      "félin",
      "femme",
      "fémur",
      "fendoir",
      "féodal",
      "fermer",
      "féroce",
      "ferveur",
      "festival",
      "feuille",
      "feutre",
      "février",
      "fiasco",
      "ficeler",
      "fictif",
      "fidèle",
      "figure",
      "filature",
      "filetage",
      "filière",
      "filleul",
      "filmer",
      "filou",
      "filtrer",
      "financer",
      "finir",
      "fiole",
      "firme",
      "fissure",
      "fixer",
      "flairer",
      "flamme",
      "flasque",
      "flatteur",
      "fléau",
      "flèche",
      "fleur",
      "flexion",
      "flocon",
      "flore",
      "fluctuer",
      "fluide",
      "fluvial",
      "folie",
      "fonderie",
      "fongible",
      "fontaine",
      "forcer",
      "forgeron",
      "formuler",
      "fortune",
      "fossile",
      "foudre",
      "fougère",
      "fouiller",
      "foulure",
      "fourmi",
      "fragile",
      "fraise",
      "franchir",
      "frapper",
      "frayeur",
      "frégate",
      "freiner",
      "frelon",
      "frémir",
      "frénésie",
      "frère",
      "friable",
      "friction",
      "frisson",
      "frivole",
      "froid",
      "fromage",
      "frontal",
      "frotter",
      "fruit",
      "fugitif",
      "fuite",
      "fureur",
      "furieux",
      "furtif",
      "fusion",
      "futur",
      "gagner",
      "galaxie",
      "galerie",
      "gambader",
      "garantir",
      "gardien",
      "garnir",
      "garrigue",
      "gazelle",
      "gazon",
      "géant",
      "gélatine",
      "gélule",
      "gendarme",
      "général",
      "génie",
      "genou",
      "gentil",
      "géologie",
      "géomètre",
      "géranium",
      "germe",
      "gestuel",
      "geyser",
      "gibier",
      "gicler",
      "girafe",
      "givre",
      "glace",
      "glaive",
      "glisser",
      "globe",
      "gloire",
      "glorieux",
      "golfeur",
      "gomme",
      "gonfler",
      "gorge",
      "gorille",
      "goudron",
      "gouffre",
      "goulot",
      "goupille",
      "gourmand",
      "goutte",
      "graduel",
      "graffiti",
      "graine",
      "grand",
      "grappin",
      "gratuit",
      "gravir",
      "grenat",
      "griffure",
      "griller",
      "grimper",
      "grogner",
      "gronder",
      "grotte",
      "groupe",
      "gruger",
      "grutier",
      "gruyère",
      "guépard",
      "guerrier",
      "guide",
      "guimauve",
      "guitare",
      "gustatif",
      "gymnaste",
      "gyrostat",
      "habitude",
      "hachoir",
      "halte",
      "hameau",
      "hangar",
      "hanneton",
      "haricot",
      "harmonie",
      "harpon",
      "hasard",
      "hélium",
      "hématome",
      "herbe",
      "hérisson",
      "hermine",
      "héron",
      "hésiter",
      "heureux",
      "hiberner",
      "hibou",
      "hilarant",
      "histoire",
      "hiver",
      "homard",
      "hommage",
      "homogène",
      "honneur",
      "honorer",
      "honteux",
      "horde",
      "horizon",
      "horloge",
      "hormone",
      "horrible",
      "houleux",
      "housse",
      "hublot",
      "huileux",
      "humain",
      "humble",
      "humide",
      "humour",
      "hurler",
      "hydromel",
      "hygiène",
      "hymne",
      "hypnose",
      "idylle",
      "ignorer",
      "iguane",
      "illicite",
      "illusion",
      "image",
      "imbiber",
      "imiter",
      "immense",
      "immobile",
      "immuable",
      "impact",
      "impérial",
      "implorer",
      "imposer",
      "imprimer",
      "imputer",
      "incarner",
      "incendie",
      "incident",
      "incliner",
      "incolore",
      "indexer",
      "indice",
      "inductif",
      "inédit",
      "ineptie",
      "inexact",
      "infini",
      "infliger",
      "informer",
      "infusion",
      "ingérer",
      "inhaler",
      "inhiber",
      "injecter",
      "injure",
      "innocent",
      "inoculer",
      "inonder",
      "inscrire",
      "insecte",
      "insigne",
      "insolite",
      "inspirer",
      "instinct",
      "insulter",
      "intact",
      "intense",
      "intime",
      "intrigue",
      "intuitif",
      "inutile",
      "invasion",
      "inventer",
      "inviter",
      "invoquer",
      "ironique",
      "irradier",
      "irréel",
      "irriter",
      "isoler",
      "ivoire",
      "ivresse",
      "jaguar",
      "jaillir",
      "jambe",
      "janvier",
      "jardin",
      "jauger",
      "jaune",
      "javelot",
      "jetable",
      "jeton",
      "jeudi",
      "jeunesse",
      "joindre",
      "joncher",
      "jongler",
      "joueur",
      "jouissif",
      "journal",
      "jovial",
      "joyau",
      "joyeux",
      "jubiler",
      "jugement",
      "junior",
      "jupon",
      "juriste",
      "justice",
      "juteux",
      "juvénile",
      "kayak",
      "kimono",
      "kiosque",
      "label",
      "labial",
      "labourer",
      "lacérer",
      "lactose",
      "lagune",
      "laine",
      "laisser",
      "laitier",
      "lambeau",
      "lamelle",
      "lampe",
      "lanceur",
      "langage",
      "lanterne",
      "lapin",
      "largeur",
      "larme",
      "laurier",
      "lavabo",
      "lavoir",
      "lecture",
      "légal",
      "léger",
      "légume",
      "lessive",
      "lettre",
      "levier",
      "lexique",
      "lézard",
      "liasse",
      "libérer",
      "libre",
      "licence",
      "licorne",
      "liège",
      "lièvre",
      "ligature",
      "ligoter",
      "ligue",
      "limer",
      "limite",
      "limonade",
      "limpide",
      "linéaire",
      "lingot",
      "lionceau",
      "liquide",
      "lisière",
      "lister",
      "lithium",
      "litige",
      "littoral",
      "livreur",
      "logique",
      "lointain",
      "loisir",
      "lombric",
      "loterie",
      "louer",
      "lourd",
      "loutre",
      "louve",
      "loyal",
      "lubie",
      "lucide",
      "lucratif",
      "lueur",
      "lugubre",
      "luisant",
      "lumière",
      "lunaire",
      "lundi",
      "luron",
      "lutter",
      "luxueux",
      "machine",
      "magasin",
      "magenta",
      "magique",
      "maigre",
      "maillon",
      "maintien",
      "mairie",
      "maison",
      "majorer",
      "malaxer",
      "maléfice",
      "malheur",
      "malice",
      "mallette",
      "mammouth",
      "mandater",
      "maniable",
      "manquant",
      "manteau",
      "manuel",
      "marathon",
      "marbre",
      "marchand",
      "mardi",
      "maritime",
      "marqueur",
      "marron",
      "marteler",
      "mascotte",
      "massif",
      "matériel",
      "matière",
      "matraque",
      "maudire",
      "maussade",
      "mauve",
      "maximal",
      "méchant",
      "méconnu",
      "médaille",
      "médecin",
      "méditer",
      "méduse",
      "meilleur",
      "mélange",
      "mélodie",
      "membre",
      "mémoire",
      "menacer",
      "mener",
      "menhir",
      "mensonge",
      "mentor",
      "mercredi",
      "mérite",
      "merle",
      "messager",
      "mesure",
      "métal",
      "météore",
      "méthode",
      "métier",
      "meuble",
      "miauler",
      "microbe",
      "miette",
      "mignon",
      "migrer",
      "milieu",
      "million",
      "mimique",
      "mince",
      "minéral",
      "minimal",
      "minorer",
      "minute",
      "miracle",
      "miroiter",
      "missile",
      "mixte",
      "mobile",
      "moderne",
      "moelleux",
      "mondial",
      "moniteur",
      "monnaie",
      "monotone",
      "monstre",
      "montagne",
      "monument",
      "moqueur",
      "morceau",
      "morsure",
      "mortier",
      "moteur",
      "motif",
      "mouche",
      "moufle",
      "moulin",
      "mousson",
      "mouton",
      "mouvant",
      "multiple",
      "munition",
      "muraille",
      "murène",
      "murmure",
      "muscle",
      "muséum",
      "musicien",
      "mutation",
      "muter",
      "mutuel",
      "myriade",
      "myrtille",
      "mystère",
      "mythique",
      "nageur",
      "nappe",
      "narquois",
      "narrer",
      "natation",
      "nation",
      "nature",
      "naufrage",
      "nautique",
      "navire",
      "nébuleux",
      "nectar",
      "néfaste",
      "négation",
      "négliger",
      "négocier",
      "neige",
      "nerveux",
      "nettoyer",
      "neurone",
      "neutron",
      "neveu",
      "niche",
      "nickel",
      "nitrate",
      "niveau",
      "noble",
      "nocif",
      "nocturne",
      "noirceur",
      "noisette",
      "nomade",
      "nombreux",
      "nommer",
      "normatif",
      "notable",
      "notifier",
      "notoire",
      "nourrir",
      "nouveau",
      "novateur",
      "novembre",
      "novice",
      "nuage",
      "nuancer",
      "nuire",
      "nuisible",
      "numéro",
      "nuptial",
      "nuque",
      "nutritif",
      "obéir",
      "objectif",
      "obliger",
      "obscur",
      "observer",
      "obstacle",
      "obtenir",
      "obturer",
      "occasion",
      "occuper",
      "océan",
      "octobre",
      "octroyer",
      "octupler",
      "oculaire",
      "odeur",
      "odorant",
      "offenser",
      "officier",
      "offrir",
      "ogive",
      "oiseau",
      "oisillon",
      "olfactif",
      "olivier",
      "ombrage",
      "omettre",
      "onctueux",
      "onduler",
      "onéreux",
      "onirique",
      "opale",
      "opaque",
      "opérer",
      "opinion",
      "opportun",
      "opprimer",
      "opter",
      "optique",
      "orageux",
      "orange",
      "orbite",
      "ordonner",
      "oreille",
      "organe",
      "orgueil",
      "orifice",
      "ornement",
      "orque",
      "ortie",
      "osciller",
      "osmose",
      "ossature",
      "otarie",
      "ouragan",
      "ourson",
      "outil",
      "outrager",
      "ouvrage",
      "ovation",
      "oxyde",
      "oxygène",
      "ozone",
      "paisible",
      "palace",
      "palmarès",
      "palourde",
      "palper",
      "panache",
      "panda",
      "pangolin",
      "paniquer",
      "panneau",
      "panorama",
      "pantalon",
      "papaye",
      "papier",
      "papoter",
      "papyrus",
      "paradoxe",
      "parcelle",
      "paresse",
      "parfumer",
      "parler",
      "parole",
      "parrain",
      "parsemer",
      "partager",
      "parure",
      "parvenir",
      "passion",
      "pastèque",
      "paternel",
      "patience",
      "patron",
      "pavillon",
      "pavoiser",
      "payer",
      "paysage",
      "peigne",
      "peintre",
      "pelage",
      "pélican",
      "pelle",
      "pelouse",
      "peluche",
      "pendule",
      "pénétrer",
      "pénible",
      "pensif",
      "pénurie",
      "pépite",
      "péplum",
      "perdrix",
      "perforer",
      "période",
      "permuter",
      "perplexe",
      "persil",
      "perte",
      "peser",
      "pétale",
      "petit",
      "pétrir",
      "peuple",
      "pharaon",
      "phobie",
      "phoque",
      "photon",
      "phrase",
      "physique",
      "piano",
      "pictural",
      "pièce",
      "pierre",
      "pieuvre",
      "pilote",
      "pinceau",
      "pipette",
      "piquer",
      "pirogue",
      "piscine",
      "piston",
      "pivoter",
      "pixel",
      "pizza",
      "placard",
      "plafond",
      "plaisir",
      "planer",
      "plaque",
      "plastron",
      "plateau",
      "pleurer",
      "plexus",
      "pliage",
      "plomb",
      "plonger",
      "pluie",
      "plumage",
      "pochette",
      "poésie",
      "poète",
      "pointe",
      "poirier",
      "poisson",
      "poivre",
      "polaire",
      "policier",
      "pollen",
      "polygone",
      "pommade",
      "pompier",
      "ponctuel",
      "pondérer",
      "poney",
      "portique",
      "position",
      "posséder",
      "posture",
      "potager",
      "poteau",
      "potion",
      "pouce",
      "poulain",
      "poumon",
      "pourpre",
      "poussin",
      "pouvoir",
      "prairie",
      "pratique",
      "précieux",
      "prédire",
      "préfixe",
      "prélude",
      "prénom",
      "présence",
      "prétexte",
      "prévoir",
      "primitif",
      "prince",
      "prison",
      "priver",
      "problème",
      "procéder",
      "prodige",
      "profond",
      "progrès",
      "proie",
      "projeter",
      "prologue",
      "promener",
      "propre",
      "prospère",
      "protéger",
      "prouesse",
      "proverbe",
      "prudence",
      "pruneau",
      "psychose",
      "public",
      "puceron",
      "puiser",
      "pulpe",
      "pulsar",
      "punaise",
      "punitif",
      "pupitre",
      "purifier",
      "puzzle",
      "pyramide",
      "quasar",
      "querelle",
      "question",
      "quiétude",
      "quitter",
      "quotient",
      "racine",
      "raconter",
      "radieux",
      "ragondin",
      "raideur",
      "raisin",
      "ralentir",
      "rallonge",
      "ramasser",
      "rapide",
      "rasage",
      "ratisser",
      "ravager",
      "ravin",
      "rayonner",
      "réactif",
      "réagir",
      "réaliser",
      "réanimer",
      "recevoir",
      "réciter",
      "réclamer",
      "récolter",
      "recruter",
      "reculer",
      "recycler",
      "rédiger",
      "redouter",
      "refaire",
      "réflexe",
      "réformer",
      "refrain",
      "refuge",
      "régalien",
      "région",
      "réglage",
      "régulier",
      "réitérer",
      "rejeter",
      "rejouer",
      "relatif",
      "relever",
      "relief",
      "remarque",
      "remède",
      "remise",
      "remonter",
      "remplir",
      "remuer",
      "renard",
      "renfort",
      "renifler",
      "renoncer",
      "rentrer",
      "renvoi",
      "replier",
      "reporter",
      "reprise",
      "reptile",
      "requin",
      "réserve",
      "résineux",
      "résoudre",
      "respect",
      "rester",
      "résultat",
      "rétablir",
      "retenir",
      "réticule",
      "retomber",
      "retracer",
      "réunion",
      "réussir",
      "revanche",
      "revivre",
      "révolte",
      "révulsif",
      "richesse",
      "rideau",
      "rieur",
      "rigide",
      "rigoler",
      "rincer",
      "riposter",
      "risible",
      "risque",
      "rituel",
      "rival",
      "rivière",
      "rocheux",
      "romance",
      "rompre",
      "ronce",
      "rondin",
      "roseau",
      "rosier",
      "rotatif",
      "rotor",
      "rotule",
      "rouge",
      "rouille",
      "rouleau",
      "routine",
      "royaume",
      "ruban",
      "rubis",
      "ruche",
      "ruelle",
      "rugueux",
      "ruiner",
      "ruisseau",
      "ruser",
      "rustique",
      "rythme",
      "sabler",
      "saboter",
      "sabre",
      "sacoche",
      "safari",
      "sagesse",
      "saisir",
      "salade",
      "salive",
      "salon",
      "saluer",
      "samedi",
      "sanction",
      "sanglier",
      "sarcasme",
      "sardine",
      "saturer",
      "saugrenu",
      "saumon",
      "sauter",
      "sauvage",
      "savant",
      "savonner",
      "scalpel",
      "scandale",
      "scélérat",
      "scénario",
      "sceptre",
      "schéma",
      "science",
      "scinder",
      "score",
      "scrutin",
      "sculpter",
      "séance",
      "sécable",
      "sécher",
      "secouer",
      "sécréter",
      "sédatif",
      "séduire",
      "seigneur",
      "séjour",
      "sélectif",
      "semaine",
      "sembler",
      "semence",
      "séminal",
      "sénateur",
      "sensible",
      "sentence",
      "séparer",
      "séquence",
      "serein",
      "sergent",
      "sérieux",
      "serrure",
      "sérum",
      "service",
      "sésame",
      "sévir",
      "sevrage",
      "sextuple",
      "sidéral",
      "siècle",
      "siéger",
      "siffler",
      "sigle",
      "signal",
      "silence",
      "silicium",
      "simple",
      "sincère",
      "sinistre",
      "siphon",
      "sirop",
      "sismique",
      "situer",
      "skier",
      "social",
      "socle",
      "sodium",
      "soigneux",
      "soldat",
      "soleil",
      "solitude",
      "soluble",
      "sombre",
      "sommeil",
      "somnoler",
      "sonde",
      "songeur",
      "sonnette",
      "sonore",
      "sorcier",
      "sortir",
      "sosie",
      "sottise",
      "soucieux",
      "soudure",
      "souffle",
      "soulever",
      "soupape",
      "source",
      "soutirer",
      "souvenir",
      "spacieux",
      "spatial",
      "spécial",
      "sphère",
      "spiral",
      "stable",
      "station",
      "sternum",
      "stimulus",
      "stipuler",
      "strict",
      "studieux",
      "stupeur",
      "styliste",
      "sublime",
      "substrat",
      "subtil",
      "subvenir",
      "succès",
      "sucre",
      "suffixe",
      "suggérer",
      "suiveur",
      "sulfate",
      "superbe",
      "supplier",
      "surface",
      "suricate",
      "surmener",
      "surprise",
      "sursaut",
      "survie",
      "suspect",
      "syllabe",
      "symbole",
      "symétrie",
      "synapse",
      "syntaxe",
      "système",
      "tabac",
      "tablier",
      "tactile",
      "tailler",
      "talent",
      "talisman",
      "talonner",
      "tambour",
      "tamiser",
      "tangible",
      "tapis",
      "taquiner",
      "tarder",
      "tarif",
      "tartine",
      "tasse",
      "tatami",
      "tatouage",
      "taupe",
      "taureau",
      "taxer",
      "témoin",
      "temporel",
      "tenaille",
      "tendre",
      "teneur",
      "tenir",
      "tension",
      "terminer",
      "terne",
      "terrible",
      "tétine",
      "texte",
      "thème",
      "théorie",
      "thérapie",
      "thorax",
      "tibia",
      "tiède",
      "timide",
      "tirelire",
      "tiroir",
      "tissu",
      "titane",
      "titre",
      "tituber",
      "toboggan",
      "tolérant",
      "tomate",
      "tonique",
      "tonneau",
      "toponyme",
      "torche",
      "tordre",
      "tornade",
      "torpille",
      "torrent",
      "torse",
      "tortue",
      "totem",
      "toucher",
      "tournage",
      "tousser",
      "toxine",
      "traction",
      "trafic",
      "tragique",
      "trahir",
      "train",
      "trancher",
      "travail",
      "trèfle",
      "tremper",
      "trésor",
      "treuil",
      "triage",
      "tribunal",
      "tricoter",
      "trilogie",
      "triomphe",
      "tripler",
      "triturer",
      "trivial",
      "trombone",
      "tronc",
      "tropical",
      "troupeau",
      "tuile",
      "tulipe",
      "tumulte",
      "tunnel",
      "turbine",
      "tuteur",
      "tutoyer",
      "tuyau",
      "tympan",
      "typhon",
      "typique",
      "tyran",
      "ubuesque",
      "ultime",
      "ultrason",
      "unanime",
      "unifier",
      "union",
      "unique",
      "unitaire",
      "univers",
      "uranium",
      "urbain",
      "urticant",
      "usage",
      "usine",
      "usuel",
      "usure",
      "utile",
      "utopie",
      "vacarme",
      "vaccin",
      "vagabond",
      "vague",
      "vaillant",
      "vaincre",
      "vaisseau",
      "valable",
      "valise",
      "vallon",
      "valve",
      "vampire",
      "vanille",
      "vapeur",
      "varier",
      "vaseux",
      "vassal",
      "vaste",
      "vecteur",
      "vedette",
      "végétal",
      "véhicule",
      "veinard",
      "véloce",
      "vendredi",
      "vénérer",
      "venger",
      "venimeux",
      "ventouse",
      "verdure",
      "vérin",
      "vernir",
      "verrou",
      "verser",
      "vertu",
      "veston",
      "vétéran",
      "vétuste",
      "vexant",
      "vexer",
      "viaduc",
      "viande",
      "victoire",
      "vidange",
      "vidéo",
      "vignette",
      "vigueur",
      "vilain",
      "village",
      "vinaigre",
      "violon",
      "vipère",
      "virement",
      "virtuose",
      "virus",
      "visage",
      "viseur",
      "vision",
      "visqueux",
      "visuel",
      "vital",
      "vitesse",
      "viticole",
      "vitrine",
      "vivace",
      "vivipare",
      "vocation",
      "voguer",
      "voile",
      "voisin",
      "voiture",
      "volaille",
      "volcan",
      "voltiger",
      "volume",
      "vorace",
      "vortex",
      "voter",
      "vouloir",
      "voyage",
      "voyelle",
      "wagon",
      "xénon",
      "yacht",
      "zèbre",
      "zénith",
      "zeste",
      "zoologie"
    ];
  }
});

// node_modules/bip39/src/wordlists/italian.json
var require_italian = __commonJS({
  "node_modules/bip39/src/wordlists/italian.json"(exports2, module2) {
    module2.exports = [
      "abaco",
      "abbaglio",
      "abbinato",
      "abete",
      "abisso",
      "abolire",
      "abrasivo",
      "abrogato",
      "accadere",
      "accenno",
      "accusato",
      "acetone",
      "achille",
      "acido",
      "acqua",
      "acre",
      "acrilico",
      "acrobata",
      "acuto",
      "adagio",
      "addebito",
      "addome",
      "adeguato",
      "aderire",
      "adipe",
      "adottare",
      "adulare",
      "affabile",
      "affetto",
      "affisso",
      "affranto",
      "aforisma",
      "afoso",
      "africano",
      "agave",
      "agente",
      "agevole",
      "aggancio",
      "agire",
      "agitare",
      "agonismo",
      "agricolo",
      "agrumeto",
      "aguzzo",
      "alabarda",
      "alato",
      "albatro",
      "alberato",
      "albo",
      "albume",
      "alce",
      "alcolico",
      "alettone",
      "alfa",
      "algebra",
      "aliante",
      "alibi",
      "alimento",
      "allagato",
      "allegro",
      "allievo",
      "allodola",
      "allusivo",
      "almeno",
      "alogeno",
      "alpaca",
      "alpestre",
      "altalena",
      "alterno",
      "alticcio",
      "altrove",
      "alunno",
      "alveolo",
      "alzare",
      "amalgama",
      "amanita",
      "amarena",
      "ambito",
      "ambrato",
      "ameba",
      "america",
      "ametista",
      "amico",
      "ammasso",
      "ammenda",
      "ammirare",
      "ammonito",
      "amore",
      "ampio",
      "ampliare",
      "amuleto",
      "anacardo",
      "anagrafe",
      "analista",
      "anarchia",
      "anatra",
      "anca",
      "ancella",
      "ancora",
      "andare",
      "andrea",
      "anello",
      "angelo",
      "angolare",
      "angusto",
      "anima",
      "annegare",
      "annidato",
      "anno",
      "annuncio",
      "anonimo",
      "anticipo",
      "anzi",
      "apatico",
      "apertura",
      "apode",
      "apparire",
      "appetito",
      "appoggio",
      "approdo",
      "appunto",
      "aprile",
      "arabica",
      "arachide",
      "aragosta",
      "araldica",
      "arancio",
      "aratura",
      "arazzo",
      "arbitro",
      "archivio",
      "ardito",
      "arenile",
      "argento",
      "argine",
      "arguto",
      "aria",
      "armonia",
      "arnese",
      "arredato",
      "arringa",
      "arrosto",
      "arsenico",
      "arso",
      "artefice",
      "arzillo",
      "asciutto",
      "ascolto",
      "asepsi",
      "asettico",
      "asfalto",
      "asino",
      "asola",
      "aspirato",
      "aspro",
      "assaggio",
      "asse",
      "assoluto",
      "assurdo",
      "asta",
      "astenuto",
      "astice",
      "astratto",
      "atavico",
      "ateismo",
      "atomico",
      "atono",
      "attesa",
      "attivare",
      "attorno",
      "attrito",
      "attuale",
      "ausilio",
      "austria",
      "autista",
      "autonomo",
      "autunno",
      "avanzato",
      "avere",
      "avvenire",
      "avviso",
      "avvolgere",
      "azione",
      "azoto",
      "azzimo",
      "azzurro",
      "babele",
      "baccano",
      "bacino",
      "baco",
      "badessa",
      "badilata",
      "bagnato",
      "baita",
      "balcone",
      "baldo",
      "balena",
      "ballata",
      "balzano",
      "bambino",
      "bandire",
      "baraonda",
      "barbaro",
      "barca",
      "baritono",
      "barlume",
      "barocco",
      "basilico",
      "basso",
      "batosta",
      "battuto",
      "baule",
      "bava",
      "bavosa",
      "becco",
      "beffa",
      "belgio",
      "belva",
      "benda",
      "benevole",
      "benigno",
      "benzina",
      "bere",
      "berlina",
      "beta",
      "bibita",
      "bici",
      "bidone",
      "bifido",
      "biga",
      "bilancia",
      "bimbo",
      "binocolo",
      "biologo",
      "bipede",
      "bipolare",
      "birbante",
      "birra",
      "biscotto",
      "bisesto",
      "bisnonno",
      "bisonte",
      "bisturi",
      "bizzarro",
      "blando",
      "blatta",
      "bollito",
      "bonifico",
      "bordo",
      "bosco",
      "botanico",
      "bottino",
      "bozzolo",
      "braccio",
      "bradipo",
      "brama",
      "branca",
      "bravura",
      "bretella",
      "brevetto",
      "brezza",
      "briglia",
      "brillante",
      "brindare",
      "broccolo",
      "brodo",
      "bronzina",
      "brullo",
      "bruno",
      "bubbone",
      "buca",
      "budino",
      "buffone",
      "buio",
      "bulbo",
      "buono",
      "burlone",
      "burrasca",
      "bussola",
      "busta",
      "cadetto",
      "caduco",
      "calamaro",
      "calcolo",
      "calesse",
      "calibro",
      "calmo",
      "caloria",
      "cambusa",
      "camerata",
      "camicia",
      "cammino",
      "camola",
      "campale",
      "canapa",
      "candela",
      "cane",
      "canino",
      "canotto",
      "cantina",
      "capace",
      "capello",
      "capitolo",
      "capogiro",
      "cappero",
      "capra",
      "capsula",
      "carapace",
      "carcassa",
      "cardo",
      "carisma",
      "carovana",
      "carretto",
      "cartolina",
      "casaccio",
      "cascata",
      "caserma",
      "caso",
      "cassone",
      "castello",
      "casuale",
      "catasta",
      "catena",
      "catrame",
      "cauto",
      "cavillo",
      "cedibile",
      "cedrata",
      "cefalo",
      "celebre",
      "cellulare",
      "cena",
      "cenone",
      "centesimo",
      "ceramica",
      "cercare",
      "certo",
      "cerume",
      "cervello",
      "cesoia",
      "cespo",
      "ceto",
      "chela",
      "chiaro",
      "chicca",
      "chiedere",
      "chimera",
      "china",
      "chirurgo",
      "chitarra",
      "ciao",
      "ciclismo",
      "cifrare",
      "cigno",
      "cilindro",
      "ciottolo",
      "circa",
      "cirrosi",
      "citrico",
      "cittadino",
      "ciuffo",
      "civetta",
      "civile",
      "classico",
      "clinica",
      "cloro",
      "cocco",
      "codardo",
      "codice",
      "coerente",
      "cognome",
      "collare",
      "colmato",
      "colore",
      "colposo",
      "coltivato",
      "colza",
      "coma",
      "cometa",
      "commando",
      "comodo",
      "computer",
      "comune",
      "conciso",
      "condurre",
      "conferma",
      "congelare",
      "coniuge",
      "connesso",
      "conoscere",
      "consumo",
      "continuo",
      "convegno",
      "coperto",
      "copione",
      "coppia",
      "copricapo",
      "corazza",
      "cordata",
      "coricato",
      "cornice",
      "corolla",
      "corpo",
      "corredo",
      "corsia",
      "cortese",
      "cosmico",
      "costante",
      "cottura",
      "covato",
      "cratere",
      "cravatta",
      "creato",
      "credere",
      "cremoso",
      "crescita",
      "creta",
      "criceto",
      "crinale",
      "crisi",
      "critico",
      "croce",
      "cronaca",
      "crostata",
      "cruciale",
      "crusca",
      "cucire",
      "cuculo",
      "cugino",
      "cullato",
      "cupola",
      "curatore",
      "cursore",
      "curvo",
      "cuscino",
      "custode",
      "dado",
      "daino",
      "dalmata",
      "damerino",
      "daniela",
      "dannoso",
      "danzare",
      "datato",
      "davanti",
      "davvero",
      "debutto",
      "decennio",
      "deciso",
      "declino",
      "decollo",
      "decreto",
      "dedicato",
      "definito",
      "deforme",
      "degno",
      "delegare",
      "delfino",
      "delirio",
      "delta",
      "demenza",
      "denotato",
      "dentro",
      "deposito",
      "derapata",
      "derivare",
      "deroga",
      "descritto",
      "deserto",
      "desiderio",
      "desumere",
      "detersivo",
      "devoto",
      "diametro",
      "dicembre",
      "diedro",
      "difeso",
      "diffuso",
      "digerire",
      "digitale",
      "diluvio",
      "dinamico",
      "dinnanzi",
      "dipinto",
      "diploma",
      "dipolo",
      "diradare",
      "dire",
      "dirotto",
      "dirupo",
      "disagio",
      "discreto",
      "disfare",
      "disgelo",
      "disposto",
      "distanza",
      "disumano",
      "dito",
      "divano",
      "divelto",
      "dividere",
      "divorato",
      "doblone",
      "docente",
      "doganale",
      "dogma",
      "dolce",
      "domato",
      "domenica",
      "dominare",
      "dondolo",
      "dono",
      "dormire",
      "dote",
      "dottore",
      "dovuto",
      "dozzina",
      "drago",
      "druido",
      "dubbio",
      "dubitare",
      "ducale",
      "duna",
      "duomo",
      "duplice",
      "duraturo",
      "ebano",
      "eccesso",
      "ecco",
      "eclissi",
      "economia",
      "edera",
      "edicola",
      "edile",
      "editoria",
      "educare",
      "egemonia",
      "egli",
      "egoismo",
      "egregio",
      "elaborato",
      "elargire",
      "elegante",
      "elencato",
      "eletto",
      "elevare",
      "elfico",
      "elica",
      "elmo",
      "elsa",
      "eluso",
      "emanato",
      "emblema",
      "emesso",
      "emiro",
      "emotivo",
      "emozione",
      "empirico",
      "emulo",
      "endemico",
      "enduro",
      "energia",
      "enfasi",
      "enoteca",
      "entrare",
      "enzima",
      "epatite",
      "epilogo",
      "episodio",
      "epocale",
      "eppure",
      "equatore",
      "erario",
      "erba",
      "erboso",
      "erede",
      "eremita",
      "erigere",
      "ermetico",
      "eroe",
      "erosivo",
      "errante",
      "esagono",
      "esame",
      "esanime",
      "esaudire",
      "esca",
      "esempio",
      "esercito",
      "esibito",
      "esigente",
      "esistere",
      "esito",
      "esofago",
      "esortato",
      "esoso",
      "espanso",
      "espresso",
      "essenza",
      "esso",
      "esteso",
      "estimare",
      "estonia",
      "estroso",
      "esultare",
      "etilico",
      "etnico",
      "etrusco",
      "etto",
      "euclideo",
      "europa",
      "evaso",
      "evidenza",
      "evitato",
      "evoluto",
      "evviva",
      "fabbrica",
      "faccenda",
      "fachiro",
      "falco",
      "famiglia",
      "fanale",
      "fanfara",
      "fango",
      "fantasma",
      "fare",
      "farfalla",
      "farinoso",
      "farmaco",
      "fascia",
      "fastoso",
      "fasullo",
      "faticare",
      "fato",
      "favoloso",
      "febbre",
      "fecola",
      "fede",
      "fegato",
      "felpa",
      "feltro",
      "femmina",
      "fendere",
      "fenomeno",
      "fermento",
      "ferro",
      "fertile",
      "fessura",
      "festivo",
      "fetta",
      "feudo",
      "fiaba",
      "fiducia",
      "fifa",
      "figurato",
      "filo",
      "finanza",
      "finestra",
      "finire",
      "fiore",
      "fiscale",
      "fisico",
      "fiume",
      "flacone",
      "flamenco",
      "flebo",
      "flemma",
      "florido",
      "fluente",
      "fluoro",
      "fobico",
      "focaccia",
      "focoso",
      "foderato",
      "foglio",
      "folata",
      "folclore",
      "folgore",
      "fondente",
      "fonetico",
      "fonia",
      "fontana",
      "forbito",
      "forchetta",
      "foresta",
      "formica",
      "fornaio",
      "foro",
      "fortezza",
      "forzare",
      "fosfato",
      "fosso",
      "fracasso",
      "frana",
      "frassino",
      "fratello",
      "freccetta",
      "frenata",
      "fresco",
      "frigo",
      "frollino",
      "fronde",
      "frugale",
      "frutta",
      "fucilata",
      "fucsia",
      "fuggente",
      "fulmine",
      "fulvo",
      "fumante",
      "fumetto",
      "fumoso",
      "fune",
      "funzione",
      "fuoco",
      "furbo",
      "furgone",
      "furore",
      "fuso",
      "futile",
      "gabbiano",
      "gaffe",
      "galateo",
      "gallina",
      "galoppo",
      "gambero",
      "gamma",
      "garanzia",
      "garbo",
      "garofano",
      "garzone",
      "gasdotto",
      "gasolio",
      "gastrico",
      "gatto",
      "gaudio",
      "gazebo",
      "gazzella",
      "geco",
      "gelatina",
      "gelso",
      "gemello",
      "gemmato",
      "gene",
      "genitore",
      "gennaio",
      "genotipo",
      "gergo",
      "ghepardo",
      "ghiaccio",
      "ghisa",
      "giallo",
      "gilda",
      "ginepro",
      "giocare",
      "gioiello",
      "giorno",
      "giove",
      "girato",
      "girone",
      "gittata",
      "giudizio",
      "giurato",
      "giusto",
      "globulo",
      "glutine",
      "gnomo",
      "gobba",
      "golf",
      "gomito",
      "gommone",
      "gonfio",
      "gonna",
      "governo",
      "gracile",
      "grado",
      "grafico",
      "grammo",
      "grande",
      "grattare",
      "gravoso",
      "grazia",
      "greca",
      "gregge",
      "grifone",
      "grigio",
      "grinza",
      "grotta",
      "gruppo",
      "guadagno",
      "guaio",
      "guanto",
      "guardare",
      "gufo",
      "guidare",
      "ibernato",
      "icona",
      "identico",
      "idillio",
      "idolo",
      "idra",
      "idrico",
      "idrogeno",
      "igiene",
      "ignaro",
      "ignorato",
      "ilare",
      "illeso",
      "illogico",
      "illudere",
      "imballo",
      "imbevuto",
      "imbocco",
      "imbuto",
      "immane",
      "immerso",
      "immolato",
      "impacco",
      "impeto",
      "impiego",
      "importo",
      "impronta",
      "inalare",
      "inarcare",
      "inattivo",
      "incanto",
      "incendio",
      "inchino",
      "incisivo",
      "incluso",
      "incontro",
      "incrocio",
      "incubo",
      "indagine",
      "india",
      "indole",
      "inedito",
      "infatti",
      "infilare",
      "inflitto",
      "ingaggio",
      "ingegno",
      "inglese",
      "ingordo",
      "ingrosso",
      "innesco",
      "inodore",
      "inoltrare",
      "inondato",
      "insano",
      "insetto",
      "insieme",
      "insonnia",
      "insulina",
      "intasato",
      "intero",
      "intonaco",
      "intuito",
      "inumidire",
      "invalido",
      "invece",
      "invito",
      "iperbole",
      "ipnotico",
      "ipotesi",
      "ippica",
      "iride",
      "irlanda",
      "ironico",
      "irrigato",
      "irrorare",
      "isolato",
      "isotopo",
      "isterico",
      "istituto",
      "istrice",
      "italia",
      "iterare",
      "labbro",
      "labirinto",
      "lacca",
      "lacerato",
      "lacrima",
      "lacuna",
      "laddove",
      "lago",
      "lampo",
      "lancetta",
      "lanterna",
      "lardoso",
      "larga",
      "laringe",
      "lastra",
      "latenza",
      "latino",
      "lattuga",
      "lavagna",
      "lavoro",
      "legale",
      "leggero",
      "lembo",
      "lentezza",
      "lenza",
      "leone",
      "lepre",
      "lesivo",
      "lessato",
      "lesto",
      "letterale",
      "leva",
      "levigato",
      "libero",
      "lido",
      "lievito",
      "lilla",
      "limatura",
      "limitare",
      "limpido",
      "lineare",
      "lingua",
      "liquido",
      "lira",
      "lirica",
      "lisca",
      "lite",
      "litigio",
      "livrea",
      "locanda",
      "lode",
      "logica",
      "lombare",
      "londra",
      "longevo",
      "loquace",
      "lorenzo",
      "loto",
      "lotteria",
      "luce",
      "lucidato",
      "lumaca",
      "luminoso",
      "lungo",
      "lupo",
      "luppolo",
      "lusinga",
      "lusso",
      "lutto",
      "macabro",
      "macchina",
      "macero",
      "macinato",
      "madama",
      "magico",
      "maglia",
      "magnete",
      "magro",
      "maiolica",
      "malafede",
      "malgrado",
      "malinteso",
      "malsano",
      "malto",
      "malumore",
      "mana",
      "mancia",
      "mandorla",
      "mangiare",
      "manifesto",
      "mannaro",
      "manovra",
      "mansarda",
      "mantide",
      "manubrio",
      "mappa",
      "maratona",
      "marcire",
      "maretta",
      "marmo",
      "marsupio",
      "maschera",
      "massaia",
      "mastino",
      "materasso",
      "matricola",
      "mattone",
      "maturo",
      "mazurca",
      "meandro",
      "meccanico",
      "mecenate",
      "medesimo",
      "meditare",
      "mega",
      "melassa",
      "melis",
      "melodia",
      "meninge",
      "meno",
      "mensola",
      "mercurio",
      "merenda",
      "merlo",
      "meschino",
      "mese",
      "messere",
      "mestolo",
      "metallo",
      "metodo",
      "mettere",
      "miagolare",
      "mica",
      "micelio",
      "michele",
      "microbo",
      "midollo",
      "miele",
      "migliore",
      "milano",
      "milite",
      "mimosa",
      "minerale",
      "mini",
      "minore",
      "mirino",
      "mirtillo",
      "miscela",
      "missiva",
      "misto",
      "misurare",
      "mitezza",
      "mitigare",
      "mitra",
      "mittente",
      "mnemonico",
      "modello",
      "modifica",
      "modulo",
      "mogano",
      "mogio",
      "mole",
      "molosso",
      "monastero",
      "monco",
      "mondina",
      "monetario",
      "monile",
      "monotono",
      "monsone",
      "montato",
      "monviso",
      "mora",
      "mordere",
      "morsicato",
      "mostro",
      "motivato",
      "motosega",
      "motto",
      "movenza",
      "movimento",
      "mozzo",
      "mucca",
      "mucosa",
      "muffa",
      "mughetto",
      "mugnaio",
      "mulatto",
      "mulinello",
      "multiplo",
      "mummia",
      "munto",
      "muovere",
      "murale",
      "musa",
      "muscolo",
      "musica",
      "mutevole",
      "muto",
      "nababbo",
      "nafta",
      "nanometro",
      "narciso",
      "narice",
      "narrato",
      "nascere",
      "nastrare",
      "naturale",
      "nautica",
      "naviglio",
      "nebulosa",
      "necrosi",
      "negativo",
      "negozio",
      "nemmeno",
      "neofita",
      "neretto",
      "nervo",
      "nessuno",
      "nettuno",
      "neutrale",
      "neve",
      "nevrotico",
      "nicchia",
      "ninfa",
      "nitido",
      "nobile",
      "nocivo",
      "nodo",
      "nome",
      "nomina",
      "nordico",
      "normale",
      "norvegese",
      "nostrano",
      "notare",
      "notizia",
      "notturno",
      "novella",
      "nucleo",
      "nulla",
      "numero",
      "nuovo",
      "nutrire",
      "nuvola",
      "nuziale",
      "oasi",
      "obbedire",
      "obbligo",
      "obelisco",
      "oblio",
      "obolo",
      "obsoleto",
      "occasione",
      "occhio",
      "occidente",
      "occorrere",
      "occultare",
      "ocra",
      "oculato",
      "odierno",
      "odorare",
      "offerta",
      "offrire",
      "offuscato",
      "oggetto",
      "oggi",
      "ognuno",
      "olandese",
      "olfatto",
      "oliato",
      "oliva",
      "ologramma",
      "oltre",
      "omaggio",
      "ombelico",
      "ombra",
      "omega",
      "omissione",
      "ondoso",
      "onere",
      "onice",
      "onnivoro",
      "onorevole",
      "onta",
      "operato",
      "opinione",
      "opposto",
      "oracolo",
      "orafo",
      "ordine",
      "orecchino",
      "orefice",
      "orfano",
      "organico",
      "origine",
      "orizzonte",
      "orma",
      "ormeggio",
      "ornativo",
      "orologio",
      "orrendo",
      "orribile",
      "ortensia",
      "ortica",
      "orzata",
      "orzo",
      "osare",
      "oscurare",
      "osmosi",
      "ospedale",
      "ospite",
      "ossa",
      "ossidare",
      "ostacolo",
      "oste",
      "otite",
      "otre",
      "ottagono",
      "ottimo",
      "ottobre",
      "ovale",
      "ovest",
      "ovino",
      "oviparo",
      "ovocito",
      "ovunque",
      "ovviare",
      "ozio",
      "pacchetto",
      "pace",
      "pacifico",
      "padella",
      "padrone",
      "paese",
      "paga",
      "pagina",
      "palazzina",
      "palesare",
      "pallido",
      "palo",
      "palude",
      "pandoro",
      "pannello",
      "paolo",
      "paonazzo",
      "paprica",
      "parabola",
      "parcella",
      "parere",
      "pargolo",
      "pari",
      "parlato",
      "parola",
      "partire",
      "parvenza",
      "parziale",
      "passivo",
      "pasticca",
      "patacca",
      "patologia",
      "pattume",
      "pavone",
      "peccato",
      "pedalare",
      "pedonale",
      "peggio",
      "peloso",
      "penare",
      "pendice",
      "penisola",
      "pennuto",
      "penombra",
      "pensare",
      "pentola",
      "pepe",
      "pepita",
      "perbene",
      "percorso",
      "perdonato",
      "perforare",
      "pergamena",
      "periodo",
      "permesso",
      "perno",
      "perplesso",
      "persuaso",
      "pertugio",
      "pervaso",
      "pesatore",
      "pesista",
      "peso",
      "pestifero",
      "petalo",
      "pettine",
      "petulante",
      "pezzo",
      "piacere",
      "pianta",
      "piattino",
      "piccino",
      "picozza",
      "piega",
      "pietra",
      "piffero",
      "pigiama",
      "pigolio",
      "pigro",
      "pila",
      "pilifero",
      "pillola",
      "pilota",
      "pimpante",
      "pineta",
      "pinna",
      "pinolo",
      "pioggia",
      "piombo",
      "piramide",
      "piretico",
      "pirite",
      "pirolisi",
      "pitone",
      "pizzico",
      "placebo",
      "planare",
      "plasma",
      "platano",
      "plenario",
      "pochezza",
      "poderoso",
      "podismo",
      "poesia",
      "poggiare",
      "polenta",
      "poligono",
      "pollice",
      "polmonite",
      "polpetta",
      "polso",
      "poltrona",
      "polvere",
      "pomice",
      "pomodoro",
      "ponte",
      "popoloso",
      "porfido",
      "poroso",
      "porpora",
      "porre",
      "portata",
      "posa",
      "positivo",
      "possesso",
      "postulato",
      "potassio",
      "potere",
      "pranzo",
      "prassi",
      "pratica",
      "precluso",
      "predica",
      "prefisso",
      "pregiato",
      "prelievo",
      "premere",
      "prenotare",
      "preparato",
      "presenza",
      "pretesto",
      "prevalso",
      "prima",
      "principe",
      "privato",
      "problema",
      "procura",
      "produrre",
      "profumo",
      "progetto",
      "prolunga",
      "promessa",
      "pronome",
      "proposta",
      "proroga",
      "proteso",
      "prova",
      "prudente",
      "prugna",
      "prurito",
      "psiche",
      "pubblico",
      "pudica",
      "pugilato",
      "pugno",
      "pulce",
      "pulito",
      "pulsante",
      "puntare",
      "pupazzo",
      "pupilla",
      "puro",
      "quadro",
      "qualcosa",
      "quasi",
      "querela",
      "quota",
      "raccolto",
      "raddoppio",
      "radicale",
      "radunato",
      "raffica",
      "ragazzo",
      "ragione",
      "ragno",
      "ramarro",
      "ramingo",
      "ramo",
      "randagio",
      "rantolare",
      "rapato",
      "rapina",
      "rappreso",
      "rasatura",
      "raschiato",
      "rasente",
      "rassegna",
      "rastrello",
      "rata",
      "ravveduto",
      "reale",
      "recepire",
      "recinto",
      "recluta",
      "recondito",
      "recupero",
      "reddito",
      "redimere",
      "regalato",
      "registro",
      "regola",
      "regresso",
      "relazione",
      "remare",
      "remoto",
      "renna",
      "replica",
      "reprimere",
      "reputare",
      "resa",
      "residente",
      "responso",
      "restauro",
      "rete",
      "retina",
      "retorica",
      "rettifica",
      "revocato",
      "riassunto",
      "ribadire",
      "ribelle",
      "ribrezzo",
      "ricarica",
      "ricco",
      "ricevere",
      "riciclato",
      "ricordo",
      "ricreduto",
      "ridicolo",
      "ridurre",
      "rifasare",
      "riflesso",
      "riforma",
      "rifugio",
      "rigare",
      "rigettato",
      "righello",
      "rilassato",
      "rilevato",
      "rimanere",
      "rimbalzo",
      "rimedio",
      "rimorchio",
      "rinascita",
      "rincaro",
      "rinforzo",
      "rinnovo",
      "rinomato",
      "rinsavito",
      "rintocco",
      "rinuncia",
      "rinvenire",
      "riparato",
      "ripetuto",
      "ripieno",
      "riportare",
      "ripresa",
      "ripulire",
      "risata",
      "rischio",
      "riserva",
      "risibile",
      "riso",
      "rispetto",
      "ristoro",
      "risultato",
      "risvolto",
      "ritardo",
      "ritegno",
      "ritmico",
      "ritrovo",
      "riunione",
      "riva",
      "riverso",
      "rivincita",
      "rivolto",
      "rizoma",
      "roba",
      "robotico",
      "robusto",
      "roccia",
      "roco",
      "rodaggio",
      "rodere",
      "roditore",
      "rogito",
      "rollio",
      "romantico",
      "rompere",
      "ronzio",
      "rosolare",
      "rospo",
      "rotante",
      "rotondo",
      "rotula",
      "rovescio",
      "rubizzo",
      "rubrica",
      "ruga",
      "rullino",
      "rumine",
      "rumoroso",
      "ruolo",
      "rupe",
      "russare",
      "rustico",
      "sabato",
      "sabbiare",
      "sabotato",
      "sagoma",
      "salasso",
      "saldatura",
      "salgemma",
      "salivare",
      "salmone",
      "salone",
      "saltare",
      "saluto",
      "salvo",
      "sapere",
      "sapido",
      "saporito",
      "saraceno",
      "sarcasmo",
      "sarto",
      "sassoso",
      "satellite",
      "satira",
      "satollo",
      "saturno",
      "savana",
      "savio",
      "saziato",
      "sbadiglio",
      "sbalzo",
      "sbancato",
      "sbarra",
      "sbattere",
      "sbavare",
      "sbendare",
      "sbirciare",
      "sbloccato",
      "sbocciato",
      "sbrinare",
      "sbruffone",
      "sbuffare",
      "scabroso",
      "scadenza",
      "scala",
      "scambiare",
      "scandalo",
      "scapola",
      "scarso",
      "scatenare",
      "scavato",
      "scelto",
      "scenico",
      "scettro",
      "scheda",
      "schiena",
      "sciarpa",
      "scienza",
      "scindere",
      "scippo",
      "sciroppo",
      "scivolo",
      "sclerare",
      "scodella",
      "scolpito",
      "scomparto",
      "sconforto",
      "scoprire",
      "scorta",
      "scossone",
      "scozzese",
      "scriba",
      "scrollare",
      "scrutinio",
      "scuderia",
      "scultore",
      "scuola",
      "scuro",
      "scusare",
      "sdebitare",
      "sdoganare",
      "seccatura",
      "secondo",
      "sedano",
      "seggiola",
      "segnalato",
      "segregato",
      "seguito",
      "selciato",
      "selettivo",
      "sella",
      "selvaggio",
      "semaforo",
      "sembrare",
      "seme",
      "seminato",
      "sempre",
      "senso",
      "sentire",
      "sepolto",
      "sequenza",
      "serata",
      "serbato",
      "sereno",
      "serio",
      "serpente",
      "serraglio",
      "servire",
      "sestina",
      "setola",
      "settimana",
      "sfacelo",
      "sfaldare",
      "sfamato",
      "sfarzoso",
      "sfaticato",
      "sfera",
      "sfida",
      "sfilato",
      "sfinge",
      "sfocato",
      "sfoderare",
      "sfogo",
      "sfoltire",
      "sforzato",
      "sfratto",
      "sfruttato",
      "sfuggito",
      "sfumare",
      "sfuso",
      "sgabello",
      "sgarbato",
      "sgonfiare",
      "sgorbio",
      "sgrassato",
      "sguardo",
      "sibilo",
      "siccome",
      "sierra",
      "sigla",
      "signore",
      "silenzio",
      "sillaba",
      "simbolo",
      "simpatico",
      "simulato",
      "sinfonia",
      "singolo",
      "sinistro",
      "sino",
      "sintesi",
      "sinusoide",
      "sipario",
      "sisma",
      "sistole",
      "situato",
      "slitta",
      "slogatura",
      "sloveno",
      "smarrito",
      "smemorato",
      "smentito",
      "smeraldo",
      "smilzo",
      "smontare",
      "smottato",
      "smussato",
      "snellire",
      "snervato",
      "snodo",
      "sobbalzo",
      "sobrio",
      "soccorso",
      "sociale",
      "sodale",
      "soffitto",
      "sogno",
      "soldato",
      "solenne",
      "solido",
      "sollazzo",
      "solo",
      "solubile",
      "solvente",
      "somatico",
      "somma",
      "sonda",
      "sonetto",
      "sonnifero",
      "sopire",
      "soppeso",
      "sopra",
      "sorgere",
      "sorpasso",
      "sorriso",
      "sorso",
      "sorteggio",
      "sorvolato",
      "sospiro",
      "sosta",
      "sottile",
      "spada",
      "spalla",
      "spargere",
      "spatola",
      "spavento",
      "spazzola",
      "specie",
      "spedire",
      "spegnere",
      "spelatura",
      "speranza",
      "spessore",
      "spettrale",
      "spezzato",
      "spia",
      "spigoloso",
      "spillato",
      "spinoso",
      "spirale",
      "splendido",
      "sportivo",
      "sposo",
      "spranga",
      "sprecare",
      "spronato",
      "spruzzo",
      "spuntino",
      "squillo",
      "sradicare",
      "srotolato",
      "stabile",
      "stacco",
      "staffa",
      "stagnare",
      "stampato",
      "stantio",
      "starnuto",
      "stasera",
      "statuto",
      "stelo",
      "steppa",
      "sterzo",
      "stiletto",
      "stima",
      "stirpe",
      "stivale",
      "stizzoso",
      "stonato",
      "storico",
      "strappo",
      "stregato",
      "stridulo",
      "strozzare",
      "strutto",
      "stuccare",
      "stufo",
      "stupendo",
      "subentro",
      "succoso",
      "sudore",
      "suggerito",
      "sugo",
      "sultano",
      "suonare",
      "superbo",
      "supporto",
      "surgelato",
      "surrogato",
      "sussurro",
      "sutura",
      "svagare",
      "svedese",
      "sveglio",
      "svelare",
      "svenuto",
      "svezia",
      "sviluppo",
      "svista",
      "svizzera",
      "svolta",
      "svuotare",
      "tabacco",
      "tabulato",
      "tacciare",
      "taciturno",
      "tale",
      "talismano",
      "tampone",
      "tannino",
      "tara",
      "tardivo",
      "targato",
      "tariffa",
      "tarpare",
      "tartaruga",
      "tasto",
      "tattico",
      "taverna",
      "tavolata",
      "tazza",
      "teca",
      "tecnico",
      "telefono",
      "temerario",
      "tempo",
      "temuto",
      "tendone",
      "tenero",
      "tensione",
      "tentacolo",
      "teorema",
      "terme",
      "terrazzo",
      "terzetto",
      "tesi",
      "tesserato",
      "testato",
      "tetro",
      "tettoia",
      "tifare",
      "tigella",
      "timbro",
      "tinto",
      "tipico",
      "tipografo",
      "tiraggio",
      "tiro",
      "titanio",
      "titolo",
      "titubante",
      "tizio",
      "tizzone",
      "toccare",
      "tollerare",
      "tolto",
      "tombola",
      "tomo",
      "tonfo",
      "tonsilla",
      "topazio",
      "topologia",
      "toppa",
      "torba",
      "tornare",
      "torrone",
      "tortora",
      "toscano",
      "tossire",
      "tostatura",
      "totano",
      "trabocco",
      "trachea",
      "trafila",
      "tragedia",
      "tralcio",
      "tramonto",
      "transito",
      "trapano",
      "trarre",
      "trasloco",
      "trattato",
      "trave",
      "treccia",
      "tremolio",
      "trespolo",
      "tributo",
      "tricheco",
      "trifoglio",
      "trillo",
      "trincea",
      "trio",
      "tristezza",
      "triturato",
      "trivella",
      "tromba",
      "trono",
      "troppo",
      "trottola",
      "trovare",
      "truccato",
      "tubatura",
      "tuffato",
      "tulipano",
      "tumulto",
      "tunisia",
      "turbare",
      "turchino",
      "tuta",
      "tutela",
      "ubicato",
      "uccello",
      "uccisore",
      "udire",
      "uditivo",
      "uffa",
      "ufficio",
      "uguale",
      "ulisse",
      "ultimato",
      "umano",
      "umile",
      "umorismo",
      "uncinetto",
      "ungere",
      "ungherese",
      "unicorno",
      "unificato",
      "unisono",
      "unitario",
      "unte",
      "uovo",
      "upupa",
      "uragano",
      "urgenza",
      "urlo",
      "usanza",
      "usato",
      "uscito",
      "usignolo",
      "usuraio",
      "utensile",
      "utilizzo",
      "utopia",
      "vacante",
      "vaccinato",
      "vagabondo",
      "vagliato",
      "valanga",
      "valgo",
      "valico",
      "valletta",
      "valoroso",
      "valutare",
      "valvola",
      "vampata",
      "vangare",
      "vanitoso",
      "vano",
      "vantaggio",
      "vanvera",
      "vapore",
      "varano",
      "varcato",
      "variante",
      "vasca",
      "vedetta",
      "vedova",
      "veduto",
      "vegetale",
      "veicolo",
      "velcro",
      "velina",
      "velluto",
      "veloce",
      "venato",
      "vendemmia",
      "vento",
      "verace",
      "verbale",
      "vergogna",
      "verifica",
      "vero",
      "verruca",
      "verticale",
      "vescica",
      "vessillo",
      "vestale",
      "veterano",
      "vetrina",
      "vetusto",
      "viandante",
      "vibrante",
      "vicenda",
      "vichingo",
      "vicinanza",
      "vidimare",
      "vigilia",
      "vigneto",
      "vigore",
      "vile",
      "villano",
      "vimini",
      "vincitore",
      "viola",
      "vipera",
      "virgola",
      "virologo",
      "virulento",
      "viscoso",
      "visione",
      "vispo",
      "vissuto",
      "visura",
      "vita",
      "vitello",
      "vittima",
      "vivanda",
      "vivido",
      "viziare",
      "voce",
      "voga",
      "volatile",
      "volere",
      "volpe",
      "voragine",
      "vulcano",
      "zampogna",
      "zanna",
      "zappato",
      "zattera",
      "zavorra",
      "zefiro",
      "zelante",
      "zelo",
      "zenzero",
      "zerbino",
      "zibetto",
      "zinco",
      "zircone",
      "zitto",
      "zolla",
      "zotico",
      "zucchero",
      "zufolo",
      "zulu",
      "zuppa"
    ];
  }
});

// node_modules/bip39/src/wordlists/spanish.json
var require_spanish = __commonJS({
  "node_modules/bip39/src/wordlists/spanish.json"(exports2, module2) {
    module2.exports = [
      "ábaco",
      "abdomen",
      "abeja",
      "abierto",
      "abogado",
      "abono",
      "aborto",
      "abrazo",
      "abrir",
      "abuelo",
      "abuso",
      "acabar",
      "academia",
      "acceso",
      "acción",
      "aceite",
      "acelga",
      "acento",
      "aceptar",
      "ácido",
      "aclarar",
      "acné",
      "acoger",
      "acoso",
      "activo",
      "acto",
      "actriz",
      "actuar",
      "acudir",
      "acuerdo",
      "acusar",
      "adicto",
      "admitir",
      "adoptar",
      "adorno",
      "aduana",
      "adulto",
      "aéreo",
      "afectar",
      "afición",
      "afinar",
      "afirmar",
      "ágil",
      "agitar",
      "agonía",
      "agosto",
      "agotar",
      "agregar",
      "agrio",
      "agua",
      "agudo",
      "águila",
      "aguja",
      "ahogo",
      "ahorro",
      "aire",
      "aislar",
      "ajedrez",
      "ajeno",
      "ajuste",
      "alacrán",
      "alambre",
      "alarma",
      "alba",
      "álbum",
      "alcalde",
      "aldea",
      "alegre",
      "alejar",
      "alerta",
      "aleta",
      "alfiler",
      "alga",
      "algodón",
      "aliado",
      "aliento",
      "alivio",
      "alma",
      "almeja",
      "almíbar",
      "altar",
      "alteza",
      "altivo",
      "alto",
      "altura",
      "alumno",
      "alzar",
      "amable",
      "amante",
      "amapola",
      "amargo",
      "amasar",
      "ámbar",
      "ámbito",
      "ameno",
      "amigo",
      "amistad",
      "amor",
      "amparo",
      "amplio",
      "ancho",
      "anciano",
      "ancla",
      "andar",
      "andén",
      "anemia",
      "ángulo",
      "anillo",
      "ánimo",
      "anís",
      "anotar",
      "antena",
      "antiguo",
      "antojo",
      "anual",
      "anular",
      "anuncio",
      "añadir",
      "añejo",
      "año",
      "apagar",
      "aparato",
      "apetito",
      "apio",
      "aplicar",
      "apodo",
      "aporte",
      "apoyo",
      "aprender",
      "aprobar",
      "apuesta",
      "apuro",
      "arado",
      "araña",
      "arar",
      "árbitro",
      "árbol",
      "arbusto",
      "archivo",
      "arco",
      "arder",
      "ardilla",
      "arduo",
      "área",
      "árido",
      "aries",
      "armonía",
      "arnés",
      "aroma",
      "arpa",
      "arpón",
      "arreglo",
      "arroz",
      "arruga",
      "arte",
      "artista",
      "asa",
      "asado",
      "asalto",
      "ascenso",
      "asegurar",
      "aseo",
      "asesor",
      "asiento",
      "asilo",
      "asistir",
      "asno",
      "asombro",
      "áspero",
      "astilla",
      "astro",
      "astuto",
      "asumir",
      "asunto",
      "atajo",
      "ataque",
      "atar",
      "atento",
      "ateo",
      "ático",
      "atleta",
      "átomo",
      "atraer",
      "atroz",
      "atún",
      "audaz",
      "audio",
      "auge",
      "aula",
      "aumento",
      "ausente",
      "autor",
      "aval",
      "avance",
      "avaro",
      "ave",
      "avellana",
      "avena",
      "avestruz",
      "avión",
      "aviso",
      "ayer",
      "ayuda",
      "ayuno",
      "azafrán",
      "azar",
      "azote",
      "azúcar",
      "azufre",
      "azul",
      "baba",
      "babor",
      "bache",
      "bahía",
      "baile",
      "bajar",
      "balanza",
      "balcón",
      "balde",
      "bambú",
      "banco",
      "banda",
      "baño",
      "barba",
      "barco",
      "barniz",
      "barro",
      "báscula",
      "bastón",
      "basura",
      "batalla",
      "batería",
      "batir",
      "batuta",
      "baúl",
      "bazar",
      "bebé",
      "bebida",
      "bello",
      "besar",
      "beso",
      "bestia",
      "bicho",
      "bien",
      "bingo",
      "blanco",
      "bloque",
      "blusa",
      "boa",
      "bobina",
      "bobo",
      "boca",
      "bocina",
      "boda",
      "bodega",
      "boina",
      "bola",
      "bolero",
      "bolsa",
      "bomba",
      "bondad",
      "bonito",
      "bono",
      "bonsái",
      "borde",
      "borrar",
      "bosque",
      "bote",
      "botín",
      "bóveda",
      "bozal",
      "bravo",
      "brazo",
      "brecha",
      "breve",
      "brillo",
      "brinco",
      "brisa",
      "broca",
      "broma",
      "bronce",
      "brote",
      "bruja",
      "brusco",
      "bruto",
      "buceo",
      "bucle",
      "bueno",
      "buey",
      "bufanda",
      "bufón",
      "búho",
      "buitre",
      "bulto",
      "burbuja",
      "burla",
      "burro",
      "buscar",
      "butaca",
      "buzón",
      "caballo",
      "cabeza",
      "cabina",
      "cabra",
      "cacao",
      "cadáver",
      "cadena",
      "caer",
      "café",
      "caída",
      "caimán",
      "caja",
      "cajón",
      "cal",
      "calamar",
      "calcio",
      "caldo",
      "calidad",
      "calle",
      "calma",
      "calor",
      "calvo",
      "cama",
      "cambio",
      "camello",
      "camino",
      "campo",
      "cáncer",
      "candil",
      "canela",
      "canguro",
      "canica",
      "canto",
      "caña",
      "cañón",
      "caoba",
      "caos",
      "capaz",
      "capitán",
      "capote",
      "captar",
      "capucha",
      "cara",
      "carbón",
      "cárcel",
      "careta",
      "carga",
      "cariño",
      "carne",
      "carpeta",
      "carro",
      "carta",
      "casa",
      "casco",
      "casero",
      "caspa",
      "castor",
      "catorce",
      "catre",
      "caudal",
      "causa",
      "cazo",
      "cebolla",
      "ceder",
      "cedro",
      "celda",
      "célebre",
      "celoso",
      "célula",
      "cemento",
      "ceniza",
      "centro",
      "cerca",
      "cerdo",
      "cereza",
      "cero",
      "cerrar",
      "certeza",
      "césped",
      "cetro",
      "chacal",
      "chaleco",
      "champú",
      "chancla",
      "chapa",
      "charla",
      "chico",
      "chiste",
      "chivo",
      "choque",
      "choza",
      "chuleta",
      "chupar",
      "ciclón",
      "ciego",
      "cielo",
      "cien",
      "cierto",
      "cifra",
      "cigarro",
      "cima",
      "cinco",
      "cine",
      "cinta",
      "ciprés",
      "circo",
      "ciruela",
      "cisne",
      "cita",
      "ciudad",
      "clamor",
      "clan",
      "claro",
      "clase",
      "clave",
      "cliente",
      "clima",
      "clínica",
      "cobre",
      "cocción",
      "cochino",
      "cocina",
      "coco",
      "código",
      "codo",
      "cofre",
      "coger",
      "cohete",
      "cojín",
      "cojo",
      "cola",
      "colcha",
      "colegio",
      "colgar",
      "colina",
      "collar",
      "colmo",
      "columna",
      "combate",
      "comer",
      "comida",
      "cómodo",
      "compra",
      "conde",
      "conejo",
      "conga",
      "conocer",
      "consejo",
      "contar",
      "copa",
      "copia",
      "corazón",
      "corbata",
      "corcho",
      "cordón",
      "corona",
      "correr",
      "coser",
      "cosmos",
      "costa",
      "cráneo",
      "cráter",
      "crear",
      "crecer",
      "creído",
      "crema",
      "cría",
      "crimen",
      "cripta",
      "crisis",
      "cromo",
      "crónica",
      "croqueta",
      "crudo",
      "cruz",
      "cuadro",
      "cuarto",
      "cuatro",
      "cubo",
      "cubrir",
      "cuchara",
      "cuello",
      "cuento",
      "cuerda",
      "cuesta",
      "cueva",
      "cuidar",
      "culebra",
      "culpa",
      "culto",
      "cumbre",
      "cumplir",
      "cuna",
      "cuneta",
      "cuota",
      "cupón",
      "cúpula",
      "curar",
      "curioso",
      "curso",
      "curva",
      "cutis",
      "dama",
      "danza",
      "dar",
      "dardo",
      "dátil",
      "deber",
      "débil",
      "década",
      "decir",
      "dedo",
      "defensa",
      "definir",
      "dejar",
      "delfín",
      "delgado",
      "delito",
      "demora",
      "denso",
      "dental",
      "deporte",
      "derecho",
      "derrota",
      "desayuno",
      "deseo",
      "desfile",
      "desnudo",
      "destino",
      "desvío",
      "detalle",
      "detener",
      "deuda",
      "día",
      "diablo",
      "diadema",
      "diamante",
      "diana",
      "diario",
      "dibujo",
      "dictar",
      "diente",
      "dieta",
      "diez",
      "difícil",
      "digno",
      "dilema",
      "diluir",
      "dinero",
      "directo",
      "dirigir",
      "disco",
      "diseño",
      "disfraz",
      "diva",
      "divino",
      "doble",
      "doce",
      "dolor",
      "domingo",
      "don",
      "donar",
      "dorado",
      "dormir",
      "dorso",
      "dos",
      "dosis",
      "dragón",
      "droga",
      "ducha",
      "duda",
      "duelo",
      "dueño",
      "dulce",
      "dúo",
      "duque",
      "durar",
      "dureza",
      "duro",
      "ébano",
      "ebrio",
      "echar",
      "eco",
      "ecuador",
      "edad",
      "edición",
      "edificio",
      "editor",
      "educar",
      "efecto",
      "eficaz",
      "eje",
      "ejemplo",
      "elefante",
      "elegir",
      "elemento",
      "elevar",
      "elipse",
      "élite",
      "elixir",
      "elogio",
      "eludir",
      "embudo",
      "emitir",
      "emoción",
      "empate",
      "empeño",
      "empleo",
      "empresa",
      "enano",
      "encargo",
      "enchufe",
      "encía",
      "enemigo",
      "enero",
      "enfado",
      "enfermo",
      "engaño",
      "enigma",
      "enlace",
      "enorme",
      "enredo",
      "ensayo",
      "enseñar",
      "entero",
      "entrar",
      "envase",
      "envío",
      "época",
      "equipo",
      "erizo",
      "escala",
      "escena",
      "escolar",
      "escribir",
      "escudo",
      "esencia",
      "esfera",
      "esfuerzo",
      "espada",
      "espejo",
      "espía",
      "esposa",
      "espuma",
      "esquí",
      "estar",
      "este",
      "estilo",
      "estufa",
      "etapa",
      "eterno",
      "ética",
      "etnia",
      "evadir",
      "evaluar",
      "evento",
      "evitar",
      "exacto",
      "examen",
      "exceso",
      "excusa",
      "exento",
      "exigir",
      "exilio",
      "existir",
      "éxito",
      "experto",
      "explicar",
      "exponer",
      "extremo",
      "fábrica",
      "fábula",
      "fachada",
      "fácil",
      "factor",
      "faena",
      "faja",
      "falda",
      "fallo",
      "falso",
      "faltar",
      "fama",
      "familia",
      "famoso",
      "faraón",
      "farmacia",
      "farol",
      "farsa",
      "fase",
      "fatiga",
      "fauna",
      "favor",
      "fax",
      "febrero",
      "fecha",
      "feliz",
      "feo",
      "feria",
      "feroz",
      "fértil",
      "fervor",
      "festín",
      "fiable",
      "fianza",
      "fiar",
      "fibra",
      "ficción",
      "ficha",
      "fideo",
      "fiebre",
      "fiel",
      "fiera",
      "fiesta",
      "figura",
      "fijar",
      "fijo",
      "fila",
      "filete",
      "filial",
      "filtro",
      "fin",
      "finca",
      "fingir",
      "finito",
      "firma",
      "flaco",
      "flauta",
      "flecha",
      "flor",
      "flota",
      "fluir",
      "flujo",
      "flúor",
      "fobia",
      "foca",
      "fogata",
      "fogón",
      "folio",
      "folleto",
      "fondo",
      "forma",
      "forro",
      "fortuna",
      "forzar",
      "fosa",
      "foto",
      "fracaso",
      "frágil",
      "franja",
      "frase",
      "fraude",
      "freír",
      "freno",
      "fresa",
      "frío",
      "frito",
      "fruta",
      "fuego",
      "fuente",
      "fuerza",
      "fuga",
      "fumar",
      "función",
      "funda",
      "furgón",
      "furia",
      "fusil",
      "fútbol",
      "futuro",
      "gacela",
      "gafas",
      "gaita",
      "gajo",
      "gala",
      "galería",
      "gallo",
      "gamba",
      "ganar",
      "gancho",
      "ganga",
      "ganso",
      "garaje",
      "garza",
      "gasolina",
      "gastar",
      "gato",
      "gavilán",
      "gemelo",
      "gemir",
      "gen",
      "género",
      "genio",
      "gente",
      "geranio",
      "gerente",
      "germen",
      "gesto",
      "gigante",
      "gimnasio",
      "girar",
      "giro",
      "glaciar",
      "globo",
      "gloria",
      "gol",
      "golfo",
      "goloso",
      "golpe",
      "goma",
      "gordo",
      "gorila",
      "gorra",
      "gota",
      "goteo",
      "gozar",
      "grada",
      "gráfico",
      "grano",
      "grasa",
      "gratis",
      "grave",
      "grieta",
      "grillo",
      "gripe",
      "gris",
      "grito",
      "grosor",
      "grúa",
      "grueso",
      "grumo",
      "grupo",
      "guante",
      "guapo",
      "guardia",
      "guerra",
      "guía",
      "guiño",
      "guion",
      "guiso",
      "guitarra",
      "gusano",
      "gustar",
      "haber",
      "hábil",
      "hablar",
      "hacer",
      "hacha",
      "hada",
      "hallar",
      "hamaca",
      "harina",
      "haz",
      "hazaña",
      "hebilla",
      "hebra",
      "hecho",
      "helado",
      "helio",
      "hembra",
      "herir",
      "hermano",
      "héroe",
      "hervir",
      "hielo",
      "hierro",
      "hígado",
      "higiene",
      "hijo",
      "himno",
      "historia",
      "hocico",
      "hogar",
      "hoguera",
      "hoja",
      "hombre",
      "hongo",
      "honor",
      "honra",
      "hora",
      "hormiga",
      "horno",
      "hostil",
      "hoyo",
      "hueco",
      "huelga",
      "huerta",
      "hueso",
      "huevo",
      "huida",
      "huir",
      "humano",
      "húmedo",
      "humilde",
      "humo",
      "hundir",
      "huracán",
      "hurto",
      "icono",
      "ideal",
      "idioma",
      "ídolo",
      "iglesia",
      "iglú",
      "igual",
      "ilegal",
      "ilusión",
      "imagen",
      "imán",
      "imitar",
      "impar",
      "imperio",
      "imponer",
      "impulso",
      "incapaz",
      "índice",
      "inerte",
      "infiel",
      "informe",
      "ingenio",
      "inicio",
      "inmenso",
      "inmune",
      "innato",
      "insecto",
      "instante",
      "interés",
      "íntimo",
      "intuir",
      "inútil",
      "invierno",
      "ira",
      "iris",
      "ironía",
      "isla",
      "islote",
      "jabalí",
      "jabón",
      "jamón",
      "jarabe",
      "jardín",
      "jarra",
      "jaula",
      "jazmín",
      "jefe",
      "jeringa",
      "jinete",
      "jornada",
      "joroba",
      "joven",
      "joya",
      "juerga",
      "jueves",
      "juez",
      "jugador",
      "jugo",
      "juguete",
      "juicio",
      "junco",
      "jungla",
      "junio",
      "juntar",
      "júpiter",
      "jurar",
      "justo",
      "juvenil",
      "juzgar",
      "kilo",
      "koala",
      "labio",
      "lacio",
      "lacra",
      "lado",
      "ladrón",
      "lagarto",
      "lágrima",
      "laguna",
      "laico",
      "lamer",
      "lámina",
      "lámpara",
      "lana",
      "lancha",
      "langosta",
      "lanza",
      "lápiz",
      "largo",
      "larva",
      "lástima",
      "lata",
      "látex",
      "latir",
      "laurel",
      "lavar",
      "lazo",
      "leal",
      "lección",
      "leche",
      "lector",
      "leer",
      "legión",
      "legumbre",
      "lejano",
      "lengua",
      "lento",
      "leña",
      "león",
      "leopardo",
      "lesión",
      "letal",
      "letra",
      "leve",
      "leyenda",
      "libertad",
      "libro",
      "licor",
      "líder",
      "lidiar",
      "lienzo",
      "liga",
      "ligero",
      "lima",
      "límite",
      "limón",
      "limpio",
      "lince",
      "lindo",
      "línea",
      "lingote",
      "lino",
      "linterna",
      "líquido",
      "liso",
      "lista",
      "litera",
      "litio",
      "litro",
      "llaga",
      "llama",
      "llanto",
      "llave",
      "llegar",
      "llenar",
      "llevar",
      "llorar",
      "llover",
      "lluvia",
      "lobo",
      "loción",
      "loco",
      "locura",
      "lógica",
      "logro",
      "lombriz",
      "lomo",
      "lonja",
      "lote",
      "lucha",
      "lucir",
      "lugar",
      "lujo",
      "luna",
      "lunes",
      "lupa",
      "lustro",
      "luto",
      "luz",
      "maceta",
      "macho",
      "madera",
      "madre",
      "maduro",
      "maestro",
      "mafia",
      "magia",
      "mago",
      "maíz",
      "maldad",
      "maleta",
      "malla",
      "malo",
      "mamá",
      "mambo",
      "mamut",
      "manco",
      "mando",
      "manejar",
      "manga",
      "maniquí",
      "manjar",
      "mano",
      "manso",
      "manta",
      "mañana",
      "mapa",
      "máquina",
      "mar",
      "marco",
      "marea",
      "marfil",
      "margen",
      "marido",
      "mármol",
      "marrón",
      "martes",
      "marzo",
      "masa",
      "máscara",
      "masivo",
      "matar",
      "materia",
      "matiz",
      "matriz",
      "máximo",
      "mayor",
      "mazorca",
      "mecha",
      "medalla",
      "medio",
      "médula",
      "mejilla",
      "mejor",
      "melena",
      "melón",
      "memoria",
      "menor",
      "mensaje",
      "mente",
      "menú",
      "mercado",
      "merengue",
      "mérito",
      "mes",
      "mesón",
      "meta",
      "meter",
      "método",
      "metro",
      "mezcla",
      "miedo",
      "miel",
      "miembro",
      "miga",
      "mil",
      "milagro",
      "militar",
      "millón",
      "mimo",
      "mina",
      "minero",
      "mínimo",
      "minuto",
      "miope",
      "mirar",
      "misa",
      "miseria",
      "misil",
      "mismo",
      "mitad",
      "mito",
      "mochila",
      "moción",
      "moda",
      "modelo",
      "moho",
      "mojar",
      "molde",
      "moler",
      "molino",
      "momento",
      "momia",
      "monarca",
      "moneda",
      "monja",
      "monto",
      "moño",
      "morada",
      "morder",
      "moreno",
      "morir",
      "morro",
      "morsa",
      "mortal",
      "mosca",
      "mostrar",
      "motivo",
      "mover",
      "móvil",
      "mozo",
      "mucho",
      "mudar",
      "mueble",
      "muela",
      "muerte",
      "muestra",
      "mugre",
      "mujer",
      "mula",
      "muleta",
      "multa",
      "mundo",
      "muñeca",
      "mural",
      "muro",
      "músculo",
      "museo",
      "musgo",
      "música",
      "muslo",
      "nácar",
      "nación",
      "nadar",
      "naipe",
      "naranja",
      "nariz",
      "narrar",
      "nasal",
      "natal",
      "nativo",
      "natural",
      "náusea",
      "naval",
      "nave",
      "navidad",
      "necio",
      "néctar",
      "negar",
      "negocio",
      "negro",
      "neón",
      "nervio",
      "neto",
      "neutro",
      "nevar",
      "nevera",
      "nicho",
      "nido",
      "niebla",
      "nieto",
      "niñez",
      "niño",
      "nítido",
      "nivel",
      "nobleza",
      "noche",
      "nómina",
      "noria",
      "norma",
      "norte",
      "nota",
      "noticia",
      "novato",
      "novela",
      "novio",
      "nube",
      "nuca",
      "núcleo",
      "nudillo",
      "nudo",
      "nuera",
      "nueve",
      "nuez",
      "nulo",
      "número",
      "nutria",
      "oasis",
      "obeso",
      "obispo",
      "objeto",
      "obra",
      "obrero",
      "observar",
      "obtener",
      "obvio",
      "oca",
      "ocaso",
      "océano",
      "ochenta",
      "ocho",
      "ocio",
      "ocre",
      "octavo",
      "octubre",
      "oculto",
      "ocupar",
      "ocurrir",
      "odiar",
      "odio",
      "odisea",
      "oeste",
      "ofensa",
      "oferta",
      "oficio",
      "ofrecer",
      "ogro",
      "oído",
      "oír",
      "ojo",
      "ola",
      "oleada",
      "olfato",
      "olivo",
      "olla",
      "olmo",
      "olor",
      "olvido",
      "ombligo",
      "onda",
      "onza",
      "opaco",
      "opción",
      "ópera",
      "opinar",
      "oponer",
      "optar",
      "óptica",
      "opuesto",
      "oración",
      "orador",
      "oral",
      "órbita",
      "orca",
      "orden",
      "oreja",
      "órgano",
      "orgía",
      "orgullo",
      "oriente",
      "origen",
      "orilla",
      "oro",
      "orquesta",
      "oruga",
      "osadía",
      "oscuro",
      "osezno",
      "oso",
      "ostra",
      "otoño",
      "otro",
      "oveja",
      "óvulo",
      "óxido",
      "oxígeno",
      "oyente",
      "ozono",
      "pacto",
      "padre",
      "paella",
      "página",
      "pago",
      "país",
      "pájaro",
      "palabra",
      "palco",
      "paleta",
      "pálido",
      "palma",
      "paloma",
      "palpar",
      "pan",
      "panal",
      "pánico",
      "pantera",
      "pañuelo",
      "papá",
      "papel",
      "papilla",
      "paquete",
      "parar",
      "parcela",
      "pared",
      "parir",
      "paro",
      "párpado",
      "parque",
      "párrafo",
      "parte",
      "pasar",
      "paseo",
      "pasión",
      "paso",
      "pasta",
      "pata",
      "patio",
      "patria",
      "pausa",
      "pauta",
      "pavo",
      "payaso",
      "peatón",
      "pecado",
      "pecera",
      "pecho",
      "pedal",
      "pedir",
      "pegar",
      "peine",
      "pelar",
      "peldaño",
      "pelea",
      "peligro",
      "pellejo",
      "pelo",
      "peluca",
      "pena",
      "pensar",
      "peñón",
      "peón",
      "peor",
      "pepino",
      "pequeño",
      "pera",
      "percha",
      "perder",
      "pereza",
      "perfil",
      "perico",
      "perla",
      "permiso",
      "perro",
      "persona",
      "pesa",
      "pesca",
      "pésimo",
      "pestaña",
      "pétalo",
      "petróleo",
      "pez",
      "pezuña",
      "picar",
      "pichón",
      "pie",
      "piedra",
      "pierna",
      "pieza",
      "pijama",
      "pilar",
      "piloto",
      "pimienta",
      "pino",
      "pintor",
      "pinza",
      "piña",
      "piojo",
      "pipa",
      "pirata",
      "pisar",
      "piscina",
      "piso",
      "pista",
      "pitón",
      "pizca",
      "placa",
      "plan",
      "plata",
      "playa",
      "plaza",
      "pleito",
      "pleno",
      "plomo",
      "pluma",
      "plural",
      "pobre",
      "poco",
      "poder",
      "podio",
      "poema",
      "poesía",
      "poeta",
      "polen",
      "policía",
      "pollo",
      "polvo",
      "pomada",
      "pomelo",
      "pomo",
      "pompa",
      "poner",
      "porción",
      "portal",
      "posada",
      "poseer",
      "posible",
      "poste",
      "potencia",
      "potro",
      "pozo",
      "prado",
      "precoz",
      "pregunta",
      "premio",
      "prensa",
      "preso",
      "previo",
      "primo",
      "príncipe",
      "prisión",
      "privar",
      "proa",
      "probar",
      "proceso",
      "producto",
      "proeza",
      "profesor",
      "programa",
      "prole",
      "promesa",
      "pronto",
      "propio",
      "próximo",
      "prueba",
      "público",
      "puchero",
      "pudor",
      "pueblo",
      "puerta",
      "puesto",
      "pulga",
      "pulir",
      "pulmón",
      "pulpo",
      "pulso",
      "puma",
      "punto",
      "puñal",
      "puño",
      "pupa",
      "pupila",
      "puré",
      "quedar",
      "queja",
      "quemar",
      "querer",
      "queso",
      "quieto",
      "química",
      "quince",
      "quitar",
      "rábano",
      "rabia",
      "rabo",
      "ración",
      "radical",
      "raíz",
      "rama",
      "rampa",
      "rancho",
      "rango",
      "rapaz",
      "rápido",
      "rapto",
      "rasgo",
      "raspa",
      "rato",
      "rayo",
      "raza",
      "razón",
      "reacción",
      "realidad",
      "rebaño",
      "rebote",
      "recaer",
      "receta",
      "rechazo",
      "recoger",
      "recreo",
      "recto",
      "recurso",
      "red",
      "redondo",
      "reducir",
      "reflejo",
      "reforma",
      "refrán",
      "refugio",
      "regalo",
      "regir",
      "regla",
      "regreso",
      "rehén",
      "reino",
      "reír",
      "reja",
      "relato",
      "relevo",
      "relieve",
      "relleno",
      "reloj",
      "remar",
      "remedio",
      "remo",
      "rencor",
      "rendir",
      "renta",
      "reparto",
      "repetir",
      "reposo",
      "reptil",
      "res",
      "rescate",
      "resina",
      "respeto",
      "resto",
      "resumen",
      "retiro",
      "retorno",
      "retrato",
      "reunir",
      "revés",
      "revista",
      "rey",
      "rezar",
      "rico",
      "riego",
      "rienda",
      "riesgo",
      "rifa",
      "rígido",
      "rigor",
      "rincón",
      "riñón",
      "río",
      "riqueza",
      "risa",
      "ritmo",
      "rito",
      "rizo",
      "roble",
      "roce",
      "rociar",
      "rodar",
      "rodeo",
      "rodilla",
      "roer",
      "rojizo",
      "rojo",
      "romero",
      "romper",
      "ron",
      "ronco",
      "ronda",
      "ropa",
      "ropero",
      "rosa",
      "rosca",
      "rostro",
      "rotar",
      "rubí",
      "rubor",
      "rudo",
      "rueda",
      "rugir",
      "ruido",
      "ruina",
      "ruleta",
      "rulo",
      "rumbo",
      "rumor",
      "ruptura",
      "ruta",
      "rutina",
      "sábado",
      "saber",
      "sabio",
      "sable",
      "sacar",
      "sagaz",
      "sagrado",
      "sala",
      "saldo",
      "salero",
      "salir",
      "salmón",
      "salón",
      "salsa",
      "salto",
      "salud",
      "salvar",
      "samba",
      "sanción",
      "sandía",
      "sanear",
      "sangre",
      "sanidad",
      "sano",
      "santo",
      "sapo",
      "saque",
      "sardina",
      "sartén",
      "sastre",
      "satán",
      "sauna",
      "saxofón",
      "sección",
      "seco",
      "secreto",
      "secta",
      "sed",
      "seguir",
      "seis",
      "sello",
      "selva",
      "semana",
      "semilla",
      "senda",
      "sensor",
      "señal",
      "señor",
      "separar",
      "sepia",
      "sequía",
      "ser",
      "serie",
      "sermón",
      "servir",
      "sesenta",
      "sesión",
      "seta",
      "setenta",
      "severo",
      "sexo",
      "sexto",
      "sidra",
      "siesta",
      "siete",
      "siglo",
      "signo",
      "sílaba",
      "silbar",
      "silencio",
      "silla",
      "símbolo",
      "simio",
      "sirena",
      "sistema",
      "sitio",
      "situar",
      "sobre",
      "socio",
      "sodio",
      "sol",
      "solapa",
      "soldado",
      "soledad",
      "sólido",
      "soltar",
      "solución",
      "sombra",
      "sondeo",
      "sonido",
      "sonoro",
      "sonrisa",
      "sopa",
      "soplar",
      "soporte",
      "sordo",
      "sorpresa",
      "sorteo",
      "sostén",
      "sótano",
      "suave",
      "subir",
      "suceso",
      "sudor",
      "suegra",
      "suelo",
      "sueño",
      "suerte",
      "sufrir",
      "sujeto",
      "sultán",
      "sumar",
      "superar",
      "suplir",
      "suponer",
      "supremo",
      "sur",
      "surco",
      "sureño",
      "surgir",
      "susto",
      "sutil",
      "tabaco",
      "tabique",
      "tabla",
      "tabú",
      "taco",
      "tacto",
      "tajo",
      "talar",
      "talco",
      "talento",
      "talla",
      "talón",
      "tamaño",
      "tambor",
      "tango",
      "tanque",
      "tapa",
      "tapete",
      "tapia",
      "tapón",
      "taquilla",
      "tarde",
      "tarea",
      "tarifa",
      "tarjeta",
      "tarot",
      "tarro",
      "tarta",
      "tatuaje",
      "tauro",
      "taza",
      "tazón",
      "teatro",
      "techo",
      "tecla",
      "técnica",
      "tejado",
      "tejer",
      "tejido",
      "tela",
      "teléfono",
      "tema",
      "temor",
      "templo",
      "tenaz",
      "tender",
      "tener",
      "tenis",
      "tenso",
      "teoría",
      "terapia",
      "terco",
      "término",
      "ternura",
      "terror",
      "tesis",
      "tesoro",
      "testigo",
      "tetera",
      "texto",
      "tez",
      "tibio",
      "tiburón",
      "tiempo",
      "tienda",
      "tierra",
      "tieso",
      "tigre",
      "tijera",
      "tilde",
      "timbre",
      "tímido",
      "timo",
      "tinta",
      "tío",
      "típico",
      "tipo",
      "tira",
      "tirón",
      "titán",
      "títere",
      "título",
      "tiza",
      "toalla",
      "tobillo",
      "tocar",
      "tocino",
      "todo",
      "toga",
      "toldo",
      "tomar",
      "tono",
      "tonto",
      "topar",
      "tope",
      "toque",
      "tórax",
      "torero",
      "tormenta",
      "torneo",
      "toro",
      "torpedo",
      "torre",
      "torso",
      "tortuga",
      "tos",
      "tosco",
      "toser",
      "tóxico",
      "trabajo",
      "tractor",
      "traer",
      "tráfico",
      "trago",
      "traje",
      "tramo",
      "trance",
      "trato",
      "trauma",
      "trazar",
      "trébol",
      "tregua",
      "treinta",
      "tren",
      "trepar",
      "tres",
      "tribu",
      "trigo",
      "tripa",
      "triste",
      "triunfo",
      "trofeo",
      "trompa",
      "tronco",
      "tropa",
      "trote",
      "trozo",
      "truco",
      "trueno",
      "trufa",
      "tubería",
      "tubo",
      "tuerto",
      "tumba",
      "tumor",
      "túnel",
      "túnica",
      "turbina",
      "turismo",
      "turno",
      "tutor",
      "ubicar",
      "úlcera",
      "umbral",
      "unidad",
      "unir",
      "universo",
      "uno",
      "untar",
      "uña",
      "urbano",
      "urbe",
      "urgente",
      "urna",
      "usar",
      "usuario",
      "útil",
      "utopía",
      "uva",
      "vaca",
      "vacío",
      "vacuna",
      "vagar",
      "vago",
      "vaina",
      "vajilla",
      "vale",
      "válido",
      "valle",
      "valor",
      "válvula",
      "vampiro",
      "vara",
      "variar",
      "varón",
      "vaso",
      "vecino",
      "vector",
      "vehículo",
      "veinte",
      "vejez",
      "vela",
      "velero",
      "veloz",
      "vena",
      "vencer",
      "venda",
      "veneno",
      "vengar",
      "venir",
      "venta",
      "venus",
      "ver",
      "verano",
      "verbo",
      "verde",
      "vereda",
      "verja",
      "verso",
      "verter",
      "vía",
      "viaje",
      "vibrar",
      "vicio",
      "víctima",
      "vida",
      "vídeo",
      "vidrio",
      "viejo",
      "viernes",
      "vigor",
      "vil",
      "villa",
      "vinagre",
      "vino",
      "viñedo",
      "violín",
      "viral",
      "virgo",
      "virtud",
      "visor",
      "víspera",
      "vista",
      "vitamina",
      "viudo",
      "vivaz",
      "vivero",
      "vivir",
      "vivo",
      "volcán",
      "volumen",
      "volver",
      "voraz",
      "votar",
      "voto",
      "voz",
      "vuelo",
      "vulgar",
      "yacer",
      "yate",
      "yegua",
      "yema",
      "yerno",
      "yeso",
      "yodo",
      "yoga",
      "yogur",
      "zafiro",
      "zanja",
      "zapato",
      "zarza",
      "zona",
      "zorro",
      "zumo",
      "zurdo"
    ];
  }
});

// node_modules/bip39/src/wordlists/japanese.json
var require_japanese = __commonJS({
  "node_modules/bip39/src/wordlists/japanese.json"(exports2, module2) {
    module2.exports = [
      "あいこくしん",
      "あいさつ",
      "あいだ",
      "あおぞら",
      "あかちゃん",
      "あきる",
      "あけがた",
      "あける",
      "あこがれる",
      "あさい",
      "あさひ",
      "あしあと",
      "あじわう",
      "あずかる",
      "あずき",
      "あそぶ",
      "あたえる",
      "あたためる",
      "あたりまえ",
      "あたる",
      "あつい",
      "あつかう",
      "あっしゅく",
      "あつまり",
      "あつめる",
      "あてな",
      "あてはまる",
      "あひる",
      "あぶら",
      "あぶる",
      "あふれる",
      "あまい",
      "あまど",
      "あまやかす",
      "あまり",
      "あみもの",
      "あめりか",
      "あやまる",
      "あゆむ",
      "あらいぐま",
      "あらし",
      "あらすじ",
      "あらためる",
      "あらゆる",
      "あらわす",
      "ありがとう",
      "あわせる",
      "あわてる",
      "あんい",
      "あんがい",
      "あんこ",
      "あんぜん",
      "あんてい",
      "あんない",
      "あんまり",
      "いいだす",
      "いおん",
      "いがい",
      "いがく",
      "いきおい",
      "いきなり",
      "いきもの",
      "いきる",
      "いくじ",
      "いくぶん",
      "いけばな",
      "いけん",
      "いこう",
      "いこく",
      "いこつ",
      "いさましい",
      "いさん",
      "いしき",
      "いじゅう",
      "いじょう",
      "いじわる",
      "いずみ",
      "いずれ",
      "いせい",
      "いせえび",
      "いせかい",
      "いせき",
      "いぜん",
      "いそうろう",
      "いそがしい",
      "いだい",
      "いだく",
      "いたずら",
      "いたみ",
      "いたりあ",
      "いちおう",
      "いちじ",
      "いちど",
      "いちば",
      "いちぶ",
      "いちりゅう",
      "いつか",
      "いっしゅん",
      "いっせい",
      "いっそう",
      "いったん",
      "いっち",
      "いってい",
      "いっぽう",
      "いてざ",
      "いてん",
      "いどう",
      "いとこ",
      "いない",
      "いなか",
      "いねむり",
      "いのち",
      "いのる",
      "いはつ",
      "いばる",
      "いはん",
      "いびき",
      "いひん",
      "いふく",
      "いへん",
      "いほう",
      "いみん",
      "いもうと",
      "いもたれ",
      "いもり",
      "いやがる",
      "いやす",
      "いよかん",
      "いよく",
      "いらい",
      "いらすと",
      "いりぐち",
      "いりょう",
      "いれい",
      "いれもの",
      "いれる",
      "いろえんぴつ",
      "いわい",
      "いわう",
      "いわかん",
      "いわば",
      "いわゆる",
      "いんげんまめ",
      "いんさつ",
      "いんしょう",
      "いんよう",
      "うえき",
      "うえる",
      "うおざ",
      "うがい",
      "うかぶ",
      "うかべる",
      "うきわ",
      "うくらいな",
      "うくれれ",
      "うけたまわる",
      "うけつけ",
      "うけとる",
      "うけもつ",
      "うける",
      "うごかす",
      "うごく",
      "うこん",
      "うさぎ",
      "うしなう",
      "うしろがみ",
      "うすい",
      "うすぎ",
      "うすぐらい",
      "うすめる",
      "うせつ",
      "うちあわせ",
      "うちがわ",
      "うちき",
      "うちゅう",
      "うっかり",
      "うつくしい",
      "うったえる",
      "うつる",
      "うどん",
      "うなぎ",
      "うなじ",
      "うなずく",
      "うなる",
      "うねる",
      "うのう",
      "うぶげ",
      "うぶごえ",
      "うまれる",
      "うめる",
      "うもう",
      "うやまう",
      "うよく",
      "うらがえす",
      "うらぐち",
      "うらない",
      "うりあげ",
      "うりきれ",
      "うるさい",
      "うれしい",
      "うれゆき",
      "うれる",
      "うろこ",
      "うわき",
      "うわさ",
      "うんこう",
      "うんちん",
      "うんてん",
      "うんどう",
      "えいえん",
      "えいが",
      "えいきょう",
      "えいご",
      "えいせい",
      "えいぶん",
      "えいよう",
      "えいわ",
      "えおり",
      "えがお",
      "えがく",
      "えきたい",
      "えくせる",
      "えしゃく",
      "えすて",
      "えつらん",
      "えのぐ",
      "えほうまき",
      "えほん",
      "えまき",
      "えもじ",
      "えもの",
      "えらい",
      "えらぶ",
      "えりあ",
      "えんえん",
      "えんかい",
      "えんぎ",
      "えんげき",
      "えんしゅう",
      "えんぜつ",
      "えんそく",
      "えんちょう",
      "えんとつ",
      "おいかける",
      "おいこす",
      "おいしい",
      "おいつく",
      "おうえん",
      "おうさま",
      "おうじ",
      "おうせつ",
      "おうたい",
      "おうふく",
      "おうべい",
      "おうよう",
      "おえる",
      "おおい",
      "おおう",
      "おおどおり",
      "おおや",
      "おおよそ",
      "おかえり",
      "おかず",
      "おがむ",
      "おかわり",
      "おぎなう",
      "おきる",
      "おくさま",
      "おくじょう",
      "おくりがな",
      "おくる",
      "おくれる",
      "おこす",
      "おこなう",
      "おこる",
      "おさえる",
      "おさない",
      "おさめる",
      "おしいれ",
      "おしえる",
      "おじぎ",
      "おじさん",
      "おしゃれ",
      "おそらく",
      "おそわる",
      "おたがい",
      "おたく",
      "おだやか",
      "おちつく",
      "おっと",
      "おつり",
      "おでかけ",
      "おとしもの",
      "おとなしい",
      "おどり",
      "おどろかす",
      "おばさん",
      "おまいり",
      "おめでとう",
      "おもいで",
      "おもう",
      "おもたい",
      "おもちゃ",
      "おやつ",
      "おやゆび",
      "およぼす",
      "おらんだ",
      "おろす",
      "おんがく",
      "おんけい",
      "おんしゃ",
      "おんせん",
      "おんだん",
      "おんちゅう",
      "おんどけい",
      "かあつ",
      "かいが",
      "がいき",
      "がいけん",
      "がいこう",
      "かいさつ",
      "かいしゃ",
      "かいすいよく",
      "かいぜん",
      "かいぞうど",
      "かいつう",
      "かいてん",
      "かいとう",
      "かいふく",
      "がいへき",
      "かいほう",
      "かいよう",
      "がいらい",
      "かいわ",
      "かえる",
      "かおり",
      "かかえる",
      "かがく",
      "かがし",
      "かがみ",
      "かくご",
      "かくとく",
      "かざる",
      "がぞう",
      "かたい",
      "かたち",
      "がちょう",
      "がっきゅう",
      "がっこう",
      "がっさん",
      "がっしょう",
      "かなざわし",
      "かのう",
      "がはく",
      "かぶか",
      "かほう",
      "かほご",
      "かまう",
      "かまぼこ",
      "かめれおん",
      "かゆい",
      "かようび",
      "からい",
      "かるい",
      "かろう",
      "かわく",
      "かわら",
      "がんか",
      "かんけい",
      "かんこう",
      "かんしゃ",
      "かんそう",
      "かんたん",
      "かんち",
      "がんばる",
      "きあい",
      "きあつ",
      "きいろ",
      "ぎいん",
      "きうい",
      "きうん",
      "きえる",
      "きおう",
      "きおく",
      "きおち",
      "きおん",
      "きかい",
      "きかく",
      "きかんしゃ",
      "ききて",
      "きくばり",
      "きくらげ",
      "きけんせい",
      "きこう",
      "きこえる",
      "きこく",
      "きさい",
      "きさく",
      "きさま",
      "きさらぎ",
      "ぎじかがく",
      "ぎしき",
      "ぎじたいけん",
      "ぎじにってい",
      "ぎじゅつしゃ",
      "きすう",
      "きせい",
      "きせき",
      "きせつ",
      "きそう",
      "きぞく",
      "きぞん",
      "きたえる",
      "きちょう",
      "きつえん",
      "ぎっちり",
      "きつつき",
      "きつね",
      "きてい",
      "きどう",
      "きどく",
      "きない",
      "きなが",
      "きなこ",
      "きぬごし",
      "きねん",
      "きのう",
      "きのした",
      "きはく",
      "きびしい",
      "きひん",
      "きふく",
      "きぶん",
      "きぼう",
      "きほん",
      "きまる",
      "きみつ",
      "きむずかしい",
      "きめる",
      "きもだめし",
      "きもち",
      "きもの",
      "きゃく",
      "きやく",
      "ぎゅうにく",
      "きよう",
      "きょうりゅう",
      "きらい",
      "きらく",
      "きりん",
      "きれい",
      "きれつ",
      "きろく",
      "ぎろん",
      "きわめる",
      "ぎんいろ",
      "きんかくじ",
      "きんじょ",
      "きんようび",
      "ぐあい",
      "くいず",
      "くうかん",
      "くうき",
      "くうぐん",
      "くうこう",
      "ぐうせい",
      "くうそう",
      "ぐうたら",
      "くうふく",
      "くうぼ",
      "くかん",
      "くきょう",
      "くげん",
      "ぐこう",
      "くさい",
      "くさき",
      "くさばな",
      "くさる",
      "くしゃみ",
      "くしょう",
      "くすのき",
      "くすりゆび",
      "くせげ",
      "くせん",
      "ぐたいてき",
      "くださる",
      "くたびれる",
      "くちこみ",
      "くちさき",
      "くつした",
      "ぐっすり",
      "くつろぐ",
      "くとうてん",
      "くどく",
      "くなん",
      "くねくね",
      "くのう",
      "くふう",
      "くみあわせ",
      "くみたてる",
      "くめる",
      "くやくしょ",
      "くらす",
      "くらべる",
      "くるま",
      "くれる",
      "くろう",
      "くわしい",
      "ぐんかん",
      "ぐんしょく",
      "ぐんたい",
      "ぐんて",
      "けあな",
      "けいかく",
      "けいけん",
      "けいこ",
      "けいさつ",
      "げいじゅつ",
      "けいたい",
      "げいのうじん",
      "けいれき",
      "けいろ",
      "けおとす",
      "けおりもの",
      "げきか",
      "げきげん",
      "げきだん",
      "げきちん",
      "げきとつ",
      "げきは",
      "げきやく",
      "げこう",
      "げこくじょう",
      "げざい",
      "けさき",
      "げざん",
      "けしき",
      "けしごむ",
      "けしょう",
      "げすと",
      "けたば",
      "けちゃっぷ",
      "けちらす",
      "けつあつ",
      "けつい",
      "けつえき",
      "けっこん",
      "けつじょ",
      "けっせき",
      "けってい",
      "けつまつ",
      "げつようび",
      "げつれい",
      "けつろん",
      "げどく",
      "けとばす",
      "けとる",
      "けなげ",
      "けなす",
      "けなみ",
      "けぬき",
      "げねつ",
      "けねん",
      "けはい",
      "げひん",
      "けぶかい",
      "げぼく",
      "けまり",
      "けみかる",
      "けむし",
      "けむり",
      "けもの",
      "けらい",
      "けろけろ",
      "けわしい",
      "けんい",
      "けんえつ",
      "けんお",
      "けんか",
      "げんき",
      "けんげん",
      "けんこう",
      "けんさく",
      "けんしゅう",
      "けんすう",
      "げんそう",
      "けんちく",
      "けんてい",
      "けんとう",
      "けんない",
      "けんにん",
      "げんぶつ",
      "けんま",
      "けんみん",
      "けんめい",
      "けんらん",
      "けんり",
      "こあくま",
      "こいぬ",
      "こいびと",
      "ごうい",
      "こうえん",
      "こうおん",
      "こうかん",
      "ごうきゅう",
      "ごうけい",
      "こうこう",
      "こうさい",
      "こうじ",
      "こうすい",
      "ごうせい",
      "こうそく",
      "こうたい",
      "こうちゃ",
      "こうつう",
      "こうてい",
      "こうどう",
      "こうない",
      "こうはい",
      "ごうほう",
      "ごうまん",
      "こうもく",
      "こうりつ",
      "こえる",
      "こおり",
      "ごかい",
      "ごがつ",
      "ごかん",
      "こくご",
      "こくさい",
      "こくとう",
      "こくない",
      "こくはく",
      "こぐま",
      "こけい",
      "こける",
      "ここのか",
      "こころ",
      "こさめ",
      "こしつ",
      "こすう",
      "こせい",
      "こせき",
      "こぜん",
      "こそだて",
      "こたい",
      "こたえる",
      "こたつ",
      "こちょう",
      "こっか",
      "こつこつ",
      "こつばん",
      "こつぶ",
      "こてい",
      "こてん",
      "ことがら",
      "ことし",
      "ことば",
      "ことり",
      "こなごな",
      "こねこね",
      "このまま",
      "このみ",
      "このよ",
      "ごはん",
      "こひつじ",
      "こふう",
      "こふん",
      "こぼれる",
      "ごまあぶら",
      "こまかい",
      "ごますり",
      "こまつな",
      "こまる",
      "こむぎこ",
      "こもじ",
      "こもち",
      "こもの",
      "こもん",
      "こやく",
      "こやま",
      "こゆう",
      "こゆび",
      "こよい",
      "こよう",
      "こりる",
      "これくしょん",
      "ころっけ",
      "こわもて",
      "こわれる",
      "こんいん",
      "こんかい",
      "こんき",
      "こんしゅう",
      "こんすい",
      "こんだて",
      "こんとん",
      "こんなん",
      "こんびに",
      "こんぽん",
      "こんまけ",
      "こんや",
      "こんれい",
      "こんわく",
      "ざいえき",
      "さいかい",
      "さいきん",
      "ざいげん",
      "ざいこ",
      "さいしょ",
      "さいせい",
      "ざいたく",
      "ざいちゅう",
      "さいてき",
      "ざいりょう",
      "さうな",
      "さかいし",
      "さがす",
      "さかな",
      "さかみち",
      "さがる",
      "さぎょう",
      "さくし",
      "さくひん",
      "さくら",
      "さこく",
      "さこつ",
      "さずかる",
      "ざせき",
      "さたん",
      "さつえい",
      "ざつおん",
      "ざっか",
      "ざつがく",
      "さっきょく",
      "ざっし",
      "さつじん",
      "ざっそう",
      "さつたば",
      "さつまいも",
      "さてい",
      "さといも",
      "さとう",
      "さとおや",
      "さとし",
      "さとる",
      "さのう",
      "さばく",
      "さびしい",
      "さべつ",
      "さほう",
      "さほど",
      "さます",
      "さみしい",
      "さみだれ",
      "さむけ",
      "さめる",
      "さやえんどう",
      "さゆう",
      "さよう",
      "さよく",
      "さらだ",
      "ざるそば",
      "さわやか",
      "さわる",
      "さんいん",
      "さんか",
      "さんきゃく",
      "さんこう",
      "さんさい",
      "ざんしょ",
      "さんすう",
      "さんせい",
      "さんそ",
      "さんち",
      "さんま",
      "さんみ",
      "さんらん",
      "しあい",
      "しあげ",
      "しあさって",
      "しあわせ",
      "しいく",
      "しいん",
      "しうち",
      "しえい",
      "しおけ",
      "しかい",
      "しかく",
      "じかん",
      "しごと",
      "しすう",
      "じだい",
      "したうけ",
      "したぎ",
      "したて",
      "したみ",
      "しちょう",
      "しちりん",
      "しっかり",
      "しつじ",
      "しつもん",
      "してい",
      "してき",
      "してつ",
      "じてん",
      "じどう",
      "しなぎれ",
      "しなもの",
      "しなん",
      "しねま",
      "しねん",
      "しのぐ",
      "しのぶ",
      "しはい",
      "しばかり",
      "しはつ",
      "しはらい",
      "しはん",
      "しひょう",
      "しふく",
      "じぶん",
      "しへい",
      "しほう",
      "しほん",
      "しまう",
      "しまる",
      "しみん",
      "しむける",
      "じむしょ",
      "しめい",
      "しめる",
      "しもん",
      "しゃいん",
      "しゃうん",
      "しゃおん",
      "じゃがいも",
      "しやくしょ",
      "しゃくほう",
      "しゃけん",
      "しゃこ",
      "しゃざい",
      "しゃしん",
      "しゃせん",
      "しゃそう",
      "しゃたい",
      "しゃちょう",
      "しゃっきん",
      "じゃま",
      "しゃりん",
      "しゃれい",
      "じゆう",
      "じゅうしょ",
      "しゅくはく",
      "じゅしん",
      "しゅっせき",
      "しゅみ",
      "しゅらば",
      "じゅんばん",
      "しょうかい",
      "しょくたく",
      "しょっけん",
      "しょどう",
      "しょもつ",
      "しらせる",
      "しらべる",
      "しんか",
      "しんこう",
      "じんじゃ",
      "しんせいじ",
      "しんちく",
      "しんりん",
      "すあげ",
      "すあし",
      "すあな",
      "ずあん",
      "すいえい",
      "すいか",
      "すいとう",
      "ずいぶん",
      "すいようび",
      "すうがく",
      "すうじつ",
      "すうせん",
      "すおどり",
      "すきま",
      "すくう",
      "すくない",
      "すける",
      "すごい",
      "すこし",
      "ずさん",
      "すずしい",
      "すすむ",
      "すすめる",
      "すっかり",
      "ずっしり",
      "ずっと",
      "すてき",
      "すてる",
      "すねる",
      "すのこ",
      "すはだ",
      "すばらしい",
      "ずひょう",
      "ずぶぬれ",
      "すぶり",
      "すふれ",
      "すべて",
      "すべる",
      "ずほう",
      "すぼん",
      "すまい",
      "すめし",
      "すもう",
      "すやき",
      "すらすら",
      "するめ",
      "すれちがう",
      "すろっと",
      "すわる",
      "すんぜん",
      "すんぽう",
      "せあぶら",
      "せいかつ",
      "せいげん",
      "せいじ",
      "せいよう",
      "せおう",
      "せかいかん",
      "せきにん",
      "せきむ",
      "せきゆ",
      "せきらんうん",
      "せけん",
      "せこう",
      "せすじ",
      "せたい",
      "せたけ",
      "せっかく",
      "せっきゃく",
      "ぜっく",
      "せっけん",
      "せっこつ",
      "せっさたくま",
      "せつぞく",
      "せつだん",
      "せつでん",
      "せっぱん",
      "せつび",
      "せつぶん",
      "せつめい",
      "せつりつ",
      "せなか",
      "せのび",
      "せはば",
      "せびろ",
      "せぼね",
      "せまい",
      "せまる",
      "せめる",
      "せもたれ",
      "せりふ",
      "ぜんあく",
      "せんい",
      "せんえい",
      "せんか",
      "せんきょ",
      "せんく",
      "せんげん",
      "ぜんご",
      "せんさい",
      "せんしゅ",
      "せんすい",
      "せんせい",
      "せんぞ",
      "せんたく",
      "せんちょう",
      "せんてい",
      "せんとう",
      "せんぬき",
      "せんねん",
      "せんぱい",
      "ぜんぶ",
      "ぜんぽう",
      "せんむ",
      "せんめんじょ",
      "せんもん",
      "せんやく",
      "せんゆう",
      "せんよう",
      "ぜんら",
      "ぜんりゃく",
      "せんれい",
      "せんろ",
      "そあく",
      "そいとげる",
      "そいね",
      "そうがんきょう",
      "そうき",
      "そうご",
      "そうしん",
      "そうだん",
      "そうなん",
      "そうび",
      "そうめん",
      "そうり",
      "そえもの",
      "そえん",
      "そがい",
      "そげき",
      "そこう",
      "そこそこ",
      "そざい",
      "そしな",
      "そせい",
      "そせん",
      "そそぐ",
      "そだてる",
      "そつう",
      "そつえん",
      "そっかん",
      "そつぎょう",
      "そっけつ",
      "そっこう",
      "そっせん",
      "そっと",
      "そとがわ",
      "そとづら",
      "そなえる",
      "そなた",
      "そふぼ",
      "そぼく",
      "そぼろ",
      "そまつ",
      "そまる",
      "そむく",
      "そむりえ",
      "そめる",
      "そもそも",
      "そよかぜ",
      "そらまめ",
      "そろう",
      "そんかい",
      "そんけい",
      "そんざい",
      "そんしつ",
      "そんぞく",
      "そんちょう",
      "ぞんび",
      "ぞんぶん",
      "そんみん",
      "たあい",
      "たいいん",
      "たいうん",
      "たいえき",
      "たいおう",
      "だいがく",
      "たいき",
      "たいぐう",
      "たいけん",
      "たいこ",
      "たいざい",
      "だいじょうぶ",
      "だいすき",
      "たいせつ",
      "たいそう",
      "だいたい",
      "たいちょう",
      "たいてい",
      "だいどころ",
      "たいない",
      "たいねつ",
      "たいのう",
      "たいはん",
      "だいひょう",
      "たいふう",
      "たいへん",
      "たいほ",
      "たいまつばな",
      "たいみんぐ",
      "たいむ",
      "たいめん",
      "たいやき",
      "たいよう",
      "たいら",
      "たいりょく",
      "たいる",
      "たいわん",
      "たうえ",
      "たえる",
      "たおす",
      "たおる",
      "たおれる",
      "たかい",
      "たかね",
      "たきび",
      "たくさん",
      "たこく",
      "たこやき",
      "たさい",
      "たしざん",
      "だじゃれ",
      "たすける",
      "たずさわる",
      "たそがれ",
      "たたかう",
      "たたく",
      "ただしい",
      "たたみ",
      "たちばな",
      "だっかい",
      "だっきゃく",
      "だっこ",
      "だっしゅつ",
      "だったい",
      "たてる",
      "たとえる",
      "たなばた",
      "たにん",
      "たぬき",
      "たのしみ",
      "たはつ",
      "たぶん",
      "たべる",
      "たぼう",
      "たまご",
      "たまる",
      "だむる",
      "ためいき",
      "ためす",
      "ためる",
      "たもつ",
      "たやすい",
      "たよる",
      "たらす",
      "たりきほんがん",
      "たりょう",
      "たりる",
      "たると",
      "たれる",
      "たれんと",
      "たろっと",
      "たわむれる",
      "だんあつ",
      "たんい",
      "たんおん",
      "たんか",
      "たんき",
      "たんけん",
      "たんご",
      "たんさん",
      "たんじょうび",
      "だんせい",
      "たんそく",
      "たんたい",
      "だんち",
      "たんてい",
      "たんとう",
      "だんな",
      "たんにん",
      "だんねつ",
      "たんのう",
      "たんぴん",
      "だんぼう",
      "たんまつ",
      "たんめい",
      "だんれつ",
      "だんろ",
      "だんわ",
      "ちあい",
      "ちあん",
      "ちいき",
      "ちいさい",
      "ちえん",
      "ちかい",
      "ちから",
      "ちきゅう",
      "ちきん",
      "ちけいず",
      "ちけん",
      "ちこく",
      "ちさい",
      "ちしき",
      "ちしりょう",
      "ちせい",
      "ちそう",
      "ちたい",
      "ちたん",
      "ちちおや",
      "ちつじょ",
      "ちてき",
      "ちてん",
      "ちぬき",
      "ちぬり",
      "ちのう",
      "ちひょう",
      "ちへいせん",
      "ちほう",
      "ちまた",
      "ちみつ",
      "ちみどろ",
      "ちめいど",
      "ちゃんこなべ",
      "ちゅうい",
      "ちゆりょく",
      "ちょうし",
      "ちょさくけん",
      "ちらし",
      "ちらみ",
      "ちりがみ",
      "ちりょう",
      "ちるど",
      "ちわわ",
      "ちんたい",
      "ちんもく",
      "ついか",
      "ついたち",
      "つうか",
      "つうじょう",
      "つうはん",
      "つうわ",
      "つかう",
      "つかれる",
      "つくね",
      "つくる",
      "つけね",
      "つける",
      "つごう",
      "つたえる",
      "つづく",
      "つつじ",
      "つつむ",
      "つとめる",
      "つながる",
      "つなみ",
      "つねづね",
      "つのる",
      "つぶす",
      "つまらない",
      "つまる",
      "つみき",
      "つめたい",
      "つもり",
      "つもる",
      "つよい",
      "つるぼ",
      "つるみく",
      "つわもの",
      "つわり",
      "てあし",
      "てあて",
      "てあみ",
      "ていおん",
      "ていか",
      "ていき",
      "ていけい",
      "ていこく",
      "ていさつ",
      "ていし",
      "ていせい",
      "ていたい",
      "ていど",
      "ていねい",
      "ていひょう",
      "ていへん",
      "ていぼう",
      "てうち",
      "ておくれ",
      "てきとう",
      "てくび",
      "でこぼこ",
      "てさぎょう",
      "てさげ",
      "てすり",
      "てそう",
      "てちがい",
      "てちょう",
      "てつがく",
      "てつづき",
      "でっぱ",
      "てつぼう",
      "てつや",
      "でぬかえ",
      "てぬき",
      "てぬぐい",
      "てのひら",
      "てはい",
      "てぶくろ",
      "てふだ",
      "てほどき",
      "てほん",
      "てまえ",
      "てまきずし",
      "てみじか",
      "てみやげ",
      "てらす",
      "てれび",
      "てわけ",
      "てわたし",
      "でんあつ",
      "てんいん",
      "てんかい",
      "てんき",
      "てんぐ",
      "てんけん",
      "てんごく",
      "てんさい",
      "てんし",
      "てんすう",
      "でんち",
      "てんてき",
      "てんとう",
      "てんない",
      "てんぷら",
      "てんぼうだい",
      "てんめつ",
      "てんらんかい",
      "でんりょく",
      "でんわ",
      "どあい",
      "といれ",
      "どうかん",
      "とうきゅう",
      "どうぐ",
      "とうし",
      "とうむぎ",
      "とおい",
      "とおか",
      "とおく",
      "とおす",
      "とおる",
      "とかい",
      "とかす",
      "ときおり",
      "ときどき",
      "とくい",
      "とくしゅう",
      "とくてん",
      "とくに",
      "とくべつ",
      "とけい",
      "とける",
      "とこや",
      "とさか",
      "としょかん",
      "とそう",
      "とたん",
      "とちゅう",
      "とっきゅう",
      "とっくん",
      "とつぜん",
      "とつにゅう",
      "とどける",
      "ととのえる",
      "とない",
      "となえる",
      "となり",
      "とのさま",
      "とばす",
      "どぶがわ",
      "とほう",
      "とまる",
      "とめる",
      "ともだち",
      "ともる",
      "どようび",
      "とらえる",
      "とんかつ",
      "どんぶり",
      "ないかく",
      "ないこう",
      "ないしょ",
      "ないす",
      "ないせん",
      "ないそう",
      "なおす",
      "ながい",
      "なくす",
      "なげる",
      "なこうど",
      "なさけ",
      "なたでここ",
      "なっとう",
      "なつやすみ",
      "ななおし",
      "なにごと",
      "なにもの",
      "なにわ",
      "なのか",
      "なふだ",
      "なまいき",
      "なまえ",
      "なまみ",
      "なみだ",
      "なめらか",
      "なめる",
      "なやむ",
      "ならう",
      "ならび",
      "ならぶ",
      "なれる",
      "なわとび",
      "なわばり",
      "にあう",
      "にいがた",
      "にうけ",
      "におい",
      "にかい",
      "にがて",
      "にきび",
      "にくしみ",
      "にくまん",
      "にげる",
      "にさんかたんそ",
      "にしき",
      "にせもの",
      "にちじょう",
      "にちようび",
      "にっか",
      "にっき",
      "にっけい",
      "にっこう",
      "にっさん",
      "にっしょく",
      "にっすう",
      "にっせき",
      "にってい",
      "になう",
      "にほん",
      "にまめ",
      "にもつ",
      "にやり",
      "にゅういん",
      "にりんしゃ",
      "にわとり",
      "にんい",
      "にんか",
      "にんき",
      "にんげん",
      "にんしき",
      "にんずう",
      "にんそう",
      "にんたい",
      "にんち",
      "にんてい",
      "にんにく",
      "にんぷ",
      "にんまり",
      "にんむ",
      "にんめい",
      "にんよう",
      "ぬいくぎ",
      "ぬかす",
      "ぬぐいとる",
      "ぬぐう",
      "ぬくもり",
      "ぬすむ",
      "ぬまえび",
      "ぬめり",
      "ぬらす",
      "ぬんちゃく",
      "ねあげ",
      "ねいき",
      "ねいる",
      "ねいろ",
      "ねぐせ",
      "ねくたい",
      "ねくら",
      "ねこぜ",
      "ねこむ",
      "ねさげ",
      "ねすごす",
      "ねそべる",
      "ねだん",
      "ねつい",
      "ねっしん",
      "ねつぞう",
      "ねったいぎょ",
      "ねぶそく",
      "ねふだ",
      "ねぼう",
      "ねほりはほり",
      "ねまき",
      "ねまわし",
      "ねみみ",
      "ねむい",
      "ねむたい",
      "ねもと",
      "ねらう",
      "ねわざ",
      "ねんいり",
      "ねんおし",
      "ねんかん",
      "ねんきん",
      "ねんぐ",
      "ねんざ",
      "ねんし",
      "ねんちゃく",
      "ねんど",
      "ねんぴ",
      "ねんぶつ",
      "ねんまつ",
      "ねんりょう",
      "ねんれい",
      "のいず",
      "のおづま",
      "のがす",
      "のきなみ",
      "のこぎり",
      "のこす",
      "のこる",
      "のせる",
      "のぞく",
      "のぞむ",
      "のたまう",
      "のちほど",
      "のっく",
      "のばす",
      "のはら",
      "のべる",
      "のぼる",
      "のみもの",
      "のやま",
      "のらいぬ",
      "のらねこ",
      "のりもの",
      "のりゆき",
      "のれん",
      "のんき",
      "ばあい",
      "はあく",
      "ばあさん",
      "ばいか",
      "ばいく",
      "はいけん",
      "はいご",
      "はいしん",
      "はいすい",
      "はいせん",
      "はいそう",
      "はいち",
      "ばいばい",
      "はいれつ",
      "はえる",
      "はおる",
      "はかい",
      "ばかり",
      "はかる",
      "はくしゅ",
      "はけん",
      "はこぶ",
      "はさみ",
      "はさん",
      "はしご",
      "ばしょ",
      "はしる",
      "はせる",
      "ぱそこん",
      "はそん",
      "はたん",
      "はちみつ",
      "はつおん",
      "はっかく",
      "はづき",
      "はっきり",
      "はっくつ",
      "はっけん",
      "はっこう",
      "はっさん",
      "はっしん",
      "はったつ",
      "はっちゅう",
      "はってん",
      "はっぴょう",
      "はっぽう",
      "はなす",
      "はなび",
      "はにかむ",
      "はぶらし",
      "はみがき",
      "はむかう",
      "はめつ",
      "はやい",
      "はやし",
      "はらう",
      "はろうぃん",
      "はわい",
      "はんい",
      "はんえい",
      "はんおん",
      "はんかく",
      "はんきょう",
      "ばんぐみ",
      "はんこ",
      "はんしゃ",
      "はんすう",
      "はんだん",
      "ぱんち",
      "ぱんつ",
      "はんてい",
      "はんとし",
      "はんのう",
      "はんぱ",
      "はんぶん",
      "はんぺん",
      "はんぼうき",
      "はんめい",
      "はんらん",
      "はんろん",
      "ひいき",
      "ひうん",
      "ひえる",
      "ひかく",
      "ひかり",
      "ひかる",
      "ひかん",
      "ひくい",
      "ひけつ",
      "ひこうき",
      "ひこく",
      "ひさい",
      "ひさしぶり",
      "ひさん",
      "びじゅつかん",
      "ひしょ",
      "ひそか",
      "ひそむ",
      "ひたむき",
      "ひだり",
      "ひたる",
      "ひつぎ",
      "ひっこし",
      "ひっし",
      "ひつじゅひん",
      "ひっす",
      "ひつぜん",
      "ぴったり",
      "ぴっちり",
      "ひつよう",
      "ひてい",
      "ひとごみ",
      "ひなまつり",
      "ひなん",
      "ひねる",
      "ひはん",
      "ひびく",
      "ひひょう",
      "ひほう",
      "ひまわり",
      "ひまん",
      "ひみつ",
      "ひめい",
      "ひめじし",
      "ひやけ",
      "ひやす",
      "ひよう",
      "びょうき",
      "ひらがな",
      "ひらく",
      "ひりつ",
      "ひりょう",
      "ひるま",
      "ひるやすみ",
      "ひれい",
      "ひろい",
      "ひろう",
      "ひろき",
      "ひろゆき",
      "ひんかく",
      "ひんけつ",
      "ひんこん",
      "ひんしゅ",
      "ひんそう",
      "ぴんち",
      "ひんぱん",
      "びんぼう",
      "ふあん",
      "ふいうち",
      "ふうけい",
      "ふうせん",
      "ぷうたろう",
      "ふうとう",
      "ふうふ",
      "ふえる",
      "ふおん",
      "ふかい",
      "ふきん",
      "ふくざつ",
      "ふくぶくろ",
      "ふこう",
      "ふさい",
      "ふしぎ",
      "ふじみ",
      "ふすま",
      "ふせい",
      "ふせぐ",
      "ふそく",
      "ぶたにく",
      "ふたん",
      "ふちょう",
      "ふつう",
      "ふつか",
      "ふっかつ",
      "ふっき",
      "ふっこく",
      "ぶどう",
      "ふとる",
      "ふとん",
      "ふのう",
      "ふはい",
      "ふひょう",
      "ふへん",
      "ふまん",
      "ふみん",
      "ふめつ",
      "ふめん",
      "ふよう",
      "ふりこ",
      "ふりる",
      "ふるい",
      "ふんいき",
      "ぶんがく",
      "ぶんぐ",
      "ふんしつ",
      "ぶんせき",
      "ふんそう",
      "ぶんぽう",
      "へいあん",
      "へいおん",
      "へいがい",
      "へいき",
      "へいげん",
      "へいこう",
      "へいさ",
      "へいしゃ",
      "へいせつ",
      "へいそ",
      "へいたく",
      "へいてん",
      "へいねつ",
      "へいわ",
      "へきが",
      "へこむ",
      "べにいろ",
      "べにしょうが",
      "へらす",
      "へんかん",
      "べんきょう",
      "べんごし",
      "へんさい",
      "へんたい",
      "べんり",
      "ほあん",
      "ほいく",
      "ぼうぎょ",
      "ほうこく",
      "ほうそう",
      "ほうほう",
      "ほうもん",
      "ほうりつ",
      "ほえる",
      "ほおん",
      "ほかん",
      "ほきょう",
      "ぼきん",
      "ほくろ",
      "ほけつ",
      "ほけん",
      "ほこう",
      "ほこる",
      "ほしい",
      "ほしつ",
      "ほしゅ",
      "ほしょう",
      "ほせい",
      "ほそい",
      "ほそく",
      "ほたて",
      "ほたる",
      "ぽちぶくろ",
      "ほっきょく",
      "ほっさ",
      "ほったん",
      "ほとんど",
      "ほめる",
      "ほんい",
      "ほんき",
      "ほんけ",
      "ほんしつ",
      "ほんやく",
      "まいにち",
      "まかい",
      "まかせる",
      "まがる",
      "まける",
      "まこと",
      "まさつ",
      "まじめ",
      "ますく",
      "まぜる",
      "まつり",
      "まとめ",
      "まなぶ",
      "まぬけ",
      "まねく",
      "まほう",
      "まもる",
      "まゆげ",
      "まよう",
      "まろやか",
      "まわす",
      "まわり",
      "まわる",
      "まんが",
      "まんきつ",
      "まんぞく",
      "まんなか",
      "みいら",
      "みうち",
      "みえる",
      "みがく",
      "みかた",
      "みかん",
      "みけん",
      "みこん",
      "みじかい",
      "みすい",
      "みすえる",
      "みせる",
      "みっか",
      "みつかる",
      "みつける",
      "みてい",
      "みとめる",
      "みなと",
      "みなみかさい",
      "みねらる",
      "みのう",
      "みのがす",
      "みほん",
      "みもと",
      "みやげ",
      "みらい",
      "みりょく",
      "みわく",
      "みんか",
      "みんぞく",
      "むいか",
      "むえき",
      "むえん",
      "むかい",
      "むかう",
      "むかえ",
      "むかし",
      "むぎちゃ",
      "むける",
      "むげん",
      "むさぼる",
      "むしあつい",
      "むしば",
      "むじゅん",
      "むしろ",
      "むすう",
      "むすこ",
      "むすぶ",
      "むすめ",
      "むせる",
      "むせん",
      "むちゅう",
      "むなしい",
      "むのう",
      "むやみ",
      "むよう",
      "むらさき",
      "むりょう",
      "むろん",
      "めいあん",
      "めいうん",
      "めいえん",
      "めいかく",
      "めいきょく",
      "めいさい",
      "めいし",
      "めいそう",
      "めいぶつ",
      "めいれい",
      "めいわく",
      "めぐまれる",
      "めざす",
      "めした",
      "めずらしい",
      "めだつ",
      "めまい",
      "めやす",
      "めんきょ",
      "めんせき",
      "めんどう",
      "もうしあげる",
      "もうどうけん",
      "もえる",
      "もくし",
      "もくてき",
      "もくようび",
      "もちろん",
      "もどる",
      "もらう",
      "もんく",
      "もんだい",
      "やおや",
      "やける",
      "やさい",
      "やさしい",
      "やすい",
      "やすたろう",
      "やすみ",
      "やせる",
      "やそう",
      "やたい",
      "やちん",
      "やっと",
      "やっぱり",
      "やぶる",
      "やめる",
      "ややこしい",
      "やよい",
      "やわらかい",
      "ゆうき",
      "ゆうびんきょく",
      "ゆうべ",
      "ゆうめい",
      "ゆけつ",
      "ゆしゅつ",
      "ゆせん",
      "ゆそう",
      "ゆたか",
      "ゆちゃく",
      "ゆでる",
      "ゆにゅう",
      "ゆびわ",
      "ゆらい",
      "ゆれる",
      "ようい",
      "ようか",
      "ようきゅう",
      "ようじ",
      "ようす",
      "ようちえん",
      "よかぜ",
      "よかん",
      "よきん",
      "よくせい",
      "よくぼう",
      "よけい",
      "よごれる",
      "よさん",
      "よしゅう",
      "よそう",
      "よそく",
      "よっか",
      "よてい",
      "よどがわく",
      "よねつ",
      "よやく",
      "よゆう",
      "よろこぶ",
      "よろしい",
      "らいう",
      "らくがき",
      "らくご",
      "らくさつ",
      "らくだ",
      "らしんばん",
      "らせん",
      "らぞく",
      "らたい",
      "らっか",
      "られつ",
      "りえき",
      "りかい",
      "りきさく",
      "りきせつ",
      "りくぐん",
      "りくつ",
      "りけん",
      "りこう",
      "りせい",
      "りそう",
      "りそく",
      "りてん",
      "りねん",
      "りゆう",
      "りゅうがく",
      "りよう",
      "りょうり",
      "りょかん",
      "りょくちゃ",
      "りょこう",
      "りりく",
      "りれき",
      "りろん",
      "りんご",
      "るいけい",
      "るいさい",
      "るいじ",
      "るいせき",
      "るすばん",
      "るりがわら",
      "れいかん",
      "れいぎ",
      "れいせい",
      "れいぞうこ",
      "れいとう",
      "れいぼう",
      "れきし",
      "れきだい",
      "れんあい",
      "れんけい",
      "れんこん",
      "れんさい",
      "れんしゅう",
      "れんぞく",
      "れんらく",
      "ろうか",
      "ろうご",
      "ろうじん",
      "ろうそく",
      "ろくが",
      "ろこつ",
      "ろじうら",
      "ろしゅつ",
      "ろせん",
      "ろてん",
      "ろめん",
      "ろれつ",
      "ろんぎ",
      "ろんぱ",
      "ろんぶん",
      "ろんり",
      "わかす",
      "わかめ",
      "わかやま",
      "わかれる",
      "わしつ",
      "わじまし",
      "わすれもの",
      "わらう",
      "われる"
    ];
  }
});

// node_modules/bip39/src/wordlists/portuguese.json
var require_portuguese = __commonJS({
  "node_modules/bip39/src/wordlists/portuguese.json"(exports2, module2) {
    module2.exports = [
      "abacate",
      "abaixo",
      "abalar",
      "abater",
      "abduzir",
      "abelha",
      "aberto",
      "abismo",
      "abotoar",
      "abranger",
      "abreviar",
      "abrigar",
      "abrupto",
      "absinto",
      "absoluto",
      "absurdo",
      "abutre",
      "acabado",
      "acalmar",
      "acampar",
      "acanhar",
      "acaso",
      "aceitar",
      "acelerar",
      "acenar",
      "acervo",
      "acessar",
      "acetona",
      "achatar",
      "acidez",
      "acima",
      "acionado",
      "acirrar",
      "aclamar",
      "aclive",
      "acolhida",
      "acomodar",
      "acoplar",
      "acordar",
      "acumular",
      "acusador",
      "adaptar",
      "adega",
      "adentro",
      "adepto",
      "adequar",
      "aderente",
      "adesivo",
      "adeus",
      "adiante",
      "aditivo",
      "adjetivo",
      "adjunto",
      "admirar",
      "adorar",
      "adquirir",
      "adubo",
      "adverso",
      "advogado",
      "aeronave",
      "afastar",
      "aferir",
      "afetivo",
      "afinador",
      "afivelar",
      "aflito",
      "afluente",
      "afrontar",
      "agachar",
      "agarrar",
      "agasalho",
      "agenciar",
      "agilizar",
      "agiota",
      "agitado",
      "agora",
      "agradar",
      "agreste",
      "agrupar",
      "aguardar",
      "agulha",
      "ajoelhar",
      "ajudar",
      "ajustar",
      "alameda",
      "alarme",
      "alastrar",
      "alavanca",
      "albergue",
      "albino",
      "alcatra",
      "aldeia",
      "alecrim",
      "alegria",
      "alertar",
      "alface",
      "alfinete",
      "algum",
      "alheio",
      "aliar",
      "alicate",
      "alienar",
      "alinhar",
      "aliviar",
      "almofada",
      "alocar",
      "alpiste",
      "alterar",
      "altitude",
      "alucinar",
      "alugar",
      "aluno",
      "alusivo",
      "alvo",
      "amaciar",
      "amador",
      "amarelo",
      "amassar",
      "ambas",
      "ambiente",
      "ameixa",
      "amenizar",
      "amido",
      "amistoso",
      "amizade",
      "amolador",
      "amontoar",
      "amoroso",
      "amostra",
      "amparar",
      "ampliar",
      "ampola",
      "anagrama",
      "analisar",
      "anarquia",
      "anatomia",
      "andaime",
      "anel",
      "anexo",
      "angular",
      "animar",
      "anjo",
      "anomalia",
      "anotado",
      "ansioso",
      "anterior",
      "anuidade",
      "anunciar",
      "anzol",
      "apagador",
      "apalpar",
      "apanhado",
      "apego",
      "apelido",
      "apertada",
      "apesar",
      "apetite",
      "apito",
      "aplauso",
      "aplicada",
      "apoio",
      "apontar",
      "aposta",
      "aprendiz",
      "aprovar",
      "aquecer",
      "arame",
      "aranha",
      "arara",
      "arcada",
      "ardente",
      "areia",
      "arejar",
      "arenito",
      "aresta",
      "argiloso",
      "argola",
      "arma",
      "arquivo",
      "arraial",
      "arrebate",
      "arriscar",
      "arroba",
      "arrumar",
      "arsenal",
      "arterial",
      "artigo",
      "arvoredo",
      "asfaltar",
      "asilado",
      "aspirar",
      "assador",
      "assinar",
      "assoalho",
      "assunto",
      "astral",
      "atacado",
      "atadura",
      "atalho",
      "atarefar",
      "atear",
      "atender",
      "aterro",
      "ateu",
      "atingir",
      "atirador",
      "ativo",
      "atoleiro",
      "atracar",
      "atrevido",
      "atriz",
      "atual",
      "atum",
      "auditor",
      "aumentar",
      "aura",
      "aurora",
      "autismo",
      "autoria",
      "autuar",
      "avaliar",
      "avante",
      "avaria",
      "avental",
      "avesso",
      "aviador",
      "avisar",
      "avulso",
      "axila",
      "azarar",
      "azedo",
      "azeite",
      "azulejo",
      "babar",
      "babosa",
      "bacalhau",
      "bacharel",
      "bacia",
      "bagagem",
      "baiano",
      "bailar",
      "baioneta",
      "bairro",
      "baixista",
      "bajular",
      "baleia",
      "baliza",
      "balsa",
      "banal",
      "bandeira",
      "banho",
      "banir",
      "banquete",
      "barato",
      "barbado",
      "baronesa",
      "barraca",
      "barulho",
      "baseado",
      "bastante",
      "batata",
      "batedor",
      "batida",
      "batom",
      "batucar",
      "baunilha",
      "beber",
      "beijo",
      "beirada",
      "beisebol",
      "beldade",
      "beleza",
      "belga",
      "beliscar",
      "bendito",
      "bengala",
      "benzer",
      "berimbau",
      "berlinda",
      "berro",
      "besouro",
      "bexiga",
      "bezerro",
      "bico",
      "bicudo",
      "bienal",
      "bifocal",
      "bifurcar",
      "bigorna",
      "bilhete",
      "bimestre",
      "bimotor",
      "biologia",
      "biombo",
      "biosfera",
      "bipolar",
      "birrento",
      "biscoito",
      "bisneto",
      "bispo",
      "bissexto",
      "bitola",
      "bizarro",
      "blindado",
      "bloco",
      "bloquear",
      "boato",
      "bobagem",
      "bocado",
      "bocejo",
      "bochecha",
      "boicotar",
      "bolada",
      "boletim",
      "bolha",
      "bolo",
      "bombeiro",
      "bonde",
      "boneco",
      "bonita",
      "borbulha",
      "borda",
      "boreal",
      "borracha",
      "bovino",
      "boxeador",
      "branco",
      "brasa",
      "braveza",
      "breu",
      "briga",
      "brilho",
      "brincar",
      "broa",
      "brochura",
      "bronzear",
      "broto",
      "bruxo",
      "bucha",
      "budismo",
      "bufar",
      "bule",
      "buraco",
      "busca",
      "busto",
      "buzina",
      "cabana",
      "cabelo",
      "cabide",
      "cabo",
      "cabrito",
      "cacau",
      "cacetada",
      "cachorro",
      "cacique",
      "cadastro",
      "cadeado",
      "cafezal",
      "caiaque",
      "caipira",
      "caixote",
      "cajado",
      "caju",
      "calafrio",
      "calcular",
      "caldeira",
      "calibrar",
      "calmante",
      "calota",
      "camada",
      "cambista",
      "camisa",
      "camomila",
      "campanha",
      "camuflar",
      "canavial",
      "cancelar",
      "caneta",
      "canguru",
      "canhoto",
      "canivete",
      "canoa",
      "cansado",
      "cantar",
      "canudo",
      "capacho",
      "capela",
      "capinar",
      "capotar",
      "capricho",
      "captador",
      "capuz",
      "caracol",
      "carbono",
      "cardeal",
      "careca",
      "carimbar",
      "carneiro",
      "carpete",
      "carreira",
      "cartaz",
      "carvalho",
      "casaco",
      "casca",
      "casebre",
      "castelo",
      "casulo",
      "catarata",
      "cativar",
      "caule",
      "causador",
      "cautelar",
      "cavalo",
      "caverna",
      "cebola",
      "cedilha",
      "cegonha",
      "celebrar",
      "celular",
      "cenoura",
      "censo",
      "centeio",
      "cercar",
      "cerrado",
      "certeiro",
      "cerveja",
      "cetim",
      "cevada",
      "chacota",
      "chaleira",
      "chamado",
      "chapada",
      "charme",
      "chatice",
      "chave",
      "chefe",
      "chegada",
      "cheiro",
      "cheque",
      "chicote",
      "chifre",
      "chinelo",
      "chocalho",
      "chover",
      "chumbo",
      "chutar",
      "chuva",
      "cicatriz",
      "ciclone",
      "cidade",
      "cidreira",
      "ciente",
      "cigana",
      "cimento",
      "cinto",
      "cinza",
      "ciranda",
      "circuito",
      "cirurgia",
      "citar",
      "clareza",
      "clero",
      "clicar",
      "clone",
      "clube",
      "coado",
      "coagir",
      "cobaia",
      "cobertor",
      "cobrar",
      "cocada",
      "coelho",
      "coentro",
      "coeso",
      "cogumelo",
      "coibir",
      "coifa",
      "coiote",
      "colar",
      "coleira",
      "colher",
      "colidir",
      "colmeia",
      "colono",
      "coluna",
      "comando",
      "combinar",
      "comentar",
      "comitiva",
      "comover",
      "complexo",
      "comum",
      "concha",
      "condor",
      "conectar",
      "confuso",
      "congelar",
      "conhecer",
      "conjugar",
      "consumir",
      "contrato",
      "convite",
      "cooperar",
      "copeiro",
      "copiador",
      "copo",
      "coquetel",
      "coragem",
      "cordial",
      "corneta",
      "coronha",
      "corporal",
      "correio",
      "cortejo",
      "coruja",
      "corvo",
      "cosseno",
      "costela",
      "cotonete",
      "couro",
      "couve",
      "covil",
      "cozinha",
      "cratera",
      "cravo",
      "creche",
      "credor",
      "creme",
      "crer",
      "crespo",
      "criada",
      "criminal",
      "crioulo",
      "crise",
      "criticar",
      "crosta",
      "crua",
      "cruzeiro",
      "cubano",
      "cueca",
      "cuidado",
      "cujo",
      "culatra",
      "culminar",
      "culpar",
      "cultura",
      "cumprir",
      "cunhado",
      "cupido",
      "curativo",
      "curral",
      "cursar",
      "curto",
      "cuspir",
      "custear",
      "cutelo",
      "damasco",
      "datar",
      "debater",
      "debitar",
      "deboche",
      "debulhar",
      "decalque",
      "decimal",
      "declive",
      "decote",
      "decretar",
      "dedal",
      "dedicado",
      "deduzir",
      "defesa",
      "defumar",
      "degelo",
      "degrau",
      "degustar",
      "deitado",
      "deixar",
      "delator",
      "delegado",
      "delinear",
      "delonga",
      "demanda",
      "demitir",
      "demolido",
      "dentista",
      "depenado",
      "depilar",
      "depois",
      "depressa",
      "depurar",
      "deriva",
      "derramar",
      "desafio",
      "desbotar",
      "descanso",
      "desenho",
      "desfiado",
      "desgaste",
      "desigual",
      "deslize",
      "desmamar",
      "desova",
      "despesa",
      "destaque",
      "desviar",
      "detalhar",
      "detentor",
      "detonar",
      "detrito",
      "deusa",
      "dever",
      "devido",
      "devotado",
      "dezena",
      "diagrama",
      "dialeto",
      "didata",
      "difuso",
      "digitar",
      "dilatado",
      "diluente",
      "diminuir",
      "dinastia",
      "dinheiro",
      "diocese",
      "direto",
      "discreta",
      "disfarce",
      "disparo",
      "disquete",
      "dissipar",
      "distante",
      "ditador",
      "diurno",
      "diverso",
      "divisor",
      "divulgar",
      "dizer",
      "dobrador",
      "dolorido",
      "domador",
      "dominado",
      "donativo",
      "donzela",
      "dormente",
      "dorsal",
      "dosagem",
      "dourado",
      "doutor",
      "drenagem",
      "drible",
      "drogaria",
      "duelar",
      "duende",
      "dueto",
      "duplo",
      "duquesa",
      "durante",
      "duvidoso",
      "eclodir",
      "ecoar",
      "ecologia",
      "edificar",
      "edital",
      "educado",
      "efeito",
      "efetivar",
      "ejetar",
      "elaborar",
      "eleger",
      "eleitor",
      "elenco",
      "elevador",
      "eliminar",
      "elogiar",
      "embargo",
      "embolado",
      "embrulho",
      "embutido",
      "emenda",
      "emergir",
      "emissor",
      "empatia",
      "empenho",
      "empinado",
      "empolgar",
      "emprego",
      "empurrar",
      "emulador",
      "encaixe",
      "encenado",
      "enchente",
      "encontro",
      "endeusar",
      "endossar",
      "enfaixar",
      "enfeite",
      "enfim",
      "engajado",
      "engenho",
      "englobar",
      "engomado",
      "engraxar",
      "enguia",
      "enjoar",
      "enlatar",
      "enquanto",
      "enraizar",
      "enrolado",
      "enrugar",
      "ensaio",
      "enseada",
      "ensino",
      "ensopado",
      "entanto",
      "enteado",
      "entidade",
      "entortar",
      "entrada",
      "entulho",
      "envergar",
      "enviado",
      "envolver",
      "enxame",
      "enxerto",
      "enxofre",
      "enxuto",
      "epiderme",
      "equipar",
      "ereto",
      "erguido",
      "errata",
      "erva",
      "ervilha",
      "esbanjar",
      "esbelto",
      "escama",
      "escola",
      "escrita",
      "escuta",
      "esfinge",
      "esfolar",
      "esfregar",
      "esfumado",
      "esgrima",
      "esmalte",
      "espanto",
      "espelho",
      "espiga",
      "esponja",
      "espreita",
      "espumar",
      "esquerda",
      "estaca",
      "esteira",
      "esticar",
      "estofado",
      "estrela",
      "estudo",
      "esvaziar",
      "etanol",
      "etiqueta",
      "euforia",
      "europeu",
      "evacuar",
      "evaporar",
      "evasivo",
      "eventual",
      "evidente",
      "evoluir",
      "exagero",
      "exalar",
      "examinar",
      "exato",
      "exausto",
      "excesso",
      "excitar",
      "exclamar",
      "executar",
      "exemplo",
      "exibir",
      "exigente",
      "exonerar",
      "expandir",
      "expelir",
      "expirar",
      "explanar",
      "exposto",
      "expresso",
      "expulsar",
      "externo",
      "extinto",
      "extrato",
      "fabricar",
      "fabuloso",
      "faceta",
      "facial",
      "fada",
      "fadiga",
      "faixa",
      "falar",
      "falta",
      "familiar",
      "fandango",
      "fanfarra",
      "fantoche",
      "fardado",
      "farelo",
      "farinha",
      "farofa",
      "farpa",
      "fartura",
      "fatia",
      "fator",
      "favorita",
      "faxina",
      "fazenda",
      "fechado",
      "feijoada",
      "feirante",
      "felino",
      "feminino",
      "fenda",
      "feno",
      "fera",
      "feriado",
      "ferrugem",
      "ferver",
      "festejar",
      "fetal",
      "feudal",
      "fiapo",
      "fibrose",
      "ficar",
      "ficheiro",
      "figurado",
      "fileira",
      "filho",
      "filme",
      "filtrar",
      "firmeza",
      "fisgada",
      "fissura",
      "fita",
      "fivela",
      "fixador",
      "fixo",
      "flacidez",
      "flamingo",
      "flanela",
      "flechada",
      "flora",
      "flutuar",
      "fluxo",
      "focal",
      "focinho",
      "fofocar",
      "fogo",
      "foguete",
      "foice",
      "folgado",
      "folheto",
      "forjar",
      "formiga",
      "forno",
      "forte",
      "fosco",
      "fossa",
      "fragata",
      "fralda",
      "frango",
      "frasco",
      "fraterno",
      "freira",
      "frente",
      "fretar",
      "frieza",
      "friso",
      "fritura",
      "fronha",
      "frustrar",
      "fruteira",
      "fugir",
      "fulano",
      "fuligem",
      "fundar",
      "fungo",
      "funil",
      "furador",
      "furioso",
      "futebol",
      "gabarito",
      "gabinete",
      "gado",
      "gaiato",
      "gaiola",
      "gaivota",
      "galega",
      "galho",
      "galinha",
      "galocha",
      "ganhar",
      "garagem",
      "garfo",
      "gargalo",
      "garimpo",
      "garoupa",
      "garrafa",
      "gasoduto",
      "gasto",
      "gata",
      "gatilho",
      "gaveta",
      "gazela",
      "gelado",
      "geleia",
      "gelo",
      "gemada",
      "gemer",
      "gemido",
      "generoso",
      "gengiva",
      "genial",
      "genoma",
      "genro",
      "geologia",
      "gerador",
      "germinar",
      "gesso",
      "gestor",
      "ginasta",
      "gincana",
      "gingado",
      "girafa",
      "girino",
      "glacial",
      "glicose",
      "global",
      "glorioso",
      "goela",
      "goiaba",
      "golfe",
      "golpear",
      "gordura",
      "gorjeta",
      "gorro",
      "gostoso",
      "goteira",
      "governar",
      "gracejo",
      "gradual",
      "grafite",
      "gralha",
      "grampo",
      "granada",
      "gratuito",
      "graveto",
      "graxa",
      "grego",
      "grelhar",
      "greve",
      "grilo",
      "grisalho",
      "gritaria",
      "grosso",
      "grotesco",
      "grudado",
      "grunhido",
      "gruta",
      "guache",
      "guarani",
      "guaxinim",
      "guerrear",
      "guiar",
      "guincho",
      "guisado",
      "gula",
      "guloso",
      "guru",
      "habitar",
      "harmonia",
      "haste",
      "haver",
      "hectare",
      "herdar",
      "heresia",
      "hesitar",
      "hiato",
      "hibernar",
      "hidratar",
      "hiena",
      "hino",
      "hipismo",
      "hipnose",
      "hipoteca",
      "hoje",
      "holofote",
      "homem",
      "honesto",
      "honrado",
      "hormonal",
      "hospedar",
      "humorado",
      "iate",
      "ideia",
      "idoso",
      "ignorado",
      "igreja",
      "iguana",
      "ileso",
      "ilha",
      "iludido",
      "iluminar",
      "ilustrar",
      "imagem",
      "imediato",
      "imenso",
      "imersivo",
      "iminente",
      "imitador",
      "imortal",
      "impacto",
      "impedir",
      "implante",
      "impor",
      "imprensa",
      "impune",
      "imunizar",
      "inalador",
      "inapto",
      "inativo",
      "incenso",
      "inchar",
      "incidir",
      "incluir",
      "incolor",
      "indeciso",
      "indireto",
      "indutor",
      "ineficaz",
      "inerente",
      "infantil",
      "infestar",
      "infinito",
      "inflamar",
      "informal",
      "infrator",
      "ingerir",
      "inibido",
      "inicial",
      "inimigo",
      "injetar",
      "inocente",
      "inodoro",
      "inovador",
      "inox",
      "inquieto",
      "inscrito",
      "inseto",
      "insistir",
      "inspetor",
      "instalar",
      "insulto",
      "intacto",
      "integral",
      "intimar",
      "intocado",
      "intriga",
      "invasor",
      "inverno",
      "invicto",
      "invocar",
      "iogurte",
      "iraniano",
      "ironizar",
      "irreal",
      "irritado",
      "isca",
      "isento",
      "isolado",
      "isqueiro",
      "italiano",
      "janeiro",
      "jangada",
      "janta",
      "jararaca",
      "jardim",
      "jarro",
      "jasmim",
      "jato",
      "javali",
      "jazida",
      "jejum",
      "joaninha",
      "joelhada",
      "jogador",
      "joia",
      "jornal",
      "jorrar",
      "jovem",
      "juba",
      "judeu",
      "judoca",
      "juiz",
      "julgador",
      "julho",
      "jurado",
      "jurista",
      "juro",
      "justa",
      "labareda",
      "laboral",
      "lacre",
      "lactante",
      "ladrilho",
      "lagarta",
      "lagoa",
      "laje",
      "lamber",
      "lamentar",
      "laminar",
      "lampejo",
      "lanche",
      "lapidar",
      "lapso",
      "laranja",
      "lareira",
      "largura",
      "lasanha",
      "lastro",
      "lateral",
      "latido",
      "lavanda",
      "lavoura",
      "lavrador",
      "laxante",
      "lazer",
      "lealdade",
      "lebre",
      "legado",
      "legendar",
      "legista",
      "leigo",
      "leiloar",
      "leitura",
      "lembrete",
      "leme",
      "lenhador",
      "lentilha",
      "leoa",
      "lesma",
      "leste",
      "letivo",
      "letreiro",
      "levar",
      "leveza",
      "levitar",
      "liberal",
      "libido",
      "liderar",
      "ligar",
      "ligeiro",
      "limitar",
      "limoeiro",
      "limpador",
      "linda",
      "linear",
      "linhagem",
      "liquidez",
      "listagem",
      "lisura",
      "litoral",
      "livro",
      "lixa",
      "lixeira",
      "locador",
      "locutor",
      "lojista",
      "lombo",
      "lona",
      "longe",
      "lontra",
      "lorde",
      "lotado",
      "loteria",
      "loucura",
      "lousa",
      "louvar",
      "luar",
      "lucidez",
      "lucro",
      "luneta",
      "lustre",
      "lutador",
      "luva",
      "macaco",
      "macete",
      "machado",
      "macio",
      "madeira",
      "madrinha",
      "magnata",
      "magreza",
      "maior",
      "mais",
      "malandro",
      "malha",
      "malote",
      "maluco",
      "mamilo",
      "mamoeiro",
      "mamute",
      "manada",
      "mancha",
      "mandato",
      "manequim",
      "manhoso",
      "manivela",
      "manobrar",
      "mansa",
      "manter",
      "manusear",
      "mapeado",
      "maquinar",
      "marcador",
      "maresia",
      "marfim",
      "margem",
      "marinho",
      "marmita",
      "maroto",
      "marquise",
      "marreco",
      "martelo",
      "marujo",
      "mascote",
      "masmorra",
      "massagem",
      "mastigar",
      "matagal",
      "materno",
      "matinal",
      "matutar",
      "maxilar",
      "medalha",
      "medida",
      "medusa",
      "megafone",
      "meiga",
      "melancia",
      "melhor",
      "membro",
      "memorial",
      "menino",
      "menos",
      "mensagem",
      "mental",
      "merecer",
      "mergulho",
      "mesada",
      "mesclar",
      "mesmo",
      "mesquita",
      "mestre",
      "metade",
      "meteoro",
      "metragem",
      "mexer",
      "mexicano",
      "micro",
      "migalha",
      "migrar",
      "milagre",
      "milenar",
      "milhar",
      "mimado",
      "minerar",
      "minhoca",
      "ministro",
      "minoria",
      "miolo",
      "mirante",
      "mirtilo",
      "misturar",
      "mocidade",
      "moderno",
      "modular",
      "moeda",
      "moer",
      "moinho",
      "moita",
      "moldura",
      "moleza",
      "molho",
      "molinete",
      "molusco",
      "montanha",
      "moqueca",
      "morango",
      "morcego",
      "mordomo",
      "morena",
      "mosaico",
      "mosquete",
      "mostarda",
      "motel",
      "motim",
      "moto",
      "motriz",
      "muda",
      "muito",
      "mulata",
      "mulher",
      "multar",
      "mundial",
      "munido",
      "muralha",
      "murcho",
      "muscular",
      "museu",
      "musical",
      "nacional",
      "nadador",
      "naja",
      "namoro",
      "narina",
      "narrado",
      "nascer",
      "nativa",
      "natureza",
      "navalha",
      "navegar",
      "navio",
      "neblina",
      "nebuloso",
      "negativa",
      "negociar",
      "negrito",
      "nervoso",
      "neta",
      "neural",
      "nevasca",
      "nevoeiro",
      "ninar",
      "ninho",
      "nitidez",
      "nivelar",
      "nobreza",
      "noite",
      "noiva",
      "nomear",
      "nominal",
      "nordeste",
      "nortear",
      "notar",
      "noticiar",
      "noturno",
      "novelo",
      "novilho",
      "novo",
      "nublado",
      "nudez",
      "numeral",
      "nupcial",
      "nutrir",
      "nuvem",
      "obcecado",
      "obedecer",
      "objetivo",
      "obrigado",
      "obscuro",
      "obstetra",
      "obter",
      "obturar",
      "ocidente",
      "ocioso",
      "ocorrer",
      "oculista",
      "ocupado",
      "ofegante",
      "ofensiva",
      "oferenda",
      "oficina",
      "ofuscado",
      "ogiva",
      "olaria",
      "oleoso",
      "olhar",
      "oliveira",
      "ombro",
      "omelete",
      "omisso",
      "omitir",
      "ondulado",
      "oneroso",
      "ontem",
      "opcional",
      "operador",
      "oponente",
      "oportuno",
      "oposto",
      "orar",
      "orbitar",
      "ordem",
      "ordinal",
      "orfanato",
      "orgasmo",
      "orgulho",
      "oriental",
      "origem",
      "oriundo",
      "orla",
      "ortodoxo",
      "orvalho",
      "oscilar",
      "ossada",
      "osso",
      "ostentar",
      "otimismo",
      "ousadia",
      "outono",
      "outubro",
      "ouvido",
      "ovelha",
      "ovular",
      "oxidar",
      "oxigenar",
      "pacato",
      "paciente",
      "pacote",
      "pactuar",
      "padaria",
      "padrinho",
      "pagar",
      "pagode",
      "painel",
      "pairar",
      "paisagem",
      "palavra",
      "palestra",
      "palheta",
      "palito",
      "palmada",
      "palpitar",
      "pancada",
      "panela",
      "panfleto",
      "panqueca",
      "pantanal",
      "papagaio",
      "papelada",
      "papiro",
      "parafina",
      "parcial",
      "pardal",
      "parede",
      "partida",
      "pasmo",
      "passado",
      "pastel",
      "patamar",
      "patente",
      "patinar",
      "patrono",
      "paulada",
      "pausar",
      "peculiar",
      "pedalar",
      "pedestre",
      "pediatra",
      "pedra",
      "pegada",
      "peitoral",
      "peixe",
      "pele",
      "pelicano",
      "penca",
      "pendurar",
      "peneira",
      "penhasco",
      "pensador",
      "pente",
      "perceber",
      "perfeito",
      "pergunta",
      "perito",
      "permitir",
      "perna",
      "perplexo",
      "persiana",
      "pertence",
      "peruca",
      "pescado",
      "pesquisa",
      "pessoa",
      "petiscar",
      "piada",
      "picado",
      "piedade",
      "pigmento",
      "pilastra",
      "pilhado",
      "pilotar",
      "pimenta",
      "pincel",
      "pinguim",
      "pinha",
      "pinote",
      "pintar",
      "pioneiro",
      "pipoca",
      "piquete",
      "piranha",
      "pires",
      "pirueta",
      "piscar",
      "pistola",
      "pitanga",
      "pivete",
      "planta",
      "plaqueta",
      "platina",
      "plebeu",
      "plumagem",
      "pluvial",
      "pneu",
      "poda",
      "poeira",
      "poetisa",
      "polegada",
      "policiar",
      "poluente",
      "polvilho",
      "pomar",
      "pomba",
      "ponderar",
      "pontaria",
      "populoso",
      "porta",
      "possuir",
      "postal",
      "pote",
      "poupar",
      "pouso",
      "povoar",
      "praia",
      "prancha",
      "prato",
      "praxe",
      "prece",
      "predador",
      "prefeito",
      "premiar",
      "prensar",
      "preparar",
      "presilha",
      "pretexto",
      "prevenir",
      "prezar",
      "primata",
      "princesa",
      "prisma",
      "privado",
      "processo",
      "produto",
      "profeta",
      "proibido",
      "projeto",
      "prometer",
      "propagar",
      "prosa",
      "protetor",
      "provador",
      "publicar",
      "pudim",
      "pular",
      "pulmonar",
      "pulseira",
      "punhal",
      "punir",
      "pupilo",
      "pureza",
      "puxador",
      "quadra",
      "quantia",
      "quarto",
      "quase",
      "quebrar",
      "queda",
      "queijo",
      "quente",
      "querido",
      "quimono",
      "quina",
      "quiosque",
      "rabanada",
      "rabisco",
      "rachar",
      "racionar",
      "radial",
      "raiar",
      "rainha",
      "raio",
      "raiva",
      "rajada",
      "ralado",
      "ramal",
      "ranger",
      "ranhura",
      "rapadura",
      "rapel",
      "rapidez",
      "raposa",
      "raquete",
      "raridade",
      "rasante",
      "rascunho",
      "rasgar",
      "raspador",
      "rasteira",
      "rasurar",
      "ratazana",
      "ratoeira",
      "realeza",
      "reanimar",
      "reaver",
      "rebaixar",
      "rebelde",
      "rebolar",
      "recado",
      "recente",
      "recheio",
      "recibo",
      "recordar",
      "recrutar",
      "recuar",
      "rede",
      "redimir",
      "redonda",
      "reduzida",
      "reenvio",
      "refinar",
      "refletir",
      "refogar",
      "refresco",
      "refugiar",
      "regalia",
      "regime",
      "regra",
      "reinado",
      "reitor",
      "rejeitar",
      "relativo",
      "remador",
      "remendo",
      "remorso",
      "renovado",
      "reparo",
      "repelir",
      "repleto",
      "repolho",
      "represa",
      "repudiar",
      "requerer",
      "resenha",
      "resfriar",
      "resgatar",
      "residir",
      "resolver",
      "respeito",
      "ressaca",
      "restante",
      "resumir",
      "retalho",
      "reter",
      "retirar",
      "retomada",
      "retratar",
      "revelar",
      "revisor",
      "revolta",
      "riacho",
      "rica",
      "rigidez",
      "rigoroso",
      "rimar",
      "ringue",
      "risada",
      "risco",
      "risonho",
      "robalo",
      "rochedo",
      "rodada",
      "rodeio",
      "rodovia",
      "roedor",
      "roleta",
      "romano",
      "roncar",
      "rosado",
      "roseira",
      "rosto",
      "rota",
      "roteiro",
      "rotina",
      "rotular",
      "rouco",
      "roupa",
      "roxo",
      "rubro",
      "rugido",
      "rugoso",
      "ruivo",
      "rumo",
      "rupestre",
      "russo",
      "sabor",
      "saciar",
      "sacola",
      "sacudir",
      "sadio",
      "safira",
      "saga",
      "sagrada",
      "saibro",
      "salada",
      "saleiro",
      "salgado",
      "saliva",
      "salpicar",
      "salsicha",
      "saltar",
      "salvador",
      "sambar",
      "samurai",
      "sanar",
      "sanfona",
      "sangue",
      "sanidade",
      "sapato",
      "sarda",
      "sargento",
      "sarjeta",
      "saturar",
      "saudade",
      "saxofone",
      "sazonal",
      "secar",
      "secular",
      "seda",
      "sedento",
      "sediado",
      "sedoso",
      "sedutor",
      "segmento",
      "segredo",
      "segundo",
      "seiva",
      "seleto",
      "selvagem",
      "semanal",
      "semente",
      "senador",
      "senhor",
      "sensual",
      "sentado",
      "separado",
      "sereia",
      "seringa",
      "serra",
      "servo",
      "setembro",
      "setor",
      "sigilo",
      "silhueta",
      "silicone",
      "simetria",
      "simpatia",
      "simular",
      "sinal",
      "sincero",
      "singular",
      "sinopse",
      "sintonia",
      "sirene",
      "siri",
      "situado",
      "soberano",
      "sobra",
      "socorro",
      "sogro",
      "soja",
      "solda",
      "soletrar",
      "solteiro",
      "sombrio",
      "sonata",
      "sondar",
      "sonegar",
      "sonhador",
      "sono",
      "soprano",
      "soquete",
      "sorrir",
      "sorteio",
      "sossego",
      "sotaque",
      "soterrar",
      "sovado",
      "sozinho",
      "suavizar",
      "subida",
      "submerso",
      "subsolo",
      "subtrair",
      "sucata",
      "sucesso",
      "suco",
      "sudeste",
      "sufixo",
      "sugador",
      "sugerir",
      "sujeito",
      "sulfato",
      "sumir",
      "suor",
      "superior",
      "suplicar",
      "suposto",
      "suprimir",
      "surdina",
      "surfista",
      "surpresa",
      "surreal",
      "surtir",
      "suspiro",
      "sustento",
      "tabela",
      "tablete",
      "tabuada",
      "tacho",
      "tagarela",
      "talher",
      "talo",
      "talvez",
      "tamanho",
      "tamborim",
      "tampa",
      "tangente",
      "tanto",
      "tapar",
      "tapioca",
      "tardio",
      "tarefa",
      "tarja",
      "tarraxa",
      "tatuagem",
      "taurino",
      "taxativo",
      "taxista",
      "teatral",
      "tecer",
      "tecido",
      "teclado",
      "tedioso",
      "teia",
      "teimar",
      "telefone",
      "telhado",
      "tempero",
      "tenente",
      "tensor",
      "tentar",
      "termal",
      "terno",
      "terreno",
      "tese",
      "tesoura",
      "testado",
      "teto",
      "textura",
      "texugo",
      "tiara",
      "tigela",
      "tijolo",
      "timbrar",
      "timidez",
      "tingido",
      "tinteiro",
      "tiragem",
      "titular",
      "toalha",
      "tocha",
      "tolerar",
      "tolice",
      "tomada",
      "tomilho",
      "tonel",
      "tontura",
      "topete",
      "tora",
      "torcido",
      "torneio",
      "torque",
      "torrada",
      "torto",
      "tostar",
      "touca",
      "toupeira",
      "toxina",
      "trabalho",
      "tracejar",
      "tradutor",
      "trafegar",
      "trajeto",
      "trama",
      "trancar",
      "trapo",
      "traseiro",
      "tratador",
      "travar",
      "treino",
      "tremer",
      "trepidar",
      "trevo",
      "triagem",
      "tribo",
      "triciclo",
      "tridente",
      "trilogia",
      "trindade",
      "triplo",
      "triturar",
      "triunfal",
      "trocar",
      "trombeta",
      "trova",
      "trunfo",
      "truque",
      "tubular",
      "tucano",
      "tudo",
      "tulipa",
      "tupi",
      "turbo",
      "turma",
      "turquesa",
      "tutelar",
      "tutorial",
      "uivar",
      "umbigo",
      "unha",
      "unidade",
      "uniforme",
      "urologia",
      "urso",
      "urtiga",
      "urubu",
      "usado",
      "usina",
      "usufruir",
      "vacina",
      "vadiar",
      "vagaroso",
      "vaidoso",
      "vala",
      "valente",
      "validade",
      "valores",
      "vantagem",
      "vaqueiro",
      "varanda",
      "vareta",
      "varrer",
      "vascular",
      "vasilha",
      "vassoura",
      "vazar",
      "vazio",
      "veado",
      "vedar",
      "vegetar",
      "veicular",
      "veleiro",
      "velhice",
      "veludo",
      "vencedor",
      "vendaval",
      "venerar",
      "ventre",
      "verbal",
      "verdade",
      "vereador",
      "vergonha",
      "vermelho",
      "verniz",
      "versar",
      "vertente",
      "vespa",
      "vestido",
      "vetorial",
      "viaduto",
      "viagem",
      "viajar",
      "viatura",
      "vibrador",
      "videira",
      "vidraria",
      "viela",
      "viga",
      "vigente",
      "vigiar",
      "vigorar",
      "vilarejo",
      "vinco",
      "vinheta",
      "vinil",
      "violeta",
      "virada",
      "virtude",
      "visitar",
      "visto",
      "vitral",
      "viveiro",
      "vizinho",
      "voador",
      "voar",
      "vogal",
      "volante",
      "voleibol",
      "voltagem",
      "volumoso",
      "vontade",
      "vulto",
      "vuvuzela",
      "xadrez",
      "xarope",
      "xeque",
      "xeretar",
      "xerife",
      "xingar",
      "zangado",
      "zarpar",
      "zebu",
      "zelador",
      "zombar",
      "zoologia",
      "zumbido"
    ];
  }
});

// node_modules/bip39/src/wordlists/english.json
var require_english = __commonJS({
  "node_modules/bip39/src/wordlists/english.json"(exports2, module2) {
    module2.exports = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
  }
});

// node_modules/bip39/src/_wordlists.js
var require_wordlists = __commonJS({
  "node_modules/bip39/src/_wordlists.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var wordlists = {};
    exports2.wordlists = wordlists;
    var _default;
    exports2._default = _default;
    try {
      exports2._default = _default = require_czech();
      wordlists.czech = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_chinese_simplified();
      wordlists.chinese_simplified = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_chinese_traditional();
      wordlists.chinese_traditional = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_korean();
      wordlists.korean = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_french();
      wordlists.french = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_italian();
      wordlists.italian = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_spanish();
      wordlists.spanish = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_japanese();
      wordlists.japanese = _default;
      wordlists.JA = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_portuguese();
      wordlists.portuguese = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_english();
      wordlists.english = _default;
      wordlists.EN = _default;
    } catch (err) {
    }
  }
});

// node_modules/bip39/src/index.js
var require_src = __commonJS({
  "node_modules/bip39/src/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var pbkdf2_1 = require_pbkdf2();
    var utils_1 = require_utils();
    var _wordlists_1 = require_wordlists();
    var DEFAULT_WORDLIST = _wordlists_1._default;
    var INVALID_MNEMONIC = "Invalid mnemonic";
    var INVALID_ENTROPY = "Invalid entropy";
    var INVALID_CHECKSUM = "Invalid mnemonic checksum";
    var WORDLIST_REQUIRED = "A wordlist is required but a default could not be found.\nPlease pass a 2048 word array explicitly.";
    function normalize3(str) {
      return (str || "").normalize("NFKD");
    }
    function lpad(str, padString, length) {
      while (str.length < length) {
        str = padString + str;
      }
      return str;
    }
    function binaryToByte(bin) {
      return parseInt(bin, 2);
    }
    function bytesToBinary(bytes) {
      return bytes.map((x) => lpad(x.toString(2), "0", 8)).join("");
    }
    function deriveChecksumBits(entropyBuffer) {
      const ENT = entropyBuffer.length * 8;
      const CS = ENT / 32;
      const hash2 = sha256_1.sha256(Uint8Array.from(entropyBuffer));
      return bytesToBinary(Array.from(hash2)).slice(0, CS);
    }
    function salt(password) {
      return "mnemonic" + (password || "");
    }
    function mnemonicToSeedSync(mnemonic, password) {
      const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize3(mnemonic), "utf8"));
      const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize3(password)), "utf8"));
      const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64
      });
      return Buffer.from(res);
    }
    exports2.mnemonicToSeedSync = mnemonicToSeedSync;
    function mnemonicToSeed(mnemonic, password) {
      const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize3(mnemonic), "utf8"));
      const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize3(password)), "utf8"));
      return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64
      }).then((res) => Buffer.from(res));
    }
    exports2.mnemonicToSeed = mnemonicToSeed;
    function mnemonicToEntropy(mnemonic, wordlist) {
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
      }
      const words = normalize3(mnemonic).split(" ");
      if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
      }
      const bits = words.map((word) => {
        const index2 = wordlist.indexOf(word);
        if (index2 === -1) {
          throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index2.toString(2), "0", 11);
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
      if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
      }
      if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
      }
      if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
      }
      const entropy = Buffer.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
      }
      return entropy.toString("hex");
    }
    exports2.mnemonicToEntropy = mnemonicToEntropy;
    function entropyToMnemonic(entropy, wordlist) {
      if (!Buffer.isBuffer(entropy)) {
        entropy = Buffer.from(entropy, "hex");
      }
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
      }
      if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
      }
      if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
      }
      if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
      }
      const entropyBits = bytesToBinary(Array.from(entropy));
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{1,11})/g);
      const words = chunks.map((binary) => {
        const index2 = binaryToByte(binary);
        return wordlist[index2];
      });
      return wordlist[0] === "あいこくしん" ? words.join("　") : words.join(" ");
    }
    exports2.entropyToMnemonic = entropyToMnemonic;
    function generateMnemonic(strength, rng, wordlist) {
      strength = strength || 128;
      if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
      }
      rng = rng || ((size4) => Buffer.from(utils_1.randomBytes(size4)));
      return entropyToMnemonic(rng(strength / 8), wordlist);
    }
    exports2.generateMnemonic = generateMnemonic;
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }
    exports2.validateMnemonic = validateMnemonic;
    function setDefaultWordlist(language) {
      const result2 = _wordlists_1.wordlists[language];
      if (result2) {
        DEFAULT_WORDLIST = result2;
      } else {
        throw new Error('Could not find wordlist for language "' + language + '"');
      }
    }
    exports2.setDefaultWordlist = setDefaultWordlist;
    function getDefaultWordlist() {
      if (!DEFAULT_WORDLIST) {
        throw new Error("No Default Wordlist set");
      }
      return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === "JA" || lang === "EN") {
          return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index2) => word === DEFAULT_WORDLIST[index2]);
      })[0];
    }
    exports2.getDefaultWordlist = getDefaultWordlist;
    var _wordlists_2 = require_wordlists();
    exports2.wordlists = _wordlists_2.wordlists;
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var buffer = (init_dist(), __toCommonJS(dist_exports));
    var Buffer2 = buffer.Buffer;
    function copyProps2(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps2(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps2(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size4, fill, encoding) {
      if (typeof size4 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size4);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size4) {
      if (typeof size4 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size4);
    };
    SafeBuffer.allocUnsafeSlow = function(size4) {
      if (typeof size4 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size4);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    module2.exports = require_events().EventEmitter;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties2(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = (init_dist(), __toCommonJS(dist_exports));
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset4) {
      Buffer2.prototype.copy.call(src, target, offset4);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass2(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift4() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat3(n) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith2(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith2(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage) return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val) return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count3 = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count3] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count3 += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from2;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index2 = indexOf(state.pipes, dest);
      if (index2 === -1) return this;
      state.pipes.splice(index2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from2 === void 0) {
          from2 = require_from_browser();
        }
        return from2(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    module2.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from2, to) {
      return from2.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop2;
      if (typeof streams[streams.length - 1] !== "function") return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "node_modules/hash-base/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_readable_browser().Transform;
    var inherits = require_inherits_browser();
    function throwIfNotStringOrBuffer(val, prefix) {
      if (!Buffer2.isBuffer(val) && typeof val !== "string") {
        throw new TypeError(prefix + " must be a string or a buffer");
      }
    }
    function HashBase(blockSize) {
      Transform.call(this);
      this._block = Buffer2.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits(HashBase, Transform);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype._flush = function(callback) {
      var error = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error = err;
      }
      callback(error);
    };
    HashBase.prototype.update = function(data, encoding) {
      throwIfNotStringOrBuffer(data, "Data");
      if (this._finalized) throw new Error("Digest already called");
      if (!Buffer2.isBuffer(data)) data = Buffer2.from(data, encoding);
      var block = this._block;
      var offset4 = 0;
      while (this._blockOffset + data.length - offset4 >= this._blockSize) {
        for (var i = this._blockOffset; i < this._blockSize; ) block[i++] = data[offset4++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset4 < data.length) block[this._blockOffset++] = data[offset4++];
      for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
        this._length[j] += carry;
        carry = this._length[j] / 4294967296 | 0;
        if (carry > 0) this._length[j] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized) throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0) digest = digest.toString(encoding);
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i = 0; i < 4; ++i) this._length[i] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module2.exports = HashBase;
  }
});

// node_modules/md5.js/index.js
var require_md5 = __commonJS({
  "node_modules/md5.js/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var HashBase = require_hash_base();
    var Buffer2 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits(MD5, HashBase);
    MD5.prototype._update = function() {
      var M = ARRAY16;
      for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);
      var a = this._a;
      var b = this._b;
      var c = this._c;
      var d = this._d;
      a = fnF(a, b, c, d, M[0], 3614090360, 7);
      d = fnF(d, a, b, c, M[1], 3905402710, 12);
      c = fnF(c, d, a, b, M[2], 606105819, 17);
      b = fnF(b, c, d, a, M[3], 3250441966, 22);
      a = fnF(a, b, c, d, M[4], 4118548399, 7);
      d = fnF(d, a, b, c, M[5], 1200080426, 12);
      c = fnF(c, d, a, b, M[6], 2821735955, 17);
      b = fnF(b, c, d, a, M[7], 4249261313, 22);
      a = fnF(a, b, c, d, M[8], 1770035416, 7);
      d = fnF(d, a, b, c, M[9], 2336552879, 12);
      c = fnF(c, d, a, b, M[10], 4294925233, 17);
      b = fnF(b, c, d, a, M[11], 2304563134, 22);
      a = fnF(a, b, c, d, M[12], 1804603682, 7);
      d = fnF(d, a, b, c, M[13], 4254626195, 12);
      c = fnF(c, d, a, b, M[14], 2792965006, 17);
      b = fnF(b, c, d, a, M[15], 1236535329, 22);
      a = fnG(a, b, c, d, M[1], 4129170786, 5);
      d = fnG(d, a, b, c, M[6], 3225465664, 9);
      c = fnG(c, d, a, b, M[11], 643717713, 14);
      b = fnG(b, c, d, a, M[0], 3921069994, 20);
      a = fnG(a, b, c, d, M[5], 3593408605, 5);
      d = fnG(d, a, b, c, M[10], 38016083, 9);
      c = fnG(c, d, a, b, M[15], 3634488961, 14);
      b = fnG(b, c, d, a, M[4], 3889429448, 20);
      a = fnG(a, b, c, d, M[9], 568446438, 5);
      d = fnG(d, a, b, c, M[14], 3275163606, 9);
      c = fnG(c, d, a, b, M[3], 4107603335, 14);
      b = fnG(b, c, d, a, M[8], 1163531501, 20);
      a = fnG(a, b, c, d, M[13], 2850285829, 5);
      d = fnG(d, a, b, c, M[2], 4243563512, 9);
      c = fnG(c, d, a, b, M[7], 1735328473, 14);
      b = fnG(b, c, d, a, M[12], 2368359562, 20);
      a = fnH(a, b, c, d, M[5], 4294588738, 4);
      d = fnH(d, a, b, c, M[8], 2272392833, 11);
      c = fnH(c, d, a, b, M[11], 1839030562, 16);
      b = fnH(b, c, d, a, M[14], 4259657740, 23);
      a = fnH(a, b, c, d, M[1], 2763975236, 4);
      d = fnH(d, a, b, c, M[4], 1272893353, 11);
      c = fnH(c, d, a, b, M[7], 4139469664, 16);
      b = fnH(b, c, d, a, M[10], 3200236656, 23);
      a = fnH(a, b, c, d, M[13], 681279174, 4);
      d = fnH(d, a, b, c, M[0], 3936430074, 11);
      c = fnH(c, d, a, b, M[3], 3572445317, 16);
      b = fnH(b, c, d, a, M[6], 76029189, 23);
      a = fnH(a, b, c, d, M[9], 3654602809, 4);
      d = fnH(d, a, b, c, M[12], 3873151461, 11);
      c = fnH(c, d, a, b, M[15], 530742520, 16);
      b = fnH(b, c, d, a, M[2], 3299628645, 23);
      a = fnI(a, b, c, d, M[0], 4096336452, 6);
      d = fnI(d, a, b, c, M[7], 1126891415, 10);
      c = fnI(c, d, a, b, M[14], 2878612391, 15);
      b = fnI(b, c, d, a, M[5], 4237533241, 21);
      a = fnI(a, b, c, d, M[12], 1700485571, 6);
      d = fnI(d, a, b, c, M[3], 2399980690, 10);
      c = fnI(c, d, a, b, M[10], 4293915773, 15);
      b = fnI(b, c, d, a, M[1], 2240044497, 21);
      a = fnI(a, b, c, d, M[8], 1873313359, 6);
      d = fnI(d, a, b, c, M[15], 4264355552, 10);
      c = fnI(c, d, a, b, M[6], 2734768916, 15);
      b = fnI(b, c, d, a, M[13], 1309151649, 21);
      a = fnI(a, b, c, d, M[4], 4149444226, 6);
      d = fnI(d, a, b, c, M[11], 3174756917, 10);
      c = fnI(c, d, a, b, M[2], 718787259, 15);
      b = fnI(b, c, d, a, M[9], 3951481745, 21);
      this._a = this._a + a | 0;
      this._b = this._b + b | 0;
      this._c = this._c + c | 0;
      this._d = this._d + d | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.allocUnsafe(16);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      return buffer;
    };
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fnF(a, b, c, d, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
    }
    function fnG(a, b, c, d, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
    }
    function fnH(a, b, c, d, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
    }
    function fnI(a, b, c, d, m, k, s) {
      return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
    }
    module2.exports = MD5;
  }
});

// node_modules/ripemd160/index.js
var require_ripemd1602 = __commonJS({
  "node_modules/ripemd160/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
    var inherits = require_inherits_browser();
    var HashBase = require_hash_base();
    var ARRAY16 = new Array(16);
    var zl = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var zr = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var sl = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sr = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
    var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function RIPEMD160() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits(RIPEMD160, HashBase);
    RIPEMD160.prototype._update = function() {
      var words = ARRAY16;
      for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);
      var al = this._a | 0;
      var bl = this._b | 0;
      var cl = this._c | 0;
      var dl = this._d | 0;
      var el = this._e | 0;
      var ar = this._a | 0;
      var br = this._b | 0;
      var cr = this._c | 0;
      var dr = this._d | 0;
      var er = this._e | 0;
      for (var i = 0; i < 80; i += 1) {
        var tl;
        var tr;
        if (i < 16) {
          tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
          tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
        } else if (i < 32) {
          tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
          tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
        } else if (i < 48) {
          tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
          tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
        } else if (i < 64) {
          tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
          tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
        } else {
          tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
          tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
        }
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = tl;
        ar = er;
        er = dr;
        dr = rotl(cr, 10);
        cr = br;
        br = tr;
      }
      var t = this._b + cl + dr | 0;
      this._b = this._c + dl + er | 0;
      this._c = this._d + el + ar | 0;
      this._d = this._e + al + br | 0;
      this._e = this._a + bl + cr | 0;
      this._a = t;
    };
    RIPEMD160.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer2.alloc ? Buffer2.alloc(20) : new Buffer2(20);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      buffer.writeInt32LE(this._e, 16);
      return buffer;
    };
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function fn1(a, b, c, d, e, m, k, s) {
      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
    }
    function fn2(a, b, c, d, e, m, k, s) {
      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
    }
    function fn3(a, b, c, d, e, m, k, s) {
      return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
    }
    function fn4(a, b, c, d, e, m, k, s) {
      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
    }
    function fn5(a, b, c, d, e, m, k, s) {
      return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
    }
    module2.exports = RIPEMD160;
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    function Hash2(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash2.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer2.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset4 = 0; offset4 < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset4, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset4 + i];
        }
        accum += remainder;
        offset4 += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash2.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash2 = this._hash();
      return enc ? hash2.toString(enc) : hash2;
    };
    Hash2.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module2.exports = Hash2;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha, Hash2);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num2) {
      return num2 << 5 | num2 >>> 27;
    }
    function rotl30(num2) {
      return num2 << 30 | num2 >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha1, Hash2);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num2) {
      return num2 << 1 | num2 >>> 31;
    }
    function rotl5(num2) {
      return num2 << 5 | num2 >>> 27;
    }
    function rotl30(num2) {
      return num2 << 30 | num2 >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha256, Hash2);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g2 = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i) W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g2) + K[j] + W2[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g2;
        g2 = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g2 + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module2.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Sha256 = require_sha2562();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module2.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha5122 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash2.call(this, 128, 112);
    }
    inherits(Sha512, Hash2);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var W2 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        W2[i] = M.readInt32BE(i * 4);
        W2[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W2[i - 15 * 2];
        var xl = W2[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W2[i - 2 * 2];
        xl = W2[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W2[i - 7 * 2];
        var Wi7l = W2[i - 7 * 2 + 1];
        var Wi16h = W2[i - 16 * 2];
        var Wi16l = W2[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W2[i] = Wih;
        W2[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W2[j];
        Wil = W2[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(64);
      function writeInt64BE(h, l, offset4) {
        H.writeInt32BE(h, offset4);
        H.writeInt32BE(l, offset4 + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module2.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var SHA512 = require_sha5122();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash2.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(48);
      function writeInt64BE(h, l, offset4) {
        H.writeInt32BE(h, offset4);
        H.writeInt32BE(l, offset4 + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module2.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var exports2 = module2.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports2[algorithm];
      if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports2.sha = require_sha();
    exports2.sha1 = require_sha1();
    exports2.sha224 = require_sha224();
    exports2.sha256 = require_sha2562();
    exports2.sha384 = require_sha384();
    exports2.sha512 = require_sha5122();
  }
});

// node_modules/cipher-base/index.js
var require_cipher_base = __commonJS({
  "node_modules/cipher-base/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var StringDecoder = require_string_decoder().StringDecoder;
    var inherits = require_inherits_browser();
    function CipherBase(hashMode) {
      Transform.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this["final"] = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits(CipherBase, Transform);
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && ArrayBuffer.isView && (Buffer2.prototype instanceof Uint8Array || Buffer2.TYPED_ARRAY_SUPPORT);
    function toBuffer(data, encoding) {
      if (data instanceof Buffer2) {
        return data;
      }
      if (typeof data === "string") {
        return Buffer2.from(data, encoding);
      }
      if (useArrayBuffer && ArrayBuffer.isView(data)) {
        if (data.byteLength === 0) {
          return Buffer2.alloc(0);
        }
        var res = Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
        if (res.byteLength === data.byteLength) {
          return res;
        }
      }
      if (useUint8Array && data instanceof Uint8Array) {
        return Buffer2.from(data);
      }
      if (Buffer2.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
        return Buffer2.from(data);
      }
      throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      var bufferData = toBuffer(data, inputEnc);
      var outData = this._update(bufferData);
      if (this.hashMode) {
        return this;
      }
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e) {
        err = e;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done) {
      var err;
      try {
        this.push(this.__final());
      } catch (e) {
        err = e;
      }
      done(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer2.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc) {
        throw new Error("can’t switch encodings");
      }
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    module2.exports = CipherBase;
  }
});

// node_modules/create-hash/browser.js
var require_browser2 = __commonJS({
  "node_modules/create-hash/browser.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var MD5 = require_md5();
    var RIPEMD160 = require_ripemd1602();
    var sha = require_sha2();
    var Base = require_cipher_base();
    function Hash2(hash2) {
      Base.call(this, "digest");
      this._hash = hash2;
    }
    inherits(Hash2, Base);
    Hash2.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash2.prototype._final = function() {
      return this._hash.digest();
    };
    module2.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === "md5") return new MD5();
      if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD160();
      return new Hash2(sha(alg));
    };
  }
});

// node_modules/create-hmac/legacy.js
var require_legacy = __commonJS({
  "node_modules/create-hmac/legacy.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var Base = require_cipher_base();
    var ZEROS = Buffer2.alloc(128);
    var blocksize = 64;
    function Hmac(alg, key) {
      Base.call(this, "digest");
      if (typeof key === "string") {
        key = Buffer2.from(key);
      }
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        key = alg(key);
      } else if (key.length < blocksize) {
        key = Buffer2.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
      var opad = this._opad = Buffer2.allocUnsafe(blocksize);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 54;
        opad[i] = key[i] ^ 92;
      }
      this._hash = [ipad];
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.push(data);
    };
    Hmac.prototype._final = function() {
      var h = this._alg(Buffer2.concat(this._hash));
      return this._alg(Buffer2.concat([this._opad, h]));
    };
    module2.exports = Hmac;
  }
});

// node_modules/create-hash/md5.js
var require_md52 = __commonJS({
  "node_modules/create-hash/md5.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var MD5 = require_md5();
    module2.exports = function(buffer) {
      return new MD5().update(buffer).digest();
    };
  }
});

// node_modules/create-hmac/browser.js
var require_browser3 = __commonJS({
  "node_modules/create-hmac/browser.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Legacy = require_legacy();
    var Base = require_cipher_base();
    var Buffer2 = require_safe_buffer().Buffer;
    var md5 = require_md52();
    var RIPEMD160 = require_ripemd1602();
    var sha = require_sha2();
    var ZEROS = Buffer2.alloc(128);
    function Hmac(alg, key) {
      Base.call(this, "digest");
      if (typeof key === "string") {
        key = Buffer2.from(key);
      }
      var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        var hash2 = alg === "rmd160" ? new RIPEMD160() : sha(alg);
        key = hash2.update(key).digest();
      } else if (key.length < blocksize) {
        key = Buffer2.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
      var opad = this._opad = Buffer2.allocUnsafe(blocksize);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 54;
        opad[i] = key[i] ^ 92;
      }
      this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
      this._hash.update(ipad);
    }
    inherits(Hmac, Base);
    Hmac.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hmac.prototype._final = function() {
      var h = this._hash.digest();
      var hash2 = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
      return hash2.update(this._opad).update(h).digest();
    };
    module2.exports = function createHmac(alg, key) {
      alg = alg.toLowerCase();
      if (alg === "rmd160" || alg === "ripemd160") {
        return new Hmac("rmd160", key);
      }
      if (alg === "md5") {
        return new Legacy(md5, key);
      }
      return new Hmac(alg, key);
    };
  }
});

// node_modules/bip32/src/crypto.js
var require_crypto = __commonJS({
  "node_modules/bip32/src/crypto.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var createHash = require_browser2();
    var createHmac = require_browser3();
    function hash160(buffer) {
      const sha256Hash = createHash("sha256").update(buffer).digest();
      try {
        return createHash("rmd160").update(sha256Hash).digest();
      } catch (err) {
        return createHash("ripemd160").update(sha256Hash).digest();
      }
    }
    exports2.hash160 = hash160;
    function hmacSHA512(key, data) {
      return createHmac("sha512", key).update(data).digest();
    }
    exports2.hmacSHA512 = hmacSHA512;
  }
});

// node_modules/base-x/src/index.js
var require_src2 = __commonJS({
  "node_modules/base-x/src/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode3(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size4);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size4 - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size4 - length;
        while (it2 !== size4 && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size4; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size4 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size4);
        while (psz < source.length) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size4 - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size4 - length;
        while (it4 !== size4 && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size4 - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size4) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode2(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode3,
        decodeUnsafe,
        decode: decode2
      };
    }
    module2.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var basex = require_src2();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module2.exports = basex(ALPHABET);
  }
});

// node_modules/bs58check/base.js
var require_base = __commonJS({
  "node_modules/bs58check/base.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var base58 = require_bs58();
    var Buffer2 = require_safe_buffer().Buffer;
    module2.exports = function(checksumFn) {
      function encode3(payload) {
        var checksum = checksumFn(payload);
        return base58.encode(Buffer2.concat([
          payload,
          checksum
        ], payload.length + 4));
      }
      function decodeRaw(buffer) {
        var payload = buffer.slice(0, -4);
        var checksum = buffer.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
        return payload;
      }
      function decodeUnsafe(string) {
        var buffer = base58.decodeUnsafe(string);
        if (!buffer) return;
        return decodeRaw(buffer);
      }
      function decode2(string) {
        var buffer = base58.decode(string);
        var payload = decodeRaw(buffer, checksumFn);
        if (!payload) throw new Error("Invalid checksum");
        return payload;
      }
      return {
        encode: encode3,
        decode: decode2,
        decodeUnsafe
      };
    };
  }
});

// node_modules/bs58check/index.js
var require_bs58check = __commonJS({
  "node_modules/bs58check/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var createHash = require_browser2();
    var bs58checkBase = require_base();
    function sha256x2(buffer) {
      var tmp = createHash("sha256").update(buffer).digest();
      return createHash("sha256").update(tmp).digest();
    }
    module2.exports = bs58checkBase(sha256x2);
  }
});

// node_modules/tiny-secp256k1/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/tiny-secp256k1/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    (function(module3, exports3) {
      "use strict";
      function assert5(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports3.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num2) {
        if (num2 instanceof BN2) {
          return true;
        }
        return num2 !== null && typeof num2 === "object" && num2.constructor.wordSize === BN2.wordSize && Array.isArray(num2.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert5(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert5(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert5(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index2) {
        var c = string.charCodeAt(index2);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index2) {
        var r2 = parseHex4Bits(string, index2);
        if (index2 - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index2 - 1) << 4;
        }
        return r2;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r2 *= mul;
          if (c >= 49) {
            r2 += c - 49 + 10;
          } else if (c >= 17) {
            r2 += c - 17 + 10;
          } else {
            r2 += c;
          }
        }
        return r2;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod2; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r2 = new BN2(null);
        this.copy(r2);
        return r2;
      };
      BN2.prototype._expand = function _expand(size4) {
        while (this.length < size4) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString4(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r2 = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros2[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert5(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber2() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert5(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert5(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert5(byteLength <= reqLength, "byte array longer than desired length");
        assert5(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r2 = 0;
          if (t >= 4096) {
            r2 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r2 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r2 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r2 += 2;
            t >>>= 2;
          }
          return r2 + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r2 = 0;
        if ((t & 8191) === 0) {
          r2 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r2 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r2 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r2 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num2) {
        var w = new Array(num2.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num2.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r2 = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r2 += b;
          if (b !== 26) break;
        }
        return r2;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num2) {
        while (this.length < num2.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num2.length; i++) {
          this.words[i] = this.words[i] | num2.words[i];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num2) {
        assert5((this.negative | num2.negative) === 0);
        return this.iuor(num2);
      };
      BN2.prototype.or = function or2(num2) {
        if (this.length > num2.length) return this.clone().ior(num2);
        return num2.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num2) {
        if (this.length > num2.length) return this.clone().iuor(num2);
        return num2.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num2) {
        var b;
        if (this.length > num2.length) {
          b = num2;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num2.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num2) {
        assert5((this.negative | num2.negative) === 0);
        return this.iuand(num2);
      };
      BN2.prototype.and = function and2(num2) {
        if (this.length > num2.length) return this.clone().iand(num2);
        return num2.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num2) {
        if (this.length > num2.length) return this.clone().iuand(num2);
        return num2.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num2) {
        var a;
        var b;
        if (this.length > num2.length) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num2) {
        assert5((this.negative | num2.negative) === 0);
        return this.iuxor(num2);
      };
      BN2.prototype.xor = function xor2(num2) {
        if (this.length > num2.length) return this.clone().ixor(num2);
        return num2.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num2) {
        if (this.length > num2.length) return this.clone().iuxor(num2);
        return num2.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert5(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert5(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num2) {
        var r2;
        if (this.negative !== 0 && num2.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num2);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num2.negative !== 0) {
          num2.negative = 0;
          r2 = this.isub(num2);
          num2.negative = 1;
          return r2._normSign();
        }
        var a, b;
        if (this.length > num2.length) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r2 = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN2.prototype.add = function add2(num2) {
        var res;
        if (num2.negative !== 0 && this.negative === 0) {
          num2.negative = 0;
          res = this.sub(num2);
          num2.negative ^= 1;
          return res;
        } else if (num2.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num2.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num2.length) return this.clone().iadd(num2);
        return num2.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num2) {
        if (num2.negative !== 0) {
          num2.negative = 0;
          var r2 = this.iadd(num2);
          num2.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num2);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num2);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num2;
        } else {
          a = num2;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r2 = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num2) {
        return this.clone().isub(num2);
      };
      function smallMulTo(self2, num2, out) {
        out.negative = num2.negative ^ self2.negative;
        var len = self2.length + num2.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num2.words[0] | 0;
        var r2 = a * b;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num2.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num2.words[j] | 0;
            r2 = a * b + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num2, out) {
        var a = self2.words;
        var b = num2.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num2.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num2, out) {
        out.negative = num2.negative ^ self2.negative;
        out.length = self2.length + num2.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num2.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num2.words[j] | 0;
            var r2 = a * b;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num2, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num2, out);
      }
      BN2.prototype.mulTo = function mulTo(num2, out) {
        var res;
        var len = this.length + num2.length;
        if (this.length === 10 && num2.length === 10) {
          res = comb10MulTo(this, num2, out);
        } else if (len < 63) {
          res = smallMulTo(this, num2, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num2, out);
        } else {
          res = jumboMulTo(this, num2, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN2.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert5(carry === 0);
        assert5((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num2) {
        var out = new BN2(null);
        out.words = new Array(this.length + num2.length);
        return this.mulTo(num2, out);
      };
      BN2.prototype.mulf = function mulf(num2) {
        var out = new BN2(null);
        out.words = new Array(this.length + num2.length);
        return jumboMulTo(this, num2, out);
      };
      BN2.prototype.imul = function imul(num2) {
        return this.clone().mulTo(num2, this);
      };
      BN2.prototype.imuln = function imuln(num2) {
        assert5(typeof num2 === "number");
        assert5(num2 < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num2;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num2) {
        return this.clone().imuln(num2);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num2) {
        var w = toBitArray(num2);
        if (w.length === 0) return new BN2(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i;
        if (r2 !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r2;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert5(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert5(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r2 = bits % 26;
        var s = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert5(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert5(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert5(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        assert5(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r2 !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num2) {
        assert5(typeof num2 === "number");
        assert5(num2 < 67108864);
        if (num2 < 0) return this.isubn(-num2);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num2) {
            this.words[0] = num2 - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num2);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num2);
      };
      BN2.prototype._iaddn = function _iaddn(num2) {
        this.words[0] += num2;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num2) {
        assert5(typeof num2 === "number");
        assert5(num2 < 67108864);
        if (num2 < 0) return this.iaddn(-num2);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num2);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num2;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num2) {
        return this.clone().iaddn(num2);
      };
      BN2.prototype.subn = function subn(num2) {
        return this.clone().isubn(num2);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num2, mul, shift4) {
        var len = num2.length + shift4;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num2.length; i++) {
          w = (this.words[i + shift4] | 0) + carry;
          var right = (num2.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift4] = w & 67108863;
        }
        for (; i < this.length - shift4; i++) {
          w = (this.words[i + shift4] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift4] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert5(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num2, mode) {
        var shift4 = this.length - num2.length;
        var a = this.clone();
        var b = num2;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift4 = 26 - bhiBits;
        if (shift4 !== 0) {
          b = b.ushln(shift4);
          a.iushln(shift4);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift4 !== 0) {
          a.iushrn(shift4);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num2, mode, positive) {
        assert5(!num2.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num2.negative === 0) {
          res = this.neg().divmod(num2, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num2);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num2.negative !== 0) {
          res = this.divmod(num2.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num2.negative) !== 0) {
          res = this.neg().divmod(num2.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num2);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num2.length > this.length || this.cmp(num2) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num2.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num2.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num2.words[0]))
            };
          }
          return {
            div: this.divn(num2.words[0]),
            mod: new BN2(this.modn(num2.words[0]))
          };
        }
        return this._wordDiv(num2, mode);
      };
      BN2.prototype.div = function div(num2) {
        return this.divmod(num2, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num2) {
        return this.divmod(num2, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num2) {
        return this.divmod(num2, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num2) {
        var dm = this.divmod(num2);
        if (dm.mod.isZero()) return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num2) : dm.mod;
        var half = num2.ushrn(1);
        var r2 = num2.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num2) {
        assert5(num2 <= 67108863);
        var p = (1 << 26) % num2;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num2;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num2) {
        assert5(num2 <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num2 | 0;
          carry = w % num2;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num2) {
        return this.clone().idivn(num2);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert5(p.negative === 0);
        assert5(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g2 = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g2;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g2)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert5(p.negative === 0);
        assert5(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num2) {
        if (this.isZero()) return num2.abs();
        if (num2.isZero()) return this.abs();
        var a = this.clone();
        var b = num2.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift4 = 0; a.isEven() && b.isEven(); shift4++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r2 = a.cmp(b);
          if (r2 < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r2 === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift4);
      };
      BN2.prototype.invm = function invm(num2) {
        return this.egcd(num2).a.umod(num2);
      };
      BN2.prototype.isEven = function isEven2() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd2() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num2) {
        return this.words[0] & num2;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert5(typeof bit === "number");
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero2() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num2) {
        var negative = num2 < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num2 = -num2;
          }
          assert5(num2 <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num2 ? 0 : w < num2 ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num2) {
        if (this.negative !== 0 && num2.negative === 0) return -1;
        if (this.negative === 0 && num2.negative !== 0) return 1;
        var res = this.ucmp(num2);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num2) {
        if (this.length > num2.length) return 1;
        if (this.length < num2.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num2.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num2) {
        return this.cmpn(num2) === 1;
      };
      BN2.prototype.gt = function gt(num2) {
        return this.cmp(num2) === 1;
      };
      BN2.prototype.gten = function gten(num2) {
        return this.cmpn(num2) >= 0;
      };
      BN2.prototype.gte = function gte(num2) {
        return this.cmp(num2) >= 0;
      };
      BN2.prototype.ltn = function ltn(num2) {
        return this.cmpn(num2) === -1;
      };
      BN2.prototype.lt = function lt(num2) {
        return this.cmp(num2) === -1;
      };
      BN2.prototype.lten = function lten(num2) {
        return this.cmpn(num2) <= 0;
      };
      BN2.prototype.lte = function lte(num2) {
        return this.cmp(num2) <= 0;
      };
      BN2.prototype.eqn = function eqn(num2) {
        return this.cmpn(num2) === 0;
      };
      BN2.prototype.eq = function eq(num2) {
        return this.cmp(num2) === 0;
      };
      BN2.red = function red(num2) {
        return new Red(num2);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        assert5(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert5(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert5(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num2) {
        assert5(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num2);
      };
      BN2.prototype.redIAdd = function redIAdd(num2) {
        assert5(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num2);
      };
      BN2.prototype.redSub = function redSub(num2) {
        assert5(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num2);
      };
      BN2.prototype.redISub = function redISub(num2) {
        assert5(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num2);
      };
      BN2.prototype.redShl = function redShl(num2) {
        assert5(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num2);
      };
      BN2.prototype.redMul = function redMul(num2) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num2);
        return this.red.mul(this, num2);
      };
      BN2.prototype.redIMul = function redIMul(num2) {
        assert5(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num2);
        return this.red.imul(this, num2);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert5(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert5(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert5(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert5(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert5(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num2) {
        assert5(this.red && !num2.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num2);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num2) {
        var r2 = num2;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num2) {
        return num2.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num2) {
        num2.words[num2.length] = 0;
        num2.words[num2.length + 1] = 0;
        num2.length += 2;
        var lo = 0;
        for (var i = 0; i < num2.length; i++) {
          var w = num2.words[i] | 0;
          lo += w * 977;
          num2.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num2.words[num2.length - 1] === 0) {
          num2.length--;
          if (num2.words[num2.length - 1] === 0) {
            num2.length--;
          }
        }
        return num2;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num2) {
        var carry = 0;
        for (var i = 0; i < num2.length; i++) {
          var hi = (num2.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num2.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num2.words[num2.length++] = carry;
        }
        return num2;
      };
      BN2._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert5(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert5(a.negative === 0, "red works only with positives");
        assert5(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert5((a.negative | b.negative) === 0, "red works only with positives");
        assert5(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add2(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num2) {
        this._verify1(a);
        return this.imod(a.ushln(num2));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert5(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert5(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r2 = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert5(i < m);
          var b = this.pow(c, new BN2(1).iushln(m - i - 1));
          r2 = r2.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num2) {
        if (num2.isZero()) return new BN2(1).toRed(this);
        if (num2.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num2.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num2.length - 1; i >= 0; i--) {
          var word = num2.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num2) {
        var r2 = num2.umod(this.m);
        return r2 === num2 ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num2) {
        var res = num2.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num2) {
        return new Mont(num2);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num2) {
        return this.imod(num2.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num2) {
        var r2 = this.imod(num2.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/tiny-secp256k1/rfc6979.js
var require_rfc6979 = __commonJS({
  "node_modules/tiny-secp256k1/rfc6979.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var createHmac = require_browser3();
    var ONE1 = Buffer.alloc(1, 1);
    var ZERO1 = Buffer.alloc(1, 0);
    function deterministicGenerateK(hash2, x, checkSig, isPrivate, extraEntropy) {
      let k = Buffer.alloc(32, 0);
      let v = Buffer.alloc(32, 1);
      k = createHmac("sha256", k).update(v).update(ZERO1).update(x).update(hash2).update(extraEntropy || "").digest();
      v = createHmac("sha256", k).update(v).digest();
      k = createHmac("sha256", k).update(v).update(ONE1).update(x).update(hash2).update(extraEntropy || "").digest();
      v = createHmac("sha256", k).update(v).digest();
      v = createHmac("sha256", k).update(v).digest();
      let T = v;
      while (!isPrivate(T) || !checkSig(T)) {
        k = createHmac("sha256", k).update(v).update(ZERO1).digest();
        v = createHmac("sha256", k).update(v).digest();
        v = createHmac("sha256", k).update(v).digest();
        T = v;
      }
      return T;
    }
    module2.exports = deterministicGenerateK;
  }
});

// node_modules/tiny-secp256k1/js.js
var require_js = __commonJS({
  "node_modules/tiny-secp256k1/js.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var BN2 = require_bn2();
    var EC = require_elliptic().ec;
    var secp256k1 = new EC("secp256k1");
    var deterministicGenerateK = require_rfc6979();
    var ZERO32 = Buffer.alloc(32, 0);
    var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
    var EC_P = Buffer.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", "hex");
    var n = secp256k1.curve.n;
    var nDiv2 = n.shrn(1);
    var G = secp256k1.curve.g;
    var THROW_BAD_PRIVATE = "Expected Private";
    var THROW_BAD_POINT = "Expected Point";
    var THROW_BAD_TWEAK = "Expected Tweak";
    var THROW_BAD_HASH = "Expected Hash";
    var THROW_BAD_SIGNATURE = "Expected Signature";
    var THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)";
    function isScalar(x) {
      return x instanceof Uint8Array && x.length === 32;
    }
    function isOrderScalar(x) {
      if (!isScalar(x)) return false;
      return EC_GROUP_ORDER.compare(x) > 0;
    }
    function isPoint(p) {
      if (!(p instanceof Uint8Array)) return false;
      if (p.length < 33) return false;
      const t = p[0];
      const x = p.subarray(1, 33);
      if (ZERO32.compare(x) === 0) return false;
      if (EC_P.compare(x) <= 0) return false;
      if ((t === 2 || t === 3) && p.length === 33) {
        try {
          decodeFrom(p);
        } catch (e) {
          return false;
        }
        return true;
      }
      const y = p.subarray(33);
      if (ZERO32.compare(y) === 0) return false;
      if (EC_P.compare(y) <= 0) return false;
      if (t === 4 && p.length === 65) return true;
      return false;
    }
    function __isPointCompressed(p) {
      return p[0] !== 4;
    }
    function isPointCompressed(p) {
      if (!isPoint(p)) return false;
      return __isPointCompressed(p);
    }
    function isPrivate(x) {
      if (!isScalar(x)) return false;
      return ZERO32.compare(x) < 0 && // > 0
      EC_GROUP_ORDER.compare(x) > 0;
    }
    function isSignature(value) {
      const r2 = value.subarray(0, 32);
      const s = value.subarray(32, 64);
      return value instanceof Uint8Array && value.length === 64 && EC_GROUP_ORDER.compare(r2) > 0 && EC_GROUP_ORDER.compare(s) > 0;
    }
    function assumeCompression(value, pubkey) {
      if (value === void 0 && pubkey !== void 0) return __isPointCompressed(pubkey);
      if (value === void 0) return true;
      return value;
    }
    function fromBuffer(d) {
      return new BN2(d);
    }
    function toBuffer(d) {
      return d.toArrayLike(Buffer, "be", 32);
    }
    function decodeFrom(P) {
      return secp256k1.curve.decodePoint(P);
    }
    function getEncoded(P, compressed) {
      return Buffer.from(P._encode(compressed));
    }
    function pointAdd(pA, pB, __compressed) {
      if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT);
      if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT);
      const a = decodeFrom(pA);
      const b = decodeFrom(pB);
      const pp = a.add(b);
      if (pp.isInfinity()) return null;
      const compressed = assumeCompression(__compressed, pA);
      return getEncoded(pp, compressed);
    }
    function pointAddScalar(p, tweak, __compressed) {
      if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
      if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
      const compressed = assumeCompression(__compressed, p);
      const pp = decodeFrom(p);
      if (ZERO32.compare(tweak) === 0) return getEncoded(pp, compressed);
      const tt = fromBuffer(tweak);
      const qq = G.mul(tt);
      const uu = pp.add(qq);
      if (uu.isInfinity()) return null;
      return getEncoded(uu, compressed);
    }
    function pointCompress(p, __compressed) {
      if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
      const pp = decodeFrom(p);
      if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT);
      const compressed = assumeCompression(__compressed, p);
      return getEncoded(pp, compressed);
    }
    function pointFromScalar(d, __compressed) {
      if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
      const dd = fromBuffer(d);
      const pp = G.mul(dd);
      if (pp.isInfinity()) return null;
      const compressed = assumeCompression(__compressed);
      return getEncoded(pp, compressed);
    }
    function pointMultiply(p, tweak, __compressed) {
      if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
      if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
      const compressed = assumeCompression(__compressed, p);
      const pp = decodeFrom(p);
      const tt = fromBuffer(tweak);
      const qq = pp.mul(tt);
      if (qq.isInfinity()) return null;
      return getEncoded(qq, compressed);
    }
    function privateAdd(d, tweak) {
      if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
      if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
      const dd = fromBuffer(d);
      const tt = fromBuffer(tweak);
      const dt = toBuffer(dd.add(tt).umod(n));
      if (!isPrivate(dt)) return null;
      return dt;
    }
    function privateSub(d, tweak) {
      if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
      if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
      const dd = fromBuffer(d);
      const tt = fromBuffer(tweak);
      const dt = toBuffer(dd.sub(tt).umod(n));
      if (!isPrivate(dt)) return null;
      return dt;
    }
    function sign(hash2, x) {
      return __sign(hash2, x);
    }
    function signWithEntropy(hash2, x, addData) {
      return __sign(hash2, x, addData);
    }
    function __sign(hash2, x, addData) {
      if (!isScalar(hash2)) throw new TypeError(THROW_BAD_HASH);
      if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE);
      if (addData !== void 0 && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA);
      const d = fromBuffer(x);
      const e = fromBuffer(hash2);
      let r2, s;
      const checkSig = function(k) {
        const kI = fromBuffer(k);
        const Q = G.mul(kI);
        if (Q.isInfinity()) return false;
        r2 = Q.x.umod(n);
        if (r2.isZero() === 0) return false;
        s = kI.invm(n).mul(e.add(d.mul(r2))).umod(n);
        if (s.isZero() === 0) return false;
        return true;
      };
      deterministicGenerateK(hash2, x, checkSig, isPrivate, addData);
      if (s.cmp(nDiv2) > 0) {
        s = n.sub(s);
      }
      const buffer = Buffer.allocUnsafe(64);
      toBuffer(r2).copy(buffer, 0);
      toBuffer(s).copy(buffer, 32);
      return buffer;
    }
    function verify(hash2, q, signature, strict) {
      if (!isScalar(hash2)) throw new TypeError(THROW_BAD_HASH);
      if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT);
      if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE);
      const Q = decodeFrom(q);
      const r2 = fromBuffer(signature.subarray(0, 32));
      const s = fromBuffer(signature.subarray(32, 64));
      if (strict && s.cmp(nDiv2) > 0) {
        return false;
      }
      if (r2.gtn(0) <= 0) return false;
      if (s.gtn(0) <= 0) return false;
      const e = fromBuffer(hash2);
      const sInv = s.invm(n);
      const u1 = e.mul(sInv).umod(n);
      const u2 = r2.mul(sInv).umod(n);
      const R = G.mulAdd(u1, Q, u2);
      if (R.isInfinity()) return false;
      const xR = R.x;
      const v = xR.umod(n);
      return v.eq(r2);
    }
    module2.exports = {
      isPoint,
      isPointCompressed,
      isPrivate,
      pointAdd,
      pointAddScalar,
      pointCompress,
      pointFromScalar,
      pointMultiply,
      privateAdd,
      privateSub,
      sign,
      signWithEntropy,
      verify
    };
  }
});

// node_modules/typeforce/native.js
var require_native = __commonJS({
  "node_modules/typeforce/native.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var types2 = {
      Array: function(value) {
        return value !== null && value !== void 0 && value.constructor === Array;
      },
      Boolean: function(value) {
        return typeof value === "boolean";
      },
      Function: function(value) {
        return typeof value === "function";
      },
      Nil: function(value) {
        return value === void 0 || value === null;
      },
      Number: function(value) {
        return typeof value === "number";
      },
      Object: function(value) {
        return typeof value === "object";
      },
      String: function(value) {
        return typeof value === "string";
      },
      "": function() {
        return true;
      }
    };
    types2.Null = types2.Nil;
    for (typeName in types2) {
      types2[typeName].toJSON = (function(t) {
        return t;
      }).bind(null, typeName);
    }
    var typeName;
    module2.exports = types2;
  }
});

// node_modules/typeforce/errors.js
var require_errors = __commonJS({
  "node_modules/typeforce/errors.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var native = require_native();
    function getTypeName(fn) {
      return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1];
    }
    function getValueTypeName(value) {
      return native.Nil(value) ? "" : getTypeName(value.constructor);
    }
    function getValue(value) {
      if (native.Function(value)) return "";
      if (native.String(value)) return JSON.stringify(value);
      if (value && native.Object(value)) return "";
      return value;
    }
    function captureStackTrace(e, t) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(e, t);
      }
    }
    function tfJSON(type) {
      if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type);
      if (native.Array(type)) return "Array";
      if (type && native.Object(type)) return "Object";
      return type !== void 0 ? type : "";
    }
    function tfErrorString(type, value, valueTypeName) {
      var valueJson = getValue(value);
      return "Expected " + tfJSON(type) + ", got" + (valueTypeName !== "" ? " " + valueTypeName : "") + (valueJson !== "" ? " " + valueJson : "");
    }
    function TfTypeError(type, value, valueTypeName) {
      valueTypeName = valueTypeName || getValueTypeName(value);
      this.message = tfErrorString(type, value, valueTypeName);
      captureStackTrace(this, TfTypeError);
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfTypeError.prototype = Object.create(Error.prototype);
    TfTypeError.prototype.constructor = TfTypeError;
    function tfPropertyErrorString(type, label, name, value, valueTypeName) {
      var description = '" of type ';
      if (label === "key") description = '" with key type ';
      return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName);
    }
    function TfPropertyTypeError(type, property, label, value, valueTypeName) {
      if (type) {
        valueTypeName = valueTypeName || getValueTypeName(value);
        this.message = tfPropertyErrorString(type, label, property, value, valueTypeName);
      } else {
        this.message = 'Unexpected property "' + property + '"';
      }
      captureStackTrace(this, TfTypeError);
      this.__label = label;
      this.__property = property;
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfPropertyTypeError.prototype = Object.create(Error.prototype);
    TfPropertyTypeError.prototype.constructor = TfTypeError;
    function tfCustomError(expected, actual) {
      return new TfTypeError(expected, {}, actual);
    }
    function tfSubError(e, property, label) {
      if (e instanceof TfPropertyTypeError) {
        property = property + "." + e.__property;
        e = new TfPropertyTypeError(
          e.__type,
          property,
          e.__label,
          e.__value,
          e.__valueTypeName
        );
      } else if (e instanceof TfTypeError) {
        e = new TfPropertyTypeError(
          e.__type,
          property,
          label,
          e.__value,
          e.__valueTypeName
        );
      }
      captureStackTrace(e);
      return e;
    }
    module2.exports = {
      TfTypeError,
      TfPropertyTypeError,
      tfCustomError,
      tfSubError,
      tfJSON,
      getValueTypeName
    };
  }
});

// node_modules/typeforce/extra.js
var require_extra = __commonJS({
  "node_modules/typeforce/extra.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var NATIVE = require_native();
    var ERRORS = require_errors();
    function _Buffer(value) {
      return Buffer.isBuffer(value);
    }
    function Hex(value) {
      return typeof value === "string" && /^([0-9a-f]{2})+$/i.test(value);
    }
    function _LengthN(type, length) {
      var name = type.toJSON();
      function Length(value) {
        if (!type(value)) return false;
        if (value.length === length) return true;
        throw ERRORS.tfCustomError(name + "(Length: " + length + ")", name + "(Length: " + value.length + ")");
      }
      Length.toJSON = function() {
        return name;
      };
      return Length;
    }
    var _ArrayN = _LengthN.bind(null, NATIVE.Array);
    var _BufferN = _LengthN.bind(null, _Buffer);
    var _HexN = _LengthN.bind(null, Hex);
    var _StringN = _LengthN.bind(null, NATIVE.String);
    function Range(a, b, f) {
      f = f || NATIVE.Number;
      function _range(value, strict) {
        return f(value, strict) && value > a && value < b;
      }
      _range.toJSON = function() {
        return `${f.toJSON()} between [${a}, ${b}]`;
      };
      return _range;
    }
    var INT53_MAX = Math.pow(2, 53) - 1;
    function Finite(value) {
      return typeof value === "number" && isFinite(value);
    }
    function Int8(value) {
      return value << 24 >> 24 === value;
    }
    function Int16(value) {
      return value << 16 >> 16 === value;
    }
    function Int32(value) {
      return (value | 0) === value;
    }
    function Int53(value) {
      return typeof value === "number" && value >= -INT53_MAX && value <= INT53_MAX && Math.floor(value) === value;
    }
    function UInt8(value) {
      return (value & 255) === value;
    }
    function UInt16(value) {
      return (value & 65535) === value;
    }
    function UInt32(value) {
      return value >>> 0 === value;
    }
    function UInt53(value) {
      return typeof value === "number" && value >= 0 && value <= INT53_MAX && Math.floor(value) === value;
    }
    var types2 = {
      ArrayN: _ArrayN,
      Buffer: _Buffer,
      BufferN: _BufferN,
      Finite,
      Hex,
      HexN: _HexN,
      Int8,
      Int16,
      Int32,
      Int53,
      Range,
      StringN: _StringN,
      UInt8,
      UInt16,
      UInt32,
      UInt53
    };
    for (typeName in types2) {
      types2[typeName].toJSON = (function(t) {
        return t;
      }).bind(null, typeName);
    }
    var typeName;
    module2.exports = types2;
  }
});

// node_modules/typeforce/index.js
var require_typeforce = __commonJS({
  "node_modules/typeforce/index.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var ERRORS = require_errors();
    var NATIVE = require_native();
    var tfJSON = ERRORS.tfJSON;
    var TfTypeError = ERRORS.TfTypeError;
    var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
    var tfSubError = ERRORS.tfSubError;
    var getValueTypeName = ERRORS.getValueTypeName;
    var TYPES = {
      arrayOf: function arrayOf(type, options) {
        type = compile(type);
        options = options || {};
        function _arrayOf(array, strict) {
          if (!NATIVE.Array(array)) return false;
          if (NATIVE.Nil(array)) return false;
          if (options.minLength !== void 0 && array.length < options.minLength) return false;
          if (options.maxLength !== void 0 && array.length > options.maxLength) return false;
          if (options.length !== void 0 && array.length !== options.length) return false;
          return array.every(function(value, i) {
            try {
              return typeforce(type, value, strict);
            } catch (e) {
              throw tfSubError(e, i);
            }
          });
        }
        _arrayOf.toJSON = function() {
          var str = "[" + tfJSON(type) + "]";
          if (options.length !== void 0) {
            str += "{" + options.length + "}";
          } else if (options.minLength !== void 0 || options.maxLength !== void 0) {
            str += "{" + (options.minLength === void 0 ? 0 : options.minLength) + "," + (options.maxLength === void 0 ? Infinity : options.maxLength) + "}";
          }
          return str;
        };
        return _arrayOf;
      },
      maybe: function maybe3(type) {
        type = compile(type);
        function _maybe(value, strict) {
          return NATIVE.Nil(value) || type(value, strict, maybe3);
        }
        _maybe.toJSON = function() {
          return "?" + tfJSON(type);
        };
        return _maybe;
      },
      map: function map(propertyType, propertyKeyType) {
        propertyType = compile(propertyType);
        if (propertyKeyType) propertyKeyType = compile(propertyKeyType);
        function _map(value, strict) {
          if (!NATIVE.Object(value)) return false;
          if (NATIVE.Nil(value)) return false;
          for (var propertyName in value) {
            try {
              if (propertyKeyType) {
                typeforce(propertyKeyType, propertyName, strict);
              }
            } catch (e) {
              throw tfSubError(e, propertyName, "key");
            }
            try {
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            } catch (e) {
              throw tfSubError(e, propertyName);
            }
          }
          return true;
        }
        if (propertyKeyType) {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyKeyType) + ": " + tfJSON(propertyType) + "}";
          };
        } else {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyType) + "}";
          };
        }
        return _map;
      },
      object: function object(uncompiled) {
        var type = {};
        for (var typePropertyName in uncompiled) {
          type[typePropertyName] = compile(uncompiled[typePropertyName]);
        }
        function _object(value, strict) {
          if (!NATIVE.Object(value)) return false;
          if (NATIVE.Nil(value)) return false;
          var propertyName;
          try {
            for (propertyName in type) {
              var propertyType = type[propertyName];
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            }
          } catch (e) {
            throw tfSubError(e, propertyName);
          }
          if (strict) {
            for (propertyName in value) {
              if (type[propertyName]) continue;
              throw new TfPropertyTypeError(void 0, propertyName);
            }
          }
          return true;
        }
        _object.toJSON = function() {
          return tfJSON(type);
        };
        return _object;
      },
      anyOf: function anyOf() {
        var types2 = [].slice.call(arguments).map(compile);
        function _anyOf(value, strict) {
          return types2.some(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e) {
              return false;
            }
          });
        }
        _anyOf.toJSON = function() {
          return types2.map(tfJSON).join("|");
        };
        return _anyOf;
      },
      allOf: function allOf() {
        var types2 = [].slice.call(arguments).map(compile);
        function _allOf(value, strict) {
          return types2.every(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e) {
              return false;
            }
          });
        }
        _allOf.toJSON = function() {
          return types2.map(tfJSON).join(" & ");
        };
        return _allOf;
      },
      quacksLike: function quacksLike(type) {
        function _quacksLike(value) {
          return type === getValueTypeName(value);
        }
        _quacksLike.toJSON = function() {
          return type;
        };
        return _quacksLike;
      },
      tuple: function tuple() {
        var types2 = [].slice.call(arguments).map(compile);
        function _tuple(values, strict) {
          if (NATIVE.Nil(values)) return false;
          if (NATIVE.Nil(values.length)) return false;
          if (strict && values.length !== types2.length) return false;
          return types2.every(function(type, i) {
            try {
              return typeforce(type, values[i], strict);
            } catch (e) {
              throw tfSubError(e, i);
            }
          });
        }
        _tuple.toJSON = function() {
          return "(" + types2.map(tfJSON).join(", ") + ")";
        };
        return _tuple;
      },
      value: function value(expected) {
        function _value(actual) {
          return actual === expected;
        }
        _value.toJSON = function() {
          return expected;
        };
        return _value;
      }
    };
    TYPES.oneOf = TYPES.anyOf;
    function compile(type) {
      if (NATIVE.String(type)) {
        if (type[0] === "?") return TYPES.maybe(type.slice(1));
        return NATIVE[type] || TYPES.quacksLike(type);
      } else if (type && NATIVE.Object(type)) {
        if (NATIVE.Array(type)) {
          if (type.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
          return TYPES.arrayOf(type[0]);
        }
        return TYPES.object(type);
      } else if (NATIVE.Function(type)) {
        return type;
      }
      return TYPES.value(type);
    }
    function typeforce(type, value, strict, surrogate) {
      if (NATIVE.Function(type)) {
        if (type(value, strict)) return true;
        throw new TfTypeError(surrogate || type, value);
      }
      return typeforce(compile(type), value, strict);
    }
    for (typeName in NATIVE) {
      typeforce[typeName] = NATIVE[typeName];
    }
    var typeName;
    for (typeName in TYPES) {
      typeforce[typeName] = TYPES[typeName];
    }
    var EXTRA = require_extra();
    for (typeName in EXTRA) {
      typeforce[typeName] = EXTRA[typeName];
    }
    typeforce.compile = compile;
    typeforce.TfTypeError = TfTypeError;
    typeforce.TfPropertyTypeError = TfPropertyTypeError;
    module2.exports = typeforce;
  }
});

// node_modules/wif/index.js
var require_wif = __commonJS({
  "node_modules/wif/index.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var bs58check = require_bs58check();
    function decodeRaw(buffer, version7) {
      if (version7 !== void 0 && buffer[0] !== version7) throw new Error("Invalid network version");
      if (buffer.length === 33) {
        return {
          version: buffer[0],
          privateKey: buffer.slice(1, 33),
          compressed: false
        };
      }
      if (buffer.length !== 34) throw new Error("Invalid WIF length");
      if (buffer[33] !== 1) throw new Error("Invalid compression flag");
      return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: true
      };
    }
    function encodeRaw(version7, privateKey, compressed) {
      var result2 = new Buffer(compressed ? 34 : 33);
      result2.writeUInt8(version7, 0);
      privateKey.copy(result2, 1);
      if (compressed) {
        result2[33] = 1;
      }
      return result2;
    }
    function decode2(string, version7) {
      return decodeRaw(bs58check.decode(string), version7);
    }
    function encode3(version7, privateKey, compressed) {
      if (typeof version7 === "number") return bs58check.encode(encodeRaw(version7, privateKey, compressed));
      return bs58check.encode(
        encodeRaw(
          version7.version,
          version7.privateKey,
          version7.compressed
        )
      );
    }
    module2.exports = {
      decode: decode2,
      decodeRaw,
      encode: encode3,
      encodeRaw
    };
  }
});

// node_modules/bip32/src/bip32.js
var require_bip32 = __commonJS({
  "node_modules/bip32/src/bip32.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto = require_crypto();
    var bs58check = require_bs58check();
    var ecc = require_js();
    var typeforce = require_typeforce();
    var wif = require_wif();
    var UINT256_TYPE = typeforce.BufferN(32);
    var NETWORK_TYPE = typeforce.compile({
      wif: typeforce.UInt8,
      bip32: {
        public: typeforce.UInt32,
        private: typeforce.UInt32
      }
    });
    var BITCOIN = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bc",
      bip32: {
        public: 76067358,
        private: 76066276
      },
      pubKeyHash: 0,
      scriptHash: 5,
      wif: 128
    };
    var HIGHEST_BIT = 2147483648;
    var UINT31_MAX = Math.pow(2, 31) - 1;
    function BIP32Path(value) {
      return typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
    }
    function UInt31(value) {
      return typeforce.UInt32(value) && value <= UINT31_MAX;
    }
    var BIP32 = class {
      constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0) {
        this.__D = __D;
        this.__Q = __Q;
        this.chainCode = chainCode;
        this.network = network;
        this.__DEPTH = __DEPTH;
        this.__INDEX = __INDEX;
        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
        typeforce(NETWORK_TYPE, network);
        this.lowR = false;
      }
      get depth() {
        return this.__DEPTH;
      }
      get index() {
        return this.__INDEX;
      }
      get parentFingerprint() {
        return this.__PARENT_FINGERPRINT;
      }
      get publicKey() {
        if (this.__Q === void 0)
          this.__Q = ecc.pointFromScalar(this.__D, true);
        return this.__Q;
      }
      get privateKey() {
        return this.__D;
      }
      get identifier() {
        return crypto.hash160(this.publicKey);
      }
      get fingerprint() {
        return this.identifier.slice(0, 4);
      }
      get compressed() {
        return true;
      }
      // Private === not neutered
      // Public === neutered
      isNeutered() {
        return this.__D === void 0;
      }
      neutered() {
        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
      }
      toBase58() {
        const network = this.network;
        const version7 = !this.isNeutered() ? network.bip32.private : network.bip32.public;
        const buffer = Buffer.allocUnsafe(78);
        buffer.writeUInt32BE(version7, 0);
        buffer.writeUInt8(this.depth, 4);
        buffer.writeUInt32BE(this.parentFingerprint, 5);
        buffer.writeUInt32BE(this.index, 9);
        this.chainCode.copy(buffer, 13);
        if (!this.isNeutered()) {
          buffer.writeUInt8(0, 45);
          this.privateKey.copy(buffer, 46);
        } else {
          this.publicKey.copy(buffer, 45);
        }
        return bs58check.encode(buffer);
      }
      toWIF() {
        if (!this.privateKey)
          throw new TypeError("Missing private key");
        return wif.encode(this.network.wif, this.privateKey, true);
      }
      // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
      derive(index2) {
        typeforce(typeforce.UInt32, index2);
        const isHardened = index2 >= HIGHEST_BIT;
        const data = Buffer.allocUnsafe(37);
        if (isHardened) {
          if (this.isNeutered())
            throw new TypeError("Missing private key for hardened child key");
          data[0] = 0;
          this.privateKey.copy(data, 1);
          data.writeUInt32BE(index2, 33);
        } else {
          this.publicKey.copy(data, 0);
          data.writeUInt32BE(index2, 33);
        }
        const I = crypto.hmacSHA512(this.chainCode, data);
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        if (!ecc.isPrivate(IL))
          return this.derive(index2 + 1);
        let hd;
        if (!this.isNeutered()) {
          const ki = ecc.privateAdd(this.privateKey, IL);
          if (ki == null)
            return this.derive(index2 + 1);
          hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index2, this.fingerprint.readUInt32BE(0));
        } else {
          const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
          if (Ki === null)
            return this.derive(index2 + 1);
          hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index2, this.fingerprint.readUInt32BE(0));
        }
        return hd;
      }
      deriveHardened(index2) {
        typeforce(UInt31, index2);
        return this.derive(index2 + HIGHEST_BIT);
      }
      derivePath(path) {
        typeforce(BIP32Path, path);
        let splitPath = path.split("/");
        if (splitPath[0] === "m") {
          if (this.parentFingerprint)
            throw new TypeError("Expected master, got child");
          splitPath = splitPath.slice(1);
        }
        return splitPath.reduce((prevHd, indexStr) => {
          let index2;
          if (indexStr.slice(-1) === `'`) {
            index2 = parseInt(indexStr.slice(0, -1), 10);
            return prevHd.deriveHardened(index2);
          } else {
            index2 = parseInt(indexStr, 10);
            return prevHd.derive(index2);
          }
        }, this);
      }
      sign(hash2, lowR) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (lowR === void 0)
          lowR = this.lowR;
        if (lowR === false) {
          return ecc.sign(hash2, this.privateKey);
        } else {
          let sig = ecc.sign(hash2, this.privateKey);
          const extraData = Buffer.alloc(32, 0);
          let counter = 0;
          while (sig[0] > 127) {
            counter++;
            extraData.writeUIntLE(counter, 0, 6);
            sig = ecc.signWithEntropy(hash2, this.privateKey, extraData);
          }
          return sig;
        }
      }
      verify(hash2, signature) {
        return ecc.verify(hash2, this.publicKey, signature);
      }
    };
    function fromBase58(inString, network) {
      const buffer = bs58check.decode(inString);
      if (buffer.length !== 78)
        throw new TypeError("Invalid buffer length");
      network = network || BITCOIN;
      const version7 = buffer.readUInt32BE(0);
      if (version7 !== network.bip32.private && version7 !== network.bip32.public)
        throw new TypeError("Invalid network version");
      const depth = buffer[4];
      const parentFingerprint = buffer.readUInt32BE(5);
      if (depth === 0) {
        if (parentFingerprint !== 0)
          throw new TypeError("Invalid parent fingerprint");
      }
      const index2 = buffer.readUInt32BE(9);
      if (depth === 0 && index2 !== 0)
        throw new TypeError("Invalid index");
      const chainCode = buffer.slice(13, 45);
      let hd;
      if (version7 === network.bip32.private) {
        if (buffer.readUInt8(45) !== 0)
          throw new TypeError("Invalid private key");
        const k = buffer.slice(46, 78);
        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index2, parentFingerprint);
      } else {
        const X = buffer.slice(45, 78);
        hd = fromPublicKeyLocal(X, chainCode, network, depth, index2, parentFingerprint);
      }
      return hd;
    }
    exports2.fromBase58 = fromBase58;
    function fromPrivateKey(privateKey, chainCode, network) {
      return fromPrivateKeyLocal(privateKey, chainCode, network);
    }
    exports2.fromPrivateKey = fromPrivateKey;
    function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index2, parentFingerprint) {
      typeforce({
        privateKey: UINT256_TYPE,
        chainCode: UINT256_TYPE
      }, { privateKey, chainCode });
      network = network || BITCOIN;
      if (!ecc.isPrivate(privateKey))
        throw new TypeError("Private key not in range [1, n)");
      return new BIP32(privateKey, void 0, chainCode, network, depth, index2, parentFingerprint);
    }
    function fromPublicKey(publicKey, chainCode, network) {
      return fromPublicKeyLocal(publicKey, chainCode, network);
    }
    exports2.fromPublicKey = fromPublicKey;
    function fromPublicKeyLocal(publicKey, chainCode, network, depth, index2, parentFingerprint) {
      typeforce({
        publicKey: typeforce.BufferN(33),
        chainCode: UINT256_TYPE
      }, { publicKey, chainCode });
      network = network || BITCOIN;
      if (!ecc.isPoint(publicKey))
        throw new TypeError("Point is not on the curve");
      return new BIP32(void 0, publicKey, chainCode, network, depth, index2, parentFingerprint);
    }
    function fromSeed(seed, network) {
      typeforce(typeforce.Buffer, seed);
      if (seed.length < 16)
        throw new TypeError("Seed should be at least 128 bits");
      if (seed.length > 64)
        throw new TypeError("Seed should be at most 512 bits");
      network = network || BITCOIN;
      const I = crypto.hmacSHA512(Buffer.from("Bitcoin seed", "utf8"), seed);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return fromPrivateKey(IL, IR, network);
    }
    exports2.fromSeed = fromSeed;
  }
});

// node_modules/bip32/src/index.js
var require_src3 = __commonJS({
  "node_modules/bip32/src/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bip32_1 = require_bip32();
    exports2.fromSeed = bip32_1.fromSeed;
    exports2.fromBase58 = bip32_1.fromBase58;
    exports2.fromPublicKey = bip32_1.fromPublicKey;
    exports2.fromPrivateKey = bip32_1.fromPrivateKey;
  }
});

// node_modules/@keplr-wallet/crypto/build/mnemonic.js
var require_mnemonic = __commonJS({
  "node_modules/@keplr-wallet/crypto/build/mnemonic.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Mnemonic = void 0;
    var bip39 = require_src();
    var bip32 = require_src3();
    var bs58check = require_bs58check();
    var buffer_1 = require_dist();
    var Mnemonic = class _Mnemonic {
      static generateWallet(rng, path = `m/44'/118'/0'/0/0`, password = "", strength = 256) {
        return __awaiter2(this, void 0, void 0, function* () {
          const mnemonic = yield _Mnemonic.generateSeed(rng, strength);
          const privKey = _Mnemonic.generateWalletFromMnemonic(mnemonic, path, password);
          return {
            privKey,
            mnemonic
          };
        });
      }
      static validateMnemonic(mnemonic) {
        return bip39.validateMnemonic(mnemonic);
      }
      static generateSeed(rng, strength = 128) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (strength % 32 !== 0) {
            throw new TypeError("invalid entropy");
          }
          let bytes = new Uint8Array(strength / 8);
          bytes = yield rng(bytes);
          return bip39.entropyToMnemonic(buffer_1.Buffer.from(bytes).toString("hex"));
        });
      }
      static generateWalletFromMnemonic(mnemonic, path = `m/44'/118'/0'/0/0`, password = "") {
        const seed = bip39.mnemonicToSeedSync(mnemonic, password);
        const masterSeed = bip32.fromSeed(seed);
        const hd = masterSeed.derivePath(path);
        const privateKey = hd.privateKey;
        if (!privateKey) {
          throw new Error("null hd key");
        }
        return privateKey;
      }
      static generateMasterSeedFromMnemonic(mnemonic, password = "") {
        const seed = bip39.mnemonicToSeedSync(mnemonic, password);
        const masterKey = bip32.fromSeed(seed);
        return buffer_1.Buffer.from(bs58check.decode(masterKey.toBase58()));
      }
      static generatePrivateKeyFromMasterSeed(seed, path = `m/44'/118'/0'/0/0`) {
        const masterSeed = bip32.fromBase58(bs58check.encode(seed));
        const hd = masterSeed.derivePath(path);
        const privateKey = hd.privateKey;
        if (!privateKey) {
          throw new Error("null hd key");
        }
        return privateKey;
      }
    };
    exports2.Mnemonic = Mnemonic;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.anumber = anumber;
    exports2.number = anumber;
    exports2.abytes = abytes;
    exports2.bytes = abytes;
    exports2.ahash = ahash;
    exports2.aexists = aexists;
    exports2.aoutput = aoutput;
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function isBytes2(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abytes(b, ...lengths) {
      if (!isBytes2(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min2 = instance.outputLen;
      if (out.length < min2) {
        throw new Error("digestInto() expects output buffer of length at least " + min2);
      }
    }
    var assert5 = {
      number: anumber,
      bytes: abytes,
      hash: ahash,
      exists: aexists,
      output: aoutput
    };
    exports2.default = assert5;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/utils.js
var require_utils2 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash = exports2.nextTick = exports2.byteSwapIfBE = exports2.byteSwap = exports2.isLE = exports2.rotl = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
    exports2.isBytes = isBytes2;
    exports2.byteSwap32 = byteSwap32;
    exports2.bytesToHex = bytesToHex;
    exports2.hexToBytes = hexToBytes;
    exports2.asyncLoop = asyncLoop;
    exports2.utf8ToBytes = utf8ToBytes;
    exports2.toBytes = toBytes2;
    exports2.concatBytes = concatBytes;
    exports2.checkOpts = checkOpts;
    exports2.wrapConstructor = wrapConstructor;
    exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
    exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    exports2.randomBytes = randomBytes;
    var crypto_1 = require_crypto2();
    var _assert_js_1 = require_assert();
    function isBytes2(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports2.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.createView = createView;
    var rotr = (word, shift4) => word << 32 - shift4 | word >>> shift4;
    exports2.rotr = rotr;
    var rotl = (word, shift4) => word << shift4 | word >>> 32 - shift4 >>> 0;
    exports2.rotl = rotl;
    exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports2.byteSwap = byteSwap;
    exports2.byteSwapIfBE = exports2.isLE ? (n) => n : (n) => (0, exports2.byteSwap)(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports2.byteSwap)(arr[i]);
      }
    }
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.abytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("utf8ToBytes expected string, got " + typeof str);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.abytes)(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.abytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    var Hash2 = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports2.Hash = Hash2;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return crypto_1.crypto.randomBytes(bytesLength);
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/_md.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HashMD = exports2.Maj = exports2.Chi = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils2();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var Chi = (a, b, c) => a & b ^ ~a & c;
    exports2.Chi = Chi;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    exports2.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.aexists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.aexists)(this);
        (0, _assert_js_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports2.HashMD = HashMD;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js
var require_sha2563 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.sha256 = exports2.SHA256 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils2();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset4) {
        for (let i = 0; i < 16; i++, offset4 += 4)
          SHA256_W[i] = view.getUint32(offset4, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    exports2.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmac = exports2.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils2();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.ahash)(hash2);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.aexists)(this);
        (0, _assert_js_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports2.HMAC = HMAC;
    var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
    exports2.hmac = hmac;
    exports2.hmac.create = (hash2, key) => new HMAC(hash2, key);
  }
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils3 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.notImplemented = exports2.bitMask = void 0;
    exports2.isBytes = isBytes2;
    exports2.abytes = abytes;
    exports2.abool = abool;
    exports2.bytesToHex = bytesToHex;
    exports2.numberToHexUnpadded = numberToHexUnpadded;
    exports2.hexToNumber = hexToNumber;
    exports2.hexToBytes = hexToBytes;
    exports2.bytesToNumberBE = bytesToNumberBE;
    exports2.bytesToNumberLE = bytesToNumberLE;
    exports2.numberToBytesBE = numberToBytesBE;
    exports2.numberToBytesLE = numberToBytesLE;
    exports2.numberToVarBytesBE = numberToVarBytesBE;
    exports2.ensureBytes = ensureBytes;
    exports2.concatBytes = concatBytes;
    exports2.equalBytes = equalBytes;
    exports2.utf8ToBytes = utf8ToBytes;
    exports2.inRange = inRange;
    exports2.aInRange = aInRange;
    exports2.bitLen = bitLen;
    exports2.bitGet = bitGet;
    exports2.bitSet = bitSet;
    exports2.createHmacDrbg = createHmacDrbg;
    exports2.validateObject = validateObject;
    exports2.memoized = memoized;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function isBytes2(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abytes(item) {
      if (!isBytes2(item))
        throw new Error("Uint8Array expected");
    }
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(title + " boolean expected, got " + value);
    }
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    function numberToHexUnpadded(num2) {
      const hex = num2.toString(16);
      return hex.length & 1 ? "0" + hex : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return hex === "" ? _0n : BigInt("0x" + hex);
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
      abytes(bytes);
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
        }
      } else if (isBytes2(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(title + " must be hex string or Uint8Array");
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(title + " of length " + expectedLength + " expected, got " + len);
      return res;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
    function inRange(n, min2, max2) {
      return isPosBig(n) && isPosBig(min2) && isPosBig(max2) && min2 <= n && n < max2;
    }
    function aInRange(title, n, min2, max2) {
      if (!inRange(n, min2, max2))
        throw new Error("expected valid " + title + ": " + min2 + " <= n < " + max2 + ", got " + n);
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports2.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error("invalid validator function");
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    exports2.notImplemented = notImplemented;
    function memoized(fn) {
      const map = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== void 0)
          return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
      };
    }
  }
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNegativeLE = void 0;
    exports2.mod = mod2;
    exports2.pow = pow;
    exports2.pow2 = pow2;
    exports2.invert = invert;
    exports2.tonelliShanks = tonelliShanks;
    exports2.FpSqrt = FpSqrt;
    exports2.validateField = validateField;
    exports2.FpPow = FpPow;
    exports2.FpInvertBatch = FpInvertBatch;
    exports2.FpDiv = FpDiv;
    exports2.FpLegendre = FpLegendre;
    exports2.FpIsSquare = FpIsSquare;
    exports2.nLength = nLength;
    exports2.Field = Field;
    exports2.FpSqrtOdd = FpSqrtOdd;
    exports2.FpSqrtEven = FpSqrtEven;
    exports2.hashToPrivateScalar = hashToPrivateScalar;
    exports2.getFieldBytesLength = getFieldBytesLength;
    exports2.getMinHashLength = getMinHashLength;
    exports2.mapHashToField = mapHashToField;
    var utils_js_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod2(a, b) {
      const result2 = a % b;
      return result2 >= _0n ? result2 : b + result2;
    }
    function pow(num2, power, modulo2) {
      if (power < _0n)
        throw new Error("invalid exponent, negatives unsupported");
      if (modulo2 <= _0n)
        throw new Error("invalid modulus");
      if (modulo2 === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num2 % modulo2;
        num2 = num2 * num2 % modulo2;
        power >>= _1n;
      }
      return res;
    }
    function pow2(x, power, modulo2) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo2;
      }
      return res;
    }
    function invert(number, modulo2) {
      if (number === _0n)
        throw new Error("invert: expected non-zero number");
      if (modulo2 <= _0n)
        throw new Error("invert: expected positive modulus, got " + modulo2);
      let a = mod2(number, modulo2);
      let b = modulo2;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r2 = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r2, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod2(x, modulo2);
    }
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {
        if (Z > 1e3)
          throw new Error("Cannot find square root: likely non-prime P");
      }
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root2 = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root2), n))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r2 = S;
        let g2 = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r2; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g2, _1n << BigInt(r2 - m - 1));
          g2 = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g2);
          r2 = m;
        }
        return x;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root2 = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root2), n))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root2 = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root2), n))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    var isNegativeLE = (num2, modulo2) => (mod2(num2, modulo2) & _1n) === _1n;
    exports2.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    function FpPow(f, num2, power) {
      if (power < _0n)
        throw new Error("invalid exponent, negatives unsupported");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num2;
      let p = f.ONE;
      let d = num2;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num2, i) => {
        if (f.is0(num2))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num2);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num2, i) => {
        if (f.is0(num2))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num2);
      }, inverted);
      return tmp;
    }
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    function FpLegendre(order) {
      const legendreConst = (order - _1n) / _2n;
      return (f, x) => f.pow(x, legendreConst);
    }
    function FpIsSquare(f) {
      const legendre = FpLegendre(f.ORDER);
      return (x) => {
        const p = legendre(f, x);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let sqrtP;
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num2) => mod2(num2, ORDER),
        isValid: (num2) => {
          if (typeof num2 !== "bigint")
            throw new Error("invalid field element: expected bigint, got " + typeof num2);
          return _0n <= num2 && num2 < ORDER;
        },
        is0: (num2) => num2 === _0n,
        isOdd: (num2) => (num2 & _1n) === _1n,
        neg: (num2) => mod2(-num2, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num2) => mod2(num2 * num2, ORDER),
        add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
        pow: (num2, power) => FpPow(f, num2, power),
        div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num2) => num2 * num2,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num2) => invert(num2, ORDER),
        sqrt: redef.sqrt || ((n) => {
          if (!sqrtP)
            sqrtP = FpSqrt(ORDER);
          return sqrtP(f, n);
        }),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num2) => isLE ? (0, utils_js_1.numberToBytesLE)(num2, BYTES) : (0, utils_js_1.numberToBytesBE)(num2, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root2 = Fp.sqrt(elm);
      return Fp.isOdd(root2) ? root2 : Fp.neg(root2);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root2 = Fp.sqrt(elm);
      return Fp.isOdd(root2) ? Fp.neg(root2) : root2;
    }
    function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
      hash2 = (0, utils_js_1.ensureBytes)("privateHash", hash2);
      const hashLen = hash2.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
      const num2 = isLE ? (0, utils_js_1.bytesToNumberLE)(hash2) : (0, utils_js_1.bytesToNumberBE)(hash2);
      return mod2(num2, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
      const num2 = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod2(num2, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wNAF = wNAF;
    exports2.pippenger = pippenger;
    exports2.precomputeMSMUnsafe = precomputeMSMUnsafe;
    exports2.validateBasic = validateBasic;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function constTimeNegate(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    function validateW(W, bits) {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
    }
    function calcWOpts(W, bits) {
      validateW(W, bits);
      const windows = Math.ceil(bits / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows, windowSize };
    }
    function validateMSMPoints(points, c) {
      if (!Array.isArray(points))
        throw new Error("array expected");
      points.forEach((p, i) => {
        if (!(p instanceof c))
          throw new Error("invalid point at index " + i);
      });
    }
    function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars))
        throw new Error("array of scalars expected");
      scalars.forEach((s, i) => {
        if (!field.isValid(s))
          throw new Error("invalid scalar at index " + i);
      });
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function getW(P) {
      return pointWindowSizes.get(P) || 1;
    }
    function wNAF(c, bits) {
      return {
        constTimeNegate,
        hasPrecomputes(elm) {
          return getW(elm) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder(elm, n, p = c.ZERO) {
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @param elm Point instance
         * @param W window size
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = calcWOpts(W, bits);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = calcWOpts(W, bits);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset4 = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset4;
            const offset22 = offset4 + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset22]));
            }
          }
          return { p, f };
        },
        /**
         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @param acc accumulator point to add result of multiplication
         * @returns point
         */
        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
          const { windows, windowSize } = calcWOpts(W, bits);
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset4 = window2 * windowSize;
            if (n === _0n)
              break;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            if (wbits === 0)
              continue;
            let curr = precomputes[offset4 + Math.abs(wbits) - 1];
            if (wbits < 0)
              curr = curr.negate();
            acc = acc.add(curr);
          }
          return acc;
        },
        getPrecomputes(W, P, transform) {
          let comp = pointPrecomputes.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1)
              pointPrecomputes.set(P, transform(comp));
          }
          return comp;
        },
        wNAFCached(P, n, transform) {
          const W = getW(P);
          return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
        },
        wNAFCachedUnsafe(P, n, transform, prev) {
          const W = getW(P);
          if (W === 1)
            return this.unsafeLadder(P, n, prev);
          return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize(P, W) {
          validateW(W, bits);
          pointWindowSizes.set(P, W);
          pointPrecomputes.delete(P);
        }
      };
    }
    function pippenger(c, fieldN, points, scalars) {
      validateMSMPoints(points, c);
      validateMSMScalars(scalars, fieldN);
      if (points.length !== scalars.length)
        throw new Error("arrays of points and scalars must have equal length");
      const zero = c.ZERO;
      const wbits = (0, utils_js_1.bitLen)(BigInt(points.length));
      const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
      const MASK = (1 << windowSize) - 1;
      const buckets = new Array(MASK + 1).fill(zero);
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < scalars.length; j++) {
          const scalar = scalars[j];
          const wbits2 = Number(scalar >> BigInt(i) & BigInt(MASK));
          buckets[wbits2] = buckets[wbits2].add(points[j]);
        }
        let resI = zero;
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
          sumI = sumI.add(buckets[j]);
          resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
          for (let j = 0; j < windowSize; j++)
            sum = sum.double();
      }
      return sum;
    }
    function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
      validateW(windowSize, fieldN.BITS);
      validateMSMPoints(points, c);
      const zero = c.ZERO;
      const tableSize = 2 ** windowSize - 1;
      const chunks = Math.ceil(fieldN.BITS / windowSize);
      const MASK = BigInt((1 << windowSize) - 1);
      const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
          res.push(acc);
          acc = acc.add(p);
        }
        return res;
      });
      return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
          throw new Error("array of scalars must be smaller than array of points");
        let res = zero;
        for (let i = 0; i < chunks; i++) {
          if (res !== zero)
            for (let j = 0; j < windowSize; j++)
              res = res.double();
          const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
          for (let j = 0; j < scalars.length; j++) {
            const n = scalars[j];
            const curr = Number(n >> shiftBy & MASK);
            if (!curr)
              continue;
            res = res.add(tables[j][curr - 1]);
          }
        }
        return res;
      };
    }
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
  }
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DER = void 0;
    exports2.weierstrassPoints = weierstrassPoints;
    exports2.weierstrass = weierstrass;
    exports2.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports2.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    var curve_js_1 = require_curve();
    var mod2 = require_modular();
    var ut = require_utils3();
    var utils_js_1 = require_utils3();
    function validateSigVerOpts(opts) {
      if (opts.lowS !== void 0)
        (0, utils_js_1.abool)("lowS", opts.lowS);
      if (opts.prehash !== void 0)
        (0, utils_js_1.abool)("prehash", opts.prehash);
    }
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports2.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E } = exports2.DER;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length & 1)
            throw new E("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = ut.numberToHexUnpadded(dataLen);
          if (len.length / 2 & 128)
            throw new E("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? ut.numberToHexUnpadded(len.length / 2 | 128) : "";
          const t = ut.numberToHexUnpadded(tag);
          return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E } = exports2.DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E("tlv.decode: wrong tlv");
          const first = data[pos++];
          const isLong2 = !!(first & 128);
          let length = 0;
          if (!isLong2)
            length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E("tlv.decode(long): zero leftmost byte");
            for (const b of lengthBytes)
              length = length << 8 | b;
            pos += lenLen;
            if (length < 128)
              throw new E("tlv.decode(long): not minimal encoding");
          }
          const v = data.subarray(pos, pos + length);
          if (v.length !== length)
            throw new E("tlv.decode: wrong value length");
          return { v, l: data.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num2) {
          const { Err: E } = exports2.DER;
          if (num2 < _0n)
            throw new E("integer: negative integers are not allowed");
          let hex = ut.numberToHexUnpadded(num2);
          if (Number.parseInt(hex[0], 16) & 8)
            hex = "00" + hex;
          if (hex.length & 1)
            throw new E("unexpected DER parsing assertion: unpadded hex");
          return hex;
        },
        decode(data) {
          const { Err: E } = exports2.DER;
          if (data[0] & 128)
            throw new E("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E("invalid signature integer: unnecessary leading zero");
          return b2n(data);
        }
      },
      toSig(hex) {
        const { Err: E, _int: int, _tlv: tlv } = exports2.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        ut.abytes(data);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E("invalid signature: left bytes after parsing");
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports2.DER;
        const rs = tlv.encode(2, int.encode(sig.r));
        const ss = tlv.encode(2, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(48, seq);
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const Fn = mod2.Field(CURVE.n, CURVE.nBitLength);
      const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes2 = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num2) {
        return ut.inRange(num2, _1n, CURVE.n);
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (ut.isBytes(key))
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("invalid private key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num2;
        try {
          num2 = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
        }
        if (wrapPrivateKey)
          num2 = mod2.mod(num2, N);
        ut.aInRange("private key", num2, _1n, N);
        return num2;
      }
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {
        const { px: x, py: y, pz: z } = p;
        if (Fp.eql(z, Fp.ONE))
          return { x, y };
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      });
      const assertValidMemo = (0, utils_js_1.memoized)((p) => {
        if (p.is0()) {
          if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        if (!Fp.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!p.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return true;
      });
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
          Object.freeze(this);
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes2((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // Multiscalar Multiplication
        static msm(points, scalars) {
          return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          wnaf.setWindowSize(this, windowSize);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          assertValidMemo(this);
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
          const { endo, n: N } = CURVE;
          ut.aInRange("scalar", sc, _0n, N);
          const I = Point.ZERO;
          if (sc === _0n)
            return I;
          if (this.is0() || sc === _1n)
            return this;
          if (!endo || wnaf.hasPrecomputes(this))
            return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          const { endo, n: N } = CURVE;
          ut.aInRange("scalar", scalar, _1n, N);
          let point, fake;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(scalar);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
          return toAffineMemo(this, iz);
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          (0, utils_js_1.abool)("isCompressed", isCompressed);
          this.assertValidity();
          return toBytes2(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          (0, utils_js_1.abool)("isCompressed", isCompressed);
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function modN(a) {
        return mod2.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod2.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          (0, utils_js_1.abool)("isCompressed", isCompressed);
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!ut.inRange(x, _1n, Fp.ORDER))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y;
            try {
              y = Fp.sqrt(y2);
            } catch (sqrtError) {
              const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("Point is not on curve" + suffix);
            }
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            const cl = compressedLen;
            const ul = uncompressedLen;
            throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
          }
        }
      });
      const numToNByteStr = (num2) => ut.bytesToHex(ut.numberToBytesBE(num2, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from2, to) => ut.bytesToNumberBE(b.slice(from2, to));
      class Signature {
        constructor(r2, s, recovery) {
          this.r = r2;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r: r2, s } = exports2.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r2, s);
        }
        assertValidity() {
          ut.aInRange("r", this.r, _1n, CURVE_ORDER);
          ut.aInRange("s", this.s, _1n, CURVE_ORDER);
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r: r2, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports2.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod2.getMinHashLength(CURVE.n);
          return mod2.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        if (bytes.length > 8192)
          throw new Error("input is too large");
        const num2 = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num2 >> BigInt(delta) : num2;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num2) {
        ut.aInRange("num < 2^" + CURVE.nBitLength, num2, _0n, ORDER_MASK);
        return ut.numberToBytesBE(num2, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash: hash2, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        validateSigVerOpts(opts);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash2(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null && ent !== false) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r2 = modN(q.x);
          if (r2 === _0n)
            return;
          const s = modN(ik * modN(m + r2 * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r2, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        var _a2;
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        const { lowS, prehash, format } = opts;
        validateSigVerOpts(opts);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        if (format !== void 0 && format !== "compact" && format !== "der")
          throw new Error("format must be compact or der");
        const isHex = typeof sg === "string" || ut.isBytes(sg);
        const isObj = !isHex && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
        if (!isHex && !isObj)
          throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let _sig = void 0;
        let P;
        try {
          if (isObj)
            _sig = new Signature(sg.r, sg.s);
          if (isHex) {
            try {
              if (format !== "compact")
                _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports2.DER.Err))
                throw derError;
            }
            if (!_sig && format !== "der")
              _sig = Signature.fromCompact(sg);
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          return false;
        }
        if (!_sig)
          return false;
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r: r2, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r2 * is);
        const R = (_a2 = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a2.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r2;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      mod2.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
  }
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getHash = getHash;
    exports2.createCurve = createCurve;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils2();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash2) {
      return {
        hash: hash2,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash2, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash2) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash2) });
      return Object.freeze({ ...create(defHash), create });
    }
  }
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.expand_message_xmd = expand_message_xmd;
    exports2.expand_message_xof = expand_message_xof;
    exports2.hash_to_field = hash_to_field;
    exports2.isogenyMap = isogenyMap;
    exports2.createHasher = createHasher;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils3();
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      anum(value);
      anum(length);
      if (value < 0 || value >= 1 << 8 * length)
        throw new Error("invalid I2OSP input: " + value);
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (lenInBytes > 65535 || ell > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count3, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash: hash2, expand, DST: _DST } = options;
      (0, utils_js_1.abytes)(msg);
      anum(count3);
      const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count3 * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count3);
      for (let i = 0; i < count3; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Same as encodeToCurve, but without hash
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("mapToCurve: expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error("mapToCurve: expected array of bigints");
          const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
  }
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@noble/curves/secp256k1.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeToCurve = exports2.hashToCurve = exports2.schnorr = exports2.secp256k1 = void 0;
    var sha256_1 = require_sha2563();
    var utils_1 = require_utils2();
    var _shortw_utils_js_1 = require_shortw_utils();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils3();
    var weierstrass_js_1 = require_weierstrass();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root2 = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fpk1.eql(Fpk1.sqr(root2), y))
        throw new Error("Cannot find square root");
      return root2;
    }
    var Fpk1 = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports2.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      // equation params: a, b
      b: BigInt(7),
      // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
      Fp: Fpk1,
      // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N,
      // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      // Cofactor
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports2.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports2.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      (0, utils_js_1.aInRange)("x", x, _1n, secp256k1P);
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    var num2 = utils_js_1.bytesToNumberBE;
    function challenge(...args) {
      return modN(num2(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ num2(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN(num2(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x(num2(pub));
        const r2 = num2(sig.subarray(0, 32));
        if (!(0, utils_js_1.inRange)(r2, _1n, secp256k1P))
          return false;
        const s = num2(sig.subarray(32, 64));
        if (!(0, utils_js_1.inRange)(s, _1n, secp256k1N))
          return false;
        const e = challenge(numTo32b(r2), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r2)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports2.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports2.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fpk1, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fpk1, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fpk1.create(BigInt("-11"))
    }))();
    var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports2.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fpk1.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fpk1.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports2.hashToCurve = (() => htf.hashToCurve)();
    exports2.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/@noble/hashes/sha2.js
var require_sha22 = __commonJS({
  "node_modules/@noble/hashes/sha2.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.sha224 = exports2.sha256 = void 0;
    var sha256_js_1 = require_sha256();
    Object.defineProperty(exports2, "sha256", { enumerable: true, get: function() {
      return sha256_js_1.sha256;
    } });
    Object.defineProperty(exports2, "sha224", { enumerable: true, get: function() {
      return sha256_js_1.sha224;
    } });
    var sha512_js_1 = require_sha512();
    Object.defineProperty(exports2, "sha512", { enumerable: true, get: function() {
      return sha512_js_1.sha512;
    } });
    Object.defineProperty(exports2, "sha512_224", { enumerable: true, get: function() {
      return sha512_js_1.sha512_224;
    } });
    Object.defineProperty(exports2, "sha512_256", { enumerable: true, get: function() {
      return sha512_js_1.sha512_256;
    } });
    Object.defineProperty(exports2, "sha384", { enumerable: true, get: function() {
      return sha512_js_1.sha384;
    } });
  }
});

// node_modules/@keplr-wallet/crypto/build/hash.js
var require_hash2 = __commonJS({
  "node_modules/@keplr-wallet/crypto/build/hash.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash = void 0;
    var sha2_1 = require_sha22();
    var sha3_1 = require_sha3();
    var Hash2 = class {
      static sha256(data) {
        return (0, sha2_1.sha256)(data);
      }
      static keccak256(data) {
        return (0, sha3_1.keccak_256)(data);
      }
      static truncHashPortion(str, firstCharCount = str.length, endCharCount = 0) {
        return str.substring(0, firstCharCount) + "…" + str.substring(str.length - endCharCount, str.length);
      }
    };
    exports2.Hash = Hash2;
  }
});

// node_modules/starknet-types-07/dist/cjs/api/contract.js
var require_contract = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/api/contract.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/starknet-types-07/dist/cjs/api/errors.js
var require_errors2 = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/api/errors.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/starknet-types-07/dist/cjs/api/components.js
var require_components = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/api/components.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/starknet-types-07/dist/cjs/api/nonspec.js
var require_nonspec = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/api/nonspec.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ETransactionVersion3 = exports2.ETransactionVersion2 = exports2.ETransactionVersion = exports2.EDAMode = exports2.EDataAvailabilityMode = exports2.EBlockTag = exports2.ETransactionExecutionStatus = exports2.ETransactionFinalityStatus = exports2.ETransactionStatus = exports2.ESimulationFlag = exports2.ETransactionType = void 0;
    exports2.ETransactionType = {
      DECLARE: "DECLARE",
      DEPLOY: "DEPLOY",
      DEPLOY_ACCOUNT: "DEPLOY_ACCOUNT",
      INVOKE: "INVOKE",
      L1_HANDLER: "L1_HANDLER"
    };
    exports2.ESimulationFlag = {
      SKIP_VALIDATE: "SKIP_VALIDATE",
      SKIP_FEE_CHARGE: "SKIP_FEE_CHARGE"
    };
    exports2.ETransactionStatus = {
      RECEIVED: "RECEIVED",
      REJECTED: "REJECTED",
      ACCEPTED_ON_L2: "ACCEPTED_ON_L2",
      ACCEPTED_ON_L1: "ACCEPTED_ON_L1"
    };
    exports2.ETransactionFinalityStatus = {
      ACCEPTED_ON_L2: "ACCEPTED_ON_L2",
      ACCEPTED_ON_L1: "ACCEPTED_ON_L1"
    };
    exports2.ETransactionExecutionStatus = {
      SUCCEEDED: "SUCCEEDED",
      REVERTED: "REVERTED"
    };
    exports2.EBlockTag = {
      LATEST: "latest",
      PENDING: "pending"
    };
    exports2.EDataAvailabilityMode = {
      L1: "L1",
      L2: "L2"
    };
    exports2.EDAMode = {
      L1: 0,
      L2: 1
    };
    exports2.ETransactionVersion = {
      V0: "0x0",
      V1: "0x1",
      V2: "0x2",
      V3: "0x3",
      F0: "0x100000000000000000000000000000000",
      F1: "0x100000000000000000000000000000001",
      F2: "0x100000000000000000000000000000002",
      F3: "0x100000000000000000000000000000003"
    };
    exports2.ETransactionVersion2 = {
      V0: "0x0",
      V1: "0x1",
      V2: "0x2",
      F0: "0x100000000000000000000000000000000",
      F1: "0x100000000000000000000000000000001",
      F2: "0x100000000000000000000000000000002"
    };
    exports2.ETransactionVersion3 = {
      V3: "0x3",
      F3: "0x100000000000000000000000000000003"
    };
  }
});

// node_modules/starknet-types-07/dist/cjs/api/index.js
var require_api = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/api/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPEC = exports2.Errors = void 0;
    __exportStar(require_contract(), exports2);
    exports2.Errors = require_errors2();
    exports2.SPEC = require_components();
    __exportStar(require_nonspec(), exports2);
  }
});

// node_modules/starknet-types-07/dist/cjs/wallet-api/constants.js
var require_constants = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/wallet-api/constants.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Permission = void 0;
    exports2.Permission = {
      ACCOUNTS: "accounts"
    };
  }
});

// node_modules/starknet-types-07/dist/cjs/wallet-api/typedData.js
var require_typedData = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/wallet-api/typedData.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypedDataRevision = void 0;
    exports2.TypedDataRevision = {
      ACTIVE: "1",
      LEGACY: "0"
    };
  }
});

// node_modules/starknet-types-07/dist/cjs/wallet-api/StarknetWindowObject.js
var require_StarknetWindowObject = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/wallet-api/StarknetWindowObject.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/starknet-types-07/dist/cjs/wallet-api/components.js
var require_components2 = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/wallet-api/components.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/starknet-types-07/dist/cjs/wallet-api/methods.js
var require_methods = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/wallet-api/methods.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/starknet-types-07/dist/cjs/wallet-api/events.js
var require_events2 = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/wallet-api/events.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/starknet-types-07/dist/cjs/wallet-api/errors.js
var require_errors3 = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/wallet-api/errors.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/starknet-types-07/dist/cjs/wallet-api/index.js
var require_wallet_api = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/wallet-api/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_constants(), exports2);
    __exportStar(require_typedData(), exports2);
    __exportStar(require_StarknetWindowObject(), exports2);
    __exportStar(require_components2(), exports2);
    __exportStar(require_methods(), exports2);
    __exportStar(require_events2(), exports2);
    __exportStar(require_errors3(), exports2);
  }
});

// node_modules/starknet-types-07/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/starknet-types-07/dist/cjs/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WALLET_API = exports2.API = void 0;
    __exportStar(require_api(), exports2);
    exports2.API = require_api();
    __exportStar(require_wallet_api(), exports2);
    exports2.WALLET_API = require_wallet_api();
  }
});

// node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/@scure/base/lib/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bytes = exports2.stringToBytes = exports2.str = exports2.bytesToString = exports2.hex = exports2.utf8 = exports2.bech32m = exports2.bech32 = exports2.base58check = exports2.createBase58check = exports2.base58xmr = exports2.base58xrp = exports2.base58flickr = exports2.base58 = exports2.base64urlnopad = exports2.base64url = exports2.base64nopad = exports2.base64 = exports2.base32crockford = exports2.base32hexnopad = exports2.base32hex = exports2.base32nopad = exports2.base32 = exports2.base16 = exports2.utils = void 0;
    exports2.assertNumber = assertNumber;
    function assertNumber(n) {
      if (!Number.isSafeInteger(n))
        throw new Error(`Wrong integer: ${n}`);
    }
    function isBytes2(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function chain(...args) {
      const id = (a) => a;
      const wrap3 = (a, b) => (c) => a(b(c));
      const encode3 = args.map((x) => x.encode).reduceRight(wrap3, id);
      const decode2 = args.map((x) => x.decode).reduce(wrap3, id);
      return { encode: encode3, decode: decode2 };
    }
    function alphabet(alphabet2) {
      return {
        encode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("alphabet.encode input should be an array of numbers");
          return digits.map((i) => {
            assertNumber(i);
            if (i < 0 || i >= alphabet2.length)
              throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
            return alphabet2[i];
          });
        },
        decode: (input) => {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("alphabet.decode input should be array of strings");
          return input.map((letter) => {
            if (typeof letter !== "string")
              throw new Error(`alphabet.decode: not string element=${letter}`);
            const index2 = alphabet2.indexOf(letter);
            if (index2 === -1)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
            return index2;
          });
        }
      };
    }
    function join(separator = "") {
      if (typeof separator !== "string")
        throw new Error("join separator should be string");
      return {
        encode: (from2) => {
          if (!Array.isArray(from2) || from2.length && typeof from2[0] !== "string")
            throw new Error("join.encode input should be array of strings");
          for (let i of from2)
            if (typeof i !== "string")
              throw new Error(`join.encode: non-string input=${i}`);
          return from2.join(separator);
        },
        decode: (to) => {
          if (typeof to !== "string")
            throw new Error("join.decode input should be string");
          return to.split(separator);
        }
      };
    }
    function padding(bits, chr = "=") {
      assertNumber(bits);
      if (typeof chr !== "string")
        throw new Error("padding chr should be string");
      return {
        encode(data) {
          if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i of data)
            if (typeof i !== "string")
              throw new Error(`padding.encode: non-string input=${i}`);
          while (data.length * bits % 8)
            data.push(chr);
          return data;
        },
        decode(input) {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i of input)
            if (typeof i !== "string")
              throw new Error(`padding.decode: non-string input=${i}`);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("Invalid padding: string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            if (!((end - 1) * bits % 8))
              throw new Error("Invalid padding: string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function normalize3(fn) {
      if (typeof fn !== "function")
        throw new Error("normalize fn should be function");
      return { encode: (from2) => from2, decode: (to) => fn(to) };
    }
    function convertRadix(data, from2, to) {
      if (from2 < 2)
        throw new Error(`convertRadix: wrong from=${from2}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
      if (!Array.isArray(data))
        throw new Error("convertRadix: data should be array");
      if (!data.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data);
      digits.forEach((d) => {
        assertNumber(d);
        if (d < 0 || d >= from2)
          throw new Error(`Wrong integer: ${d}`);
      });
      while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < digits.length; i++) {
          const digit = digits[i];
          const digitBase = from2 * carry + digit;
          if (!Number.isSafeInteger(digitBase) || from2 * carry / from2 !== carry || digitBase - digit !== from2 * carry) {
            throw new Error("convertRadix: carry overflow");
          }
          carry = digitBase % to;
          const rounded = Math.floor(digitBase / to);
          digits[i] = rounded;
          if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!rounded)
            pos = i;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
      return res.reverse();
    }
    var gcd = (a, b) => !b ? a : gcd(b, a % b);
    var radix2carry = (from2, to) => from2 + (to - gcd(from2, to));
    function convertRadix2(data, from2, to, padding2) {
      if (!Array.isArray(data))
        throw new Error("convertRadix2: data should be array");
      if (from2 <= 0 || from2 > 32)
        throw new Error(`convertRadix2: wrong from=${from2}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (radix2carry(from2, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from2} to=${to} carryBits=${radix2carry(from2, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const mask = 2 ** to - 1;
      const res = [];
      for (const n of data) {
        assertNumber(n);
        if (n >= 2 ** from2)
          throw new Error(`convertRadix2: invalid data word=${n} from=${from2}`);
        carry = carry << from2 | n;
        if (pos + from2 > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from2}`);
        pos += from2;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask) >>> 0);
        carry &= 2 ** pos - 1;
      }
      carry = carry << to - pos & mask;
      if (!padding2 && pos >= from2)
        throw new Error("Excess padding");
      if (!padding2 && carry)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding2 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    function radix(num2) {
      assertNumber(num2);
      return {
        encode: (bytes) => {
          if (!isBytes2(bytes))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix(Array.from(bytes), 2 ** 8, num2);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix.decode input should be array of numbers");
          return Uint8Array.from(convertRadix(digits, num2, 2 ** 8));
        }
      };
    }
    function radix2(bits, revPadding = false) {
      assertNumber(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes) => {
          if (!isBytes2(bytes))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix2.decode input should be array of numbers");
          return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper(fn) {
      if (typeof fn !== "function")
        throw new Error("unsafeWrapper fn should be function");
      return function(...args) {
        try {
          return fn.apply(null, args);
        } catch (e) {
        }
      };
    }
    function checksum(len, fn) {
      assertNumber(len);
      if (typeof fn !== "function")
        throw new Error("checksum fn should be function");
      return {
        encode(data) {
          if (!isBytes2(data))
            throw new Error("checksum.encode: input should be Uint8Array");
          const checksum2 = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(checksum2, data.length);
          return res;
        },
        decode(data) {
          if (!isBytes2(data))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const newChecksum = fn(payload).slice(0, len);
          const oldChecksum = data.slice(-len);
          for (let i = 0; i < len; i++)
            if (newChecksum[i] !== oldChecksum[i])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports2.utils = {
      alphabet,
      chain,
      checksum,
      convertRadix,
      convertRadix2,
      radix,
      radix2,
      join,
      padding
    };
    exports2.base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
    exports2.base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
    exports2.base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
    exports2.base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
    exports2.base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
    exports2.base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize3((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    exports2.base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
    exports2.base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
    exports2.base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
    exports2.base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
    var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
    exports2.base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports2.base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports2.base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports2.base58xmr = {
      encode(data) {
        let res = "";
        for (let i = 0; i < data.length; i += 8) {
          const block = data.subarray(i, i + 8);
          res += exports2.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
          const slice2 = str.slice(i, i + 11);
          const blockLen = XMR_BLOCK_LEN.indexOf(slice2.length);
          const block = exports2.base58.decode(slice2);
          for (let j = 0; j < block.length - blockLen; j++) {
            if (block[j] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var createBase58check = (sha2563) => chain(checksum(4, (data) => sha2563(sha2563(data))), exports2.base58);
    exports2.createBase58check = createBase58check;
    exports2.base58check = exports2.createBase58check;
    var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
    var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod(pre) {
      const b = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if ((b >> i & 1) === 1)
          chk ^= POLYMOD_GENERATORS[i];
      }
      return chk;
    }
    function bechChecksum(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c >> 5;
      }
      chk = bech32Polymod(chk);
      for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
      for (let v of words)
        chk = bech32Polymod(chk) ^ v;
      for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
    }
    function genBech32(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = radix2(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper(fromWords);
      function encode3(prefix, words, limit = 90) {
        if (typeof prefix !== "string")
          throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (words instanceof Uint8Array)
          words = Array.from(words);
        if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
          throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        if (prefix.length === 0)
          throw new TypeError(`Invalid prefix length ${prefix.length}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
      }
      function decode2(str, limit = 90) {
        if (typeof str !== "string")
          throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || limit !== false && str.length > limit)
          throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper(decode2);
      function decodeToBytes(str) {
        const { prefix, words } = decode2(str, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      function encodeFromBytes(prefix, bytes) {
        return encode3(prefix, toWords(bytes));
      }
      return {
        encode: encode3,
        decode: decode2,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords
      };
    }
    exports2.bech32 = genBech32("bech32");
    exports2.bech32m = genBech32("bech32m");
    exports2.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str)
    };
    exports2.hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize3((s) => {
      if (typeof s !== "string" || s.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
      return s.toLowerCase();
    }));
    var CODERS = {
      utf8: exports2.utf8,
      hex: exports2.hex,
      base16: exports2.base16,
      base32: exports2.base32,
      base64: exports2.base64,
      base64url: exports2.base64url,
      base58: exports2.base58,
      base58xmr: exports2.base58xmr
    };
    var coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
    var bytesToString = (type, bytes) => {
      if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (!isBytes2(bytes))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS[type].encode(bytes);
    };
    exports2.bytesToString = bytesToString;
    exports2.str = exports2.bytesToString;
    var stringToBytes = (type, str) => {
      if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS[type].decode(str);
    };
    exports2.stringToBytes = stringToBytes;
    exports2.bytes = exports2.stringToBytes;
  }
});

// node_modules/starknet/node_modules/@noble/curves/abstract/utils.js
var require_utils4 = __commonJS({
  "node_modules/starknet/node_modules/@noble/curves/abstract/utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bitMask = void 0;
    exports2.isBytes = isBytes2;
    exports2.abytes = abytes;
    exports2.bytesToHex = bytesToHex;
    exports2.numberToHexUnpadded = numberToHexUnpadded;
    exports2.hexToNumber = hexToNumber;
    exports2.hexToBytes = hexToBytes;
    exports2.bytesToNumberBE = bytesToNumberBE;
    exports2.bytesToNumberLE = bytesToNumberLE;
    exports2.numberToBytesBE = numberToBytesBE;
    exports2.numberToBytesLE = numberToBytesLE;
    exports2.numberToVarBytesBE = numberToVarBytesBE;
    exports2.ensureBytes = ensureBytes;
    exports2.concatBytes = concatBytes;
    exports2.equalBytes = equalBytes;
    exports2.utf8ToBytes = utf8ToBytes;
    exports2.bitLen = bitLen;
    exports2.bitGet = bitGet;
    exports2.bitSet = bitSet;
    exports2.createHmacDrbg = createHmacDrbg;
    exports2.validateObject = validateObject;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function isBytes2(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function abytes(item) {
      if (!isBytes2(item))
        throw new Error("Uint8Array expected");
    }
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    function numberToHexUnpadded(num2) {
      const hex = num2.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
      abytes(bytes);
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (isBytes2(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports2.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
  }
});

// node_modules/starknet/node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "node_modules/starknet/node_modules/@noble/hashes/_assert.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = exports2.isBytes = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
    }
    exports2.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
    }
    exports2.bool = bool;
    function isBytes2(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports2.isBytes = isBytes2;
    function bytes(b, ...lengths) {
      if (!isBytes2(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
    }
    exports2.bytes = bytes;
    function hash2(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(h.outputLen);
      number(h.blockLen);
    }
    exports2.hash = hash2;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports2.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min2 = instance.outputLen;
      if (out.length < min2) {
        throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
      }
    }
    exports2.output = output;
    var assert5 = { number, bool, bytes, hash: hash2, exists, output };
    exports2.default = assert5;
  }
});

// node_modules/starknet/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/starknet/node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.add = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = exports2.split = exports2.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports2.fromBig = fromBig;
    function split2(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports2.split = split2;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports2.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports2.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports2.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports2.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports2.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports2.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports2.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports2.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports2.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports2.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports2.rotlBL = rotlBL;
    function add2(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports2.add = add2;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports2.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports2.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports2.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports2.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports2.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports2.add5H = add5H;
    var u64 = {
      fromBig,
      split: split2,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add: add2,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports2.default = u64;
  }
});

// node_modules/starknet/node_modules/@noble/hashes/crypto.js
var require_crypto3 = __commonJS({
  "node_modules/starknet/node_modules/@noble/hashes/crypto.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/starknet/node_modules/@noble/hashes/utils.js
var require_utils5 = __commonJS({
  "node_modules/starknet/node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.byteSwap32 = exports2.byteSwapIfBE = exports2.byteSwap = exports2.isLE = exports2.rotl = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = exports2.isBytes = void 0;
    var crypto_1 = require_crypto3();
    var _assert_js_1 = require_assert2();
    function isBytes2(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports2.isBytes = isBytes2;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports2.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.createView = createView;
    var rotr = (word, shift4) => word << 32 - shift4 | word >>> shift4;
    exports2.rotr = rotr;
    var rotl = (word, shift4) => word << shift4 | word >>> 32 - shift4 >>> 0;
    exports2.rotl = rotl;
    exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports2.byteSwap = byteSwap;
    exports2.byteSwapIfBE = exports2.isLE ? (n) => n : (n) => (0, exports2.byteSwap)(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports2.byteSwap)(arr[i]);
      }
    }
    exports2.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports2.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports2.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    exports2.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports2.utf8ToBytes = utf8ToBytes;
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports2.toBytes = toBytes2;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.bytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports2.concatBytes = concatBytes;
    var Hash2 = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports2.Hash = Hash2;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports2.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports2.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports2.randomBytes = randomBytes;
  }
});

// node_modules/starknet/node_modules/@noble/hashes/sha3.js
var require_sha32 = __commonJS({
  "node_modules/starknet/node_modules/@noble/hashes/sha3.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shake256 = exports2.shake128 = exports2.keccak_512 = exports2.keccak_384 = exports2.keccak_256 = exports2.keccak_224 = exports2.sha3_512 = exports2.sha3_384 = exports2.sha3_256 = exports2.sha3_224 = exports2.Keccak = exports2.keccakP = void 0;
    var _assert_js_1 = require_assert2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils5();
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round2 = 0, R = _1n, x = 1, y = 0; round2 < 24; round2++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round2 = 24 - rounds; round2 < 24; round2++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift4 = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift4);
          const Tl = rotlL(curH, curL, shift4);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round2];
        s[1] ^= SHA3_IOTA_L[round2];
      }
      B.fill(0);
    }
    exports2.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports2.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports2.sha3_224 = gen(6, 144, 224 / 8);
    exports2.sha3_256 = gen(6, 136, 256 / 8);
    exports2.sha3_384 = gen(6, 104, 384 / 8);
    exports2.sha3_512 = gen(6, 72, 512 / 8);
    exports2.keccak_224 = gen(1, 144, 224 / 8);
    exports2.keccak_256 = gen(1, 136, 256 / 8);
    exports2.keccak_384 = gen(1, 104, 384 / 8);
    exports2.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports2.shake128 = genShake(31, 168, 128 / 8);
    exports2.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@scure/starknet/node_modules/@noble/hashes/_assert.js
var require_assert3 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/hashes/_assert.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports2.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports2.bool = bool;
    function isBytes2(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function bytes(b, ...lengths) {
      if (!isBytes2(b))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports2.bytes = bytes;
    function hash2(hash3) {
      if (typeof hash3 !== "function" || typeof hash3.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash3.outputLen);
      number(hash3.blockLen);
    }
    exports2.hash = hash2;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports2.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min2 = instance.outputLen;
      if (out.length < min2) {
        throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
      }
    }
    exports2.output = output;
    var assert5 = { number, bool, bytes, hash: hash2, exists, output };
    exports2.default = assert5;
  }
});

// node_modules/@scure/starknet/node_modules/@noble/hashes/_u64.js
var require_u642 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.add = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = exports2.split = exports2.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports2.fromBig = fromBig;
    function split2(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports2.split = split2;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports2.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports2.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports2.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports2.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports2.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports2.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports2.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports2.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports2.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports2.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports2.rotlBL = rotlBL;
    function add2(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports2.add = add2;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports2.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports2.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports2.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports2.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports2.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports2.add5H = add5H;
    var u64 = {
      fromBig,
      split: split2,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add: add2,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports2.default = u64;
  }
});

// node_modules/@scure/starknet/node_modules/@noble/hashes/crypto.js
var require_crypto4 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/hashes/crypto.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@scure/starknet/node_modules/@noble/hashes/utils.js
var require_utils6 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
    var crypto_1 = require_crypto4();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports2.u32 = u32;
    function isBytes2(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.createView = createView;
    var rotr = (word, shift4) => word << 32 - shift4 | word >>> shift4;
    exports2.rotr = rotr;
    exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports2.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!isBytes2(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports2.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports2.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    exports2.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports2.utf8ToBytes = utf8ToBytes;
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!isBytes2(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports2.toBytes = toBytes2;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        if (!isBytes2(a))
          throw new Error("Uint8Array expected");
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports2.concatBytes = concatBytes;
    var Hash2 = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports2.Hash = Hash2;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports2.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports2.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports2.randomBytes = randomBytes;
  }
});

// node_modules/@scure/starknet/node_modules/@noble/hashes/sha3.js
var require_sha33 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/hashes/sha3.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shake256 = exports2.shake128 = exports2.keccak_512 = exports2.keccak_384 = exports2.keccak_256 = exports2.keccak_224 = exports2.sha3_512 = exports2.sha3_384 = exports2.sha3_256 = exports2.sha3_224 = exports2.Keccak = exports2.keccakP = void 0;
    var _assert_js_1 = require_assert3();
    var _u64_js_1 = require_u642();
    var utils_js_1 = require_utils6();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round2 = 0, R = _1n, x = 1, y = 0; round2 < 24; round2++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round2 = 24 - rounds; round2 < 24; round2++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift4 = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift4);
          const Tl = rotlL(curH, curL, shift4);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round2];
        s[1] ^= SHA3_IOTA_L[round2];
      }
      B.fill(0);
    }
    exports2.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports2.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports2.sha3_224 = gen(6, 144, 224 / 8);
    exports2.sha3_256 = gen(6, 136, 256 / 8);
    exports2.sha3_384 = gen(6, 104, 384 / 8);
    exports2.sha3_512 = gen(6, 72, 512 / 8);
    exports2.keccak_224 = gen(1, 144, 224 / 8);
    exports2.keccak_256 = gen(1, 136, 256 / 8);
    exports2.keccak_384 = gen(1, 104, 384 / 8);
    exports2.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports2.shake128 = genShake(31, 168, 128 / 8);
    exports2.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@scure/starknet/node_modules/@noble/hashes/_sha2.js
var require_sha23 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/hashes/_sha2.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SHA2 = void 0;
    var _assert_js_1 = require_assert3();
    var utils_js_1 = require_utils6();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports2.SHA2 = SHA2;
  }
});

// node_modules/@scure/starknet/node_modules/@noble/hashes/sha256.js
var require_sha2564 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.sha256 = void 0;
    var _sha2_js_1 = require_sha23();
    var utils_js_1 = require_utils6();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset4) {
        for (let i = 0; i < 16; i++, offset4 += 4)
          SHA256_W[i] = view.getUint32(offset4, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@scure/starknet/node_modules/@noble/curves/abstract/utils.js
var require_utils7 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/curves/abstract/utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateObject = exports2.createHmacDrbg = exports2.bitMask = exports2.bitSet = exports2.bitGet = exports2.bitLen = exports2.utf8ToBytes = exports2.equalBytes = exports2.concatBytes = exports2.ensureBytes = exports2.numberToVarBytesBE = exports2.numberToBytesLE = exports2.numberToBytesBE = exports2.bytesToNumberLE = exports2.bytesToNumberBE = exports2.hexToBytes = exports2.hexToNumber = exports2.numberToHexUnpadded = exports2.bytesToHex = exports2.isBytes = void 0;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function isBytes2(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports2.isBytes = isBytes2;
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!isBytes2(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports2.bytesToHex = bytesToHex;
    function numberToHexUnpadded(num2) {
      const hex = num2.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    exports2.numberToHexUnpadded = numberToHexUnpadded;
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    exports2.hexToNumber = hexToNumber;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports2.hexToBytes = hexToBytes;
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    exports2.bytesToNumberBE = bytesToNumberBE;
    function bytesToNumberLE(bytes) {
      if (!isBytes2(bytes))
        throw new Error("Uint8Array expected");
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    exports2.bytesToNumberLE = bytesToNumberLE;
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    exports2.numberToBytesBE = numberToBytesBE;
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    exports2.numberToBytesLE = numberToBytesLE;
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    exports2.numberToVarBytesBE = numberToVarBytesBE;
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (isBytes2(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports2.ensureBytes = ensureBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        if (!isBytes2(a))
          throw new Error("Uint8Array expected");
        sum += a.length;
      }
      let res = new Uint8Array(sum);
      let pad = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports2.concatBytes = concatBytes;
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    exports2.equalBytes = equalBytes;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports2.utf8ToBytes = utf8ToBytes;
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    exports2.bitLen = bitLen;
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    exports2.bitGet = bitGet;
    var bitSet = (n, pos, value) => {
      return n | (value ? _1n : _0n) << BigInt(pos);
    };
    exports2.bitSet = bitSet;
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports2.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    exports2.createHmacDrbg = createHmacDrbg;
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    exports2.validateObject = validateObject;
  }
});

// node_modules/@scure/starknet/node_modules/@noble/curves/abstract/modular.js
var require_modular2 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/curves/abstract/modular.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapHashToField = exports2.getMinHashLength = exports2.getFieldBytesLength = exports2.hashToPrivateScalar = exports2.FpSqrtEven = exports2.FpSqrtOdd = exports2.Field = exports2.nLength = exports2.FpIsSquare = exports2.FpDiv = exports2.FpInvertBatch = exports2.FpPow = exports2.validateField = exports2.isNegativeLE = exports2.FpSqrt = exports2.tonelliShanks = exports2.invert = exports2.pow2 = exports2.pow = exports2.mod = void 0;
    var utils_js_1 = require_utils7();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod2(a, b) {
      const result2 = a % b;
      return result2 >= _0n ? result2 : b + result2;
    }
    exports2.mod = mod2;
    function pow(num2, power, modulo2) {
      if (modulo2 <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo2 === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num2 % modulo2;
        num2 = num2 * num2 % modulo2;
        power >>= _1n;
      }
      return res;
    }
    exports2.pow = pow;
    function pow2(x, power, modulo2) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo2;
      }
      return res;
    }
    exports2.pow2 = pow2;
    function invert(number, modulo2) {
      if (number === _0n || modulo2 <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo2}`);
      }
      let a = mod2(number, modulo2);
      let b = modulo2;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r2 = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r2, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod2(x, modulo2);
    }
    exports2.invert = invert;
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root2 = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root2), n))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r2 = S;
        let g2 = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r2; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g2, _1n << BigInt(r2 - m - 1));
          g2 = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g2);
          r2 = m;
        }
        return x;
      };
    }
    exports2.tonelliShanks = tonelliShanks;
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root2 = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root2), n))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root2 = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root2), n))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    exports2.FpSqrt = FpSqrt;
    var isNegativeLE = (num2, modulo2) => (mod2(num2, modulo2) & _1n) === _1n;
    exports2.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    exports2.validateField = validateField;
    function FpPow(f, num2, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num2;
      let p = f.ONE;
      let d = num2;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    exports2.FpPow = FpPow;
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num2, i) => {
        if (f.is0(num2))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num2);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num2, i) => {
        if (f.is0(num2))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num2);
      }, inverted);
      return tmp;
    }
    exports2.FpInvertBatch = FpInvertBatch;
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    exports2.FpDiv = FpDiv;
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    exports2.FpIsSquare = FpIsSquare;
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    exports2.nLength = nLength;
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num2) => mod2(num2, ORDER),
        isValid: (num2) => {
          if (typeof num2 !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num2}`);
          return _0n <= num2 && num2 < ORDER;
        },
        is0: (num2) => num2 === _0n,
        isOdd: (num2) => (num2 & _1n) === _1n,
        neg: (num2) => mod2(-num2, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num2) => mod2(num2 * num2, ORDER),
        add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
        pow: (num2, power) => FpPow(f, num2, power),
        div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num2) => num2 * num2,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num2) => invert(num2, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num2) => isLE ? (0, utils_js_1.numberToBytesLE)(num2, BYTES) : (0, utils_js_1.numberToBytesBE)(num2, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    exports2.Field = Field;
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root2 = Fp.sqrt(elm);
      return Fp.isOdd(root2) ? root2 : Fp.neg(root2);
    }
    exports2.FpSqrtOdd = FpSqrtOdd;
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root2 = Fp.sqrt(elm);
      return Fp.isOdd(root2) ? Fp.neg(root2) : root2;
    }
    exports2.FpSqrtEven = FpSqrtEven;
    function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
      hash2 = (0, utils_js_1.ensureBytes)("privateHash", hash2);
      const hashLen = hash2.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num2 = isLE ? (0, utils_js_1.bytesToNumberLE)(hash2) : (0, utils_js_1.bytesToNumberBE)(hash2);
      return mod2(num2, groupOrder - _1n) + _1n;
    }
    exports2.hashToPrivateScalar = hashToPrivateScalar;
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    exports2.getFieldBytesLength = getFieldBytesLength;
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    exports2.getMinHashLength = getMinHashLength;
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num2 = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod2(num2, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
    exports2.mapHashToField = mapHashToField;
  }
});

// node_modules/@scure/starknet/node_modules/@noble/curves/abstract/poseidon.js
var require_poseidon = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/curves/abstract/poseidon.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.poseidon = exports2.splitConstants = exports2.validateOpts = void 0;
    var modular_js_1 = require_modular2();
    function validateOpts(opts) {
      const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;
      const { roundsFull, roundsPartial, sboxPower, t } = opts;
      (0, modular_js_1.validateField)(Fp);
      for (const i of ["t", "roundsFull", "roundsPartial"]) {
        if (typeof opts[i] !== "number" || !Number.isSafeInteger(opts[i]))
          throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);
      }
      if (!Array.isArray(mds) || mds.length !== t)
        throw new Error("Poseidon: wrong MDS matrix");
      const _mds = mds.map((mdsRow) => {
        if (!Array.isArray(mdsRow) || mdsRow.length !== t)
          throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);
        return mdsRow.map((i) => {
          if (typeof i !== "bigint")
            throw new Error(`Poseidon MDS matrix value=${i}`);
          return Fp.create(i);
        });
      });
      if (rev !== void 0 && typeof rev !== "boolean")
        throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);
      if (roundsFull % 2 !== 0)
        throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);
      const rounds = roundsFull + roundsPartial;
      if (!Array.isArray(rc) || rc.length !== rounds)
        throw new Error("Poseidon: wrong round constants");
      const roundConstants = rc.map((rc2) => {
        if (!Array.isArray(rc2) || rc2.length !== t)
          throw new Error(`Poseidon wrong round constants: ${rc2}`);
        return rc2.map((i) => {
          if (typeof i !== "bigint" || !Fp.isValid(i))
            throw new Error(`Poseidon wrong round constant=${i}`);
          return Fp.create(i);
        });
      });
      if (!sboxPower || ![3, 5, 7].includes(sboxPower))
        throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);
      const _sboxPower = BigInt(sboxPower);
      let sboxFn = (n) => (0, modular_js_1.FpPow)(Fp, n, _sboxPower);
      if (sboxPower === 3)
        sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);
      else if (sboxPower === 5)
        sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);
      return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds: _mds });
    }
    exports2.validateOpts = validateOpts;
    function splitConstants(rc, t) {
      if (typeof t !== "number")
        throw new Error("poseidonSplitConstants: wrong t");
      if (!Array.isArray(rc) || rc.length % t)
        throw new Error("poseidonSplitConstants: wrong rc");
      const res = [];
      let tmp = [];
      for (let i = 0; i < rc.length; i++) {
        tmp.push(rc[i]);
        if (tmp.length === t) {
          res.push(tmp);
          tmp = [];
        }
      }
      return res;
    }
    exports2.splitConstants = splitConstants;
    function poseidon(opts) {
      const _opts = validateOpts(opts);
      const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;
      const halfRoundsFull = _opts.roundsFull / 2;
      const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;
      const poseidonRound = (values, isFull, idx) => {
        values = values.map((i, j) => Fp.add(i, roundConstants[idx][j]));
        if (isFull)
          values = values.map((i) => sboxFn(i));
        else
          values[partialIdx] = sboxFn(values[partialIdx]);
        values = mds.map((i) => i.reduce((acc, i2, j) => Fp.add(acc, Fp.mulN(i2, values[j])), Fp.ZERO));
        return values;
      };
      const poseidonHash = function poseidonHash2(values) {
        if (!Array.isArray(values) || values.length !== t)
          throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);
        values = values.map((i) => {
          if (typeof i !== "bigint")
            throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);
          return Fp.create(i);
        });
        let round2 = 0;
        for (let i = 0; i < halfRoundsFull; i++)
          values = poseidonRound(values, true, round2++);
        for (let i = 0; i < roundsPartial; i++)
          values = poseidonRound(values, false, round2++);
        for (let i = 0; i < halfRoundsFull; i++)
          values = poseidonRound(values, true, round2++);
        if (round2 !== rounds)
          throw new Error(`Poseidon: wrong number of rounds: last round=${round2}, total=${rounds}`);
        return values;
      };
      poseidonHash.roundConstants = roundConstants;
      return poseidonHash;
    }
    exports2.poseidon = poseidon;
  }
});

// node_modules/@scure/starknet/node_modules/@noble/curves/abstract/curve.js
var require_curve2 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/curves/abstract/curve.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateBasic = exports2.wNAF = void 0;
    var modular_js_1 = require_modular2();
    var utils_js_1 = require_utils7();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset4 = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset4;
            const offset22 = offset4 + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset22]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    exports2.wNAF = wNAF;
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    exports2.validateBasic = validateBasic;
  }
});

// node_modules/@scure/starknet/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass2 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/curves/abstract/weierstrass.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapToCurveSimpleSWU = exports2.SWUFpSqrtRatio = exports2.weierstrass = exports2.weierstrassPoints = exports2.DER = void 0;
    var mod2 = require_modular2();
    var ut = require_utils7();
    var utils_js_1 = require_utils7();
    var curve_js_1 = require_curve2();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports2.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports2.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports2.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!ut.isBytes(data))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r2, l: sBytes } = exports2.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports2.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r: r2, s };
      },
      hexFromSig(sig) {
        const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num2) => {
          const hex = num2.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice2(h(sig.s));
        const r2 = slice2(h(sig.r));
        const shl = s.length / 2;
        const rhl = r2.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r2}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes2 = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num2) {
        return typeof num2 === "bigint" && _0n < num2 && num2 < CURVE.n;
      }
      function assertGE(num2) {
        if (!isWithinCurveOrder(num2))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (ut.isBytes(key))
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num2;
        try {
          num2 = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num2 = mod2.mod(num2, n);
        assertGE(num2);
        return num2;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes2((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes2(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    exports2.weierstrassPoints = weierstrassPoints;
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num2) {
        return _0n < num2 && num2 < Fp.ORDER;
      }
      function modN(a) {
        return mod2.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod2.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y = Fp.sqrt(y2);
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num2) => ut.bytesToHex(ut.numberToBytesBE(num2, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from2, to) => ut.bytesToNumberBE(b.slice(from2, to));
      class Signature {
        constructor(r2, s, recovery) {
          this.r = r2;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r: r2, s } = exports2.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r2, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r: r2, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports2.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod2.getMinHashLength(CURVE.n);
          return mod2.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num2 = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num2 >> BigInt(delta) : num2;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num2) {
        if (typeof num2 !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num2 && num2 < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num2, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash: hash2, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash2(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r2 = modN(q.x);
          if (r2 === _0n)
            return;
          const s = modN(ik * modN(m + r2 * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r2, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        var _a2;
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || ut.isBytes(sg)) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports2.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r3, s: s2 } = sg;
            _sig = new Signature(r3, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r: r2, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r2 * is);
        const R = (_a2 = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a2.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r2;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    exports2.weierstrass = weierstrass;
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    exports2.SWUFpSqrtRatio = SWUFpSqrtRatio;
    function mapToCurveSimpleSWU(Fp, opts) {
      mod2.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
    exports2.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  }
});

// node_modules/@scure/starknet/node_modules/@noble/hashes/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/hashes/hmac.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmac = exports2.HMAC = void 0;
    var _assert_js_1 = require_assert3();
    var utils_js_1 = require_utils6();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash2);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports2.HMAC = HMAC;
    var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
    exports2.hmac = hmac;
    exports2.hmac.create = (hash2, key) => new HMAC(hash2, key);
  }
});

// node_modules/@scure/starknet/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils2 = __commonJS({
  "node_modules/@scure/starknet/node_modules/@noble/curves/_shortw_utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createCurve = exports2.getHash = void 0;
    var hmac_1 = require_hmac2();
    var utils_1 = require_utils6();
    var weierstrass_js_1 = require_weierstrass2();
    function getHash(hash2) {
      return {
        hash: hash2,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash2, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    exports2.getHash = getHash;
    function createCurve(curveDef, defHash) {
      const create = (hash2) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash2) });
      return Object.freeze({ ...create(defHash), create });
    }
    exports2.createCurve = createCurve;
  }
});

// node_modules/@scure/starknet/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@scure/starknet/lib/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.poseidonHashMany = exports2.poseidonHashSingle = exports2.poseidonHashFunc = exports2.poseidonHash = exports2.poseidonSmall = exports2.poseidonCreate = exports2.poseidonBasic = exports2._poseidonMDS = exports2.Fp251 = exports2.keccak = exports2.computeHashOnElements = exports2.pedersen = exports2.getAccountPath = exports2.ethSigToPrivate = exports2.getStarkKey = exports2.grindKey = exports2.utils = exports2.Signature = exports2.ProjectivePoint = exports2.CURVE = exports2.verify = exports2.sign = exports2.getSharedSecret = exports2.getPublicKey = exports2._starkCurve = exports2.MAX_VALUE = void 0;
    var sha3_1 = require_sha33();
    var sha256_1 = require_sha2564();
    var utils_1 = require_utils6();
    var modular_1 = require_modular2();
    var poseidon_1 = require_poseidon();
    var weierstrass_1 = require_weierstrass2();
    var u = require_utils7();
    var _shortw_utils_1 = require_shortw_utils2();
    var CURVE_ORDER = BigInt("3618502788666131213697322783095070105526743751716087489154079457884512865583");
    exports2.MAX_VALUE = BigInt("0x800000000000000000000000000000000000000000000000000000000000000");
    var nBitLength = 252;
    function bits2int(bytes) {
      while (bytes[0] === 0)
        bytes = bytes.subarray(1);
      const delta = bytes.length * 8 - nBitLength;
      const num2 = u.bytesToNumberBE(bytes);
      return delta > 0 ? num2 >> BigInt(delta) : num2;
    }
    function hex0xToBytes(hex) {
      if (typeof hex === "string") {
        hex = strip0x(hex);
        if (hex.length & 1)
          hex = "0" + hex;
      }
      return u.hexToBytes(hex);
    }
    var curve = (0, weierstrass_1.weierstrass)({
      a: BigInt(1),
      b: BigInt("3141592653589793238462643383279502884197169399375105820974944592307816406665"),
      Fp: (0, modular_1.Field)(BigInt("0x800000000000011000000000000000000000000000000000000000000000001")),
      n: CURVE_ORDER,
      nBitLength,
      Gx: BigInt("874739451078007766457464989774322083649278607533249481151382481072868806602"),
      Gy: BigInt("152666792071518830868575557812948353041420400780739481342941381225525861407"),
      h: BigInt(1),
      lowS: false,
      ...(0, _shortw_utils_1.getHash)(sha256_1.sha256),
      bits2int,
      bits2int_modN: (bytes) => {
        const hex = u.bytesToNumberBE(bytes).toString(16);
        if (hex.length === 63)
          bytes = hex0xToBytes(hex + "0");
        return (0, modular_1.mod)(bits2int(bytes), CURVE_ORDER);
      }
    });
    exports2._starkCurve = curve;
    function ensureBytes(hex) {
      return u.ensureBytes("", typeof hex === "string" ? hex0xToBytes(hex) : hex);
    }
    function normPrivKey(privKey) {
      return u.bytesToHex(ensureBytes(privKey)).padStart(64, "0");
    }
    function getPublicKey(privKey, isCompressed = false) {
      return curve.getPublicKey(normPrivKey(privKey), isCompressed);
    }
    exports2.getPublicKey = getPublicKey;
    function getSharedSecret(privKeyA, pubKeyB) {
      return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);
    }
    exports2.getSharedSecret = getSharedSecret;
    function checkSignature(signature) {
      const { r: r2, s } = signature;
      if (r2 < 0n || r2 >= exports2.MAX_VALUE)
        throw new Error(`Signature.r should be [1, ${exports2.MAX_VALUE})`);
      const w = (0, modular_1.invert)(s, CURVE_ORDER);
      if (w < 0n || w >= exports2.MAX_VALUE)
        throw new Error(`inv(Signature.s) should be [1, ${exports2.MAX_VALUE})`);
    }
    function checkMessage(msgHash) {
      const bytes = ensureBytes(msgHash);
      const num2 = u.bytesToNumberBE(bytes);
      if (num2 >= exports2.MAX_VALUE)
        throw new Error(`msgHash should be [0, ${exports2.MAX_VALUE})`);
      return bytes;
    }
    function sign(msgHash, privKey, opts) {
      const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);
      checkSignature(sig);
      return sig;
    }
    exports2.sign = sign;
    function verify(signature, msgHash, pubKey) {
      if (!(signature instanceof Signature)) {
        const bytes = ensureBytes(signature);
        try {
          signature = Signature.fromDER(bytes);
        } catch (derError) {
          if (!(derError instanceof weierstrass_1.DER.Err))
            throw derError;
          signature = Signature.fromCompact(bytes);
        }
      }
      checkSignature(signature);
      return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));
    }
    exports2.verify = verify;
    var { CURVE, ProjectivePoint, Signature, utils } = curve;
    exports2.CURVE = CURVE;
    exports2.ProjectivePoint = ProjectivePoint;
    exports2.Signature = Signature;
    exports2.utils = utils;
    function extractX(bytes) {
      const hex = u.bytesToHex(bytes.subarray(1));
      const stripped = hex.replace(/^0+/gm, "");
      return `0x${stripped}`;
    }
    function strip0x(hex) {
      return hex.replace(/^0x/i, "");
    }
    function grindKey(seed) {
      const _seed = ensureBytes(seed);
      const sha256mask = 2n ** 256n;
      const limit = sha256mask - (0, modular_1.mod)(sha256mask, CURVE_ORDER);
      for (let i = 0; ; i++) {
        const key = sha256Num(u.concatBytes(_seed, u.numberToVarBytesBE(BigInt(i))));
        if (key < limit)
          return (0, modular_1.mod)(key, CURVE_ORDER).toString(16);
        if (i === 1e5)
          throw new Error("grindKey is broken: tried 100k vals");
      }
    }
    exports2.grindKey = grindKey;
    function getStarkKey(privateKey) {
      return extractX(getPublicKey(privateKey, true));
    }
    exports2.getStarkKey = getStarkKey;
    function ethSigToPrivate(signature) {
      signature = strip0x(signature);
      if (signature.length !== 130)
        throw new Error("Wrong ethereum signature");
      return grindKey(signature.substring(0, 64));
    }
    exports2.ethSigToPrivate = ethSigToPrivate;
    var MASK_31 = 2n ** 31n - 1n;
    var int31 = (n) => Number(n & MASK_31);
    function getAccountPath(layer, application, ethereumAddress, index2) {
      const layerNum = int31(sha256Num(layer));
      const applicationNum = int31(sha256Num(application));
      const eth2 = u.hexToNumber(strip0x(ethereumAddress));
      return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth2)}'/${int31(eth2 >> 31n)}'/${index2}`;
    }
    exports2.getAccountPath = getAccountPath;
    var PEDERSEN_POINTS = [
      new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),
      new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),
      new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),
      new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),
      new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)
    ];
    function pedersenPrecompute(p1, p2) {
      const out = [];
      let p = p1;
      for (let i = 0; i < 248; i++) {
        out.push(p);
        p = p.double();
      }
      p = p2;
      for (let i = 0; i < 4; i++) {
        out.push(p);
        p = p.double();
      }
      return out;
    }
    var PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);
    var PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);
    function pedersenArg(arg) {
      let value;
      if (typeof arg === "bigint") {
        value = arg;
      } else if (typeof arg === "number") {
        if (!Number.isSafeInteger(arg))
          throw new Error(`Invalid pedersenArg: ${arg}`);
        value = BigInt(arg);
      } else {
        value = u.bytesToNumberBE(ensureBytes(arg));
      }
      if (!(0n <= value && value < curve.CURVE.Fp.ORDER))
        throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);
      return value;
    }
    function pedersenSingle(point, value, constants2) {
      let x = pedersenArg(value);
      for (let j = 0; j < 252; j++) {
        const pt = constants2[j];
        if (pt.equals(point))
          throw new Error("Same point");
        if ((x & 1n) !== 0n)
          point = point.add(pt);
        x >>= 1n;
      }
      return point;
    }
    function pedersen(x, y) {
      let point = PEDERSEN_POINTS[0];
      point = pedersenSingle(point, x, PEDERSEN_POINTS1);
      point = pedersenSingle(point, y, PEDERSEN_POINTS2);
      return extractX(point.toRawBytes(true));
    }
    exports2.pedersen = pedersen;
    var computeHashOnElements = (data, fn = pedersen) => [0, ...data, data.length].reduce((x, y) => fn(x, y));
    exports2.computeHashOnElements = computeHashOnElements;
    var MASK_250 = u.bitMask(250);
    var keccak = (data) => u.bytesToNumberBE((0, sha3_1.keccak_256)(data)) & MASK_250;
    exports2.keccak = keccak;
    var sha256Num = (data) => u.bytesToNumberBE((0, sha256_1.sha256)(data));
    exports2.Fp251 = (0, modular_1.Field)(BigInt("3618502788666131213697322783095070105623107215331596699973092056135872020481"));
    function poseidonRoundConstant(Fp, name, idx) {
      const val = Fp.fromBytes((0, sha256_1.sha256)((0, utils_1.utf8ToBytes)(`${name}${idx}`)));
      return Fp.create(val);
    }
    function _poseidonMDS(Fp, name, m, attempt = 0) {
      const x_values = [];
      const y_values = [];
      for (let i = 0; i < m; i++) {
        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));
        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));
      }
      if ((/* @__PURE__ */ new Set([...x_values, ...y_values])).size !== 2 * m)
        throw new Error("X and Y values are not distinct");
      return x_values.map((x) => y_values.map((y) => Fp.inv(Fp.sub(x, y))));
    }
    exports2._poseidonMDS = _poseidonMDS;
    var MDS_SMALL = [
      [3, 1, 1],
      [1, -1, 1],
      [1, 1, -2]
    ].map((i) => i.map(BigInt));
    function poseidonBasic(opts, mds) {
      (0, modular_1.validateField)(opts.Fp);
      if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity))
        throw new Error(`Wrong poseidon opts: ${opts}`);
      const m = opts.rate + opts.capacity;
      const rounds = opts.roundsFull + opts.roundsPartial;
      const roundConstants = [];
      for (let i = 0; i < rounds; i++) {
        const row = [];
        for (let j = 0; j < m; j++)
          row.push(poseidonRoundConstant(opts.Fp, "Hades", m * i + j));
        roundConstants.push(row);
      }
      const res = (0, poseidon_1.poseidon)({
        ...opts,
        t: m,
        sboxPower: 3,
        reversePartialPowIdx: true,
        mds,
        roundConstants
      });
      res.m = m;
      res.rate = opts.rate;
      res.capacity = opts.capacity;
      return res;
    }
    exports2.poseidonBasic = poseidonBasic;
    function poseidonCreate(opts, mdsAttempt = 0) {
      const m = opts.rate + opts.capacity;
      if (!Number.isSafeInteger(mdsAttempt))
        throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);
      return poseidonBasic(opts, _poseidonMDS(opts.Fp, "HadesMDS", m, mdsAttempt));
    }
    exports2.poseidonCreate = poseidonCreate;
    exports2.poseidonSmall = poseidonBasic({ Fp: exports2.Fp251, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, MDS_SMALL);
    function poseidonHash(x, y, fn = exports2.poseidonSmall) {
      return fn([x, y, 2n])[0];
    }
    exports2.poseidonHash = poseidonHash;
    function poseidonHashFunc(x, y, fn = exports2.poseidonSmall) {
      return u.numberToVarBytesBE(poseidonHash(u.bytesToNumberBE(x), u.bytesToNumberBE(y), fn));
    }
    exports2.poseidonHashFunc = poseidonHashFunc;
    function poseidonHashSingle(x, fn = exports2.poseidonSmall) {
      return fn([x, 0n, 1n])[0];
    }
    exports2.poseidonHashSingle = poseidonHashSingle;
    function poseidonHashMany(values, fn = exports2.poseidonSmall) {
      const { m, rate } = fn;
      if (!Array.isArray(values))
        throw new Error("bigint array expected in values");
      const padded = Array.from(values);
      padded.push(1n);
      while (padded.length % rate !== 0)
        padded.push(0n);
      let state = new Array(m).fill(0n);
      for (let i = 0; i < padded.length; i += rate) {
        for (let j = 0; j < rate; j++)
          state[j] += padded[i + j];
        state = fn(state);
      }
      return state[0];
    }
    exports2.poseidonHashMany = poseidonHashMany;
  }
});

// node_modules/starknet/node_modules/@noble/curves/abstract/modular.js
var require_modular3 = __commonJS({
  "node_modules/starknet/node_modules/@noble/curves/abstract/modular.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNegativeLE = void 0;
    exports2.mod = mod2;
    exports2.pow = pow;
    exports2.pow2 = pow2;
    exports2.invert = invert;
    exports2.tonelliShanks = tonelliShanks;
    exports2.FpSqrt = FpSqrt;
    exports2.validateField = validateField;
    exports2.FpPow = FpPow;
    exports2.FpInvertBatch = FpInvertBatch;
    exports2.FpDiv = FpDiv;
    exports2.FpIsSquare = FpIsSquare;
    exports2.nLength = nLength;
    exports2.Field = Field;
    exports2.FpSqrtOdd = FpSqrtOdd;
    exports2.FpSqrtEven = FpSqrtEven;
    exports2.hashToPrivateScalar = hashToPrivateScalar;
    exports2.getFieldBytesLength = getFieldBytesLength;
    exports2.getMinHashLength = getMinHashLength;
    exports2.mapHashToField = mapHashToField;
    var utils_js_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod2(a, b) {
      const result2 = a % b;
      return result2 >= _0n ? result2 : b + result2;
    }
    function pow(num2, power, modulo2) {
      if (modulo2 <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo2 === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num2 % modulo2;
        num2 = num2 * num2 % modulo2;
        power >>= _1n;
      }
      return res;
    }
    function pow2(x, power, modulo2) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo2;
      }
      return res;
    }
    function invert(number, modulo2) {
      if (number === _0n || modulo2 <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo2}`);
      }
      let a = mod2(number, modulo2);
      let b = modulo2;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r2 = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r2, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod2(x, modulo2);
    }
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root2 = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root2), n))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r2 = S;
        let g2 = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r2; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g2, _1n << BigInt(r2 - m - 1));
          g2 = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g2);
          r2 = m;
        }
        return x;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root2 = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root2), n))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root2 = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root2), n))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    var isNegativeLE = (num2, modulo2) => (mod2(num2, modulo2) & _1n) === _1n;
    exports2.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    function FpPow(f, num2, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num2;
      let p = f.ONE;
      let d = num2;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num2, i) => {
        if (f.is0(num2))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num2);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num2, i) => {
        if (f.is0(num2))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num2);
      }, inverted);
      return tmp;
    }
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num2) => mod2(num2, ORDER),
        isValid: (num2) => {
          if (typeof num2 !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num2}`);
          return _0n <= num2 && num2 < ORDER;
        },
        is0: (num2) => num2 === _0n,
        isOdd: (num2) => (num2 & _1n) === _1n,
        neg: (num2) => mod2(-num2, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num2) => mod2(num2 * num2, ORDER),
        add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
        pow: (num2, power) => FpPow(f, num2, power),
        div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num2) => num2 * num2,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num2) => invert(num2, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num2) => isLE ? (0, utils_js_1.numberToBytesLE)(num2, BYTES) : (0, utils_js_1.numberToBytesBE)(num2, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root2 = Fp.sqrt(elm);
      return Fp.isOdd(root2) ? root2 : Fp.neg(root2);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root2 = Fp.sqrt(elm);
      return Fp.isOdd(root2) ? Fp.neg(root2) : root2;
    }
    function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
      hash2 = (0, utils_js_1.ensureBytes)("privateHash", hash2);
      const hashLen = hash2.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num2 = isLE ? (0, utils_js_1.bytesToNumberLE)(hash2) : (0, utils_js_1.bytesToNumberBE)(hash2);
      return mod2(num2, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num2 = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod2(num2, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/starknet/node_modules/@noble/curves/abstract/poseidon.js
var require_poseidon2 = __commonJS({
  "node_modules/starknet/node_modules/@noble/curves/abstract/poseidon.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateOpts = validateOpts;
    exports2.splitConstants = splitConstants;
    exports2.poseidon = poseidon;
    var modular_js_1 = require_modular3();
    function validateOpts(opts) {
      const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;
      const { roundsFull, roundsPartial, sboxPower, t } = opts;
      (0, modular_js_1.validateField)(Fp);
      for (const i of ["t", "roundsFull", "roundsPartial"]) {
        if (typeof opts[i] !== "number" || !Number.isSafeInteger(opts[i]))
          throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);
      }
      if (!Array.isArray(mds) || mds.length !== t)
        throw new Error("Poseidon: wrong MDS matrix");
      const _mds = mds.map((mdsRow) => {
        if (!Array.isArray(mdsRow) || mdsRow.length !== t)
          throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);
        return mdsRow.map((i) => {
          if (typeof i !== "bigint")
            throw new Error(`Poseidon MDS matrix value=${i}`);
          return Fp.create(i);
        });
      });
      if (rev !== void 0 && typeof rev !== "boolean")
        throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);
      if (roundsFull % 2 !== 0)
        throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);
      const rounds = roundsFull + roundsPartial;
      if (!Array.isArray(rc) || rc.length !== rounds)
        throw new Error("Poseidon: wrong round constants");
      const roundConstants = rc.map((rc2) => {
        if (!Array.isArray(rc2) || rc2.length !== t)
          throw new Error(`Poseidon wrong round constants: ${rc2}`);
        return rc2.map((i) => {
          if (typeof i !== "bigint" || !Fp.isValid(i))
            throw new Error(`Poseidon wrong round constant=${i}`);
          return Fp.create(i);
        });
      });
      if (!sboxPower || ![3, 5, 7].includes(sboxPower))
        throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);
      const _sboxPower = BigInt(sboxPower);
      let sboxFn = (n) => (0, modular_js_1.FpPow)(Fp, n, _sboxPower);
      if (sboxPower === 3)
        sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);
      else if (sboxPower === 5)
        sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);
      return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds: _mds });
    }
    function splitConstants(rc, t) {
      if (typeof t !== "number")
        throw new Error("poseidonSplitConstants: wrong t");
      if (!Array.isArray(rc) || rc.length % t)
        throw new Error("poseidonSplitConstants: wrong rc");
      const res = [];
      let tmp = [];
      for (let i = 0; i < rc.length; i++) {
        tmp.push(rc[i]);
        if (tmp.length === t) {
          res.push(tmp);
          tmp = [];
        }
      }
      return res;
    }
    function poseidon(opts) {
      const _opts = validateOpts(opts);
      const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;
      const halfRoundsFull = _opts.roundsFull / 2;
      const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;
      const poseidonRound = (values, isFull, idx) => {
        values = values.map((i, j) => Fp.add(i, roundConstants[idx][j]));
        if (isFull)
          values = values.map((i) => sboxFn(i));
        else
          values[partialIdx] = sboxFn(values[partialIdx]);
        values = mds.map((i) => i.reduce((acc, i2, j) => Fp.add(acc, Fp.mulN(i2, values[j])), Fp.ZERO));
        return values;
      };
      const poseidonHash = function poseidonHash2(values) {
        if (!Array.isArray(values) || values.length !== t)
          throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);
        values = values.map((i) => {
          if (typeof i !== "bigint")
            throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);
          return Fp.create(i);
        });
        let round2 = 0;
        for (let i = 0; i < halfRoundsFull; i++)
          values = poseidonRound(values, true, round2++);
        for (let i = 0; i < roundsPartial; i++)
          values = poseidonRound(values, false, round2++);
        for (let i = 0; i < halfRoundsFull; i++)
          values = poseidonRound(values, true, round2++);
        if (round2 !== rounds)
          throw new Error(`Poseidon: wrong number of rounds: last round=${round2}, total=${rounds}`);
        return values;
      };
      poseidonHash.roundConstants = roundConstants;
      return poseidonHash;
    }
  }
});

// node_modules/starknet/node_modules/@noble/curves/abstract/curve.js
var require_curve3 = __commonJS({
  "node_modules/starknet/node_modules/@noble/curves/abstract/curve.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wNAF = wNAF;
    exports2.validateBasic = validateBasic;
    var modular_js_1 = require_modular3();
    var utils_js_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset4 = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset4;
            const offset22 = offset4 + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset22]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
  }
});

// node_modules/starknet/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass3 = __commonJS({
  "node_modules/starknet/node_modules/@noble/curves/abstract/weierstrass.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DER = void 0;
    exports2.weierstrassPoints = weierstrassPoints;
    exports2.weierstrass = weierstrass;
    exports2.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports2.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    var curve_js_1 = require_curve3();
    var mod2 = require_modular3();
    var ut = require_utils4();
    var utils_js_1 = require_utils4();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports2.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports2.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports2.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        ut.abytes(data);
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r2, l: sBytes } = exports2.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports2.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r: r2, s };
      },
      hexFromSig(sig) {
        const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num2) => {
          const hex = num2.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice2(h(sig.s));
        const r2 = slice2(h(sig.r));
        const shl = s.length / 2;
        const rhl = r2.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r2}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes2 = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num2) {
        return typeof num2 === "bigint" && _0n < num2 && num2 < CURVE.n;
      }
      function assertGE(num2) {
        if (!isWithinCurveOrder(num2))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (ut.isBytes(key))
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num2;
        try {
          num2 = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num2 = mod2.mod(num2, n);
        assertGE(num2);
        return num2;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes2((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes2(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num2) {
        return _0n < num2 && num2 < Fp.ORDER;
      }
      function modN(a) {
        return mod2.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod2.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y;
            try {
              y = Fp.sqrt(y2);
            } catch (sqrtError) {
              const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("Point is not on curve" + suffix);
            }
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num2) => ut.bytesToHex(ut.numberToBytesBE(num2, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from2, to) => ut.bytesToNumberBE(b.slice(from2, to));
      class Signature {
        constructor(r2, s, recovery) {
          this.r = r2;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r: r2, s } = exports2.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r2, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r: r2, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports2.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod2.getMinHashLength(CURVE.n);
          return mod2.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num2 = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num2 >> BigInt(delta) : num2;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num2) {
        if (typeof num2 !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num2 && num2 < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num2, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash: hash2, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash2(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null && ent !== false) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r2 = modN(q.x);
          if (r2 === _0n)
            return;
          const s = modN(ik * modN(m + r2 * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r2, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        var _a2;
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || ut.isBytes(sg)) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports2.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r3, s: s2 } = sg;
            _sig = new Signature(r3, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r: r2, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r2 * is);
        const R = (_a2 = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a2.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r2;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      mod2.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
  }
});

// node_modules/lossless-json/lib/umd/lossless-json.js
var require_lossless_json = __commonJS({
  "node_modules/lossless-json/lib/umd/lossless-json.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    !function(t, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? e(exports2) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).LosslessJSON = {});
    }(exports2, function(t) {
      "use strict";
      function e(t2) {
        return r2.test(t2);
      }
      const r2 = /^-?[0-9]+$/;
      function n(t2) {
        return o.test(t2);
      }
      const o = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
      function i(t2, r3) {
        const n2 = Number.parseFloat(t2), o2 = String(n2), i2 = a(t2), u2 = a(o2);
        if (i2 === u2) return true;
        if (true === (r3 == null ? void 0 : r3.approx)) {
          const r4 = 14;
          if (!e(t2) && u2.length >= r4 && i2.startsWith(u2.substring(0, r4))) return true;
        }
        return false;
      }
      let u = function(t2) {
        return t2.underflow = "underflow", t2.overflow = "overflow", t2.truncate_integer = "truncate_integer", t2.truncate_float = "truncate_float", t2;
      }({});
      function c(t2) {
        if (i(t2, { approx: false })) return;
        if (e(t2)) return u.truncate_integer;
        const r3 = Number.parseFloat(t2);
        return Number.isFinite(r3) ? 0 === r3 ? u.underflow : u.truncate_float : u.overflow;
      }
      function a(t2) {
        return t2.replace(f, "").replace(l, "").replace(d, "").replace(s, "");
      }
      const f = /[eE][+-]?\d+$/, s = /^-?(0*)?/, l = /\./, d = /0+$/;
      class h {
        constructor(t2) {
          __publicField(this, "isLosslessNumber", true);
          if (!n(t2)) throw new Error(`Invalid number (value: "${t2}")`);
          this.value = t2;
        }
        valueOf() {
          const t2 = c(this.value);
          if (void 0 === t2 || t2 === u.truncate_float) return Number.parseFloat(this.value);
          if (e(this.value)) return BigInt(this.value);
          throw new Error(`Cannot safely convert to number: the value '${this.value}' would ${t2} and become ${Number.parseFloat(this.value)}`);
        }
        toString() {
          return this.value;
        }
      }
      function p(t2) {
        return t2 && "object" == typeof t2 && true === t2.isLosslessNumber || false;
      }
      function y(t2) {
        return new h(t2);
      }
      function b(t2, e2, r3, n2) {
        return Array.isArray(r3) ? n2.call(t2, e2, function(t3, e3) {
          for (let r4 = 0; r4 < t3.length; r4++) t3[r4] = b(t3, String(r4), t3[r4], e3);
          return t3;
        }(r3, n2)) : r3 && "object" == typeof r3 && !p(r3) ? n2.call(t2, e2, function(t3, e3) {
          for (const r4 of Object.keys(t3)) {
            const n3 = b(t3, r4, t3[r4], e3);
            void 0 !== n3 ? t3[r4] = n3 : delete t3[r4];
          }
          return t3;
        }(r3, n2)) : n2.call(t2, e2, r3);
      }
      function w(t2) {
        return t2 >= J && t2 <= B || t2 >= Q && t2 <= Z || t2 >= U && t2 <= q;
      }
      function g2(t2) {
        return t2 >= J && t2 <= B;
      }
      function v(t2, e2) {
        if (t2 === e2) return true;
        if (Array.isArray(t2) && Array.isArray(e2)) return t2.length === e2.length && t2.every((t3, r3) => v(t3, e2[r3]));
        if (m(t2) && m(e2)) {
          return [.../* @__PURE__ */ new Set([...Object.keys(t2), ...Object.keys(e2)])].every((r3) => v(t2[r3], e2[r3]));
        }
        return false;
      }
      function m(t2) {
        return "object" == typeof t2 && null !== t2;
      }
      const A = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: "\n", r: "\r", t: "	" }, $ = 92, C = 123, N = 125, S = 91, x = 93, E = 32, O = 10, I = 9, j = 13, k = 34, _ = 43, F = 45, J = 48, L = 49, B = 57, D = 44, T = 46, R = 58, Q = 65, U = 97, P = 69, W = 101, Z = 70, q = 102;
      const z = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/;
      t.LosslessNumber = h, t.UnsafeNumberReason = u, t.config = function(t2) {
        throw new Error("config is deprecated, support for circularRefs is removed from the library. If you encounter circular references in your data structures, please rethink your datastructures: better prevent circular references in the first place.");
      }, t.getUnsafeNumberReason = c, t.isInteger = e, t.isLosslessNumber = p, t.isNumber = n, t.isSafeNumber = i, t.parse = function(t2, e2) {
        let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : y, n2 = 0;
        const o2 = c2();
        return function(t3) {
          if (void 0 === t3) throw new SyntaxError(`JSON value expected ${H()}`);
        }(o2), function() {
          if (n2 < t2.length) throw new SyntaxError(`Expected end of input ${H()}`);
        }(), e2 ? function(t3, e3) {
          return b({ "": t3 }, "", t3, e3);
        }(o2, e2) : o2;
        function i2() {
          if (t2.charCodeAt(n2) === C) {
            n2++, f2();
            const e3 = {};
            let r4 = true;
            for (; n2 < t2.length && t2.charCodeAt(n2) !== N; ) {
              r4 ? r4 = false : (l2(), f2());
              const t3 = n2, o3 = s2();
              if (void 0 === o3) return void m2();
              f2(), d2();
              const i3 = c2();
              if (void 0 === i3) return void q2();
              Object.prototype.hasOwnProperty.call(e3, o3) && !v(i3, e3[o3]) && Q2(o3, t3 + 1), e3[o3] = i3;
            }
            return t2.charCodeAt(n2) !== N && function() {
              throw new SyntaxError(`Quoted object key or end of object '}' expected ${H()}`);
            }(), n2++, e3;
          }
        }
        function u2() {
          if (t2.charCodeAt(n2) === S) {
            n2++, f2();
            const e3 = [];
            let r4 = true;
            for (; n2 < t2.length && t2.charCodeAt(n2) !== x; ) {
              r4 ? r4 = false : l2();
              const t3 = c2();
              h2(t3), e3.push(t3);
            }
            return t2.charCodeAt(n2) !== x && function() {
              throw new SyntaxError(`Array item or end of array ']' expected ${H()}`);
            }(), n2++, e3;
          }
        }
        function c2() {
          f2();
          const e3 = s2() ?? function() {
            const e4 = n2;
            t2.charCodeAt(n2) === F && (n2++, p2(e4));
            if (t2.charCodeAt(n2) === J) n2++;
            else if (o3 = t2.charCodeAt(n2), o3 >= L && o3 <= B) for (n2++; g2(t2.charCodeAt(n2)); ) n2++;
            var o3;
            if (t2.charCodeAt(n2) === T) for (n2++, p2(e4); g2(t2.charCodeAt(n2)); ) n2++;
            if (t2.charCodeAt(n2) === W || t2.charCodeAt(n2) === P) for (n2++, t2.charCodeAt(n2) !== F && t2.charCodeAt(n2) !== _ || n2++, p2(e4); g2(t2.charCodeAt(n2)); ) n2++;
            if (n2 > e4) return r3(t2.slice(e4, n2));
          }() ?? i2() ?? u2() ?? a2("true", true) ?? a2("false", false) ?? a2("null", null);
          return f2(), e3;
        }
        function a2(e3, r4) {
          if (t2.slice(n2, n2 + e3.length) === e3) return n2 += e3.length, r4;
        }
        function f2() {
          for (; (e3 = t2.charCodeAt(n2)) === E || e3 === O || e3 === I || e3 === j; ) n2++;
          var e3;
        }
        function s2() {
          if (t2.charCodeAt(n2) === k) {
            n2++;
            let r4 = "";
            for (; n2 < t2.length && t2.charCodeAt(n2) !== k; ) {
              if (t2.charCodeAt(n2) === $) {
                const e4 = t2[n2 + 1], o3 = A[e4];
                void 0 !== o3 ? (r4 += o3, n2++) : "u" === e4 ? w(t2.charCodeAt(n2 + 2)) && w(t2.charCodeAt(n2 + 3)) && w(t2.charCodeAt(n2 + 4)) && w(t2.charCodeAt(n2 + 5)) ? (r4 += String.fromCharCode(Number.parseInt(t2.slice(n2 + 2, n2 + 6), 16)), n2 += 5) : z2(n2) : Z2(n2);
              } else (e3 = t2.charCodeAt(n2)) >= 32 && e3 <= 1114111 ? r4 += t2[n2] : U2(t2[n2]);
              n2++;
            }
            return function() {
              if (t2.charCodeAt(n2) !== k) throw new SyntaxError(`End of string '"' expected ${H()}`);
            }(), n2++, r4;
          }
          var e3;
        }
        function l2() {
          if (t2.charCodeAt(n2) !== D) throw new SyntaxError(`Comma ',' expected after value ${H()}`);
          n2++;
        }
        function d2() {
          if (t2.charCodeAt(n2) !== R) throw new SyntaxError(`Colon ':' expected after property name ${H()}`);
          n2++;
        }
        function h2(t3) {
          if (void 0 === t3) throw new SyntaxError(`Array item expected ${H()}`);
        }
        function p2(e3) {
          if (!g2(t2.charCodeAt(n2))) {
            const r4 = t2.slice(e3, n2);
            throw new SyntaxError(`Invalid number '${r4}', expecting a digit ${H()}`);
          }
        }
        function m2() {
          throw new SyntaxError(`Quoted object key expected ${H()}`);
        }
        function Q2(t3, e3) {
          throw new SyntaxError(`Duplicate key '${t3}' encountered at position ${e3}`);
        }
        function U2(t3) {
          throw new SyntaxError(`Invalid character '${t3}' ${G()}`);
        }
        function Z2(e3) {
          const r4 = t2.slice(e3, e3 + 2);
          throw new SyntaxError(`Invalid escape character '${r4}' ${G()}`);
        }
        function q2() {
          throw new SyntaxError(`Object value expected after ':' ${G()}`);
        }
        function z2(e3) {
          const r4 = t2.slice(e3, e3 + 6);
          throw new SyntaxError(`Invalid unicode character '${r4}' ${G()}`);
        }
        function G() {
          return `at position ${n2}`;
        }
        function H() {
          return `${n2 < t2.length ? `but got '${t2[n2]}'` : "but reached end of input"} ${G()}`;
        }
      }, t.parseLosslessNumber = y, t.parseNumberAndBigInt = function(t2) {
        return e(t2) ? BigInt(t2) : Number.parseFloat(t2);
      }, t.reviveDate = function(t2, e2) {
        return "string" == typeof e2 && z.test(e2) ? new Date(e2) : e2;
      }, t.stringify = function t2(e2, r3, o2, i2) {
        const u2 = function(t3) {
          if ("number" == typeof t3) return " ".repeat(t3);
          if ("string" == typeof t3 && "" !== t3) return t3;
          return;
        }(o2);
        return c2("function" == typeof r3 ? r3.call({ "": e2 }, "", e2) : e2, "");
        function c2(e3, f2) {
          if (Array.isArray(i2)) {
            const t3 = i2.find((t4) => t4.test(e3));
            if (t3) {
              const r4 = t3.stringify(e3);
              if ("string" != typeof r4 || !n(r4)) throw new Error(`Invalid JSON number: output of a number stringifier must be a string containing a JSON number (output: ${r4})`);
              return r4;
            }
          }
          return "boolean" == typeof e3 || "number" == typeof e3 || "string" == typeof e3 || null === e3 || e3 instanceof Date || e3 instanceof Boolean || e3 instanceof Number || e3 instanceof String ? JSON.stringify(e3) : (e3 == null ? void 0 : e3.isLosslessNumber) || "bigint" == typeof e3 ? e3.toString() : Array.isArray(e3) ? function(t3, e4) {
            if (0 === t3.length) return "[]";
            const n2 = u2 ? e4 + u2 : void 0;
            let o3 = u2 ? "[\n" : "[";
            for (let e5 = 0; e5 < t3.length; e5++) {
              const i3 = "function" == typeof r3 ? r3.call(t3, String(e5), t3[e5]) : t3[e5];
              u2 && (o3 += n2), o3 += void 0 !== i3 && "function" != typeof i3 ? c2(i3, n2) : "null", e5 < t3.length - 1 && (o3 += u2 ? ",\n" : ",");
            }
            return o3 += u2 ? `
${e4}]` : "]", o3;
          }(e3, f2) : e3 && "object" == typeof e3 ? function(e4, n2) {
            if ("function" == typeof e4.toJSON) return t2(e4.toJSON(), r3, o2, void 0);
            const i3 = Array.isArray(r3) ? r3.map(String) : Object.keys(e4);
            if (0 === i3.length) return "{}";
            const f3 = u2 ? n2 + u2 : void 0;
            let s2 = true, l2 = u2 ? "{\n" : "{";
            for (const t3 of i3) {
              const n3 = "function" == typeof r3 ? r3.call(e4, t3, e4[t3]) : e4[t3];
              if (a2(t3, n3)) {
                s2 ? s2 = false : l2 += u2 ? ",\n" : ",";
                const e5 = JSON.stringify(t3);
                l2 += u2 ? `${f3 + e5}: ` : `${e5}:`, l2 += c2(n3, f3);
              }
            }
            return l2 += u2 ? `
${n2}}` : "}", l2;
          }(e3, f2) : void 0;
        }
        function a2(t3, e3) {
          return void 0 !== e3 && "function" != typeof e3 && "symbol" != typeof e3;
        }
      }, t.toLosslessNumber = function(t2) {
        if (a(String(t2)).length > 15) throw new Error(`Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself (value: ${t2})`);
        if (Number.isNaN(t2)) throw new Error("Invalid number: NaN");
        if (!Number.isFinite(t2)) throw new Error(`Invalid number: ${t2}`);
        return new h(String(t2));
      }, t.toSafeNumberOrThrow = function(t2, e2) {
        const r3 = Number.parseFloat(t2), n2 = c(t2);
        if (true === (e2 == null ? void 0 : e2.approx) ? n2 && n2 !== u.truncate_float : n2) {
          const e3 = n2 == null ? void 0 : n2.replace(/_\w+$/, "");
          throw new Error(`Cannot safely convert to number: the value '${t2}' would ${e3} and become ${r3}`);
        }
        return r3;
      };
    });
  }
});

// node_modules/starknet/node_modules/@noble/hashes/_md.js
var require_md2 = __commonJS({
  "node_modules/starknet/node_modules/@noble/hashes/_md.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HashMD = exports2.Maj = exports2.Chi = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils5();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var Chi = (a, b, c) => a & b ^ ~a & c;
    exports2.Chi = Chi;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    exports2.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports2.HashMD = HashMD;
  }
});

// node_modules/starknet/node_modules/@noble/hashes/sha256.js
var require_sha2565 = __commonJS({
  "node_modules/starknet/node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.sha256 = void 0;
    var _md_js_1 = require_md2();
    var utils_js_1 = require_utils5();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset4) {
        for (let i = 0; i < 16; i++, offset4 += 4)
          SHA256_W[i] = view.getUint32(offset4, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/starknet/node_modules/@noble/hashes/hmac.js
var require_hmac3 = __commonJS({
  "node_modules/starknet/node_modules/@noble/hashes/hmac.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmac = exports2.HMAC = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils5();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash2);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports2.HMAC = HMAC;
    var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
    exports2.hmac = hmac;
    exports2.hmac.create = (hash2, key) => new HMAC(hash2, key);
  }
});

// node_modules/starknet/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils3 = __commonJS({
  "node_modules/starknet/node_modules/@noble/curves/_shortw_utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getHash = getHash;
    exports2.createCurve = createCurve;
    var hmac_1 = require_hmac3();
    var utils_1 = require_utils5();
    var weierstrass_js_1 = require_weierstrass3();
    function getHash(hash2) {
      return {
        hash: hash2,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash2, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash2) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash2) });
      return Object.freeze({ ...create(defHash), create });
    }
  }
});

// node_modules/starknet/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve2 = __commonJS({
  "node_modules/starknet/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.expand_message_xmd = expand_message_xmd;
    exports2.expand_message_xof = expand_message_xof;
    exports2.hash_to_field = hash_to_field;
    exports2.isogenyMap = isogenyMap;
    exports2.createHasher = createHasher;
    var modular_js_1 = require_modular3();
    var utils_js_1 = require_utils4();
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count3, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash: hash2, expand, DST: _DST } = options;
      (0, utils_js_1.abytes)(msg);
      anum(count3);
      const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count3 * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count3);
      for (let i = 0; i < count3; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Same as encodeToCurve, but without hash
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("mapToCurve: expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);
          const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
  }
});

// node_modules/starknet/node_modules/@noble/curves/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/starknet/node_modules/@noble/curves/secp256k1.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeToCurve = exports2.hashToCurve = exports2.schnorr = exports2.secp256k1 = void 0;
    var sha256_1 = require_sha2565();
    var utils_1 = require_utils5();
    var _shortw_utils_js_1 = require_shortw_utils3();
    var hash_to_curve_js_1 = require_hash_to_curve2();
    var modular_js_1 = require_modular3();
    var utils_js_1 = require_utils4();
    var weierstrass_js_1 = require_weierstrass3();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root2 = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root2), y))
        throw new Error("Cannot find square root");
      return root2;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports2.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      // equation params: a, b
      b: BigInt(7),
      // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
      Fp,
      // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N,
      // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      // Cofactor
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
    var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports2.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports2.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      if (!fe(x))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r2 = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r2))
          return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s))
          return false;
        const e = challenge(numTo32b(r2), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r2)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports2.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports2.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports2.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports2.hashToCurve = (() => htf.hashToCurve)();
    exports2.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// ../../node_modules/node-stdlib-browser/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "../../node_modules/node-stdlib-browser/node_modules/punycode/punycode.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    (function(root2) {
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root2 = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor2 = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result2 = [];
        while (length--) {
          result2[length] = fn(array[length]);
        }
        return result2;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result2 = "";
        if (parts.length > 1) {
          result2 = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result2 + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor2(delta / damp) : delta >> 1;
        delta += floor2(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor2(delta / baseMinusTMin);
        }
        return floor2(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode2(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index2, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index2 >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base || digit > floor2((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor2(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor2(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor2(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode3(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor2((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor2(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode3(string) : string;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode2,
        "encode": encode3,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module2.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root2.punycode = punycode;
      }
    })(exports2);
  }
});

// node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "node_modules/requires-port/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    module2.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port) return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "node_modules/querystringify/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var has = Object.prototype.hasOwnProperty;
    var undef;
    function decode2(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e) {
        return null;
      }
    }
    function encode3(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }
    function querystring(query) {
      var parser2 = /([^=?#&]+)=?([^&]*)/g, result2 = {}, part;
      while (part = parser2.exec(query)) {
        var key = decode2(part[1]), value = decode2(part[2]);
        if (key === null || value === null || key in result2) continue;
        result2[key] = value;
      }
      return result2;
    }
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key;
      if ("string" !== typeof prefix) prefix = "?";
      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key = encode3(key);
          value = encode3(value);
          if (key === null || value === null) continue;
          pairs.push(key + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    exports2.stringify = querystringify;
    exports2.parse = querystring;
  }
});

// node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "node_modules/url-parse/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined") globalVar = window;
      else if (typeof global !== "undefined") globalVar = global;
      else if (typeof self !== "undefined") globalVar = self;
      else globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type = typeof loc, key;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ("string" === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore) delete finaldestination[key];
      } else if ("object" === type) {
        for (key in loc) {
          if (key in ignore) continue;
          finaldestination[key] = loc[key];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve(relative, base) {
      if (relative === "") return base;
      var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
      while (i--) {
        if (path[i] === ".") {
          path.splice(i, 1);
        } else if (path[i] === "..") {
          path.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0) unshift = true;
          path.splice(i, 1);
          up--;
        }
      }
      if (unshift) path.unshift("");
      if (last === "." || last === "..") path.push("");
      return path.join("/");
    }
    function Url(address, location, parser2) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location, parser2);
      }
      var relative, extracted, parse3, instruction, index2, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
      if ("object" !== type && "string" !== type) {
        parser2 = location;
        location = null;
      }
      if (parser2 && "function" !== typeof parser2) parser2 = qs.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i < instructions.length; i++) {
        instruction = instructions[i];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse3 = instruction[0];
        key = instruction[1];
        if (parse3 !== parse3) {
          url[key] = address;
        } else if ("string" === typeof parse3) {
          index2 = parse3 === "@" ? address.lastIndexOf(parse3) : address.indexOf(parse3);
          if (~index2) {
            if ("number" === typeof instruction[2]) {
              url[key] = address.slice(0, index2);
              address = address.slice(index2 + instruction[2]);
            } else {
              url[key] = address.slice(index2);
              address = address.slice(0, index2);
            }
          }
        } else if (index2 = parse3.exec(address)) {
          url[key] = index2[1];
          address = address.slice(0, index2.index);
        }
        url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
        if (instruction[4]) url[key] = url[key].toLowerCase();
      }
      if (parser2) url.query = parser2(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index2 = url.auth.indexOf(":");
        if (~index2) {
          url.username = url.auth.slice(0, index2);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index2 + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port) value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index2 = value.indexOf(":");
          if (~index2) {
            url.username = value.slice(0, index2);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index2 + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];
        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString4(stringify2) {
      if (!stringify2 || "function" !== typeof stringify2) stringify2 = qs.stringify;
      var query, url = this, host2 = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
      var result2 = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result2 += url.username;
        if (url.password) result2 += ":" + url.password;
        result2 += "@";
      } else if (url.password) {
        result2 += ":" + url.password;
        result2 += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host2 && url.pathname !== "/") {
        result2 += "@";
      }
      if (host2[host2.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host2 += ":";
      }
      result2 += host2 + url.pathname;
      query = "object" === typeof url.query ? stringify2(url.query) : url.query;
      if (query) result2 += "?" !== query.charAt(0) ? "?" + query : query;
      if (url.hash) result2 += url.hash;
      return result2;
    }
    Url.prototype = { set, toString: toString4 };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module2.exports = Url;
  }
});

// node_modules/psl/dist/psl.cjs
var require_psl = __commonJS({
  "node_modules/psl/dist/psl.cjs"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    function K(e) {
      return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
    }
    var O;
    var F;
    function Q() {
      if (F) return O;
      F = 1;
      const e = 2147483647, s = 36, c = 1, o = 26, t = 38, d = 700, z = 72, y = 128, g2 = "-", P = /^xn--/, V = /[^\0-\x7F]/, G = /[\x2E\u3002\uFF0E\uFF61]/g, W = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, C = s - c, h = Math.floor, I = String.fromCharCode;
      function v(a) {
        throw new RangeError(W[a]);
      }
      function U(a, i) {
        const m = [];
        let n = a.length;
        for (; n--; ) m[n] = i(a[n]);
        return m;
      }
      function S(a, i) {
        const m = a.split("@");
        let n = "";
        m.length > 1 && (n = m[0] + "@", a = m[1]), a = a.replace(G, ".");
        const r2 = a.split("."), p = U(r2, i).join(".");
        return n + p;
      }
      function L(a) {
        const i = [];
        let m = 0;
        const n = a.length;
        for (; m < n; ) {
          const r2 = a.charCodeAt(m++);
          if (r2 >= 55296 && r2 <= 56319 && m < n) {
            const p = a.charCodeAt(m++);
            (p & 64512) == 56320 ? i.push(((r2 & 1023) << 10) + (p & 1023) + 65536) : (i.push(r2), m--);
          } else i.push(r2);
        }
        return i;
      }
      const $ = (a) => String.fromCodePoint(...a), J = function(a) {
        return a >= 48 && a < 58 ? 26 + (a - 48) : a >= 65 && a < 91 ? a - 65 : a >= 97 && a < 123 ? a - 97 : s;
      }, D = function(a, i) {
        return a + 22 + 75 * (a < 26) - ((i != 0) << 5);
      }, T = function(a, i, m) {
        let n = 0;
        for (a = m ? h(a / d) : a >> 1, a += h(a / i); a > C * o >> 1; n += s) a = h(a / C);
        return h(n + (C + 1) * a / (a + t));
      }, E = function(a) {
        const i = [], m = a.length;
        let n = 0, r2 = y, p = z, j = a.lastIndexOf(g2);
        j < 0 && (j = 0);
        for (let u = 0; u < j; ++u) a.charCodeAt(u) >= 128 && v("not-basic"), i.push(a.charCodeAt(u));
        for (let u = j > 0 ? j + 1 : 0; u < m; ) {
          const k = n;
          for (let l = 1, b = s; ; b += s) {
            u >= m && v("invalid-input");
            const w = J(a.charCodeAt(u++));
            w >= s && v("invalid-input"), w > h((e - n) / l) && v("overflow"), n += w * l;
            const x = b <= p ? c : b >= p + o ? o : b - p;
            if (w < x) break;
            const q = s - x;
            l > h(e / q) && v("overflow"), l *= q;
          }
          const f = i.length + 1;
          p = T(n - k, f, k == 0), h(n / f) > e - r2 && v("overflow"), r2 += h(n / f), n %= f, i.splice(n++, 0, r2);
        }
        return String.fromCodePoint(...i);
      }, B = function(a) {
        const i = [];
        a = L(a);
        const m = a.length;
        let n = y, r2 = 0, p = z;
        for (const k of a) k < 128 && i.push(I(k));
        const j = i.length;
        let u = j;
        for (j && i.push(g2); u < m; ) {
          let k = e;
          for (const l of a) l >= n && l < k && (k = l);
          const f = u + 1;
          k - n > h((e - r2) / f) && v("overflow"), r2 += (k - n) * f, n = k;
          for (const l of a) if (l < n && ++r2 > e && v("overflow"), l === n) {
            let b = r2;
            for (let w = s; ; w += s) {
              const x = w <= p ? c : w >= p + o ? o : w - p;
              if (b < x) break;
              const q = b - x, M = s - x;
              i.push(I(D(x + q % M, 0))), b = h(q / M);
            }
            i.push(I(D(b, 0))), p = T(r2, f, u === j), r2 = 0, ++u;
          }
          ++r2, ++n;
        }
        return i.join("");
      };
      return O = { version: "2.3.1", ucs2: { decode: L, encode: $ }, decode: E, encode: B, toASCII: function(a) {
        return S(a, function(i) {
          return V.test(i) ? "xn--" + B(i) : i;
        });
      }, toUnicode: function(a) {
        return S(a, function(i) {
          return P.test(i) ? E(i.slice(4).toLowerCase()) : i;
        });
      } }, O;
    }
    var X = Q();
    var A = K(X);
    var Y = ["ac", "com.ac", "edu.ac", "gov.ac", "mil.ac", "net.ac", "org.ac", "ad", "ae", "ac.ae", "co.ae", "gov.ae", "mil.ae", "net.ae", "org.ae", "sch.ae", "aero", "airline.aero", "airport.aero", "accident-investigation.aero", "accident-prevention.aero", "aerobatic.aero", "aeroclub.aero", "aerodrome.aero", "agents.aero", "air-surveillance.aero", "air-traffic-control.aero", "aircraft.aero", "airtraffic.aero", "ambulance.aero", "association.aero", "author.aero", "ballooning.aero", "broker.aero", "caa.aero", "cargo.aero", "catering.aero", "certification.aero", "championship.aero", "charter.aero", "civilaviation.aero", "club.aero", "conference.aero", "consultant.aero", "consulting.aero", "control.aero", "council.aero", "crew.aero", "design.aero", "dgca.aero", "educator.aero", "emergency.aero", "engine.aero", "engineer.aero", "entertainment.aero", "equipment.aero", "exchange.aero", "express.aero", "federation.aero", "flight.aero", "freight.aero", "fuel.aero", "gliding.aero", "government.aero", "groundhandling.aero", "group.aero", "hanggliding.aero", "homebuilt.aero", "insurance.aero", "journal.aero", "journalist.aero", "leasing.aero", "logistics.aero", "magazine.aero", "maintenance.aero", "marketplace.aero", "media.aero", "microlight.aero", "modelling.aero", "navigation.aero", "parachuting.aero", "paragliding.aero", "passenger-association.aero", "pilot.aero", "press.aero", "production.aero", "recreation.aero", "repbody.aero", "res.aero", "research.aero", "rotorcraft.aero", "safety.aero", "scientist.aero", "services.aero", "show.aero", "skydiving.aero", "software.aero", "student.aero", "taxi.aero", "trader.aero", "trading.aero", "trainer.aero", "union.aero", "workinggroup.aero", "works.aero", "af", "com.af", "edu.af", "gov.af", "net.af", "org.af", "ag", "co.ag", "com.ag", "net.ag", "nom.ag", "org.ag", "ai", "com.ai", "net.ai", "off.ai", "org.ai", "al", "com.al", "edu.al", "gov.al", "mil.al", "net.al", "org.al", "am", "co.am", "com.am", "commune.am", "net.am", "org.am", "ao", "co.ao", "ed.ao", "edu.ao", "gov.ao", "gv.ao", "it.ao", "og.ao", "org.ao", "pb.ao", "aq", "ar", "bet.ar", "com.ar", "coop.ar", "edu.ar", "gob.ar", "gov.ar", "int.ar", "mil.ar", "musica.ar", "mutual.ar", "net.ar", "org.ar", "senasa.ar", "tur.ar", "arpa", "e164.arpa", "home.arpa", "in-addr.arpa", "ip6.arpa", "iris.arpa", "uri.arpa", "urn.arpa", "as", "gov.as", "asia", "at", "ac.at", "sth.ac.at", "co.at", "gv.at", "or.at", "au", "asn.au", "com.au", "edu.au", "gov.au", "id.au", "net.au", "org.au", "conf.au", "oz.au", "act.au", "nsw.au", "nt.au", "qld.au", "sa.au", "tas.au", "vic.au", "wa.au", "act.edu.au", "catholic.edu.au", "nsw.edu.au", "nt.edu.au", "qld.edu.au", "sa.edu.au", "tas.edu.au", "vic.edu.au", "wa.edu.au", "qld.gov.au", "sa.gov.au", "tas.gov.au", "vic.gov.au", "wa.gov.au", "schools.nsw.edu.au", "aw", "com.aw", "ax", "az", "biz.az", "com.az", "edu.az", "gov.az", "info.az", "int.az", "mil.az", "name.az", "net.az", "org.az", "pp.az", "pro.az", "ba", "com.ba", "edu.ba", "gov.ba", "mil.ba", "net.ba", "org.ba", "bb", "biz.bb", "co.bb", "com.bb", "edu.bb", "gov.bb", "info.bb", "net.bb", "org.bb", "store.bb", "tv.bb", "*.bd", "be", "ac.be", "bf", "gov.bf", "bg", "0.bg", "1.bg", "2.bg", "3.bg", "4.bg", "5.bg", "6.bg", "7.bg", "8.bg", "9.bg", "a.bg", "b.bg", "c.bg", "d.bg", "e.bg", "f.bg", "g.bg", "h.bg", "i.bg", "j.bg", "k.bg", "l.bg", "m.bg", "n.bg", "o.bg", "p.bg", "q.bg", "r.bg", "s.bg", "t.bg", "u.bg", "v.bg", "w.bg", "x.bg", "y.bg", "z.bg", "bh", "com.bh", "edu.bh", "gov.bh", "net.bh", "org.bh", "bi", "co.bi", "com.bi", "edu.bi", "or.bi", "org.bi", "biz", "bj", "africa.bj", "agro.bj", "architectes.bj", "assur.bj", "avocats.bj", "co.bj", "com.bj", "eco.bj", "econo.bj", "edu.bj", "info.bj", "loisirs.bj", "money.bj", "net.bj", "org.bj", "ote.bj", "restaurant.bj", "resto.bj", "tourism.bj", "univ.bj", "bm", "com.bm", "edu.bm", "gov.bm", "net.bm", "org.bm", "bn", "com.bn", "edu.bn", "gov.bn", "net.bn", "org.bn", "bo", "com.bo", "edu.bo", "gob.bo", "int.bo", "mil.bo", "net.bo", "org.bo", "tv.bo", "web.bo", "academia.bo", "agro.bo", "arte.bo", "blog.bo", "bolivia.bo", "ciencia.bo", "cooperativa.bo", "democracia.bo", "deporte.bo", "ecologia.bo", "economia.bo", "empresa.bo", "indigena.bo", "industria.bo", "info.bo", "medicina.bo", "movimiento.bo", "musica.bo", "natural.bo", "nombre.bo", "noticias.bo", "patria.bo", "plurinacional.bo", "politica.bo", "profesional.bo", "pueblo.bo", "revista.bo", "salud.bo", "tecnologia.bo", "tksat.bo", "transporte.bo", "wiki.bo", "br", "9guacu.br", "abc.br", "adm.br", "adv.br", "agr.br", "aju.br", "am.br", "anani.br", "aparecida.br", "app.br", "arq.br", "art.br", "ato.br", "b.br", "barueri.br", "belem.br", "bet.br", "bhz.br", "bib.br", "bio.br", "blog.br", "bmd.br", "boavista.br", "bsb.br", "campinagrande.br", "campinas.br", "caxias.br", "cim.br", "cng.br", "cnt.br", "com.br", "contagem.br", "coop.br", "coz.br", "cri.br", "cuiaba.br", "curitiba.br", "def.br", "des.br", "det.br", "dev.br", "ecn.br", "eco.br", "edu.br", "emp.br", "enf.br", "eng.br", "esp.br", "etc.br", "eti.br", "far.br", "feira.br", "flog.br", "floripa.br", "fm.br", "fnd.br", "fortal.br", "fot.br", "foz.br", "fst.br", "g12.br", "geo.br", "ggf.br", "goiania.br", "gov.br", "ac.gov.br", "al.gov.br", "am.gov.br", "ap.gov.br", "ba.gov.br", "ce.gov.br", "df.gov.br", "es.gov.br", "go.gov.br", "ma.gov.br", "mg.gov.br", "ms.gov.br", "mt.gov.br", "pa.gov.br", "pb.gov.br", "pe.gov.br", "pi.gov.br", "pr.gov.br", "rj.gov.br", "rn.gov.br", "ro.gov.br", "rr.gov.br", "rs.gov.br", "sc.gov.br", "se.gov.br", "sp.gov.br", "to.gov.br", "gru.br", "imb.br", "ind.br", "inf.br", "jab.br", "jampa.br", "jdf.br", "joinville.br", "jor.br", "jus.br", "leg.br", "leilao.br", "lel.br", "log.br", "londrina.br", "macapa.br", "maceio.br", "manaus.br", "maringa.br", "mat.br", "med.br", "mil.br", "morena.br", "mp.br", "mus.br", "natal.br", "net.br", "niteroi.br", "*.nom.br", "not.br", "ntr.br", "odo.br", "ong.br", "org.br", "osasco.br", "palmas.br", "poa.br", "ppg.br", "pro.br", "psc.br", "psi.br", "pvh.br", "qsl.br", "radio.br", "rec.br", "recife.br", "rep.br", "ribeirao.br", "rio.br", "riobranco.br", "riopreto.br", "salvador.br", "sampa.br", "santamaria.br", "santoandre.br", "saobernardo.br", "saogonca.br", "seg.br", "sjc.br", "slg.br", "slz.br", "sorocaba.br", "srv.br", "taxi.br", "tc.br", "tec.br", "teo.br", "the.br", "tmp.br", "trd.br", "tur.br", "tv.br", "udi.br", "vet.br", "vix.br", "vlog.br", "wiki.br", "zlg.br", "bs", "com.bs", "edu.bs", "gov.bs", "net.bs", "org.bs", "bt", "com.bt", "edu.bt", "gov.bt", "net.bt", "org.bt", "bv", "bw", "co.bw", "org.bw", "by", "gov.by", "mil.by", "com.by", "of.by", "bz", "co.bz", "com.bz", "edu.bz", "gov.bz", "net.bz", "org.bz", "ca", "ab.ca", "bc.ca", "mb.ca", "nb.ca", "nf.ca", "nl.ca", "ns.ca", "nt.ca", "nu.ca", "on.ca", "pe.ca", "qc.ca", "sk.ca", "yk.ca", "gc.ca", "cat", "cc", "cd", "gov.cd", "cf", "cg", "ch", "ci", "ac.ci", "aéroport.ci", "asso.ci", "co.ci", "com.ci", "ed.ci", "edu.ci", "go.ci", "gouv.ci", "int.ci", "net.ci", "or.ci", "org.ci", "*.ck", "!www.ck", "cl", "co.cl", "gob.cl", "gov.cl", "mil.cl", "cm", "co.cm", "com.cm", "gov.cm", "net.cm", "cn", "ac.cn", "com.cn", "edu.cn", "gov.cn", "mil.cn", "net.cn", "org.cn", "公司.cn", "網絡.cn", "网络.cn", "ah.cn", "bj.cn", "cq.cn", "fj.cn", "gd.cn", "gs.cn", "gx.cn", "gz.cn", "ha.cn", "hb.cn", "he.cn", "hi.cn", "hk.cn", "hl.cn", "hn.cn", "jl.cn", "js.cn", "jx.cn", "ln.cn", "mo.cn", "nm.cn", "nx.cn", "qh.cn", "sc.cn", "sd.cn", "sh.cn", "sn.cn", "sx.cn", "tj.cn", "tw.cn", "xj.cn", "xz.cn", "yn.cn", "zj.cn", "co", "com.co", "edu.co", "gov.co", "mil.co", "net.co", "nom.co", "org.co", "com", "coop", "cr", "ac.cr", "co.cr", "ed.cr", "fi.cr", "go.cr", "or.cr", "sa.cr", "cu", "com.cu", "edu.cu", "gob.cu", "inf.cu", "nat.cu", "net.cu", "org.cu", "cv", "com.cv", "edu.cv", "id.cv", "int.cv", "net.cv", "nome.cv", "org.cv", "publ.cv", "cw", "com.cw", "edu.cw", "net.cw", "org.cw", "cx", "gov.cx", "cy", "ac.cy", "biz.cy", "com.cy", "ekloges.cy", "gov.cy", "ltd.cy", "mil.cy", "net.cy", "org.cy", "press.cy", "pro.cy", "tm.cy", "cz", "de", "dj", "dk", "dm", "co.dm", "com.dm", "edu.dm", "gov.dm", "net.dm", "org.dm", "do", "art.do", "com.do", "edu.do", "gob.do", "gov.do", "mil.do", "net.do", "org.do", "sld.do", "web.do", "dz", "art.dz", "asso.dz", "com.dz", "edu.dz", "gov.dz", "net.dz", "org.dz", "pol.dz", "soc.dz", "tm.dz", "ec", "com.ec", "edu.ec", "fin.ec", "gob.ec", "gov.ec", "info.ec", "k12.ec", "med.ec", "mil.ec", "net.ec", "org.ec", "pro.ec", "edu", "ee", "aip.ee", "com.ee", "edu.ee", "fie.ee", "gov.ee", "lib.ee", "med.ee", "org.ee", "pri.ee", "riik.ee", "eg", "ac.eg", "com.eg", "edu.eg", "eun.eg", "gov.eg", "info.eg", "me.eg", "mil.eg", "name.eg", "net.eg", "org.eg", "sci.eg", "sport.eg", "tv.eg", "*.er", "es", "com.es", "edu.es", "gob.es", "nom.es", "org.es", "et", "biz.et", "com.et", "edu.et", "gov.et", "info.et", "name.et", "net.et", "org.et", "eu", "fi", "aland.fi", "fj", "ac.fj", "biz.fj", "com.fj", "gov.fj", "info.fj", "mil.fj", "name.fj", "net.fj", "org.fj", "pro.fj", "*.fk", "fm", "com.fm", "edu.fm", "net.fm", "org.fm", "fo", "fr", "asso.fr", "com.fr", "gouv.fr", "nom.fr", "prd.fr", "tm.fr", "avoues.fr", "cci.fr", "greta.fr", "huissier-justice.fr", "ga", "gb", "gd", "edu.gd", "gov.gd", "ge", "com.ge", "edu.ge", "gov.ge", "net.ge", "org.ge", "pvt.ge", "school.ge", "gf", "gg", "co.gg", "net.gg", "org.gg", "gh", "com.gh", "edu.gh", "gov.gh", "mil.gh", "org.gh", "gi", "com.gi", "edu.gi", "gov.gi", "ltd.gi", "mod.gi", "org.gi", "gl", "co.gl", "com.gl", "edu.gl", "net.gl", "org.gl", "gm", "gn", "ac.gn", "com.gn", "edu.gn", "gov.gn", "net.gn", "org.gn", "gov", "gp", "asso.gp", "com.gp", "edu.gp", "mobi.gp", "net.gp", "org.gp", "gq", "gr", "com.gr", "edu.gr", "gov.gr", "net.gr", "org.gr", "gs", "gt", "com.gt", "edu.gt", "gob.gt", "ind.gt", "mil.gt", "net.gt", "org.gt", "gu", "com.gu", "edu.gu", "gov.gu", "guam.gu", "info.gu", "net.gu", "org.gu", "web.gu", "gw", "gy", "co.gy", "com.gy", "edu.gy", "gov.gy", "net.gy", "org.gy", "hk", "com.hk", "edu.hk", "gov.hk", "idv.hk", "net.hk", "org.hk", "个人.hk", "個人.hk", "公司.hk", "政府.hk", "敎育.hk", "教育.hk", "箇人.hk", "組織.hk", "組织.hk", "網絡.hk", "網络.hk", "组織.hk", "组织.hk", "网絡.hk", "网络.hk", "hm", "hn", "com.hn", "edu.hn", "gob.hn", "mil.hn", "net.hn", "org.hn", "hr", "com.hr", "from.hr", "iz.hr", "name.hr", "ht", "adult.ht", "art.ht", "asso.ht", "com.ht", "coop.ht", "edu.ht", "firm.ht", "gouv.ht", "info.ht", "med.ht", "net.ht", "org.ht", "perso.ht", "pol.ht", "pro.ht", "rel.ht", "shop.ht", "hu", "2000.hu", "agrar.hu", "bolt.hu", "casino.hu", "city.hu", "co.hu", "erotica.hu", "erotika.hu", "film.hu", "forum.hu", "games.hu", "hotel.hu", "info.hu", "ingatlan.hu", "jogasz.hu", "konyvelo.hu", "lakas.hu", "media.hu", "news.hu", "org.hu", "priv.hu", "reklam.hu", "sex.hu", "shop.hu", "sport.hu", "suli.hu", "szex.hu", "tm.hu", "tozsde.hu", "utazas.hu", "video.hu", "id", "ac.id", "biz.id", "co.id", "desa.id", "go.id", "mil.id", "my.id", "net.id", "or.id", "ponpes.id", "sch.id", "web.id", "ie", "gov.ie", "il", "ac.il", "co.il", "gov.il", "idf.il", "k12.il", "muni.il", "net.il", "org.il", "ישראל", "אקדמיה.ישראל", "ישוב.ישראל", "צהל.ישראל", "ממשל.ישראל", "im", "ac.im", "co.im", "ltd.co.im", "plc.co.im", "com.im", "net.im", "org.im", "tt.im", "tv.im", "in", "5g.in", "6g.in", "ac.in", "ai.in", "am.in", "bihar.in", "biz.in", "business.in", "ca.in", "cn.in", "co.in", "com.in", "coop.in", "cs.in", "delhi.in", "dr.in", "edu.in", "er.in", "firm.in", "gen.in", "gov.in", "gujarat.in", "ind.in", "info.in", "int.in", "internet.in", "io.in", "me.in", "mil.in", "net.in", "nic.in", "org.in", "pg.in", "post.in", "pro.in", "res.in", "travel.in", "tv.in", "uk.in", "up.in", "us.in", "info", "int", "eu.int", "io", "co.io", "com.io", "edu.io", "gov.io", "mil.io", "net.io", "nom.io", "org.io", "iq", "com.iq", "edu.iq", "gov.iq", "mil.iq", "net.iq", "org.iq", "ir", "ac.ir", "co.ir", "gov.ir", "id.ir", "net.ir", "org.ir", "sch.ir", "ایران.ir", "ايران.ir", "is", "it", "edu.it", "gov.it", "abr.it", "abruzzo.it", "aosta-valley.it", "aostavalley.it", "bas.it", "basilicata.it", "cal.it", "calabria.it", "cam.it", "campania.it", "emilia-romagna.it", "emiliaromagna.it", "emr.it", "friuli-v-giulia.it", "friuli-ve-giulia.it", "friuli-vegiulia.it", "friuli-venezia-giulia.it", "friuli-veneziagiulia.it", "friuli-vgiulia.it", "friuliv-giulia.it", "friulive-giulia.it", "friulivegiulia.it", "friulivenezia-giulia.it", "friuliveneziagiulia.it", "friulivgiulia.it", "fvg.it", "laz.it", "lazio.it", "lig.it", "liguria.it", "lom.it", "lombardia.it", "lombardy.it", "lucania.it", "mar.it", "marche.it", "mol.it", "molise.it", "piedmont.it", "piemonte.it", "pmn.it", "pug.it", "puglia.it", "sar.it", "sardegna.it", "sardinia.it", "sic.it", "sicilia.it", "sicily.it", "taa.it", "tos.it", "toscana.it", "trentin-sud-tirol.it", "trentin-süd-tirol.it", "trentin-sudtirol.it", "trentin-südtirol.it", "trentin-sued-tirol.it", "trentin-suedtirol.it", "trentino.it", "trentino-a-adige.it", "trentino-aadige.it", "trentino-alto-adige.it", "trentino-altoadige.it", "trentino-s-tirol.it", "trentino-stirol.it", "trentino-sud-tirol.it", "trentino-süd-tirol.it", "trentino-sudtirol.it", "trentino-südtirol.it", "trentino-sued-tirol.it", "trentino-suedtirol.it", "trentinoa-adige.it", "trentinoaadige.it", "trentinoalto-adige.it", "trentinoaltoadige.it", "trentinos-tirol.it", "trentinostirol.it", "trentinosud-tirol.it", "trentinosüd-tirol.it", "trentinosudtirol.it", "trentinosüdtirol.it", "trentinosued-tirol.it", "trentinosuedtirol.it", "trentinsud-tirol.it", "trentinsüd-tirol.it", "trentinsudtirol.it", "trentinsüdtirol.it", "trentinsued-tirol.it", "trentinsuedtirol.it", "tuscany.it", "umb.it", "umbria.it", "val-d-aosta.it", "val-daosta.it", "vald-aosta.it", "valdaosta.it", "valle-aosta.it", "valle-d-aosta.it", "valle-daosta.it", "valleaosta.it", "valled-aosta.it", "valledaosta.it", "vallee-aoste.it", "vallée-aoste.it", "vallee-d-aoste.it", "vallée-d-aoste.it", "valleeaoste.it", "valléeaoste.it", "valleedaoste.it", "valléedaoste.it", "vao.it", "vda.it", "ven.it", "veneto.it", "ag.it", "agrigento.it", "al.it", "alessandria.it", "alto-adige.it", "altoadige.it", "an.it", "ancona.it", "andria-barletta-trani.it", "andria-trani-barletta.it", "andriabarlettatrani.it", "andriatranibarletta.it", "ao.it", "aosta.it", "aoste.it", "ap.it", "aq.it", "aquila.it", "ar.it", "arezzo.it", "ascoli-piceno.it", "ascolipiceno.it", "asti.it", "at.it", "av.it", "avellino.it", "ba.it", "balsan.it", "balsan-sudtirol.it", "balsan-südtirol.it", "balsan-suedtirol.it", "bari.it", "barletta-trani-andria.it", "barlettatraniandria.it", "belluno.it", "benevento.it", "bergamo.it", "bg.it", "bi.it", "biella.it", "bl.it", "bn.it", "bo.it", "bologna.it", "bolzano.it", "bolzano-altoadige.it", "bozen.it", "bozen-sudtirol.it", "bozen-südtirol.it", "bozen-suedtirol.it", "br.it", "brescia.it", "brindisi.it", "bs.it", "bt.it", "bulsan.it", "bulsan-sudtirol.it", "bulsan-südtirol.it", "bulsan-suedtirol.it", "bz.it", "ca.it", "cagliari.it", "caltanissetta.it", "campidano-medio.it", "campidanomedio.it", "campobasso.it", "carbonia-iglesias.it", "carboniaiglesias.it", "carrara-massa.it", "carraramassa.it", "caserta.it", "catania.it", "catanzaro.it", "cb.it", "ce.it", "cesena-forli.it", "cesena-forlì.it", "cesenaforli.it", "cesenaforlì.it", "ch.it", "chieti.it", "ci.it", "cl.it", "cn.it", "co.it", "como.it", "cosenza.it", "cr.it", "cremona.it", "crotone.it", "cs.it", "ct.it", "cuneo.it", "cz.it", "dell-ogliastra.it", "dellogliastra.it", "en.it", "enna.it", "fc.it", "fe.it", "fermo.it", "ferrara.it", "fg.it", "fi.it", "firenze.it", "florence.it", "fm.it", "foggia.it", "forli-cesena.it", "forlì-cesena.it", "forlicesena.it", "forlìcesena.it", "fr.it", "frosinone.it", "ge.it", "genoa.it", "genova.it", "go.it", "gorizia.it", "gr.it", "grosseto.it", "iglesias-carbonia.it", "iglesiascarbonia.it", "im.it", "imperia.it", "is.it", "isernia.it", "kr.it", "la-spezia.it", "laquila.it", "laspezia.it", "latina.it", "lc.it", "le.it", "lecce.it", "lecco.it", "li.it", "livorno.it", "lo.it", "lodi.it", "lt.it", "lu.it", "lucca.it", "macerata.it", "mantova.it", "massa-carrara.it", "massacarrara.it", "matera.it", "mb.it", "mc.it", "me.it", "medio-campidano.it", "mediocampidano.it", "messina.it", "mi.it", "milan.it", "milano.it", "mn.it", "mo.it", "modena.it", "monza.it", "monza-brianza.it", "monza-e-della-brianza.it", "monzabrianza.it", "monzaebrianza.it", "monzaedellabrianza.it", "ms.it", "mt.it", "na.it", "naples.it", "napoli.it", "no.it", "novara.it", "nu.it", "nuoro.it", "og.it", "ogliastra.it", "olbia-tempio.it", "olbiatempio.it", "or.it", "oristano.it", "ot.it", "pa.it", "padova.it", "padua.it", "palermo.it", "parma.it", "pavia.it", "pc.it", "pd.it", "pe.it", "perugia.it", "pesaro-urbino.it", "pesarourbino.it", "pescara.it", "pg.it", "pi.it", "piacenza.it", "pisa.it", "pistoia.it", "pn.it", "po.it", "pordenone.it", "potenza.it", "pr.it", "prato.it", "pt.it", "pu.it", "pv.it", "pz.it", "ra.it", "ragusa.it", "ravenna.it", "rc.it", "re.it", "reggio-calabria.it", "reggio-emilia.it", "reggiocalabria.it", "reggioemilia.it", "rg.it", "ri.it", "rieti.it", "rimini.it", "rm.it", "rn.it", "ro.it", "roma.it", "rome.it", "rovigo.it", "sa.it", "salerno.it", "sassari.it", "savona.it", "si.it", "siena.it", "siracusa.it", "so.it", "sondrio.it", "sp.it", "sr.it", "ss.it", "südtirol.it", "suedtirol.it", "sv.it", "ta.it", "taranto.it", "te.it", "tempio-olbia.it", "tempioolbia.it", "teramo.it", "terni.it", "tn.it", "to.it", "torino.it", "tp.it", "tr.it", "trani-andria-barletta.it", "trani-barletta-andria.it", "traniandriabarletta.it", "tranibarlettaandria.it", "trapani.it", "trento.it", "treviso.it", "trieste.it", "ts.it", "turin.it", "tv.it", "ud.it", "udine.it", "urbino-pesaro.it", "urbinopesaro.it", "va.it", "varese.it", "vb.it", "vc.it", "ve.it", "venezia.it", "venice.it", "verbania.it", "vercelli.it", "verona.it", "vi.it", "vibo-valentia.it", "vibovalentia.it", "vicenza.it", "viterbo.it", "vr.it", "vs.it", "vt.it", "vv.it", "je", "co.je", "net.je", "org.je", "*.jm", "jo", "agri.jo", "ai.jo", "com.jo", "edu.jo", "eng.jo", "fm.jo", "gov.jo", "mil.jo", "net.jo", "org.jo", "per.jo", "phd.jo", "sch.jo", "tv.jo", "jobs", "jp", "ac.jp", "ad.jp", "co.jp", "ed.jp", "go.jp", "gr.jp", "lg.jp", "ne.jp", "or.jp", "aichi.jp", "akita.jp", "aomori.jp", "chiba.jp", "ehime.jp", "fukui.jp", "fukuoka.jp", "fukushima.jp", "gifu.jp", "gunma.jp", "hiroshima.jp", "hokkaido.jp", "hyogo.jp", "ibaraki.jp", "ishikawa.jp", "iwate.jp", "kagawa.jp", "kagoshima.jp", "kanagawa.jp", "kochi.jp", "kumamoto.jp", "kyoto.jp", "mie.jp", "miyagi.jp", "miyazaki.jp", "nagano.jp", "nagasaki.jp", "nara.jp", "niigata.jp", "oita.jp", "okayama.jp", "okinawa.jp", "osaka.jp", "saga.jp", "saitama.jp", "shiga.jp", "shimane.jp", "shizuoka.jp", "tochigi.jp", "tokushima.jp", "tokyo.jp", "tottori.jp", "toyama.jp", "wakayama.jp", "yamagata.jp", "yamaguchi.jp", "yamanashi.jp", "三重.jp", "京都.jp", "佐賀.jp", "兵庫.jp", "北海道.jp", "千葉.jp", "和歌山.jp", "埼玉.jp", "大分.jp", "大阪.jp", "奈良.jp", "宮城.jp", "宮崎.jp", "富山.jp", "山口.jp", "山形.jp", "山梨.jp", "岐阜.jp", "岡山.jp", "岩手.jp", "島根.jp", "広島.jp", "徳島.jp", "愛媛.jp", "愛知.jp", "新潟.jp", "東京.jp", "栃木.jp", "沖縄.jp", "滋賀.jp", "熊本.jp", "石川.jp", "神奈川.jp", "福井.jp", "福岡.jp", "福島.jp", "秋田.jp", "群馬.jp", "茨城.jp", "長崎.jp", "長野.jp", "青森.jp", "静岡.jp", "香川.jp", "高知.jp", "鳥取.jp", "鹿児島.jp", "*.kawasaki.jp", "!city.kawasaki.jp", "*.kitakyushu.jp", "!city.kitakyushu.jp", "*.kobe.jp", "!city.kobe.jp", "*.nagoya.jp", "!city.nagoya.jp", "*.sapporo.jp", "!city.sapporo.jp", "*.sendai.jp", "!city.sendai.jp", "*.yokohama.jp", "!city.yokohama.jp", "aisai.aichi.jp", "ama.aichi.jp", "anjo.aichi.jp", "asuke.aichi.jp", "chiryu.aichi.jp", "chita.aichi.jp", "fuso.aichi.jp", "gamagori.aichi.jp", "handa.aichi.jp", "hazu.aichi.jp", "hekinan.aichi.jp", "higashiura.aichi.jp", "ichinomiya.aichi.jp", "inazawa.aichi.jp", "inuyama.aichi.jp", "isshiki.aichi.jp", "iwakura.aichi.jp", "kanie.aichi.jp", "kariya.aichi.jp", "kasugai.aichi.jp", "kira.aichi.jp", "kiyosu.aichi.jp", "komaki.aichi.jp", "konan.aichi.jp", "kota.aichi.jp", "mihama.aichi.jp", "miyoshi.aichi.jp", "nishio.aichi.jp", "nisshin.aichi.jp", "obu.aichi.jp", "oguchi.aichi.jp", "oharu.aichi.jp", "okazaki.aichi.jp", "owariasahi.aichi.jp", "seto.aichi.jp", "shikatsu.aichi.jp", "shinshiro.aichi.jp", "shitara.aichi.jp", "tahara.aichi.jp", "takahama.aichi.jp", "tobishima.aichi.jp", "toei.aichi.jp", "togo.aichi.jp", "tokai.aichi.jp", "tokoname.aichi.jp", "toyoake.aichi.jp", "toyohashi.aichi.jp", "toyokawa.aichi.jp", "toyone.aichi.jp", "toyota.aichi.jp", "tsushima.aichi.jp", "yatomi.aichi.jp", "akita.akita.jp", "daisen.akita.jp", "fujisato.akita.jp", "gojome.akita.jp", "hachirogata.akita.jp", "happou.akita.jp", "higashinaruse.akita.jp", "honjo.akita.jp", "honjyo.akita.jp", "ikawa.akita.jp", "kamikoani.akita.jp", "kamioka.akita.jp", "katagami.akita.jp", "kazuno.akita.jp", "kitaakita.akita.jp", "kosaka.akita.jp", "kyowa.akita.jp", "misato.akita.jp", "mitane.akita.jp", "moriyoshi.akita.jp", "nikaho.akita.jp", "noshiro.akita.jp", "odate.akita.jp", "oga.akita.jp", "ogata.akita.jp", "semboku.akita.jp", "yokote.akita.jp", "yurihonjo.akita.jp", "aomori.aomori.jp", "gonohe.aomori.jp", "hachinohe.aomori.jp", "hashikami.aomori.jp", "hiranai.aomori.jp", "hirosaki.aomori.jp", "itayanagi.aomori.jp", "kuroishi.aomori.jp", "misawa.aomori.jp", "mutsu.aomori.jp", "nakadomari.aomori.jp", "noheji.aomori.jp", "oirase.aomori.jp", "owani.aomori.jp", "rokunohe.aomori.jp", "sannohe.aomori.jp", "shichinohe.aomori.jp", "shingo.aomori.jp", "takko.aomori.jp", "towada.aomori.jp", "tsugaru.aomori.jp", "tsuruta.aomori.jp", "abiko.chiba.jp", "asahi.chiba.jp", "chonan.chiba.jp", "chosei.chiba.jp", "choshi.chiba.jp", "chuo.chiba.jp", "funabashi.chiba.jp", "futtsu.chiba.jp", "hanamigawa.chiba.jp", "ichihara.chiba.jp", "ichikawa.chiba.jp", "ichinomiya.chiba.jp", "inzai.chiba.jp", "isumi.chiba.jp", "kamagaya.chiba.jp", "kamogawa.chiba.jp", "kashiwa.chiba.jp", "katori.chiba.jp", "katsuura.chiba.jp", "kimitsu.chiba.jp", "kisarazu.chiba.jp", "kozaki.chiba.jp", "kujukuri.chiba.jp", "kyonan.chiba.jp", "matsudo.chiba.jp", "midori.chiba.jp", "mihama.chiba.jp", "minamiboso.chiba.jp", "mobara.chiba.jp", "mutsuzawa.chiba.jp", "nagara.chiba.jp", "nagareyama.chiba.jp", "narashino.chiba.jp", "narita.chiba.jp", "noda.chiba.jp", "oamishirasato.chiba.jp", "omigawa.chiba.jp", "onjuku.chiba.jp", "otaki.chiba.jp", "sakae.chiba.jp", "sakura.chiba.jp", "shimofusa.chiba.jp", "shirako.chiba.jp", "shiroi.chiba.jp", "shisui.chiba.jp", "sodegaura.chiba.jp", "sosa.chiba.jp", "tako.chiba.jp", "tateyama.chiba.jp", "togane.chiba.jp", "tohnosho.chiba.jp", "tomisato.chiba.jp", "urayasu.chiba.jp", "yachimata.chiba.jp", "yachiyo.chiba.jp", "yokaichiba.chiba.jp", "yokoshibahikari.chiba.jp", "yotsukaido.chiba.jp", "ainan.ehime.jp", "honai.ehime.jp", "ikata.ehime.jp", "imabari.ehime.jp", "iyo.ehime.jp", "kamijima.ehime.jp", "kihoku.ehime.jp", "kumakogen.ehime.jp", "masaki.ehime.jp", "matsuno.ehime.jp", "matsuyama.ehime.jp", "namikata.ehime.jp", "niihama.ehime.jp", "ozu.ehime.jp", "saijo.ehime.jp", "seiyo.ehime.jp", "shikokuchuo.ehime.jp", "tobe.ehime.jp", "toon.ehime.jp", "uchiko.ehime.jp", "uwajima.ehime.jp", "yawatahama.ehime.jp", "echizen.fukui.jp", "eiheiji.fukui.jp", "fukui.fukui.jp", "ikeda.fukui.jp", "katsuyama.fukui.jp", "mihama.fukui.jp", "minamiechizen.fukui.jp", "obama.fukui.jp", "ohi.fukui.jp", "ono.fukui.jp", "sabae.fukui.jp", "sakai.fukui.jp", "takahama.fukui.jp", "tsuruga.fukui.jp", "wakasa.fukui.jp", "ashiya.fukuoka.jp", "buzen.fukuoka.jp", "chikugo.fukuoka.jp", "chikuho.fukuoka.jp", "chikujo.fukuoka.jp", "chikushino.fukuoka.jp", "chikuzen.fukuoka.jp", "chuo.fukuoka.jp", "dazaifu.fukuoka.jp", "fukuchi.fukuoka.jp", "hakata.fukuoka.jp", "higashi.fukuoka.jp", "hirokawa.fukuoka.jp", "hisayama.fukuoka.jp", "iizuka.fukuoka.jp", "inatsuki.fukuoka.jp", "kaho.fukuoka.jp", "kasuga.fukuoka.jp", "kasuya.fukuoka.jp", "kawara.fukuoka.jp", "keisen.fukuoka.jp", "koga.fukuoka.jp", "kurate.fukuoka.jp", "kurogi.fukuoka.jp", "kurume.fukuoka.jp", "minami.fukuoka.jp", "miyako.fukuoka.jp", "miyama.fukuoka.jp", "miyawaka.fukuoka.jp", "mizumaki.fukuoka.jp", "munakata.fukuoka.jp", "nakagawa.fukuoka.jp", "nakama.fukuoka.jp", "nishi.fukuoka.jp", "nogata.fukuoka.jp", "ogori.fukuoka.jp", "okagaki.fukuoka.jp", "okawa.fukuoka.jp", "oki.fukuoka.jp", "omuta.fukuoka.jp", "onga.fukuoka.jp", "onojo.fukuoka.jp", "oto.fukuoka.jp", "saigawa.fukuoka.jp", "sasaguri.fukuoka.jp", "shingu.fukuoka.jp", "shinyoshitomi.fukuoka.jp", "shonai.fukuoka.jp", "soeda.fukuoka.jp", "sue.fukuoka.jp", "tachiarai.fukuoka.jp", "tagawa.fukuoka.jp", "takata.fukuoka.jp", "toho.fukuoka.jp", "toyotsu.fukuoka.jp", "tsuiki.fukuoka.jp", "ukiha.fukuoka.jp", "umi.fukuoka.jp", "usui.fukuoka.jp", "yamada.fukuoka.jp", "yame.fukuoka.jp", "yanagawa.fukuoka.jp", "yukuhashi.fukuoka.jp", "aizubange.fukushima.jp", "aizumisato.fukushima.jp", "aizuwakamatsu.fukushima.jp", "asakawa.fukushima.jp", "bandai.fukushima.jp", "date.fukushima.jp", "fukushima.fukushima.jp", "furudono.fukushima.jp", "futaba.fukushima.jp", "hanawa.fukushima.jp", "higashi.fukushima.jp", "hirata.fukushima.jp", "hirono.fukushima.jp", "iitate.fukushima.jp", "inawashiro.fukushima.jp", "ishikawa.fukushima.jp", "iwaki.fukushima.jp", "izumizaki.fukushima.jp", "kagamiishi.fukushima.jp", "kaneyama.fukushima.jp", "kawamata.fukushima.jp", "kitakata.fukushima.jp", "kitashiobara.fukushima.jp", "koori.fukushima.jp", "koriyama.fukushima.jp", "kunimi.fukushima.jp", "miharu.fukushima.jp", "mishima.fukushima.jp", "namie.fukushima.jp", "nango.fukushima.jp", "nishiaizu.fukushima.jp", "nishigo.fukushima.jp", "okuma.fukushima.jp", "omotego.fukushima.jp", "ono.fukushima.jp", "otama.fukushima.jp", "samegawa.fukushima.jp", "shimogo.fukushima.jp", "shirakawa.fukushima.jp", "showa.fukushima.jp", "soma.fukushima.jp", "sukagawa.fukushima.jp", "taishin.fukushima.jp", "tamakawa.fukushima.jp", "tanagura.fukushima.jp", "tenei.fukushima.jp", "yabuki.fukushima.jp", "yamato.fukushima.jp", "yamatsuri.fukushima.jp", "yanaizu.fukushima.jp", "yugawa.fukushima.jp", "anpachi.gifu.jp", "ena.gifu.jp", "gifu.gifu.jp", "ginan.gifu.jp", "godo.gifu.jp", "gujo.gifu.jp", "hashima.gifu.jp", "hichiso.gifu.jp", "hida.gifu.jp", "higashishirakawa.gifu.jp", "ibigawa.gifu.jp", "ikeda.gifu.jp", "kakamigahara.gifu.jp", "kani.gifu.jp", "kasahara.gifu.jp", "kasamatsu.gifu.jp", "kawaue.gifu.jp", "kitagata.gifu.jp", "mino.gifu.jp", "minokamo.gifu.jp", "mitake.gifu.jp", "mizunami.gifu.jp", "motosu.gifu.jp", "nakatsugawa.gifu.jp", "ogaki.gifu.jp", "sakahogi.gifu.jp", "seki.gifu.jp", "sekigahara.gifu.jp", "shirakawa.gifu.jp", "tajimi.gifu.jp", "takayama.gifu.jp", "tarui.gifu.jp", "toki.gifu.jp", "tomika.gifu.jp", "wanouchi.gifu.jp", "yamagata.gifu.jp", "yaotsu.gifu.jp", "yoro.gifu.jp", "annaka.gunma.jp", "chiyoda.gunma.jp", "fujioka.gunma.jp", "higashiagatsuma.gunma.jp", "isesaki.gunma.jp", "itakura.gunma.jp", "kanna.gunma.jp", "kanra.gunma.jp", "katashina.gunma.jp", "kawaba.gunma.jp", "kiryu.gunma.jp", "kusatsu.gunma.jp", "maebashi.gunma.jp", "meiwa.gunma.jp", "midori.gunma.jp", "minakami.gunma.jp", "naganohara.gunma.jp", "nakanojo.gunma.jp", "nanmoku.gunma.jp", "numata.gunma.jp", "oizumi.gunma.jp", "ora.gunma.jp", "ota.gunma.jp", "shibukawa.gunma.jp", "shimonita.gunma.jp", "shinto.gunma.jp", "showa.gunma.jp", "takasaki.gunma.jp", "takayama.gunma.jp", "tamamura.gunma.jp", "tatebayashi.gunma.jp", "tomioka.gunma.jp", "tsukiyono.gunma.jp", "tsumagoi.gunma.jp", "ueno.gunma.jp", "yoshioka.gunma.jp", "asaminami.hiroshima.jp", "daiwa.hiroshima.jp", "etajima.hiroshima.jp", "fuchu.hiroshima.jp", "fukuyama.hiroshima.jp", "hatsukaichi.hiroshima.jp", "higashihiroshima.hiroshima.jp", "hongo.hiroshima.jp", "jinsekikogen.hiroshima.jp", "kaita.hiroshima.jp", "kui.hiroshima.jp", "kumano.hiroshima.jp", "kure.hiroshima.jp", "mihara.hiroshima.jp", "miyoshi.hiroshima.jp", "naka.hiroshima.jp", "onomichi.hiroshima.jp", "osakikamijima.hiroshima.jp", "otake.hiroshima.jp", "saka.hiroshima.jp", "sera.hiroshima.jp", "seranishi.hiroshima.jp", "shinichi.hiroshima.jp", "shobara.hiroshima.jp", "takehara.hiroshima.jp", "abashiri.hokkaido.jp", "abira.hokkaido.jp", "aibetsu.hokkaido.jp", "akabira.hokkaido.jp", "akkeshi.hokkaido.jp", "asahikawa.hokkaido.jp", "ashibetsu.hokkaido.jp", "ashoro.hokkaido.jp", "assabu.hokkaido.jp", "atsuma.hokkaido.jp", "bibai.hokkaido.jp", "biei.hokkaido.jp", "bifuka.hokkaido.jp", "bihoro.hokkaido.jp", "biratori.hokkaido.jp", "chippubetsu.hokkaido.jp", "chitose.hokkaido.jp", "date.hokkaido.jp", "ebetsu.hokkaido.jp", "embetsu.hokkaido.jp", "eniwa.hokkaido.jp", "erimo.hokkaido.jp", "esan.hokkaido.jp", "esashi.hokkaido.jp", "fukagawa.hokkaido.jp", "fukushima.hokkaido.jp", "furano.hokkaido.jp", "furubira.hokkaido.jp", "haboro.hokkaido.jp", "hakodate.hokkaido.jp", "hamatonbetsu.hokkaido.jp", "hidaka.hokkaido.jp", "higashikagura.hokkaido.jp", "higashikawa.hokkaido.jp", "hiroo.hokkaido.jp", "hokuryu.hokkaido.jp", "hokuto.hokkaido.jp", "honbetsu.hokkaido.jp", "horokanai.hokkaido.jp", "horonobe.hokkaido.jp", "ikeda.hokkaido.jp", "imakane.hokkaido.jp", "ishikari.hokkaido.jp", "iwamizawa.hokkaido.jp", "iwanai.hokkaido.jp", "kamifurano.hokkaido.jp", "kamikawa.hokkaido.jp", "kamishihoro.hokkaido.jp", "kamisunagawa.hokkaido.jp", "kamoenai.hokkaido.jp", "kayabe.hokkaido.jp", "kembuchi.hokkaido.jp", "kikonai.hokkaido.jp", "kimobetsu.hokkaido.jp", "kitahiroshima.hokkaido.jp", "kitami.hokkaido.jp", "kiyosato.hokkaido.jp", "koshimizu.hokkaido.jp", "kunneppu.hokkaido.jp", "kuriyama.hokkaido.jp", "kuromatsunai.hokkaido.jp", "kushiro.hokkaido.jp", "kutchan.hokkaido.jp", "kyowa.hokkaido.jp", "mashike.hokkaido.jp", "matsumae.hokkaido.jp", "mikasa.hokkaido.jp", "minamifurano.hokkaido.jp", "mombetsu.hokkaido.jp", "moseushi.hokkaido.jp", "mukawa.hokkaido.jp", "muroran.hokkaido.jp", "naie.hokkaido.jp", "nakagawa.hokkaido.jp", "nakasatsunai.hokkaido.jp", "nakatombetsu.hokkaido.jp", "nanae.hokkaido.jp", "nanporo.hokkaido.jp", "nayoro.hokkaido.jp", "nemuro.hokkaido.jp", "niikappu.hokkaido.jp", "niki.hokkaido.jp", "nishiokoppe.hokkaido.jp", "noboribetsu.hokkaido.jp", "numata.hokkaido.jp", "obihiro.hokkaido.jp", "obira.hokkaido.jp", "oketo.hokkaido.jp", "okoppe.hokkaido.jp", "otaru.hokkaido.jp", "otobe.hokkaido.jp", "otofuke.hokkaido.jp", "otoineppu.hokkaido.jp", "oumu.hokkaido.jp", "ozora.hokkaido.jp", "pippu.hokkaido.jp", "rankoshi.hokkaido.jp", "rebun.hokkaido.jp", "rikubetsu.hokkaido.jp", "rishiri.hokkaido.jp", "rishirifuji.hokkaido.jp", "saroma.hokkaido.jp", "sarufutsu.hokkaido.jp", "shakotan.hokkaido.jp", "shari.hokkaido.jp", "shibecha.hokkaido.jp", "shibetsu.hokkaido.jp", "shikabe.hokkaido.jp", "shikaoi.hokkaido.jp", "shimamaki.hokkaido.jp", "shimizu.hokkaido.jp", "shimokawa.hokkaido.jp", "shinshinotsu.hokkaido.jp", "shintoku.hokkaido.jp", "shiranuka.hokkaido.jp", "shiraoi.hokkaido.jp", "shiriuchi.hokkaido.jp", "sobetsu.hokkaido.jp", "sunagawa.hokkaido.jp", "taiki.hokkaido.jp", "takasu.hokkaido.jp", "takikawa.hokkaido.jp", "takinoue.hokkaido.jp", "teshikaga.hokkaido.jp", "tobetsu.hokkaido.jp", "tohma.hokkaido.jp", "tomakomai.hokkaido.jp", "tomari.hokkaido.jp", "toya.hokkaido.jp", "toyako.hokkaido.jp", "toyotomi.hokkaido.jp", "toyoura.hokkaido.jp", "tsubetsu.hokkaido.jp", "tsukigata.hokkaido.jp", "urakawa.hokkaido.jp", "urausu.hokkaido.jp", "uryu.hokkaido.jp", "utashinai.hokkaido.jp", "wakkanai.hokkaido.jp", "wassamu.hokkaido.jp", "yakumo.hokkaido.jp", "yoichi.hokkaido.jp", "aioi.hyogo.jp", "akashi.hyogo.jp", "ako.hyogo.jp", "amagasaki.hyogo.jp", "aogaki.hyogo.jp", "asago.hyogo.jp", "ashiya.hyogo.jp", "awaji.hyogo.jp", "fukusaki.hyogo.jp", "goshiki.hyogo.jp", "harima.hyogo.jp", "himeji.hyogo.jp", "ichikawa.hyogo.jp", "inagawa.hyogo.jp", "itami.hyogo.jp", "kakogawa.hyogo.jp", "kamigori.hyogo.jp", "kamikawa.hyogo.jp", "kasai.hyogo.jp", "kasuga.hyogo.jp", "kawanishi.hyogo.jp", "miki.hyogo.jp", "minamiawaji.hyogo.jp", "nishinomiya.hyogo.jp", "nishiwaki.hyogo.jp", "ono.hyogo.jp", "sanda.hyogo.jp", "sannan.hyogo.jp", "sasayama.hyogo.jp", "sayo.hyogo.jp", "shingu.hyogo.jp", "shinonsen.hyogo.jp", "shiso.hyogo.jp", "sumoto.hyogo.jp", "taishi.hyogo.jp", "taka.hyogo.jp", "takarazuka.hyogo.jp", "takasago.hyogo.jp", "takino.hyogo.jp", "tamba.hyogo.jp", "tatsuno.hyogo.jp", "toyooka.hyogo.jp", "yabu.hyogo.jp", "yashiro.hyogo.jp", "yoka.hyogo.jp", "yokawa.hyogo.jp", "ami.ibaraki.jp", "asahi.ibaraki.jp", "bando.ibaraki.jp", "chikusei.ibaraki.jp", "daigo.ibaraki.jp", "fujishiro.ibaraki.jp", "hitachi.ibaraki.jp", "hitachinaka.ibaraki.jp", "hitachiomiya.ibaraki.jp", "hitachiota.ibaraki.jp", "ibaraki.ibaraki.jp", "ina.ibaraki.jp", "inashiki.ibaraki.jp", "itako.ibaraki.jp", "iwama.ibaraki.jp", "joso.ibaraki.jp", "kamisu.ibaraki.jp", "kasama.ibaraki.jp", "kashima.ibaraki.jp", "kasumigaura.ibaraki.jp", "koga.ibaraki.jp", "miho.ibaraki.jp", "mito.ibaraki.jp", "moriya.ibaraki.jp", "naka.ibaraki.jp", "namegata.ibaraki.jp", "oarai.ibaraki.jp", "ogawa.ibaraki.jp", "omitama.ibaraki.jp", "ryugasaki.ibaraki.jp", "sakai.ibaraki.jp", "sakuragawa.ibaraki.jp", "shimodate.ibaraki.jp", "shimotsuma.ibaraki.jp", "shirosato.ibaraki.jp", "sowa.ibaraki.jp", "suifu.ibaraki.jp", "takahagi.ibaraki.jp", "tamatsukuri.ibaraki.jp", "tokai.ibaraki.jp", "tomobe.ibaraki.jp", "tone.ibaraki.jp", "toride.ibaraki.jp", "tsuchiura.ibaraki.jp", "tsukuba.ibaraki.jp", "uchihara.ibaraki.jp", "ushiku.ibaraki.jp", "yachiyo.ibaraki.jp", "yamagata.ibaraki.jp", "yawara.ibaraki.jp", "yuki.ibaraki.jp", "anamizu.ishikawa.jp", "hakui.ishikawa.jp", "hakusan.ishikawa.jp", "kaga.ishikawa.jp", "kahoku.ishikawa.jp", "kanazawa.ishikawa.jp", "kawakita.ishikawa.jp", "komatsu.ishikawa.jp", "nakanoto.ishikawa.jp", "nanao.ishikawa.jp", "nomi.ishikawa.jp", "nonoichi.ishikawa.jp", "noto.ishikawa.jp", "shika.ishikawa.jp", "suzu.ishikawa.jp", "tsubata.ishikawa.jp", "tsurugi.ishikawa.jp", "uchinada.ishikawa.jp", "wajima.ishikawa.jp", "fudai.iwate.jp", "fujisawa.iwate.jp", "hanamaki.iwate.jp", "hiraizumi.iwate.jp", "hirono.iwate.jp", "ichinohe.iwate.jp", "ichinoseki.iwate.jp", "iwaizumi.iwate.jp", "iwate.iwate.jp", "joboji.iwate.jp", "kamaishi.iwate.jp", "kanegasaki.iwate.jp", "karumai.iwate.jp", "kawai.iwate.jp", "kitakami.iwate.jp", "kuji.iwate.jp", "kunohe.iwate.jp", "kuzumaki.iwate.jp", "miyako.iwate.jp", "mizusawa.iwate.jp", "morioka.iwate.jp", "ninohe.iwate.jp", "noda.iwate.jp", "ofunato.iwate.jp", "oshu.iwate.jp", "otsuchi.iwate.jp", "rikuzentakata.iwate.jp", "shiwa.iwate.jp", "shizukuishi.iwate.jp", "sumita.iwate.jp", "tanohata.iwate.jp", "tono.iwate.jp", "yahaba.iwate.jp", "yamada.iwate.jp", "ayagawa.kagawa.jp", "higashikagawa.kagawa.jp", "kanonji.kagawa.jp", "kotohira.kagawa.jp", "manno.kagawa.jp", "marugame.kagawa.jp", "mitoyo.kagawa.jp", "naoshima.kagawa.jp", "sanuki.kagawa.jp", "tadotsu.kagawa.jp", "takamatsu.kagawa.jp", "tonosho.kagawa.jp", "uchinomi.kagawa.jp", "utazu.kagawa.jp", "zentsuji.kagawa.jp", "akune.kagoshima.jp", "amami.kagoshima.jp", "hioki.kagoshima.jp", "isa.kagoshima.jp", "isen.kagoshima.jp", "izumi.kagoshima.jp", "kagoshima.kagoshima.jp", "kanoya.kagoshima.jp", "kawanabe.kagoshima.jp", "kinko.kagoshima.jp", "kouyama.kagoshima.jp", "makurazaki.kagoshima.jp", "matsumoto.kagoshima.jp", "minamitane.kagoshima.jp", "nakatane.kagoshima.jp", "nishinoomote.kagoshima.jp", "satsumasendai.kagoshima.jp", "soo.kagoshima.jp", "tarumizu.kagoshima.jp", "yusui.kagoshima.jp", "aikawa.kanagawa.jp", "atsugi.kanagawa.jp", "ayase.kanagawa.jp", "chigasaki.kanagawa.jp", "ebina.kanagawa.jp", "fujisawa.kanagawa.jp", "hadano.kanagawa.jp", "hakone.kanagawa.jp", "hiratsuka.kanagawa.jp", "isehara.kanagawa.jp", "kaisei.kanagawa.jp", "kamakura.kanagawa.jp", "kiyokawa.kanagawa.jp", "matsuda.kanagawa.jp", "minamiashigara.kanagawa.jp", "miura.kanagawa.jp", "nakai.kanagawa.jp", "ninomiya.kanagawa.jp", "odawara.kanagawa.jp", "oi.kanagawa.jp", "oiso.kanagawa.jp", "sagamihara.kanagawa.jp", "samukawa.kanagawa.jp", "tsukui.kanagawa.jp", "yamakita.kanagawa.jp", "yamato.kanagawa.jp", "yokosuka.kanagawa.jp", "yugawara.kanagawa.jp", "zama.kanagawa.jp", "zushi.kanagawa.jp", "aki.kochi.jp", "geisei.kochi.jp", "hidaka.kochi.jp", "higashitsuno.kochi.jp", "ino.kochi.jp", "kagami.kochi.jp", "kami.kochi.jp", "kitagawa.kochi.jp", "kochi.kochi.jp", "mihara.kochi.jp", "motoyama.kochi.jp", "muroto.kochi.jp", "nahari.kochi.jp", "nakamura.kochi.jp", "nankoku.kochi.jp", "nishitosa.kochi.jp", "niyodogawa.kochi.jp", "ochi.kochi.jp", "okawa.kochi.jp", "otoyo.kochi.jp", "otsuki.kochi.jp", "sakawa.kochi.jp", "sukumo.kochi.jp", "susaki.kochi.jp", "tosa.kochi.jp", "tosashimizu.kochi.jp", "toyo.kochi.jp", "tsuno.kochi.jp", "umaji.kochi.jp", "yasuda.kochi.jp", "yusuhara.kochi.jp", "amakusa.kumamoto.jp", "arao.kumamoto.jp", "aso.kumamoto.jp", "choyo.kumamoto.jp", "gyokuto.kumamoto.jp", "kamiamakusa.kumamoto.jp", "kikuchi.kumamoto.jp", "kumamoto.kumamoto.jp", "mashiki.kumamoto.jp", "mifune.kumamoto.jp", "minamata.kumamoto.jp", "minamioguni.kumamoto.jp", "nagasu.kumamoto.jp", "nishihara.kumamoto.jp", "oguni.kumamoto.jp", "ozu.kumamoto.jp", "sumoto.kumamoto.jp", "takamori.kumamoto.jp", "uki.kumamoto.jp", "uto.kumamoto.jp", "yamaga.kumamoto.jp", "yamato.kumamoto.jp", "yatsushiro.kumamoto.jp", "ayabe.kyoto.jp", "fukuchiyama.kyoto.jp", "higashiyama.kyoto.jp", "ide.kyoto.jp", "ine.kyoto.jp", "joyo.kyoto.jp", "kameoka.kyoto.jp", "kamo.kyoto.jp", "kita.kyoto.jp", "kizu.kyoto.jp", "kumiyama.kyoto.jp", "kyotamba.kyoto.jp", "kyotanabe.kyoto.jp", "kyotango.kyoto.jp", "maizuru.kyoto.jp", "minami.kyoto.jp", "minamiyamashiro.kyoto.jp", "miyazu.kyoto.jp", "muko.kyoto.jp", "nagaokakyo.kyoto.jp", "nakagyo.kyoto.jp", "nantan.kyoto.jp", "oyamazaki.kyoto.jp", "sakyo.kyoto.jp", "seika.kyoto.jp", "tanabe.kyoto.jp", "uji.kyoto.jp", "ujitawara.kyoto.jp", "wazuka.kyoto.jp", "yamashina.kyoto.jp", "yawata.kyoto.jp", "asahi.mie.jp", "inabe.mie.jp", "ise.mie.jp", "kameyama.mie.jp", "kawagoe.mie.jp", "kiho.mie.jp", "kisosaki.mie.jp", "kiwa.mie.jp", "komono.mie.jp", "kumano.mie.jp", "kuwana.mie.jp", "matsusaka.mie.jp", "meiwa.mie.jp", "mihama.mie.jp", "minamiise.mie.jp", "misugi.mie.jp", "miyama.mie.jp", "nabari.mie.jp", "shima.mie.jp", "suzuka.mie.jp", "tado.mie.jp", "taiki.mie.jp", "taki.mie.jp", "tamaki.mie.jp", "toba.mie.jp", "tsu.mie.jp", "udono.mie.jp", "ureshino.mie.jp", "watarai.mie.jp", "yokkaichi.mie.jp", "furukawa.miyagi.jp", "higashimatsushima.miyagi.jp", "ishinomaki.miyagi.jp", "iwanuma.miyagi.jp", "kakuda.miyagi.jp", "kami.miyagi.jp", "kawasaki.miyagi.jp", "marumori.miyagi.jp", "matsushima.miyagi.jp", "minamisanriku.miyagi.jp", "misato.miyagi.jp", "murata.miyagi.jp", "natori.miyagi.jp", "ogawara.miyagi.jp", "ohira.miyagi.jp", "onagawa.miyagi.jp", "osaki.miyagi.jp", "rifu.miyagi.jp", "semine.miyagi.jp", "shibata.miyagi.jp", "shichikashuku.miyagi.jp", "shikama.miyagi.jp", "shiogama.miyagi.jp", "shiroishi.miyagi.jp", "tagajo.miyagi.jp", "taiwa.miyagi.jp", "tome.miyagi.jp", "tomiya.miyagi.jp", "wakuya.miyagi.jp", "watari.miyagi.jp", "yamamoto.miyagi.jp", "zao.miyagi.jp", "aya.miyazaki.jp", "ebino.miyazaki.jp", "gokase.miyazaki.jp", "hyuga.miyazaki.jp", "kadogawa.miyazaki.jp", "kawaminami.miyazaki.jp", "kijo.miyazaki.jp", "kitagawa.miyazaki.jp", "kitakata.miyazaki.jp", "kitaura.miyazaki.jp", "kobayashi.miyazaki.jp", "kunitomi.miyazaki.jp", "kushima.miyazaki.jp", "mimata.miyazaki.jp", "miyakonojo.miyazaki.jp", "miyazaki.miyazaki.jp", "morotsuka.miyazaki.jp", "nichinan.miyazaki.jp", "nishimera.miyazaki.jp", "nobeoka.miyazaki.jp", "saito.miyazaki.jp", "shiiba.miyazaki.jp", "shintomi.miyazaki.jp", "takaharu.miyazaki.jp", "takanabe.miyazaki.jp", "takazaki.miyazaki.jp", "tsuno.miyazaki.jp", "achi.nagano.jp", "agematsu.nagano.jp", "anan.nagano.jp", "aoki.nagano.jp", "asahi.nagano.jp", "azumino.nagano.jp", "chikuhoku.nagano.jp", "chikuma.nagano.jp", "chino.nagano.jp", "fujimi.nagano.jp", "hakuba.nagano.jp", "hara.nagano.jp", "hiraya.nagano.jp", "iida.nagano.jp", "iijima.nagano.jp", "iiyama.nagano.jp", "iizuna.nagano.jp", "ikeda.nagano.jp", "ikusaka.nagano.jp", "ina.nagano.jp", "karuizawa.nagano.jp", "kawakami.nagano.jp", "kiso.nagano.jp", "kisofukushima.nagano.jp", "kitaaiki.nagano.jp", "komagane.nagano.jp", "komoro.nagano.jp", "matsukawa.nagano.jp", "matsumoto.nagano.jp", "miasa.nagano.jp", "minamiaiki.nagano.jp", "minamimaki.nagano.jp", "minamiminowa.nagano.jp", "minowa.nagano.jp", "miyada.nagano.jp", "miyota.nagano.jp", "mochizuki.nagano.jp", "nagano.nagano.jp", "nagawa.nagano.jp", "nagiso.nagano.jp", "nakagawa.nagano.jp", "nakano.nagano.jp", "nozawaonsen.nagano.jp", "obuse.nagano.jp", "ogawa.nagano.jp", "okaya.nagano.jp", "omachi.nagano.jp", "omi.nagano.jp", "ookuwa.nagano.jp", "ooshika.nagano.jp", "otaki.nagano.jp", "otari.nagano.jp", "sakae.nagano.jp", "sakaki.nagano.jp", "saku.nagano.jp", "sakuho.nagano.jp", "shimosuwa.nagano.jp", "shinanomachi.nagano.jp", "shiojiri.nagano.jp", "suwa.nagano.jp", "suzaka.nagano.jp", "takagi.nagano.jp", "takamori.nagano.jp", "takayama.nagano.jp", "tateshina.nagano.jp", "tatsuno.nagano.jp", "togakushi.nagano.jp", "togura.nagano.jp", "tomi.nagano.jp", "ueda.nagano.jp", "wada.nagano.jp", "yamagata.nagano.jp", "yamanouchi.nagano.jp", "yasaka.nagano.jp", "yasuoka.nagano.jp", "chijiwa.nagasaki.jp", "futsu.nagasaki.jp", "goto.nagasaki.jp", "hasami.nagasaki.jp", "hirado.nagasaki.jp", "iki.nagasaki.jp", "isahaya.nagasaki.jp", "kawatana.nagasaki.jp", "kuchinotsu.nagasaki.jp", "matsuura.nagasaki.jp", "nagasaki.nagasaki.jp", "obama.nagasaki.jp", "omura.nagasaki.jp", "oseto.nagasaki.jp", "saikai.nagasaki.jp", "sasebo.nagasaki.jp", "seihi.nagasaki.jp", "shimabara.nagasaki.jp", "shinkamigoto.nagasaki.jp", "togitsu.nagasaki.jp", "tsushima.nagasaki.jp", "unzen.nagasaki.jp", "ando.nara.jp", "gose.nara.jp", "heguri.nara.jp", "higashiyoshino.nara.jp", "ikaruga.nara.jp", "ikoma.nara.jp", "kamikitayama.nara.jp", "kanmaki.nara.jp", "kashiba.nara.jp", "kashihara.nara.jp", "katsuragi.nara.jp", "kawai.nara.jp", "kawakami.nara.jp", "kawanishi.nara.jp", "koryo.nara.jp", "kurotaki.nara.jp", "mitsue.nara.jp", "miyake.nara.jp", "nara.nara.jp", "nosegawa.nara.jp", "oji.nara.jp", "ouda.nara.jp", "oyodo.nara.jp", "sakurai.nara.jp", "sango.nara.jp", "shimoichi.nara.jp", "shimokitayama.nara.jp", "shinjo.nara.jp", "soni.nara.jp", "takatori.nara.jp", "tawaramoto.nara.jp", "tenkawa.nara.jp", "tenri.nara.jp", "uda.nara.jp", "yamatokoriyama.nara.jp", "yamatotakada.nara.jp", "yamazoe.nara.jp", "yoshino.nara.jp", "aga.niigata.jp", "agano.niigata.jp", "gosen.niigata.jp", "itoigawa.niigata.jp", "izumozaki.niigata.jp", "joetsu.niigata.jp", "kamo.niigata.jp", "kariwa.niigata.jp", "kashiwazaki.niigata.jp", "minamiuonuma.niigata.jp", "mitsuke.niigata.jp", "muika.niigata.jp", "murakami.niigata.jp", "myoko.niigata.jp", "nagaoka.niigata.jp", "niigata.niigata.jp", "ojiya.niigata.jp", "omi.niigata.jp", "sado.niigata.jp", "sanjo.niigata.jp", "seiro.niigata.jp", "seirou.niigata.jp", "sekikawa.niigata.jp", "shibata.niigata.jp", "tagami.niigata.jp", "tainai.niigata.jp", "tochio.niigata.jp", "tokamachi.niigata.jp", "tsubame.niigata.jp", "tsunan.niigata.jp", "uonuma.niigata.jp", "yahiko.niigata.jp", "yoita.niigata.jp", "yuzawa.niigata.jp", "beppu.oita.jp", "bungoono.oita.jp", "bungotakada.oita.jp", "hasama.oita.jp", "hiji.oita.jp", "himeshima.oita.jp", "hita.oita.jp", "kamitsue.oita.jp", "kokonoe.oita.jp", "kuju.oita.jp", "kunisaki.oita.jp", "kusu.oita.jp", "oita.oita.jp", "saiki.oita.jp", "taketa.oita.jp", "tsukumi.oita.jp", "usa.oita.jp", "usuki.oita.jp", "yufu.oita.jp", "akaiwa.okayama.jp", "asakuchi.okayama.jp", "bizen.okayama.jp", "hayashima.okayama.jp", "ibara.okayama.jp", "kagamino.okayama.jp", "kasaoka.okayama.jp", "kibichuo.okayama.jp", "kumenan.okayama.jp", "kurashiki.okayama.jp", "maniwa.okayama.jp", "misaki.okayama.jp", "nagi.okayama.jp", "niimi.okayama.jp", "nishiawakura.okayama.jp", "okayama.okayama.jp", "satosho.okayama.jp", "setouchi.okayama.jp", "shinjo.okayama.jp", "shoo.okayama.jp", "soja.okayama.jp", "takahashi.okayama.jp", "tamano.okayama.jp", "tsuyama.okayama.jp", "wake.okayama.jp", "yakage.okayama.jp", "aguni.okinawa.jp", "ginowan.okinawa.jp", "ginoza.okinawa.jp", "gushikami.okinawa.jp", "haebaru.okinawa.jp", "higashi.okinawa.jp", "hirara.okinawa.jp", "iheya.okinawa.jp", "ishigaki.okinawa.jp", "ishikawa.okinawa.jp", "itoman.okinawa.jp", "izena.okinawa.jp", "kadena.okinawa.jp", "kin.okinawa.jp", "kitadaito.okinawa.jp", "kitanakagusuku.okinawa.jp", "kumejima.okinawa.jp", "kunigami.okinawa.jp", "minamidaito.okinawa.jp", "motobu.okinawa.jp", "nago.okinawa.jp", "naha.okinawa.jp", "nakagusuku.okinawa.jp", "nakijin.okinawa.jp", "nanjo.okinawa.jp", "nishihara.okinawa.jp", "ogimi.okinawa.jp", "okinawa.okinawa.jp", "onna.okinawa.jp", "shimoji.okinawa.jp", "taketomi.okinawa.jp", "tarama.okinawa.jp", "tokashiki.okinawa.jp", "tomigusuku.okinawa.jp", "tonaki.okinawa.jp", "urasoe.okinawa.jp", "uruma.okinawa.jp", "yaese.okinawa.jp", "yomitan.okinawa.jp", "yonabaru.okinawa.jp", "yonaguni.okinawa.jp", "zamami.okinawa.jp", "abeno.osaka.jp", "chihayaakasaka.osaka.jp", "chuo.osaka.jp", "daito.osaka.jp", "fujiidera.osaka.jp", "habikino.osaka.jp", "hannan.osaka.jp", "higashiosaka.osaka.jp", "higashisumiyoshi.osaka.jp", "higashiyodogawa.osaka.jp", "hirakata.osaka.jp", "ibaraki.osaka.jp", "ikeda.osaka.jp", "izumi.osaka.jp", "izumiotsu.osaka.jp", "izumisano.osaka.jp", "kadoma.osaka.jp", "kaizuka.osaka.jp", "kanan.osaka.jp", "kashiwara.osaka.jp", "katano.osaka.jp", "kawachinagano.osaka.jp", "kishiwada.osaka.jp", "kita.osaka.jp", "kumatori.osaka.jp", "matsubara.osaka.jp", "minato.osaka.jp", "minoh.osaka.jp", "misaki.osaka.jp", "moriguchi.osaka.jp", "neyagawa.osaka.jp", "nishi.osaka.jp", "nose.osaka.jp", "osakasayama.osaka.jp", "sakai.osaka.jp", "sayama.osaka.jp", "sennan.osaka.jp", "settsu.osaka.jp", "shijonawate.osaka.jp", "shimamoto.osaka.jp", "suita.osaka.jp", "tadaoka.osaka.jp", "taishi.osaka.jp", "tajiri.osaka.jp", "takaishi.osaka.jp", "takatsuki.osaka.jp", "tondabayashi.osaka.jp", "toyonaka.osaka.jp", "toyono.osaka.jp", "yao.osaka.jp", "ariake.saga.jp", "arita.saga.jp", "fukudomi.saga.jp", "genkai.saga.jp", "hamatama.saga.jp", "hizen.saga.jp", "imari.saga.jp", "kamimine.saga.jp", "kanzaki.saga.jp", "karatsu.saga.jp", "kashima.saga.jp", "kitagata.saga.jp", "kitahata.saga.jp", "kiyama.saga.jp", "kouhoku.saga.jp", "kyuragi.saga.jp", "nishiarita.saga.jp", "ogi.saga.jp", "omachi.saga.jp", "ouchi.saga.jp", "saga.saga.jp", "shiroishi.saga.jp", "taku.saga.jp", "tara.saga.jp", "tosu.saga.jp", "yoshinogari.saga.jp", "arakawa.saitama.jp", "asaka.saitama.jp", "chichibu.saitama.jp", "fujimi.saitama.jp", "fujimino.saitama.jp", "fukaya.saitama.jp", "hanno.saitama.jp", "hanyu.saitama.jp", "hasuda.saitama.jp", "hatogaya.saitama.jp", "hatoyama.saitama.jp", "hidaka.saitama.jp", "higashichichibu.saitama.jp", "higashimatsuyama.saitama.jp", "honjo.saitama.jp", "ina.saitama.jp", "iruma.saitama.jp", "iwatsuki.saitama.jp", "kamiizumi.saitama.jp", "kamikawa.saitama.jp", "kamisato.saitama.jp", "kasukabe.saitama.jp", "kawagoe.saitama.jp", "kawaguchi.saitama.jp", "kawajima.saitama.jp", "kazo.saitama.jp", "kitamoto.saitama.jp", "koshigaya.saitama.jp", "kounosu.saitama.jp", "kuki.saitama.jp", "kumagaya.saitama.jp", "matsubushi.saitama.jp", "minano.saitama.jp", "misato.saitama.jp", "miyashiro.saitama.jp", "miyoshi.saitama.jp", "moroyama.saitama.jp", "nagatoro.saitama.jp", "namegawa.saitama.jp", "niiza.saitama.jp", "ogano.saitama.jp", "ogawa.saitama.jp", "ogose.saitama.jp", "okegawa.saitama.jp", "omiya.saitama.jp", "otaki.saitama.jp", "ranzan.saitama.jp", "ryokami.saitama.jp", "saitama.saitama.jp", "sakado.saitama.jp", "satte.saitama.jp", "sayama.saitama.jp", "shiki.saitama.jp", "shiraoka.saitama.jp", "soka.saitama.jp", "sugito.saitama.jp", "toda.saitama.jp", "tokigawa.saitama.jp", "tokorozawa.saitama.jp", "tsurugashima.saitama.jp", "urawa.saitama.jp", "warabi.saitama.jp", "yashio.saitama.jp", "yokoze.saitama.jp", "yono.saitama.jp", "yorii.saitama.jp", "yoshida.saitama.jp", "yoshikawa.saitama.jp", "yoshimi.saitama.jp", "aisho.shiga.jp", "gamo.shiga.jp", "higashiomi.shiga.jp", "hikone.shiga.jp", "koka.shiga.jp", "konan.shiga.jp", "kosei.shiga.jp", "koto.shiga.jp", "kusatsu.shiga.jp", "maibara.shiga.jp", "moriyama.shiga.jp", "nagahama.shiga.jp", "nishiazai.shiga.jp", "notogawa.shiga.jp", "omihachiman.shiga.jp", "otsu.shiga.jp", "ritto.shiga.jp", "ryuoh.shiga.jp", "takashima.shiga.jp", "takatsuki.shiga.jp", "torahime.shiga.jp", "toyosato.shiga.jp", "yasu.shiga.jp", "akagi.shimane.jp", "ama.shimane.jp", "gotsu.shimane.jp", "hamada.shimane.jp", "higashiizumo.shimane.jp", "hikawa.shimane.jp", "hikimi.shimane.jp", "izumo.shimane.jp", "kakinoki.shimane.jp", "masuda.shimane.jp", "matsue.shimane.jp", "misato.shimane.jp", "nishinoshima.shimane.jp", "ohda.shimane.jp", "okinoshima.shimane.jp", "okuizumo.shimane.jp", "shimane.shimane.jp", "tamayu.shimane.jp", "tsuwano.shimane.jp", "unnan.shimane.jp", "yakumo.shimane.jp", "yasugi.shimane.jp", "yatsuka.shimane.jp", "arai.shizuoka.jp", "atami.shizuoka.jp", "fuji.shizuoka.jp", "fujieda.shizuoka.jp", "fujikawa.shizuoka.jp", "fujinomiya.shizuoka.jp", "fukuroi.shizuoka.jp", "gotemba.shizuoka.jp", "haibara.shizuoka.jp", "hamamatsu.shizuoka.jp", "higashiizu.shizuoka.jp", "ito.shizuoka.jp", "iwata.shizuoka.jp", "izu.shizuoka.jp", "izunokuni.shizuoka.jp", "kakegawa.shizuoka.jp", "kannami.shizuoka.jp", "kawanehon.shizuoka.jp", "kawazu.shizuoka.jp", "kikugawa.shizuoka.jp", "kosai.shizuoka.jp", "makinohara.shizuoka.jp", "matsuzaki.shizuoka.jp", "minamiizu.shizuoka.jp", "mishima.shizuoka.jp", "morimachi.shizuoka.jp", "nishiizu.shizuoka.jp", "numazu.shizuoka.jp", "omaezaki.shizuoka.jp", "shimada.shizuoka.jp", "shimizu.shizuoka.jp", "shimoda.shizuoka.jp", "shizuoka.shizuoka.jp", "susono.shizuoka.jp", "yaizu.shizuoka.jp", "yoshida.shizuoka.jp", "ashikaga.tochigi.jp", "bato.tochigi.jp", "haga.tochigi.jp", "ichikai.tochigi.jp", "iwafune.tochigi.jp", "kaminokawa.tochigi.jp", "kanuma.tochigi.jp", "karasuyama.tochigi.jp", "kuroiso.tochigi.jp", "mashiko.tochigi.jp", "mibu.tochigi.jp", "moka.tochigi.jp", "motegi.tochigi.jp", "nasu.tochigi.jp", "nasushiobara.tochigi.jp", "nikko.tochigi.jp", "nishikata.tochigi.jp", "nogi.tochigi.jp", "ohira.tochigi.jp", "ohtawara.tochigi.jp", "oyama.tochigi.jp", "sakura.tochigi.jp", "sano.tochigi.jp", "shimotsuke.tochigi.jp", "shioya.tochigi.jp", "takanezawa.tochigi.jp", "tochigi.tochigi.jp", "tsuga.tochigi.jp", "ujiie.tochigi.jp", "utsunomiya.tochigi.jp", "yaita.tochigi.jp", "aizumi.tokushima.jp", "anan.tokushima.jp", "ichiba.tokushima.jp", "itano.tokushima.jp", "kainan.tokushima.jp", "komatsushima.tokushima.jp", "matsushige.tokushima.jp", "mima.tokushima.jp", "minami.tokushima.jp", "miyoshi.tokushima.jp", "mugi.tokushima.jp", "nakagawa.tokushima.jp", "naruto.tokushima.jp", "sanagochi.tokushima.jp", "shishikui.tokushima.jp", "tokushima.tokushima.jp", "wajiki.tokushima.jp", "adachi.tokyo.jp", "akiruno.tokyo.jp", "akishima.tokyo.jp", "aogashima.tokyo.jp", "arakawa.tokyo.jp", "bunkyo.tokyo.jp", "chiyoda.tokyo.jp", "chofu.tokyo.jp", "chuo.tokyo.jp", "edogawa.tokyo.jp", "fuchu.tokyo.jp", "fussa.tokyo.jp", "hachijo.tokyo.jp", "hachioji.tokyo.jp", "hamura.tokyo.jp", "higashikurume.tokyo.jp", "higashimurayama.tokyo.jp", "higashiyamato.tokyo.jp", "hino.tokyo.jp", "hinode.tokyo.jp", "hinohara.tokyo.jp", "inagi.tokyo.jp", "itabashi.tokyo.jp", "katsushika.tokyo.jp", "kita.tokyo.jp", "kiyose.tokyo.jp", "kodaira.tokyo.jp", "koganei.tokyo.jp", "kokubunji.tokyo.jp", "komae.tokyo.jp", "koto.tokyo.jp", "kouzushima.tokyo.jp", "kunitachi.tokyo.jp", "machida.tokyo.jp", "meguro.tokyo.jp", "minato.tokyo.jp", "mitaka.tokyo.jp", "mizuho.tokyo.jp", "musashimurayama.tokyo.jp", "musashino.tokyo.jp", "nakano.tokyo.jp", "nerima.tokyo.jp", "ogasawara.tokyo.jp", "okutama.tokyo.jp", "ome.tokyo.jp", "oshima.tokyo.jp", "ota.tokyo.jp", "setagaya.tokyo.jp", "shibuya.tokyo.jp", "shinagawa.tokyo.jp", "shinjuku.tokyo.jp", "suginami.tokyo.jp", "sumida.tokyo.jp", "tachikawa.tokyo.jp", "taito.tokyo.jp", "tama.tokyo.jp", "toshima.tokyo.jp", "chizu.tottori.jp", "hino.tottori.jp", "kawahara.tottori.jp", "koge.tottori.jp", "kotoura.tottori.jp", "misasa.tottori.jp", "nanbu.tottori.jp", "nichinan.tottori.jp", "sakaiminato.tottori.jp", "tottori.tottori.jp", "wakasa.tottori.jp", "yazu.tottori.jp", "yonago.tottori.jp", "asahi.toyama.jp", "fuchu.toyama.jp", "fukumitsu.toyama.jp", "funahashi.toyama.jp", "himi.toyama.jp", "imizu.toyama.jp", "inami.toyama.jp", "johana.toyama.jp", "kamiichi.toyama.jp", "kurobe.toyama.jp", "nakaniikawa.toyama.jp", "namerikawa.toyama.jp", "nanto.toyama.jp", "nyuzen.toyama.jp", "oyabe.toyama.jp", "taira.toyama.jp", "takaoka.toyama.jp", "tateyama.toyama.jp", "toga.toyama.jp", "tonami.toyama.jp", "toyama.toyama.jp", "unazuki.toyama.jp", "uozu.toyama.jp", "yamada.toyama.jp", "arida.wakayama.jp", "aridagawa.wakayama.jp", "gobo.wakayama.jp", "hashimoto.wakayama.jp", "hidaka.wakayama.jp", "hirogawa.wakayama.jp", "inami.wakayama.jp", "iwade.wakayama.jp", "kainan.wakayama.jp", "kamitonda.wakayama.jp", "katsuragi.wakayama.jp", "kimino.wakayama.jp", "kinokawa.wakayama.jp", "kitayama.wakayama.jp", "koya.wakayama.jp", "koza.wakayama.jp", "kozagawa.wakayama.jp", "kudoyama.wakayama.jp", "kushimoto.wakayama.jp", "mihama.wakayama.jp", "misato.wakayama.jp", "nachikatsuura.wakayama.jp", "shingu.wakayama.jp", "shirahama.wakayama.jp", "taiji.wakayama.jp", "tanabe.wakayama.jp", "wakayama.wakayama.jp", "yuasa.wakayama.jp", "yura.wakayama.jp", "asahi.yamagata.jp", "funagata.yamagata.jp", "higashine.yamagata.jp", "iide.yamagata.jp", "kahoku.yamagata.jp", "kaminoyama.yamagata.jp", "kaneyama.yamagata.jp", "kawanishi.yamagata.jp", "mamurogawa.yamagata.jp", "mikawa.yamagata.jp", "murayama.yamagata.jp", "nagai.yamagata.jp", "nakayama.yamagata.jp", "nanyo.yamagata.jp", "nishikawa.yamagata.jp", "obanazawa.yamagata.jp", "oe.yamagata.jp", "oguni.yamagata.jp", "ohkura.yamagata.jp", "oishida.yamagata.jp", "sagae.yamagata.jp", "sakata.yamagata.jp", "sakegawa.yamagata.jp", "shinjo.yamagata.jp", "shirataka.yamagata.jp", "shonai.yamagata.jp", "takahata.yamagata.jp", "tendo.yamagata.jp", "tozawa.yamagata.jp", "tsuruoka.yamagata.jp", "yamagata.yamagata.jp", "yamanobe.yamagata.jp", "yonezawa.yamagata.jp", "yuza.yamagata.jp", "abu.yamaguchi.jp", "hagi.yamaguchi.jp", "hikari.yamaguchi.jp", "hofu.yamaguchi.jp", "iwakuni.yamaguchi.jp", "kudamatsu.yamaguchi.jp", "mitou.yamaguchi.jp", "nagato.yamaguchi.jp", "oshima.yamaguchi.jp", "shimonoseki.yamaguchi.jp", "shunan.yamaguchi.jp", "tabuse.yamaguchi.jp", "tokuyama.yamaguchi.jp", "toyota.yamaguchi.jp", "ube.yamaguchi.jp", "yuu.yamaguchi.jp", "chuo.yamanashi.jp", "doshi.yamanashi.jp", "fuefuki.yamanashi.jp", "fujikawa.yamanashi.jp", "fujikawaguchiko.yamanashi.jp", "fujiyoshida.yamanashi.jp", "hayakawa.yamanashi.jp", "hokuto.yamanashi.jp", "ichikawamisato.yamanashi.jp", "kai.yamanashi.jp", "kofu.yamanashi.jp", "koshu.yamanashi.jp", "kosuge.yamanashi.jp", "minami-alps.yamanashi.jp", "minobu.yamanashi.jp", "nakamichi.yamanashi.jp", "nanbu.yamanashi.jp", "narusawa.yamanashi.jp", "nirasaki.yamanashi.jp", "nishikatsura.yamanashi.jp", "oshino.yamanashi.jp", "otsuki.yamanashi.jp", "showa.yamanashi.jp", "tabayama.yamanashi.jp", "tsuru.yamanashi.jp", "uenohara.yamanashi.jp", "yamanakako.yamanashi.jp", "yamanashi.yamanashi.jp", "ke", "ac.ke", "co.ke", "go.ke", "info.ke", "me.ke", "mobi.ke", "ne.ke", "or.ke", "sc.ke", "kg", "com.kg", "edu.kg", "gov.kg", "mil.kg", "net.kg", "org.kg", "*.kh", "ki", "biz.ki", "com.ki", "edu.ki", "gov.ki", "info.ki", "net.ki", "org.ki", "km", "ass.km", "com.km", "edu.km", "gov.km", "mil.km", "nom.km", "org.km", "prd.km", "tm.km", "asso.km", "coop.km", "gouv.km", "medecin.km", "notaires.km", "pharmaciens.km", "presse.km", "veterinaire.km", "kn", "edu.kn", "gov.kn", "net.kn", "org.kn", "kp", "com.kp", "edu.kp", "gov.kp", "org.kp", "rep.kp", "tra.kp", "kr", "ac.kr", "co.kr", "es.kr", "go.kr", "hs.kr", "kg.kr", "mil.kr", "ms.kr", "ne.kr", "or.kr", "pe.kr", "re.kr", "sc.kr", "busan.kr", "chungbuk.kr", "chungnam.kr", "daegu.kr", "daejeon.kr", "gangwon.kr", "gwangju.kr", "gyeongbuk.kr", "gyeonggi.kr", "gyeongnam.kr", "incheon.kr", "jeju.kr", "jeonbuk.kr", "jeonnam.kr", "seoul.kr", "ulsan.kr", "kw", "com.kw", "edu.kw", "emb.kw", "gov.kw", "ind.kw", "net.kw", "org.kw", "ky", "com.ky", "edu.ky", "net.ky", "org.ky", "kz", "com.kz", "edu.kz", "gov.kz", "mil.kz", "net.kz", "org.kz", "la", "com.la", "edu.la", "gov.la", "info.la", "int.la", "net.la", "org.la", "per.la", "lb", "com.lb", "edu.lb", "gov.lb", "net.lb", "org.lb", "lc", "co.lc", "com.lc", "edu.lc", "gov.lc", "net.lc", "org.lc", "li", "lk", "ac.lk", "assn.lk", "com.lk", "edu.lk", "gov.lk", "grp.lk", "hotel.lk", "int.lk", "ltd.lk", "net.lk", "ngo.lk", "org.lk", "sch.lk", "soc.lk", "web.lk", "lr", "com.lr", "edu.lr", "gov.lr", "net.lr", "org.lr", "ls", "ac.ls", "biz.ls", "co.ls", "edu.ls", "gov.ls", "info.ls", "net.ls", "org.ls", "sc.ls", "lt", "gov.lt", "lu", "lv", "asn.lv", "com.lv", "conf.lv", "edu.lv", "gov.lv", "id.lv", "mil.lv", "net.lv", "org.lv", "ly", "com.ly", "edu.ly", "gov.ly", "id.ly", "med.ly", "net.ly", "org.ly", "plc.ly", "sch.ly", "ma", "ac.ma", "co.ma", "gov.ma", "net.ma", "org.ma", "press.ma", "mc", "asso.mc", "tm.mc", "md", "me", "ac.me", "co.me", "edu.me", "gov.me", "its.me", "net.me", "org.me", "priv.me", "mg", "co.mg", "com.mg", "edu.mg", "gov.mg", "mil.mg", "nom.mg", "org.mg", "prd.mg", "mh", "mil", "mk", "com.mk", "edu.mk", "gov.mk", "inf.mk", "name.mk", "net.mk", "org.mk", "ml", "com.ml", "edu.ml", "gouv.ml", "gov.ml", "net.ml", "org.ml", "presse.ml", "*.mm", "mn", "edu.mn", "gov.mn", "org.mn", "mo", "com.mo", "edu.mo", "gov.mo", "net.mo", "org.mo", "mobi", "mp", "mq", "mr", "gov.mr", "ms", "com.ms", "edu.ms", "gov.ms", "net.ms", "org.ms", "mt", "com.mt", "edu.mt", "net.mt", "org.mt", "mu", "ac.mu", "co.mu", "com.mu", "gov.mu", "net.mu", "or.mu", "org.mu", "museum", "mv", "aero.mv", "biz.mv", "com.mv", "coop.mv", "edu.mv", "gov.mv", "info.mv", "int.mv", "mil.mv", "museum.mv", "name.mv", "net.mv", "org.mv", "pro.mv", "mw", "ac.mw", "biz.mw", "co.mw", "com.mw", "coop.mw", "edu.mw", "gov.mw", "int.mw", "net.mw", "org.mw", "mx", "com.mx", "edu.mx", "gob.mx", "net.mx", "org.mx", "my", "biz.my", "com.my", "edu.my", "gov.my", "mil.my", "name.my", "net.my", "org.my", "mz", "ac.mz", "adv.mz", "co.mz", "edu.mz", "gov.mz", "mil.mz", "net.mz", "org.mz", "na", "alt.na", "co.na", "com.na", "gov.na", "net.na", "org.na", "name", "nc", "asso.nc", "nom.nc", "ne", "net", "nf", "arts.nf", "com.nf", "firm.nf", "info.nf", "net.nf", "other.nf", "per.nf", "rec.nf", "store.nf", "web.nf", "ng", "com.ng", "edu.ng", "gov.ng", "i.ng", "mil.ng", "mobi.ng", "name.ng", "net.ng", "org.ng", "sch.ng", "ni", "ac.ni", "biz.ni", "co.ni", "com.ni", "edu.ni", "gob.ni", "in.ni", "info.ni", "int.ni", "mil.ni", "net.ni", "nom.ni", "org.ni", "web.ni", "nl", "no", "fhs.no", "folkebibl.no", "fylkesbibl.no", "idrett.no", "museum.no", "priv.no", "vgs.no", "dep.no", "herad.no", "kommune.no", "mil.no", "stat.no", "aa.no", "ah.no", "bu.no", "fm.no", "hl.no", "hm.no", "jan-mayen.no", "mr.no", "nl.no", "nt.no", "of.no", "ol.no", "oslo.no", "rl.no", "sf.no", "st.no", "svalbard.no", "tm.no", "tr.no", "va.no", "vf.no", "gs.aa.no", "gs.ah.no", "gs.bu.no", "gs.fm.no", "gs.hl.no", "gs.hm.no", "gs.jan-mayen.no", "gs.mr.no", "gs.nl.no", "gs.nt.no", "gs.of.no", "gs.ol.no", "gs.oslo.no", "gs.rl.no", "gs.sf.no", "gs.st.no", "gs.svalbard.no", "gs.tm.no", "gs.tr.no", "gs.va.no", "gs.vf.no", "akrehamn.no", "åkrehamn.no", "algard.no", "ålgård.no", "arna.no", "bronnoysund.no", "brønnøysund.no", "brumunddal.no", "bryne.no", "drobak.no", "drøbak.no", "egersund.no", "fetsund.no", "floro.no", "florø.no", "fredrikstad.no", "hokksund.no", "honefoss.no", "hønefoss.no", "jessheim.no", "jorpeland.no", "jørpeland.no", "kirkenes.no", "kopervik.no", "krokstadelva.no", "langevag.no", "langevåg.no", "leirvik.no", "mjondalen.no", "mjøndalen.no", "mo-i-rana.no", "mosjoen.no", "mosjøen.no", "nesoddtangen.no", "orkanger.no", "osoyro.no", "osøyro.no", "raholt.no", "råholt.no", "sandnessjoen.no", "sandnessjøen.no", "skedsmokorset.no", "slattum.no", "spjelkavik.no", "stathelle.no", "stavern.no", "stjordalshalsen.no", "stjørdalshalsen.no", "tananger.no", "tranby.no", "vossevangen.no", "aarborte.no", "aejrie.no", "afjord.no", "åfjord.no", "agdenes.no", "nes.akershus.no", "aknoluokta.no", "ákŋoluokta.no", "al.no", "ål.no", "alaheadju.no", "álaheadju.no", "alesund.no", "ålesund.no", "alstahaug.no", "alta.no", "áltá.no", "alvdal.no", "amli.no", "åmli.no", "amot.no", "åmot.no", "andasuolo.no", "andebu.no", "andoy.no", "andøy.no", "ardal.no", "årdal.no", "aremark.no", "arendal.no", "ås.no", "aseral.no", "åseral.no", "asker.no", "askim.no", "askoy.no", "askøy.no", "askvoll.no", "asnes.no", "åsnes.no", "audnedaln.no", "aukra.no", "aure.no", "aurland.no", "aurskog-holand.no", "aurskog-høland.no", "austevoll.no", "austrheim.no", "averoy.no", "averøy.no", "badaddja.no", "bådåddjå.no", "bærum.no", "bahcavuotna.no", "báhcavuotna.no", "bahccavuotna.no", "báhccavuotna.no", "baidar.no", "báidár.no", "bajddar.no", "bájddar.no", "balat.no", "bálát.no", "balestrand.no", "ballangen.no", "balsfjord.no", "bamble.no", "bardu.no", "barum.no", "batsfjord.no", "båtsfjord.no", "bearalvahki.no", "bearalváhki.no", "beardu.no", "beiarn.no", "berg.no", "bergen.no", "berlevag.no", "berlevåg.no", "bievat.no", "bievát.no", "bindal.no", "birkenes.no", "bjarkoy.no", "bjarkøy.no", "bjerkreim.no", "bjugn.no", "bodo.no", "bodø.no", "bokn.no", "bomlo.no", "bømlo.no", "bremanger.no", "bronnoy.no", "brønnøy.no", "budejju.no", "nes.buskerud.no", "bygland.no", "bykle.no", "cahcesuolo.no", "čáhcesuolo.no", "davvenjarga.no", "davvenjárga.no", "davvesiida.no", "deatnu.no", "dielddanuorri.no", "divtasvuodna.no", "divttasvuotna.no", "donna.no", "dønna.no", "dovre.no", "drammen.no", "drangedal.no", "dyroy.no", "dyrøy.no", "eid.no", "eidfjord.no", "eidsberg.no", "eidskog.no", "eidsvoll.no", "eigersund.no", "elverum.no", "enebakk.no", "engerdal.no", "etne.no", "etnedal.no", "evenassi.no", "evenášši.no", "evenes.no", "evje-og-hornnes.no", "farsund.no", "fauske.no", "fedje.no", "fet.no", "finnoy.no", "finnøy.no", "fitjar.no", "fjaler.no", "fjell.no", "fla.no", "flå.no", "flakstad.no", "flatanger.no", "flekkefjord.no", "flesberg.no", "flora.no", "folldal.no", "forde.no", "førde.no", "forsand.no", "fosnes.no", "fræna.no", "frana.no", "frei.no", "frogn.no", "froland.no", "frosta.no", "froya.no", "frøya.no", "fuoisku.no", "fuossko.no", "fusa.no", "fyresdal.no", "gaivuotna.no", "gáivuotna.no", "galsa.no", "gálsá.no", "gamvik.no", "gangaviika.no", "gáŋgaviika.no", "gaular.no", "gausdal.no", "giehtavuoatna.no", "gildeskal.no", "gildeskål.no", "giske.no", "gjemnes.no", "gjerdrum.no", "gjerstad.no", "gjesdal.no", "gjovik.no", "gjøvik.no", "gloppen.no", "gol.no", "gran.no", "grane.no", "granvin.no", "gratangen.no", "grimstad.no", "grong.no", "grue.no", "gulen.no", "guovdageaidnu.no", "ha.no", "hå.no", "habmer.no", "hábmer.no", "hadsel.no", "hægebostad.no", "hagebostad.no", "halden.no", "halsa.no", "hamar.no", "hamaroy.no", "hammarfeasta.no", "hámmárfeasta.no", "hammerfest.no", "hapmir.no", "hápmir.no", "haram.no", "hareid.no", "harstad.no", "hasvik.no", "hattfjelldal.no", "haugesund.no", "os.hedmark.no", "valer.hedmark.no", "våler.hedmark.no", "hemne.no", "hemnes.no", "hemsedal.no", "hitra.no", "hjartdal.no", "hjelmeland.no", "hobol.no", "hobøl.no", "hof.no", "hol.no", "hole.no", "holmestrand.no", "holtalen.no", "holtålen.no", "os.hordaland.no", "hornindal.no", "horten.no", "hoyanger.no", "høyanger.no", "hoylandet.no", "høylandet.no", "hurdal.no", "hurum.no", "hvaler.no", "hyllestad.no", "ibestad.no", "inderoy.no", "inderøy.no", "iveland.no", "ivgu.no", "jevnaker.no", "jolster.no", "jølster.no", "jondal.no", "kafjord.no", "kåfjord.no", "karasjohka.no", "kárášjohka.no", "karasjok.no", "karlsoy.no", "karmoy.no", "karmøy.no", "kautokeino.no", "klabu.no", "klæbu.no", "klepp.no", "kongsberg.no", "kongsvinger.no", "kraanghke.no", "kråanghke.no", "kragero.no", "kragerø.no", "kristiansand.no", "kristiansund.no", "krodsherad.no", "krødsherad.no", "kvæfjord.no", "kvænangen.no", "kvafjord.no", "kvalsund.no", "kvam.no", "kvanangen.no", "kvinesdal.no", "kvinnherad.no", "kviteseid.no", "kvitsoy.no", "kvitsøy.no", "laakesvuemie.no", "lærdal.no", "lahppi.no", "láhppi.no", "lardal.no", "larvik.no", "lavagis.no", "lavangen.no", "leangaviika.no", "leaŋgaviika.no", "lebesby.no", "leikanger.no", "leirfjord.no", "leka.no", "leksvik.no", "lenvik.no", "lerdal.no", "lesja.no", "levanger.no", "lier.no", "lierne.no", "lillehammer.no", "lillesand.no", "lindas.no", "lindås.no", "lindesnes.no", "loabat.no", "loabát.no", "lodingen.no", "lødingen.no", "lom.no", "loppa.no", "lorenskog.no", "lørenskog.no", "loten.no", "løten.no", "lund.no", "lunner.no", "luroy.no", "lurøy.no", "luster.no", "lyngdal.no", "lyngen.no", "malatvuopmi.no", "málatvuopmi.no", "malselv.no", "målselv.no", "malvik.no", "mandal.no", "marker.no", "marnardal.no", "masfjorden.no", "masoy.no", "måsøy.no", "matta-varjjat.no", "mátta-várjjat.no", "meland.no", "meldal.no", "melhus.no", "meloy.no", "meløy.no", "meraker.no", "meråker.no", "midsund.no", "midtre-gauldal.no", "moareke.no", "moåreke.no", "modalen.no", "modum.no", "molde.no", "heroy.more-og-romsdal.no", "sande.more-og-romsdal.no", "herøy.møre-og-romsdal.no", "sande.møre-og-romsdal.no", "moskenes.no", "moss.no", "mosvik.no", "muosat.no", "muosát.no", "naamesjevuemie.no", "nååmesjevuemie.no", "nærøy.no", "namdalseid.no", "namsos.no", "namsskogan.no", "nannestad.no", "naroy.no", "narviika.no", "narvik.no", "naustdal.no", "navuotna.no", "návuotna.no", "nedre-eiker.no", "nesna.no", "nesodden.no", "nesseby.no", "nesset.no", "nissedal.no", "nittedal.no", "nord-aurdal.no", "nord-fron.no", "nord-odal.no", "norddal.no", "nordkapp.no", "bo.nordland.no", "bø.nordland.no", "heroy.nordland.no", "herøy.nordland.no", "nordre-land.no", "nordreisa.no", "nore-og-uvdal.no", "notodden.no", "notteroy.no", "nøtterøy.no", "odda.no", "oksnes.no", "øksnes.no", "omasvuotna.no", "oppdal.no", "oppegard.no", "oppegård.no", "orkdal.no", "orland.no", "ørland.no", "orskog.no", "ørskog.no", "orsta.no", "ørsta.no", "osen.no", "osteroy.no", "osterøy.no", "valer.ostfold.no", "våler.østfold.no", "ostre-toten.no", "østre-toten.no", "overhalla.no", "ovre-eiker.no", "øvre-eiker.no", "oyer.no", "øyer.no", "oygarden.no", "øygarden.no", "oystre-slidre.no", "øystre-slidre.no", "porsanger.no", "porsangu.no", "porsáŋgu.no", "porsgrunn.no", "rade.no", "råde.no", "radoy.no", "radøy.no", "rælingen.no", "rahkkeravju.no", "ráhkkerávju.no", "raisa.no", "ráisa.no", "rakkestad.no", "ralingen.no", "rana.no", "randaberg.no", "rauma.no", "rendalen.no", "rennebu.no", "rennesoy.no", "rennesøy.no", "rindal.no", "ringebu.no", "ringerike.no", "ringsaker.no", "risor.no", "risør.no", "rissa.no", "roan.no", "rodoy.no", "rødøy.no", "rollag.no", "romsa.no", "romskog.no", "rømskog.no", "roros.no", "røros.no", "rost.no", "røst.no", "royken.no", "røyken.no", "royrvik.no", "røyrvik.no", "ruovat.no", "rygge.no", "salangen.no", "salat.no", "sálat.no", "sálát.no", "saltdal.no", "samnanger.no", "sandefjord.no", "sandnes.no", "sandoy.no", "sandøy.no", "sarpsborg.no", "sauda.no", "sauherad.no", "sel.no", "selbu.no", "selje.no", "seljord.no", "siellak.no", "sigdal.no", "siljan.no", "sirdal.no", "skanit.no", "skánit.no", "skanland.no", "skånland.no", "skaun.no", "skedsmo.no", "ski.no", "skien.no", "skierva.no", "skiervá.no", "skiptvet.no", "skjak.no", "skjåk.no", "skjervoy.no", "skjervøy.no", "skodje.no", "smola.no", "smøla.no", "snaase.no", "snåase.no", "snasa.no", "snåsa.no", "snillfjord.no", "snoasa.no", "sogndal.no", "sogne.no", "søgne.no", "sokndal.no", "sola.no", "solund.no", "somna.no", "sømna.no", "sondre-land.no", "søndre-land.no", "songdalen.no", "sor-aurdal.no", "sør-aurdal.no", "sor-fron.no", "sør-fron.no", "sor-odal.no", "sør-odal.no", "sor-varanger.no", "sør-varanger.no", "sorfold.no", "sørfold.no", "sorreisa.no", "sørreisa.no", "sortland.no", "sorum.no", "sørum.no", "spydeberg.no", "stange.no", "stavanger.no", "steigen.no", "steinkjer.no", "stjordal.no", "stjørdal.no", "stokke.no", "stor-elvdal.no", "stord.no", "stordal.no", "storfjord.no", "strand.no", "stranda.no", "stryn.no", "sula.no", "suldal.no", "sund.no", "sunndal.no", "surnadal.no", "sveio.no", "svelvik.no", "sykkylven.no", "tana.no", "bo.telemark.no", "bø.telemark.no", "time.no", "tingvoll.no", "tinn.no", "tjeldsund.no", "tjome.no", "tjøme.no", "tokke.no", "tolga.no", "tonsberg.no", "tønsberg.no", "torsken.no", "træna.no", "trana.no", "tranoy.no", "tranøy.no", "troandin.no", "trogstad.no", "trøgstad.no", "tromsa.no", "tromso.no", "tromsø.no", "trondheim.no", "trysil.no", "tvedestrand.no", "tydal.no", "tynset.no", "tysfjord.no", "tysnes.no", "tysvær.no", "tysvar.no", "ullensaker.no", "ullensvang.no", "ulvik.no", "unjarga.no", "unjárga.no", "utsira.no", "vaapste.no", "vadso.no", "vadsø.no", "værøy.no", "vaga.no", "vågå.no", "vagan.no", "vågan.no", "vagsoy.no", "vågsøy.no", "vaksdal.no", "valle.no", "vang.no", "vanylven.no", "vardo.no", "vardø.no", "varggat.no", "várggát.no", "varoy.no", "vefsn.no", "vega.no", "vegarshei.no", "vegårshei.no", "vennesla.no", "verdal.no", "verran.no", "vestby.no", "sande.vestfold.no", "vestnes.no", "vestre-slidre.no", "vestre-toten.no", "vestvagoy.no", "vestvågøy.no", "vevelstad.no", "vik.no", "vikna.no", "vindafjord.no", "voagat.no", "volda.no", "voss.no", "*.np", "nr", "biz.nr", "com.nr", "edu.nr", "gov.nr", "info.nr", "net.nr", "org.nr", "nu", "nz", "ac.nz", "co.nz", "cri.nz", "geek.nz", "gen.nz", "govt.nz", "health.nz", "iwi.nz", "kiwi.nz", "maori.nz", "māori.nz", "mil.nz", "net.nz", "org.nz", "parliament.nz", "school.nz", "om", "co.om", "com.om", "edu.om", "gov.om", "med.om", "museum.om", "net.om", "org.om", "pro.om", "onion", "org", "pa", "abo.pa", "ac.pa", "com.pa", "edu.pa", "gob.pa", "ing.pa", "med.pa", "net.pa", "nom.pa", "org.pa", "sld.pa", "pe", "com.pe", "edu.pe", "gob.pe", "mil.pe", "net.pe", "nom.pe", "org.pe", "pf", "com.pf", "edu.pf", "org.pf", "*.pg", "ph", "com.ph", "edu.ph", "gov.ph", "i.ph", "mil.ph", "net.ph", "ngo.ph", "org.ph", "pk", "ac.pk", "biz.pk", "com.pk", "edu.pk", "fam.pk", "gkp.pk", "gob.pk", "gog.pk", "gok.pk", "gon.pk", "gop.pk", "gos.pk", "gov.pk", "net.pk", "org.pk", "web.pk", "pl", "com.pl", "net.pl", "org.pl", "agro.pl", "aid.pl", "atm.pl", "auto.pl", "biz.pl", "edu.pl", "gmina.pl", "gsm.pl", "info.pl", "mail.pl", "media.pl", "miasta.pl", "mil.pl", "nieruchomosci.pl", "nom.pl", "pc.pl", "powiat.pl", "priv.pl", "realestate.pl", "rel.pl", "sex.pl", "shop.pl", "sklep.pl", "sos.pl", "szkola.pl", "targi.pl", "tm.pl", "tourism.pl", "travel.pl", "turystyka.pl", "gov.pl", "ap.gov.pl", "griw.gov.pl", "ic.gov.pl", "is.gov.pl", "kmpsp.gov.pl", "konsulat.gov.pl", "kppsp.gov.pl", "kwp.gov.pl", "kwpsp.gov.pl", "mup.gov.pl", "mw.gov.pl", "oia.gov.pl", "oirm.gov.pl", "oke.gov.pl", "oow.gov.pl", "oschr.gov.pl", "oum.gov.pl", "pa.gov.pl", "pinb.gov.pl", "piw.gov.pl", "po.gov.pl", "pr.gov.pl", "psp.gov.pl", "psse.gov.pl", "pup.gov.pl", "rzgw.gov.pl", "sa.gov.pl", "sdn.gov.pl", "sko.gov.pl", "so.gov.pl", "sr.gov.pl", "starostwo.gov.pl", "ug.gov.pl", "ugim.gov.pl", "um.gov.pl", "umig.gov.pl", "upow.gov.pl", "uppo.gov.pl", "us.gov.pl", "uw.gov.pl", "uzs.gov.pl", "wif.gov.pl", "wiih.gov.pl", "winb.gov.pl", "wios.gov.pl", "witd.gov.pl", "wiw.gov.pl", "wkz.gov.pl", "wsa.gov.pl", "wskr.gov.pl", "wsse.gov.pl", "wuoz.gov.pl", "wzmiuw.gov.pl", "zp.gov.pl", "zpisdn.gov.pl", "augustow.pl", "babia-gora.pl", "bedzin.pl", "beskidy.pl", "bialowieza.pl", "bialystok.pl", "bielawa.pl", "bieszczady.pl", "boleslawiec.pl", "bydgoszcz.pl", "bytom.pl", "cieszyn.pl", "czeladz.pl", "czest.pl", "dlugoleka.pl", "elblag.pl", "elk.pl", "glogow.pl", "gniezno.pl", "gorlice.pl", "grajewo.pl", "ilawa.pl", "jaworzno.pl", "jelenia-gora.pl", "jgora.pl", "kalisz.pl", "karpacz.pl", "kartuzy.pl", "kaszuby.pl", "katowice.pl", "kazimierz-dolny.pl", "kepno.pl", "ketrzyn.pl", "klodzko.pl", "kobierzyce.pl", "kolobrzeg.pl", "konin.pl", "konskowola.pl", "kutno.pl", "lapy.pl", "lebork.pl", "legnica.pl", "lezajsk.pl", "limanowa.pl", "lomza.pl", "lowicz.pl", "lubin.pl", "lukow.pl", "malbork.pl", "malopolska.pl", "mazowsze.pl", "mazury.pl", "mielec.pl", "mielno.pl", "mragowo.pl", "naklo.pl", "nowaruda.pl", "nysa.pl", "olawa.pl", "olecko.pl", "olkusz.pl", "olsztyn.pl", "opoczno.pl", "opole.pl", "ostroda.pl", "ostroleka.pl", "ostrowiec.pl", "ostrowwlkp.pl", "pila.pl", "pisz.pl", "podhale.pl", "podlasie.pl", "polkowice.pl", "pomorskie.pl", "pomorze.pl", "prochowice.pl", "pruszkow.pl", "przeworsk.pl", "pulawy.pl", "radom.pl", "rawa-maz.pl", "rybnik.pl", "rzeszow.pl", "sanok.pl", "sejny.pl", "skoczow.pl", "slask.pl", "slupsk.pl", "sosnowiec.pl", "stalowa-wola.pl", "starachowice.pl", "stargard.pl", "suwalki.pl", "swidnica.pl", "swiebodzin.pl", "swinoujscie.pl", "szczecin.pl", "szczytno.pl", "tarnobrzeg.pl", "tgory.pl", "turek.pl", "tychy.pl", "ustka.pl", "walbrzych.pl", "warmia.pl", "warszawa.pl", "waw.pl", "wegrow.pl", "wielun.pl", "wlocl.pl", "wloclawek.pl", "wodzislaw.pl", "wolomin.pl", "wroclaw.pl", "zachpomor.pl", "zagan.pl", "zarow.pl", "zgora.pl", "zgorzelec.pl", "pm", "pn", "co.pn", "edu.pn", "gov.pn", "net.pn", "org.pn", "post", "pr", "biz.pr", "com.pr", "edu.pr", "gov.pr", "info.pr", "isla.pr", "name.pr", "net.pr", "org.pr", "pro.pr", "ac.pr", "est.pr", "prof.pr", "pro", "aaa.pro", "aca.pro", "acct.pro", "avocat.pro", "bar.pro", "cpa.pro", "eng.pro", "jur.pro", "law.pro", "med.pro", "recht.pro", "ps", "com.ps", "edu.ps", "gov.ps", "net.ps", "org.ps", "plo.ps", "sec.ps", "pt", "com.pt", "edu.pt", "gov.pt", "int.pt", "net.pt", "nome.pt", "org.pt", "publ.pt", "pw", "belau.pw", "co.pw", "ed.pw", "go.pw", "or.pw", "py", "com.py", "coop.py", "edu.py", "gov.py", "mil.py", "net.py", "org.py", "qa", "com.qa", "edu.qa", "gov.qa", "mil.qa", "name.qa", "net.qa", "org.qa", "sch.qa", "re", "asso.re", "com.re", "ro", "arts.ro", "com.ro", "firm.ro", "info.ro", "nom.ro", "nt.ro", "org.ro", "rec.ro", "store.ro", "tm.ro", "www.ro", "rs", "ac.rs", "co.rs", "edu.rs", "gov.rs", "in.rs", "org.rs", "ru", "rw", "ac.rw", "co.rw", "coop.rw", "gov.rw", "mil.rw", "net.rw", "org.rw", "sa", "com.sa", "edu.sa", "gov.sa", "med.sa", "net.sa", "org.sa", "pub.sa", "sch.sa", "sb", "com.sb", "edu.sb", "gov.sb", "net.sb", "org.sb", "sc", "com.sc", "edu.sc", "gov.sc", "net.sc", "org.sc", "sd", "com.sd", "edu.sd", "gov.sd", "info.sd", "med.sd", "net.sd", "org.sd", "tv.sd", "se", "a.se", "ac.se", "b.se", "bd.se", "brand.se", "c.se", "d.se", "e.se", "f.se", "fh.se", "fhsk.se", "fhv.se", "g.se", "h.se", "i.se", "k.se", "komforb.se", "kommunalforbund.se", "komvux.se", "l.se", "lanbib.se", "m.se", "n.se", "naturbruksgymn.se", "o.se", "org.se", "p.se", "parti.se", "pp.se", "press.se", "r.se", "s.se", "t.se", "tm.se", "u.se", "w.se", "x.se", "y.se", "z.se", "sg", "com.sg", "edu.sg", "gov.sg", "net.sg", "org.sg", "sh", "com.sh", "gov.sh", "mil.sh", "net.sh", "org.sh", "si", "sj", "sk", "sl", "com.sl", "edu.sl", "gov.sl", "net.sl", "org.sl", "sm", "sn", "art.sn", "com.sn", "edu.sn", "gouv.sn", "org.sn", "perso.sn", "univ.sn", "so", "com.so", "edu.so", "gov.so", "me.so", "net.so", "org.so", "sr", "ss", "biz.ss", "co.ss", "com.ss", "edu.ss", "gov.ss", "me.ss", "net.ss", "org.ss", "sch.ss", "st", "co.st", "com.st", "consulado.st", "edu.st", "embaixada.st", "mil.st", "net.st", "org.st", "principe.st", "saotome.st", "store.st", "su", "sv", "com.sv", "edu.sv", "gob.sv", "org.sv", "red.sv", "sx", "gov.sx", "sy", "com.sy", "edu.sy", "gov.sy", "mil.sy", "net.sy", "org.sy", "sz", "ac.sz", "co.sz", "org.sz", "tc", "td", "tel", "tf", "tg", "th", "ac.th", "co.th", "go.th", "in.th", "mi.th", "net.th", "or.th", "tj", "ac.tj", "biz.tj", "co.tj", "com.tj", "edu.tj", "go.tj", "gov.tj", "int.tj", "mil.tj", "name.tj", "net.tj", "nic.tj", "org.tj", "test.tj", "web.tj", "tk", "tl", "gov.tl", "tm", "co.tm", "com.tm", "edu.tm", "gov.tm", "mil.tm", "net.tm", "nom.tm", "org.tm", "tn", "com.tn", "ens.tn", "fin.tn", "gov.tn", "ind.tn", "info.tn", "intl.tn", "mincom.tn", "nat.tn", "net.tn", "org.tn", "perso.tn", "tourism.tn", "to", "com.to", "edu.to", "gov.to", "mil.to", "net.to", "org.to", "tr", "av.tr", "bbs.tr", "bel.tr", "biz.tr", "com.tr", "dr.tr", "edu.tr", "gen.tr", "gov.tr", "info.tr", "k12.tr", "kep.tr", "mil.tr", "name.tr", "net.tr", "org.tr", "pol.tr", "tel.tr", "tsk.tr", "tv.tr", "web.tr", "nc.tr", "gov.nc.tr", "tt", "biz.tt", "co.tt", "com.tt", "edu.tt", "gov.tt", "info.tt", "mil.tt", "name.tt", "net.tt", "org.tt", "pro.tt", "tv", "tw", "club.tw", "com.tw", "ebiz.tw", "edu.tw", "game.tw", "gov.tw", "idv.tw", "mil.tw", "net.tw", "org.tw", "tz", "ac.tz", "co.tz", "go.tz", "hotel.tz", "info.tz", "me.tz", "mil.tz", "mobi.tz", "ne.tz", "or.tz", "sc.tz", "tv.tz", "ua", "com.ua", "edu.ua", "gov.ua", "in.ua", "net.ua", "org.ua", "cherkassy.ua", "cherkasy.ua", "chernigov.ua", "chernihiv.ua", "chernivtsi.ua", "chernovtsy.ua", "ck.ua", "cn.ua", "cr.ua", "crimea.ua", "cv.ua", "dn.ua", "dnepropetrovsk.ua", "dnipropetrovsk.ua", "donetsk.ua", "dp.ua", "if.ua", "ivano-frankivsk.ua", "kh.ua", "kharkiv.ua", "kharkov.ua", "kherson.ua", "khmelnitskiy.ua", "khmelnytskyi.ua", "kiev.ua", "kirovograd.ua", "km.ua", "kr.ua", "kropyvnytskyi.ua", "krym.ua", "ks.ua", "kv.ua", "kyiv.ua", "lg.ua", "lt.ua", "lugansk.ua", "luhansk.ua", "lutsk.ua", "lv.ua", "lviv.ua", "mk.ua", "mykolaiv.ua", "nikolaev.ua", "od.ua", "odesa.ua", "odessa.ua", "pl.ua", "poltava.ua", "rivne.ua", "rovno.ua", "rv.ua", "sb.ua", "sebastopol.ua", "sevastopol.ua", "sm.ua", "sumy.ua", "te.ua", "ternopil.ua", "uz.ua", "uzhgorod.ua", "uzhhorod.ua", "vinnica.ua", "vinnytsia.ua", "vn.ua", "volyn.ua", "yalta.ua", "zakarpattia.ua", "zaporizhzhe.ua", "zaporizhzhia.ua", "zhitomir.ua", "zhytomyr.ua", "zp.ua", "zt.ua", "ug", "ac.ug", "co.ug", "com.ug", "go.ug", "ne.ug", "or.ug", "org.ug", "sc.ug", "uk", "ac.uk", "co.uk", "gov.uk", "ltd.uk", "me.uk", "net.uk", "nhs.uk", "org.uk", "plc.uk", "police.uk", "*.sch.uk", "us", "dni.us", "fed.us", "isa.us", "kids.us", "nsn.us", "ak.us", "al.us", "ar.us", "as.us", "az.us", "ca.us", "co.us", "ct.us", "dc.us", "de.us", "fl.us", "ga.us", "gu.us", "hi.us", "ia.us", "id.us", "il.us", "in.us", "ks.us", "ky.us", "la.us", "ma.us", "md.us", "me.us", "mi.us", "mn.us", "mo.us", "ms.us", "mt.us", "nc.us", "nd.us", "ne.us", "nh.us", "nj.us", "nm.us", "nv.us", "ny.us", "oh.us", "ok.us", "or.us", "pa.us", "pr.us", "ri.us", "sc.us", "sd.us", "tn.us", "tx.us", "ut.us", "va.us", "vi.us", "vt.us", "wa.us", "wi.us", "wv.us", "wy.us", "k12.ak.us", "k12.al.us", "k12.ar.us", "k12.as.us", "k12.az.us", "k12.ca.us", "k12.co.us", "k12.ct.us", "k12.dc.us", "k12.fl.us", "k12.ga.us", "k12.gu.us", "k12.ia.us", "k12.id.us", "k12.il.us", "k12.in.us", "k12.ks.us", "k12.ky.us", "k12.la.us", "k12.ma.us", "k12.md.us", "k12.me.us", "k12.mi.us", "k12.mn.us", "k12.mo.us", "k12.ms.us", "k12.mt.us", "k12.nc.us", "k12.ne.us", "k12.nh.us", "k12.nj.us", "k12.nm.us", "k12.nv.us", "k12.ny.us", "k12.oh.us", "k12.ok.us", "k12.or.us", "k12.pa.us", "k12.pr.us", "k12.sc.us", "k12.tn.us", "k12.tx.us", "k12.ut.us", "k12.va.us", "k12.vi.us", "k12.vt.us", "k12.wa.us", "k12.wi.us", "cc.ak.us", "lib.ak.us", "cc.al.us", "lib.al.us", "cc.ar.us", "lib.ar.us", "cc.as.us", "lib.as.us", "cc.az.us", "lib.az.us", "cc.ca.us", "lib.ca.us", "cc.co.us", "lib.co.us", "cc.ct.us", "lib.ct.us", "cc.dc.us", "lib.dc.us", "cc.de.us", "cc.fl.us", "cc.ga.us", "cc.gu.us", "cc.hi.us", "cc.ia.us", "cc.id.us", "cc.il.us", "cc.in.us", "cc.ks.us", "cc.ky.us", "cc.la.us", "cc.ma.us", "cc.md.us", "cc.me.us", "cc.mi.us", "cc.mn.us", "cc.mo.us", "cc.ms.us", "cc.mt.us", "cc.nc.us", "cc.nd.us", "cc.ne.us", "cc.nh.us", "cc.nj.us", "cc.nm.us", "cc.nv.us", "cc.ny.us", "cc.oh.us", "cc.ok.us", "cc.or.us", "cc.pa.us", "cc.pr.us", "cc.ri.us", "cc.sc.us", "cc.sd.us", "cc.tn.us", "cc.tx.us", "cc.ut.us", "cc.va.us", "cc.vi.us", "cc.vt.us", "cc.wa.us", "cc.wi.us", "cc.wv.us", "cc.wy.us", "k12.wy.us", "lib.fl.us", "lib.ga.us", "lib.gu.us", "lib.hi.us", "lib.ia.us", "lib.id.us", "lib.il.us", "lib.in.us", "lib.ks.us", "lib.ky.us", "lib.la.us", "lib.ma.us", "lib.md.us", "lib.me.us", "lib.mi.us", "lib.mn.us", "lib.mo.us", "lib.ms.us", "lib.mt.us", "lib.nc.us", "lib.nd.us", "lib.ne.us", "lib.nh.us", "lib.nj.us", "lib.nm.us", "lib.nv.us", "lib.ny.us", "lib.oh.us", "lib.ok.us", "lib.or.us", "lib.pa.us", "lib.pr.us", "lib.ri.us", "lib.sc.us", "lib.sd.us", "lib.tn.us", "lib.tx.us", "lib.ut.us", "lib.va.us", "lib.vi.us", "lib.vt.us", "lib.wa.us", "lib.wi.us", "lib.wy.us", "chtr.k12.ma.us", "paroch.k12.ma.us", "pvt.k12.ma.us", "ann-arbor.mi.us", "cog.mi.us", "dst.mi.us", "eaton.mi.us", "gen.mi.us", "mus.mi.us", "tec.mi.us", "washtenaw.mi.us", "uy", "com.uy", "edu.uy", "gub.uy", "mil.uy", "net.uy", "org.uy", "uz", "co.uz", "com.uz", "net.uz", "org.uz", "va", "vc", "com.vc", "edu.vc", "gov.vc", "mil.vc", "net.vc", "org.vc", "ve", "arts.ve", "bib.ve", "co.ve", "com.ve", "e12.ve", "edu.ve", "firm.ve", "gob.ve", "gov.ve", "info.ve", "int.ve", "mil.ve", "net.ve", "nom.ve", "org.ve", "rar.ve", "rec.ve", "store.ve", "tec.ve", "web.ve", "vg", "vi", "co.vi", "com.vi", "k12.vi", "net.vi", "org.vi", "vn", "ac.vn", "ai.vn", "biz.vn", "com.vn", "edu.vn", "gov.vn", "health.vn", "id.vn", "info.vn", "int.vn", "io.vn", "name.vn", "net.vn", "org.vn", "pro.vn", "angiang.vn", "bacgiang.vn", "backan.vn", "baclieu.vn", "bacninh.vn", "baria-vungtau.vn", "bentre.vn", "binhdinh.vn", "binhduong.vn", "binhphuoc.vn", "binhthuan.vn", "camau.vn", "cantho.vn", "caobang.vn", "daklak.vn", "daknong.vn", "danang.vn", "dienbien.vn", "dongnai.vn", "dongthap.vn", "gialai.vn", "hagiang.vn", "haiduong.vn", "haiphong.vn", "hanam.vn", "hanoi.vn", "hatinh.vn", "haugiang.vn", "hoabinh.vn", "hungyen.vn", "khanhhoa.vn", "kiengiang.vn", "kontum.vn", "laichau.vn", "lamdong.vn", "langson.vn", "laocai.vn", "longan.vn", "namdinh.vn", "nghean.vn", "ninhbinh.vn", "ninhthuan.vn", "phutho.vn", "phuyen.vn", "quangbinh.vn", "quangnam.vn", "quangngai.vn", "quangninh.vn", "quangtri.vn", "soctrang.vn", "sonla.vn", "tayninh.vn", "thaibinh.vn", "thainguyen.vn", "thanhhoa.vn", "thanhphohochiminh.vn", "thuathienhue.vn", "tiengiang.vn", "travinh.vn", "tuyenquang.vn", "vinhlong.vn", "vinhphuc.vn", "yenbai.vn", "vu", "com.vu", "edu.vu", "net.vu", "org.vu", "wf", "ws", "com.ws", "edu.ws", "gov.ws", "net.ws", "org.ws", "yt", "امارات", "հայ", "বাংলা", "бг", "البحرين", "бел", "中国", "中國", "الجزائر", "مصر", "ею", "ευ", "موريتانيا", "გე", "ελ", "香港", "個人.香港", "公司.香港", "政府.香港", "教育.香港", "組織.香港", "網絡.香港", "ಭಾರತ", "ଭାରତ", "ভাৰত", "भारतम्", "भारोत", "ڀارت", "ഭാരതം", "भारत", "بارت", "بھارت", "భారత్", "ભારત", "ਭਾਰਤ", "ভারত", "இந்தியா", "ایران", "ايران", "عراق", "الاردن", "한국", "қаз", "ລາວ", "ලංකා", "இலங்கை", "المغرب", "мкд", "мон", "澳門", "澳门", "مليسيا", "عمان", "پاکستان", "پاكستان", "فلسطين", "срб", "ак.срб", "обр.срб", "од.срб", "орг.срб", "пр.срб", "упр.срб", "рф", "قطر", "السعودية", "السعودیة", "السعودیۃ", "السعوديه", "سودان", "新加坡", "சிங்கப்பூர்", "سورية", "سوريا", "ไทย", "ทหาร.ไทย", "ธุรกิจ.ไทย", "เน็ต.ไทย", "รัฐบาล.ไทย", "ศึกษา.ไทย", "องค์กร.ไทย", "تونس", "台灣", "台湾", "臺灣", "укр", "اليمن", "xxx", "ye", "com.ye", "edu.ye", "gov.ye", "mil.ye", "net.ye", "org.ye", "ac.za", "agric.za", "alt.za", "co.za", "edu.za", "gov.za", "grondar.za", "law.za", "mil.za", "net.za", "ngo.za", "nic.za", "nis.za", "nom.za", "org.za", "school.za", "tm.za", "web.za", "zm", "ac.zm", "biz.zm", "co.zm", "com.zm", "edu.zm", "gov.zm", "info.zm", "mil.zm", "net.zm", "org.zm", "sch.zm", "zw", "ac.zw", "co.zw", "gov.zw", "mil.zw", "org.zw", "aaa", "aarp", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "academy", "accenture", "accountant", "accountants", "aco", "actor", "ads", "adult", "aeg", "aetna", "afl", "africa", "agakhan", "agency", "aig", "airbus", "airforce", "airtel", "akdn", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "amazon", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "aol", "apartments", "app", "apple", "aquarelle", "arab", "aramco", "archi", "army", "art", "arte", "asda", "associates", "athleta", "attorney", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "aws", "axa", "azure", "baby", "baidu", "banamex", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bbc", "bbt", "bbva", "bcg", "bcn", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bharti", "bible", "bid", "bike", "bing", "bingo", "bio", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bms", "bmw", "bnpparibas", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "build", "builders", "business", "buy", "buzz", "bzh", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "casa", "case", "cash", "casino", "catering", "catholic", "cba", "cbn", "cbre", "center", "ceo", "cern", "cfa", "cfd", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "church", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "coach", "codes", "coffee", "college", "cologne", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cool", "corsica", "country", "coupon", "coupons", "courses", "cpa", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "cuisinella", "cymru", "cyou", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dnp", "docs", "doctor", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "dunlop", "dupont", "durban", "dvag", "dvr", "earth", "eat", "eco", "edeka", "education", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "ericsson", "erni", "esq", "estate", "eurovision", "eus", "events", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "flickr", "flights", "flir", "florist", "flowers", "fly", "foo", "food", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "free", "fresenius", "frl", "frogans", "frontier", "ftr", "fujitsu", "fun", "fund", "furniture", "futbol", "fyi", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gay", "gbiz", "gdn", "gea", "gent", "genting", "george", "ggee", "gift", "gifts", "gives", "giving", "glass", "gle", "global", "globo", "gmail", "gmbh", "gmo", "gmx", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "gucci", "guge", "guide", "guitars", "guru", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hiphop", "hisamitsu", "hitachi", "hiv", "hkt", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "horse", "hospital", "host", "hosting", "hot", "hotels", "hotmail", "house", "how", "hsbc", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "ieee", "ifm", "ikano", "imamat", "imdb", "immo", "immobilien", "inc", "industries", "infiniti", "ing", "ink", "institute", "insurance", "insure", "international", "intuit", "investments", "ipiranga", "irish", "ismaili", "ist", "istanbul", "itau", "itv", "jaguar", "java", "jcb", "jeep", "jetzt", "jewelry", "jio", "jll", "jmp", "jnj", "joburg", "jot", "joy", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kia", "kids", "kim", "kindle", "kitchen", "kiwi", "koeln", "komatsu", "kosher", "kpmg", "kpn", "krd", "kred", "kuokgroup", "kyoto", "lacaixa", "lamborghini", "lamer", "lancaster", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "link", "lipsy", "live", "living", "llc", "llp", "loan", "loans", "locker", "locus", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "ltd", "ltda", "lundbeck", "luxe", "luxury", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "mattel", "mba", "mckinsey", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merck", "merckmsd", "miami", "microsoft", "mini", "mint", "mit", "mitsubishi", "mlb", "mls", "mma", "mobile", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "msd", "mtn", "mtr", "music", "nab", "nagoya", "navy", "nba", "nec", "netbank", "netflix", "network", "neustar", "new", "news", "next", "nextdirect", "nexus", "nfl", "ngo", "nhk", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nokia", "norton", "now", "nowruz", "nowtv", "nra", "nrw", "ntt", "nyc", "obi", "observer", "office", "okinawa", "olayan", "olayangroup", "ollo", "omega", "one", "ong", "onl", "online", "ooo", "open", "oracle", "orange", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "pay", "pccw", "pet", "pfizer", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "place", "play", "playstation", "plumbing", "plus", "pnc", "pohl", "poker", "politie", "porn", "pramerica", "praxi", "press", "prime", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "pub", "pwc", "qpon", "quebec", "quest", "racing", "radio", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "ril", "rio", "rip", "rocks", "rodeo", "rogers", "room", "rsvp", "rugby", "ruhr", "run", "rwe", "ryukyu", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sbi", "sbs", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scot", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "seven", "sew", "sex", "sexy", "sfr", "shangrila", "sharp", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "silk", "sina", "singles", "site", "ski", "skin", "sky", "skype", "sling", "smart", "smile", "sncf", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "spa", "space", "sport", "spot", "srl", "stada", "staples", "star", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "swatch", "swiss", "sydney", "systems", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tci", "tdk", "team", "tech", "technology", "temasek", "tennis", "teva", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tips", "tires", "tirol", "tjmaxx", "tjx", "tkmaxx", "tmall", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "trade", "trading", "training", "travel", "travelers", "travelersinsurance", "trust", "trv", "tube", "tui", "tunes", "tushu", "tvs", "ubank", "ubs", "unicom", "university", "uno", "uol", "ups", "vacations", "vana", "vanguard", "vegas", "ventures", "verisign", "versicherung", "vet", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "viva", "vivo", "vlaanderen", "vodka", "volvo", "vote", "voting", "voto", "voyage", "wales", "walmart", "walter", "wang", "wanggou", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "wtc", "wtf", "xbox", "xerox", "xihuan", "xin", "कॉम", "セール", "佛山", "慈善", "集团", "在线", "点看", "คอม", "八卦", "موقع", "公益", "公司", "香格里拉", "网站", "移动", "我爱你", "москва", "католик", "онлайн", "сайт", "联通", "קום", "时尚", "微博", "淡马锡", "ファッション", "орг", "नेट", "ストア", "アマゾン", "삼성", "商标", "商店", "商城", "дети", "ポイント", "新闻", "家電", "كوم", "中文网", "中信", "娱乐", "谷歌", "電訊盈科", "购物", "クラウド", "通販", "网店", "संगठन", "餐厅", "网络", "ком", "亚马逊", "食品", "飞利浦", "手机", "ارامكو", "العليان", "بازار", "ابوظبي", "كاثوليك", "همراه", "닷컴", "政府", "شبكة", "بيتك", "عرب", "机构", "组织机构", "健康", "招聘", "рус", "大拿", "みんな", "グーグル", "世界", "書籍", "网址", "닷넷", "コム", "天主教", "游戏", "vermögensberater", "vermögensberatung", "企业", "信息", "嘉里大酒店", "嘉里", "广东", "政务", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "yodobashi", "yoga", "yokohama", "you", "youtube", "yun", "zappos", "zara", "zero", "zip", "zone", "zuerich", "co.krd", "edu.krd", "art.pl", "gliwice.pl", "krakow.pl", "poznan.pl", "wroc.pl", "zakopane.pl", "lib.de.us", "12chars.dev", "12chars.it", "12chars.pro", "cc.ua", "inf.ua", "ltd.ua", "611.to", "a2hosted.com", "cpserver.com", "aaa.vodka", "*.on-acorn.io", "activetrail.biz", "adaptable.app", "adobeaemcloud.com", "*.dev.adobeaemcloud.com", "aem.live", "hlx.live", "adobeaemcloud.net", "aem.page", "hlx.page", "hlx3.page", "adobeio-static.net", "adobeioruntime.net", "africa.com", "beep.pl", "airkitapps.com", "airkitapps-au.com", "airkitapps.eu", "aivencloud.com", "akadns.net", "akamai.net", "akamai-staging.net", "akamaiedge.net", "akamaiedge-staging.net", "akamaihd.net", "akamaihd-staging.net", "akamaiorigin.net", "akamaiorigin-staging.net", "akamaized.net", "akamaized-staging.net", "edgekey.net", "edgekey-staging.net", "edgesuite.net", "edgesuite-staging.net", "barsy.ca", "*.compute.estate", "*.alces.network", "kasserver.com", "altervista.org", "alwaysdata.net", "myamaze.net", "execute-api.cn-north-1.amazonaws.com.cn", "execute-api.cn-northwest-1.amazonaws.com.cn", "execute-api.af-south-1.amazonaws.com", "execute-api.ap-east-1.amazonaws.com", "execute-api.ap-northeast-1.amazonaws.com", "execute-api.ap-northeast-2.amazonaws.com", "execute-api.ap-northeast-3.amazonaws.com", "execute-api.ap-south-1.amazonaws.com", "execute-api.ap-south-2.amazonaws.com", "execute-api.ap-southeast-1.amazonaws.com", "execute-api.ap-southeast-2.amazonaws.com", "execute-api.ap-southeast-3.amazonaws.com", "execute-api.ap-southeast-4.amazonaws.com", "execute-api.ap-southeast-5.amazonaws.com", "execute-api.ca-central-1.amazonaws.com", "execute-api.ca-west-1.amazonaws.com", "execute-api.eu-central-1.amazonaws.com", "execute-api.eu-central-2.amazonaws.com", "execute-api.eu-north-1.amazonaws.com", "execute-api.eu-south-1.amazonaws.com", "execute-api.eu-south-2.amazonaws.com", "execute-api.eu-west-1.amazonaws.com", "execute-api.eu-west-2.amazonaws.com", "execute-api.eu-west-3.amazonaws.com", "execute-api.il-central-1.amazonaws.com", "execute-api.me-central-1.amazonaws.com", "execute-api.me-south-1.amazonaws.com", "execute-api.sa-east-1.amazonaws.com", "execute-api.us-east-1.amazonaws.com", "execute-api.us-east-2.amazonaws.com", "execute-api.us-gov-east-1.amazonaws.com", "execute-api.us-gov-west-1.amazonaws.com", "execute-api.us-west-1.amazonaws.com", "execute-api.us-west-2.amazonaws.com", "cloudfront.net", "auth.af-south-1.amazoncognito.com", "auth.ap-east-1.amazoncognito.com", "auth.ap-northeast-1.amazoncognito.com", "auth.ap-northeast-2.amazoncognito.com", "auth.ap-northeast-3.amazoncognito.com", "auth.ap-south-1.amazoncognito.com", "auth.ap-south-2.amazoncognito.com", "auth.ap-southeast-1.amazoncognito.com", "auth.ap-southeast-2.amazoncognito.com", "auth.ap-southeast-3.amazoncognito.com", "auth.ap-southeast-4.amazoncognito.com", "auth.ca-central-1.amazoncognito.com", "auth.ca-west-1.amazoncognito.com", "auth.eu-central-1.amazoncognito.com", "auth.eu-central-2.amazoncognito.com", "auth.eu-north-1.amazoncognito.com", "auth.eu-south-1.amazoncognito.com", "auth.eu-south-2.amazoncognito.com", "auth.eu-west-1.amazoncognito.com", "auth.eu-west-2.amazoncognito.com", "auth.eu-west-3.amazoncognito.com", "auth.il-central-1.amazoncognito.com", "auth.me-central-1.amazoncognito.com", "auth.me-south-1.amazoncognito.com", "auth.sa-east-1.amazoncognito.com", "auth.us-east-1.amazoncognito.com", "auth-fips.us-east-1.amazoncognito.com", "auth.us-east-2.amazoncognito.com", "auth-fips.us-east-2.amazoncognito.com", "auth-fips.us-gov-west-1.amazoncognito.com", "auth.us-west-1.amazoncognito.com", "auth-fips.us-west-1.amazoncognito.com", "auth.us-west-2.amazoncognito.com", "auth-fips.us-west-2.amazoncognito.com", "*.compute.amazonaws.com.cn", "*.compute.amazonaws.com", "*.compute-1.amazonaws.com", "us-east-1.amazonaws.com", "emrappui-prod.cn-north-1.amazonaws.com.cn", "emrnotebooks-prod.cn-north-1.amazonaws.com.cn", "emrstudio-prod.cn-north-1.amazonaws.com.cn", "emrappui-prod.cn-northwest-1.amazonaws.com.cn", "emrnotebooks-prod.cn-northwest-1.amazonaws.com.cn", "emrstudio-prod.cn-northwest-1.amazonaws.com.cn", "emrappui-prod.af-south-1.amazonaws.com", "emrnotebooks-prod.af-south-1.amazonaws.com", "emrstudio-prod.af-south-1.amazonaws.com", "emrappui-prod.ap-east-1.amazonaws.com", "emrnotebooks-prod.ap-east-1.amazonaws.com", "emrstudio-prod.ap-east-1.amazonaws.com", "emrappui-prod.ap-northeast-1.amazonaws.com", "emrnotebooks-prod.ap-northeast-1.amazonaws.com", "emrstudio-prod.ap-northeast-1.amazonaws.com", "emrappui-prod.ap-northeast-2.amazonaws.com", "emrnotebooks-prod.ap-northeast-2.amazonaws.com", "emrstudio-prod.ap-northeast-2.amazonaws.com", "emrappui-prod.ap-northeast-3.amazonaws.com", "emrnotebooks-prod.ap-northeast-3.amazonaws.com", "emrstudio-prod.ap-northeast-3.amazonaws.com", "emrappui-prod.ap-south-1.amazonaws.com", "emrnotebooks-prod.ap-south-1.amazonaws.com", "emrstudio-prod.ap-south-1.amazonaws.com", "emrappui-prod.ap-south-2.amazonaws.com", "emrnotebooks-prod.ap-south-2.amazonaws.com", "emrstudio-prod.ap-south-2.amazonaws.com", "emrappui-prod.ap-southeast-1.amazonaws.com", "emrnotebooks-prod.ap-southeast-1.amazonaws.com", "emrstudio-prod.ap-southeast-1.amazonaws.com", "emrappui-prod.ap-southeast-2.amazonaws.com", "emrnotebooks-prod.ap-southeast-2.amazonaws.com", "emrstudio-prod.ap-southeast-2.amazonaws.com", "emrappui-prod.ap-southeast-3.amazonaws.com", "emrnotebooks-prod.ap-southeast-3.amazonaws.com", "emrstudio-prod.ap-southeast-3.amazonaws.com", "emrappui-prod.ap-southeast-4.amazonaws.com", "emrnotebooks-prod.ap-southeast-4.amazonaws.com", "emrstudio-prod.ap-southeast-4.amazonaws.com", "emrappui-prod.ca-central-1.amazonaws.com", "emrnotebooks-prod.ca-central-1.amazonaws.com", "emrstudio-prod.ca-central-1.amazonaws.com", "emrappui-prod.ca-west-1.amazonaws.com", "emrnotebooks-prod.ca-west-1.amazonaws.com", "emrstudio-prod.ca-west-1.amazonaws.com", "emrappui-prod.eu-central-1.amazonaws.com", "emrnotebooks-prod.eu-central-1.amazonaws.com", "emrstudio-prod.eu-central-1.amazonaws.com", "emrappui-prod.eu-central-2.amazonaws.com", "emrnotebooks-prod.eu-central-2.amazonaws.com", "emrstudio-prod.eu-central-2.amazonaws.com", "emrappui-prod.eu-north-1.amazonaws.com", "emrnotebooks-prod.eu-north-1.amazonaws.com", "emrstudio-prod.eu-north-1.amazonaws.com", "emrappui-prod.eu-south-1.amazonaws.com", "emrnotebooks-prod.eu-south-1.amazonaws.com", "emrstudio-prod.eu-south-1.amazonaws.com", "emrappui-prod.eu-south-2.amazonaws.com", "emrnotebooks-prod.eu-south-2.amazonaws.com", "emrstudio-prod.eu-south-2.amazonaws.com", "emrappui-prod.eu-west-1.amazonaws.com", "emrnotebooks-prod.eu-west-1.amazonaws.com", "emrstudio-prod.eu-west-1.amazonaws.com", "emrappui-prod.eu-west-2.amazonaws.com", "emrnotebooks-prod.eu-west-2.amazonaws.com", "emrstudio-prod.eu-west-2.amazonaws.com", "emrappui-prod.eu-west-3.amazonaws.com", "emrnotebooks-prod.eu-west-3.amazonaws.com", "emrstudio-prod.eu-west-3.amazonaws.com", "emrappui-prod.il-central-1.amazonaws.com", "emrnotebooks-prod.il-central-1.amazonaws.com", "emrstudio-prod.il-central-1.amazonaws.com", "emrappui-prod.me-central-1.amazonaws.com", "emrnotebooks-prod.me-central-1.amazonaws.com", "emrstudio-prod.me-central-1.amazonaws.com", "emrappui-prod.me-south-1.amazonaws.com", "emrnotebooks-prod.me-south-1.amazonaws.com", "emrstudio-prod.me-south-1.amazonaws.com", "emrappui-prod.sa-east-1.amazonaws.com", "emrnotebooks-prod.sa-east-1.amazonaws.com", "emrstudio-prod.sa-east-1.amazonaws.com", "emrappui-prod.us-east-1.amazonaws.com", "emrnotebooks-prod.us-east-1.amazonaws.com", "emrstudio-prod.us-east-1.amazonaws.com", "emrappui-prod.us-east-2.amazonaws.com", "emrnotebooks-prod.us-east-2.amazonaws.com", "emrstudio-prod.us-east-2.amazonaws.com", "emrappui-prod.us-gov-east-1.amazonaws.com", "emrnotebooks-prod.us-gov-east-1.amazonaws.com", "emrstudio-prod.us-gov-east-1.amazonaws.com", "emrappui-prod.us-gov-west-1.amazonaws.com", "emrnotebooks-prod.us-gov-west-1.amazonaws.com", "emrstudio-prod.us-gov-west-1.amazonaws.com", "emrappui-prod.us-west-1.amazonaws.com", "emrnotebooks-prod.us-west-1.amazonaws.com", "emrstudio-prod.us-west-1.amazonaws.com", "emrappui-prod.us-west-2.amazonaws.com", "emrnotebooks-prod.us-west-2.amazonaws.com", "emrstudio-prod.us-west-2.amazonaws.com", "*.cn-north-1.airflow.amazonaws.com.cn", "*.cn-northwest-1.airflow.amazonaws.com.cn", "*.af-south-1.airflow.amazonaws.com", "*.ap-east-1.airflow.amazonaws.com", "*.ap-northeast-1.airflow.amazonaws.com", "*.ap-northeast-2.airflow.amazonaws.com", "*.ap-northeast-3.airflow.amazonaws.com", "*.ap-south-1.airflow.amazonaws.com", "*.ap-south-2.airflow.amazonaws.com", "*.ap-southeast-1.airflow.amazonaws.com", "*.ap-southeast-2.airflow.amazonaws.com", "*.ap-southeast-3.airflow.amazonaws.com", "*.ap-southeast-4.airflow.amazonaws.com", "*.ca-central-1.airflow.amazonaws.com", "*.ca-west-1.airflow.amazonaws.com", "*.eu-central-1.airflow.amazonaws.com", "*.eu-central-2.airflow.amazonaws.com", "*.eu-north-1.airflow.amazonaws.com", "*.eu-south-1.airflow.amazonaws.com", "*.eu-south-2.airflow.amazonaws.com", "*.eu-west-1.airflow.amazonaws.com", "*.eu-west-2.airflow.amazonaws.com", "*.eu-west-3.airflow.amazonaws.com", "*.il-central-1.airflow.amazonaws.com", "*.me-central-1.airflow.amazonaws.com", "*.me-south-1.airflow.amazonaws.com", "*.sa-east-1.airflow.amazonaws.com", "*.us-east-1.airflow.amazonaws.com", "*.us-east-2.airflow.amazonaws.com", "*.us-west-1.airflow.amazonaws.com", "*.us-west-2.airflow.amazonaws.com", "s3.dualstack.cn-north-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-north-1.amazonaws.com.cn", "s3-website.dualstack.cn-north-1.amazonaws.com.cn", "s3.cn-north-1.amazonaws.com.cn", "s3-accesspoint.cn-north-1.amazonaws.com.cn", "s3-deprecated.cn-north-1.amazonaws.com.cn", "s3-object-lambda.cn-north-1.amazonaws.com.cn", "s3-website.cn-north-1.amazonaws.com.cn", "s3.dualstack.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-northwest-1.amazonaws.com.cn", "s3.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.cn-northwest-1.amazonaws.com.cn", "s3-object-lambda.cn-northwest-1.amazonaws.com.cn", "s3-website.cn-northwest-1.amazonaws.com.cn", "s3.dualstack.af-south-1.amazonaws.com", "s3-accesspoint.dualstack.af-south-1.amazonaws.com", "s3-website.dualstack.af-south-1.amazonaws.com", "s3.af-south-1.amazonaws.com", "s3-accesspoint.af-south-1.amazonaws.com", "s3-object-lambda.af-south-1.amazonaws.com", "s3-website.af-south-1.amazonaws.com", "s3.dualstack.ap-east-1.amazonaws.com", "s3-accesspoint.dualstack.ap-east-1.amazonaws.com", "s3.ap-east-1.amazonaws.com", "s3-accesspoint.ap-east-1.amazonaws.com", "s3-object-lambda.ap-east-1.amazonaws.com", "s3-website.ap-east-1.amazonaws.com", "s3.dualstack.ap-northeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-1.amazonaws.com", "s3-website.dualstack.ap-northeast-1.amazonaws.com", "s3.ap-northeast-1.amazonaws.com", "s3-accesspoint.ap-northeast-1.amazonaws.com", "s3-object-lambda.ap-northeast-1.amazonaws.com", "s3-website.ap-northeast-1.amazonaws.com", "s3.dualstack.ap-northeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-2.amazonaws.com", "s3-website.dualstack.ap-northeast-2.amazonaws.com", "s3.ap-northeast-2.amazonaws.com", "s3-accesspoint.ap-northeast-2.amazonaws.com", "s3-object-lambda.ap-northeast-2.amazonaws.com", "s3-website.ap-northeast-2.amazonaws.com", "s3.dualstack.ap-northeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-3.amazonaws.com", "s3-website.dualstack.ap-northeast-3.amazonaws.com", "s3.ap-northeast-3.amazonaws.com", "s3-accesspoint.ap-northeast-3.amazonaws.com", "s3-object-lambda.ap-northeast-3.amazonaws.com", "s3-website.ap-northeast-3.amazonaws.com", "s3.dualstack.ap-south-1.amazonaws.com", "s3-accesspoint.dualstack.ap-south-1.amazonaws.com", "s3-website.dualstack.ap-south-1.amazonaws.com", "s3.ap-south-1.amazonaws.com", "s3-accesspoint.ap-south-1.amazonaws.com", "s3-object-lambda.ap-south-1.amazonaws.com", "s3-website.ap-south-1.amazonaws.com", "s3.dualstack.ap-south-2.amazonaws.com", "s3-accesspoint.dualstack.ap-south-2.amazonaws.com", "s3-website.dualstack.ap-south-2.amazonaws.com", "s3.ap-south-2.amazonaws.com", "s3-accesspoint.ap-south-2.amazonaws.com", "s3-object-lambda.ap-south-2.amazonaws.com", "s3-website.ap-south-2.amazonaws.com", "s3.dualstack.ap-southeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-1.amazonaws.com", "s3-website.dualstack.ap-southeast-1.amazonaws.com", "s3.ap-southeast-1.amazonaws.com", "s3-accesspoint.ap-southeast-1.amazonaws.com", "s3-object-lambda.ap-southeast-1.amazonaws.com", "s3-website.ap-southeast-1.amazonaws.com", "s3.dualstack.ap-southeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-2.amazonaws.com", "s3-website.dualstack.ap-southeast-2.amazonaws.com", "s3.ap-southeast-2.amazonaws.com", "s3-accesspoint.ap-southeast-2.amazonaws.com", "s3-object-lambda.ap-southeast-2.amazonaws.com", "s3-website.ap-southeast-2.amazonaws.com", "s3.dualstack.ap-southeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-3.amazonaws.com", "s3-website.dualstack.ap-southeast-3.amazonaws.com", "s3.ap-southeast-3.amazonaws.com", "s3-accesspoint.ap-southeast-3.amazonaws.com", "s3-object-lambda.ap-southeast-3.amazonaws.com", "s3-website.ap-southeast-3.amazonaws.com", "s3.dualstack.ap-southeast-4.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-4.amazonaws.com", "s3-website.dualstack.ap-southeast-4.amazonaws.com", "s3.ap-southeast-4.amazonaws.com", "s3-accesspoint.ap-southeast-4.amazonaws.com", "s3-object-lambda.ap-southeast-4.amazonaws.com", "s3-website.ap-southeast-4.amazonaws.com", "s3.dualstack.ap-southeast-5.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-5.amazonaws.com", "s3-website.dualstack.ap-southeast-5.amazonaws.com", "s3.ap-southeast-5.amazonaws.com", "s3-accesspoint.ap-southeast-5.amazonaws.com", "s3-deprecated.ap-southeast-5.amazonaws.com", "s3-object-lambda.ap-southeast-5.amazonaws.com", "s3-website.ap-southeast-5.amazonaws.com", "s3.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-central-1.amazonaws.com", "s3-fips.dualstack.ca-central-1.amazonaws.com", "s3-website.dualstack.ca-central-1.amazonaws.com", "s3.ca-central-1.amazonaws.com", "s3-accesspoint.ca-central-1.amazonaws.com", "s3-accesspoint-fips.ca-central-1.amazonaws.com", "s3-fips.ca-central-1.amazonaws.com", "s3-object-lambda.ca-central-1.amazonaws.com", "s3-website.ca-central-1.amazonaws.com", "s3.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com", "s3-fips.dualstack.ca-west-1.amazonaws.com", "s3-website.dualstack.ca-west-1.amazonaws.com", "s3.ca-west-1.amazonaws.com", "s3-accesspoint.ca-west-1.amazonaws.com", "s3-accesspoint-fips.ca-west-1.amazonaws.com", "s3-fips.ca-west-1.amazonaws.com", "s3-object-lambda.ca-west-1.amazonaws.com", "s3-website.ca-west-1.amazonaws.com", "s3.dualstack.eu-central-1.amazonaws.com", "s3-accesspoint.dualstack.eu-central-1.amazonaws.com", "s3-website.dualstack.eu-central-1.amazonaws.com", "s3.eu-central-1.amazonaws.com", "s3-accesspoint.eu-central-1.amazonaws.com", "s3-object-lambda.eu-central-1.amazonaws.com", "s3-website.eu-central-1.amazonaws.com", "s3.dualstack.eu-central-2.amazonaws.com", "s3-accesspoint.dualstack.eu-central-2.amazonaws.com", "s3-website.dualstack.eu-central-2.amazonaws.com", "s3.eu-central-2.amazonaws.com", "s3-accesspoint.eu-central-2.amazonaws.com", "s3-object-lambda.eu-central-2.amazonaws.com", "s3-website.eu-central-2.amazonaws.com", "s3.dualstack.eu-north-1.amazonaws.com", "s3-accesspoint.dualstack.eu-north-1.amazonaws.com", "s3.eu-north-1.amazonaws.com", "s3-accesspoint.eu-north-1.amazonaws.com", "s3-object-lambda.eu-north-1.amazonaws.com", "s3-website.eu-north-1.amazonaws.com", "s3.dualstack.eu-south-1.amazonaws.com", "s3-accesspoint.dualstack.eu-south-1.amazonaws.com", "s3-website.dualstack.eu-south-1.amazonaws.com", "s3.eu-south-1.amazonaws.com", "s3-accesspoint.eu-south-1.amazonaws.com", "s3-object-lambda.eu-south-1.amazonaws.com", "s3-website.eu-south-1.amazonaws.com", "s3.dualstack.eu-south-2.amazonaws.com", "s3-accesspoint.dualstack.eu-south-2.amazonaws.com", "s3-website.dualstack.eu-south-2.amazonaws.com", "s3.eu-south-2.amazonaws.com", "s3-accesspoint.eu-south-2.amazonaws.com", "s3-object-lambda.eu-south-2.amazonaws.com", "s3-website.eu-south-2.amazonaws.com", "s3.dualstack.eu-west-1.amazonaws.com", "s3-accesspoint.dualstack.eu-west-1.amazonaws.com", "s3-website.dualstack.eu-west-1.amazonaws.com", "s3.eu-west-1.amazonaws.com", "s3-accesspoint.eu-west-1.amazonaws.com", "s3-deprecated.eu-west-1.amazonaws.com", "s3-object-lambda.eu-west-1.amazonaws.com", "s3-website.eu-west-1.amazonaws.com", "s3.dualstack.eu-west-2.amazonaws.com", "s3-accesspoint.dualstack.eu-west-2.amazonaws.com", "s3.eu-west-2.amazonaws.com", "s3-accesspoint.eu-west-2.amazonaws.com", "s3-object-lambda.eu-west-2.amazonaws.com", "s3-website.eu-west-2.amazonaws.com", "s3.dualstack.eu-west-3.amazonaws.com", "s3-accesspoint.dualstack.eu-west-3.amazonaws.com", "s3-website.dualstack.eu-west-3.amazonaws.com", "s3.eu-west-3.amazonaws.com", "s3-accesspoint.eu-west-3.amazonaws.com", "s3-object-lambda.eu-west-3.amazonaws.com", "s3-website.eu-west-3.amazonaws.com", "s3.dualstack.il-central-1.amazonaws.com", "s3-accesspoint.dualstack.il-central-1.amazonaws.com", "s3-website.dualstack.il-central-1.amazonaws.com", "s3.il-central-1.amazonaws.com", "s3-accesspoint.il-central-1.amazonaws.com", "s3-object-lambda.il-central-1.amazonaws.com", "s3-website.il-central-1.amazonaws.com", "s3.dualstack.me-central-1.amazonaws.com", "s3-accesspoint.dualstack.me-central-1.amazonaws.com", "s3-website.dualstack.me-central-1.amazonaws.com", "s3.me-central-1.amazonaws.com", "s3-accesspoint.me-central-1.amazonaws.com", "s3-object-lambda.me-central-1.amazonaws.com", "s3-website.me-central-1.amazonaws.com", "s3.dualstack.me-south-1.amazonaws.com", "s3-accesspoint.dualstack.me-south-1.amazonaws.com", "s3.me-south-1.amazonaws.com", "s3-accesspoint.me-south-1.amazonaws.com", "s3-object-lambda.me-south-1.amazonaws.com", "s3-website.me-south-1.amazonaws.com", "s3.amazonaws.com", "s3-1.amazonaws.com", "s3-ap-east-1.amazonaws.com", "s3-ap-northeast-1.amazonaws.com", "s3-ap-northeast-2.amazonaws.com", "s3-ap-northeast-3.amazonaws.com", "s3-ap-south-1.amazonaws.com", "s3-ap-southeast-1.amazonaws.com", "s3-ap-southeast-2.amazonaws.com", "s3-ca-central-1.amazonaws.com", "s3-eu-central-1.amazonaws.com", "s3-eu-north-1.amazonaws.com", "s3-eu-west-1.amazonaws.com", "s3-eu-west-2.amazonaws.com", "s3-eu-west-3.amazonaws.com", "s3-external-1.amazonaws.com", "s3-fips-us-gov-east-1.amazonaws.com", "s3-fips-us-gov-west-1.amazonaws.com", "mrap.accesspoint.s3-global.amazonaws.com", "s3-me-south-1.amazonaws.com", "s3-sa-east-1.amazonaws.com", "s3-us-east-2.amazonaws.com", "s3-us-gov-east-1.amazonaws.com", "s3-us-gov-west-1.amazonaws.com", "s3-us-west-1.amazonaws.com", "s3-us-west-2.amazonaws.com", "s3-website-ap-northeast-1.amazonaws.com", "s3-website-ap-southeast-1.amazonaws.com", "s3-website-ap-southeast-2.amazonaws.com", "s3-website-eu-west-1.amazonaws.com", "s3-website-sa-east-1.amazonaws.com", "s3-website-us-east-1.amazonaws.com", "s3-website-us-gov-west-1.amazonaws.com", "s3-website-us-west-1.amazonaws.com", "s3-website-us-west-2.amazonaws.com", "s3.dualstack.sa-east-1.amazonaws.com", "s3-accesspoint.dualstack.sa-east-1.amazonaws.com", "s3-website.dualstack.sa-east-1.amazonaws.com", "s3.sa-east-1.amazonaws.com", "s3-accesspoint.sa-east-1.amazonaws.com", "s3-object-lambda.sa-east-1.amazonaws.com", "s3-website.sa-east-1.amazonaws.com", "s3.dualstack.us-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-1.amazonaws.com", "s3-fips.dualstack.us-east-1.amazonaws.com", "s3-website.dualstack.us-east-1.amazonaws.com", "s3.us-east-1.amazonaws.com", "s3-accesspoint.us-east-1.amazonaws.com", "s3-accesspoint-fips.us-east-1.amazonaws.com", "s3-deprecated.us-east-1.amazonaws.com", "s3-fips.us-east-1.amazonaws.com", "s3-object-lambda.us-east-1.amazonaws.com", "s3-website.us-east-1.amazonaws.com", "s3.dualstack.us-east-2.amazonaws.com", "s3-accesspoint.dualstack.us-east-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-2.amazonaws.com", "s3-fips.dualstack.us-east-2.amazonaws.com", "s3-website.dualstack.us-east-2.amazonaws.com", "s3.us-east-2.amazonaws.com", "s3-accesspoint.us-east-2.amazonaws.com", "s3-accesspoint-fips.us-east-2.amazonaws.com", "s3-deprecated.us-east-2.amazonaws.com", "s3-fips.us-east-2.amazonaws.com", "s3-object-lambda.us-east-2.amazonaws.com", "s3-website.us-east-2.amazonaws.com", "s3.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-east-1.amazonaws.com", "s3-fips.dualstack.us-gov-east-1.amazonaws.com", "s3.us-gov-east-1.amazonaws.com", "s3-accesspoint.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.us-gov-east-1.amazonaws.com", "s3-fips.us-gov-east-1.amazonaws.com", "s3-object-lambda.us-gov-east-1.amazonaws.com", "s3-website.us-gov-east-1.amazonaws.com", "s3.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-west-1.amazonaws.com", "s3-fips.dualstack.us-gov-west-1.amazonaws.com", "s3.us-gov-west-1.amazonaws.com", "s3-accesspoint.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.us-gov-west-1.amazonaws.com", "s3-fips.us-gov-west-1.amazonaws.com", "s3-object-lambda.us-gov-west-1.amazonaws.com", "s3-website.us-gov-west-1.amazonaws.com", "s3.dualstack.us-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-1.amazonaws.com", "s3-fips.dualstack.us-west-1.amazonaws.com", "s3-website.dualstack.us-west-1.amazonaws.com", "s3.us-west-1.amazonaws.com", "s3-accesspoint.us-west-1.amazonaws.com", "s3-accesspoint-fips.us-west-1.amazonaws.com", "s3-fips.us-west-1.amazonaws.com", "s3-object-lambda.us-west-1.amazonaws.com", "s3-website.us-west-1.amazonaws.com", "s3.dualstack.us-west-2.amazonaws.com", "s3-accesspoint.dualstack.us-west-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-2.amazonaws.com", "s3-fips.dualstack.us-west-2.amazonaws.com", "s3-website.dualstack.us-west-2.amazonaws.com", "s3.us-west-2.amazonaws.com", "s3-accesspoint.us-west-2.amazonaws.com", "s3-accesspoint-fips.us-west-2.amazonaws.com", "s3-deprecated.us-west-2.amazonaws.com", "s3-fips.us-west-2.amazonaws.com", "s3-object-lambda.us-west-2.amazonaws.com", "s3-website.us-west-2.amazonaws.com", "labeling.ap-northeast-1.sagemaker.aws", "labeling.ap-northeast-2.sagemaker.aws", "labeling.ap-south-1.sagemaker.aws", "labeling.ap-southeast-1.sagemaker.aws", "labeling.ap-southeast-2.sagemaker.aws", "labeling.ca-central-1.sagemaker.aws", "labeling.eu-central-1.sagemaker.aws", "labeling.eu-west-1.sagemaker.aws", "labeling.eu-west-2.sagemaker.aws", "labeling.us-east-1.sagemaker.aws", "labeling.us-east-2.sagemaker.aws", "labeling.us-west-2.sagemaker.aws", "notebook.af-south-1.sagemaker.aws", "notebook.ap-east-1.sagemaker.aws", "notebook.ap-northeast-1.sagemaker.aws", "notebook.ap-northeast-2.sagemaker.aws", "notebook.ap-northeast-3.sagemaker.aws", "notebook.ap-south-1.sagemaker.aws", "notebook.ap-south-2.sagemaker.aws", "notebook.ap-southeast-1.sagemaker.aws", "notebook.ap-southeast-2.sagemaker.aws", "notebook.ap-southeast-3.sagemaker.aws", "notebook.ap-southeast-4.sagemaker.aws", "notebook.ca-central-1.sagemaker.aws", "notebook-fips.ca-central-1.sagemaker.aws", "notebook.ca-west-1.sagemaker.aws", "notebook-fips.ca-west-1.sagemaker.aws", "notebook.eu-central-1.sagemaker.aws", "notebook.eu-central-2.sagemaker.aws", "notebook.eu-north-1.sagemaker.aws", "notebook.eu-south-1.sagemaker.aws", "notebook.eu-south-2.sagemaker.aws", "notebook.eu-west-1.sagemaker.aws", "notebook.eu-west-2.sagemaker.aws", "notebook.eu-west-3.sagemaker.aws", "notebook.il-central-1.sagemaker.aws", "notebook.me-central-1.sagemaker.aws", "notebook.me-south-1.sagemaker.aws", "notebook.sa-east-1.sagemaker.aws", "notebook.us-east-1.sagemaker.aws", "notebook-fips.us-east-1.sagemaker.aws", "notebook.us-east-2.sagemaker.aws", "notebook-fips.us-east-2.sagemaker.aws", "notebook.us-gov-east-1.sagemaker.aws", "notebook-fips.us-gov-east-1.sagemaker.aws", "notebook.us-gov-west-1.sagemaker.aws", "notebook-fips.us-gov-west-1.sagemaker.aws", "notebook.us-west-1.sagemaker.aws", "notebook-fips.us-west-1.sagemaker.aws", "notebook.us-west-2.sagemaker.aws", "notebook-fips.us-west-2.sagemaker.aws", "notebook.cn-north-1.sagemaker.com.cn", "notebook.cn-northwest-1.sagemaker.com.cn", "studio.af-south-1.sagemaker.aws", "studio.ap-east-1.sagemaker.aws", "studio.ap-northeast-1.sagemaker.aws", "studio.ap-northeast-2.sagemaker.aws", "studio.ap-northeast-3.sagemaker.aws", "studio.ap-south-1.sagemaker.aws", "studio.ap-southeast-1.sagemaker.aws", "studio.ap-southeast-2.sagemaker.aws", "studio.ap-southeast-3.sagemaker.aws", "studio.ca-central-1.sagemaker.aws", "studio.eu-central-1.sagemaker.aws", "studio.eu-north-1.sagemaker.aws", "studio.eu-south-1.sagemaker.aws", "studio.eu-south-2.sagemaker.aws", "studio.eu-west-1.sagemaker.aws", "studio.eu-west-2.sagemaker.aws", "studio.eu-west-3.sagemaker.aws", "studio.il-central-1.sagemaker.aws", "studio.me-central-1.sagemaker.aws", "studio.me-south-1.sagemaker.aws", "studio.sa-east-1.sagemaker.aws", "studio.us-east-1.sagemaker.aws", "studio.us-east-2.sagemaker.aws", "studio.us-gov-east-1.sagemaker.aws", "studio-fips.us-gov-east-1.sagemaker.aws", "studio.us-gov-west-1.sagemaker.aws", "studio-fips.us-gov-west-1.sagemaker.aws", "studio.us-west-1.sagemaker.aws", "studio.us-west-2.sagemaker.aws", "studio.cn-north-1.sagemaker.com.cn", "studio.cn-northwest-1.sagemaker.com.cn", "*.experiments.sagemaker.aws", "analytics-gateway.ap-northeast-1.amazonaws.com", "analytics-gateway.ap-northeast-2.amazonaws.com", "analytics-gateway.ap-south-1.amazonaws.com", "analytics-gateway.ap-southeast-1.amazonaws.com", "analytics-gateway.ap-southeast-2.amazonaws.com", "analytics-gateway.eu-central-1.amazonaws.com", "analytics-gateway.eu-west-1.amazonaws.com", "analytics-gateway.us-east-1.amazonaws.com", "analytics-gateway.us-east-2.amazonaws.com", "analytics-gateway.us-west-2.amazonaws.com", "amplifyapp.com", "*.awsapprunner.com", "webview-assets.aws-cloud9.af-south-1.amazonaws.com", "vfs.cloud9.af-south-1.amazonaws.com", "webview-assets.cloud9.af-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-east-1.amazonaws.com", "vfs.cloud9.ap-east-1.amazonaws.com", "webview-assets.cloud9.ap-east-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-1.amazonaws.com", "vfs.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-2.amazonaws.com", "vfs.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-3.amazonaws.com", "vfs.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.aws-cloud9.ap-south-1.amazonaws.com", "vfs.cloud9.ap-south-1.amazonaws.com", "webview-assets.cloud9.ap-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-1.amazonaws.com", "vfs.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-2.amazonaws.com", "vfs.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.aws-cloud9.ca-central-1.amazonaws.com", "vfs.cloud9.ca-central-1.amazonaws.com", "webview-assets.cloud9.ca-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-central-1.amazonaws.com", "vfs.cloud9.eu-central-1.amazonaws.com", "webview-assets.cloud9.eu-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-north-1.amazonaws.com", "vfs.cloud9.eu-north-1.amazonaws.com", "webview-assets.cloud9.eu-north-1.amazonaws.com", "webview-assets.aws-cloud9.eu-south-1.amazonaws.com", "vfs.cloud9.eu-south-1.amazonaws.com", "webview-assets.cloud9.eu-south-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-1.amazonaws.com", "vfs.cloud9.eu-west-1.amazonaws.com", "webview-assets.cloud9.eu-west-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-2.amazonaws.com", "vfs.cloud9.eu-west-2.amazonaws.com", "webview-assets.cloud9.eu-west-2.amazonaws.com", "webview-assets.aws-cloud9.eu-west-3.amazonaws.com", "vfs.cloud9.eu-west-3.amazonaws.com", "webview-assets.cloud9.eu-west-3.amazonaws.com", "webview-assets.aws-cloud9.il-central-1.amazonaws.com", "vfs.cloud9.il-central-1.amazonaws.com", "webview-assets.aws-cloud9.me-south-1.amazonaws.com", "vfs.cloud9.me-south-1.amazonaws.com", "webview-assets.cloud9.me-south-1.amazonaws.com", "webview-assets.aws-cloud9.sa-east-1.amazonaws.com", "vfs.cloud9.sa-east-1.amazonaws.com", "webview-assets.cloud9.sa-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-1.amazonaws.com", "vfs.cloud9.us-east-1.amazonaws.com", "webview-assets.cloud9.us-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-2.amazonaws.com", "vfs.cloud9.us-east-2.amazonaws.com", "webview-assets.cloud9.us-east-2.amazonaws.com", "webview-assets.aws-cloud9.us-west-1.amazonaws.com", "vfs.cloud9.us-west-1.amazonaws.com", "webview-assets.cloud9.us-west-1.amazonaws.com", "webview-assets.aws-cloud9.us-west-2.amazonaws.com", "vfs.cloud9.us-west-2.amazonaws.com", "webview-assets.cloud9.us-west-2.amazonaws.com", "awsapps.com", "cn-north-1.eb.amazonaws.com.cn", "cn-northwest-1.eb.amazonaws.com.cn", "elasticbeanstalk.com", "af-south-1.elasticbeanstalk.com", "ap-east-1.elasticbeanstalk.com", "ap-northeast-1.elasticbeanstalk.com", "ap-northeast-2.elasticbeanstalk.com", "ap-northeast-3.elasticbeanstalk.com", "ap-south-1.elasticbeanstalk.com", "ap-southeast-1.elasticbeanstalk.com", "ap-southeast-2.elasticbeanstalk.com", "ap-southeast-3.elasticbeanstalk.com", "ca-central-1.elasticbeanstalk.com", "eu-central-1.elasticbeanstalk.com", "eu-north-1.elasticbeanstalk.com", "eu-south-1.elasticbeanstalk.com", "eu-west-1.elasticbeanstalk.com", "eu-west-2.elasticbeanstalk.com", "eu-west-3.elasticbeanstalk.com", "il-central-1.elasticbeanstalk.com", "me-south-1.elasticbeanstalk.com", "sa-east-1.elasticbeanstalk.com", "us-east-1.elasticbeanstalk.com", "us-east-2.elasticbeanstalk.com", "us-gov-east-1.elasticbeanstalk.com", "us-gov-west-1.elasticbeanstalk.com", "us-west-1.elasticbeanstalk.com", "us-west-2.elasticbeanstalk.com", "*.elb.amazonaws.com.cn", "*.elb.amazonaws.com", "awsglobalaccelerator.com", "*.private.repost.aws", "eero.online", "eero-stage.online", "apigee.io", "panel.dev", "siiites.com", "appspacehosted.com", "appspaceusercontent.com", "appudo.net", "on-aptible.com", "f5.si", "arvanedge.ir", "user.aseinet.ne.jp", "gv.vc", "d.gv.vc", "user.party.eus", "pimienta.org", "poivron.org", "potager.org", "sweetpepper.org", "myasustor.com", "cdn.prod.atlassian-dev.net", "translated.page", "myfritz.link", "myfritz.net", "onavstack.net", "*.awdev.ca", "*.advisor.ws", "ecommerce-shop.pl", "b-data.io", "balena-devices.com", "base.ec", "official.ec", "buyshop.jp", "fashionstore.jp", "handcrafted.jp", "kawaiishop.jp", "supersale.jp", "theshop.jp", "shopselect.net", "base.shop", "beagleboard.io", "*.beget.app", "pages.gay", "bnr.la", "bitbucket.io", "blackbaudcdn.net", "of.je", "bluebite.io", "boomla.net", "boutir.com", "boxfuse.io", "square7.ch", "bplaced.com", "bplaced.de", "square7.de", "bplaced.net", "square7.net", "*.s.brave.io", "shop.brendly.hr", "shop.brendly.rs", "browsersafetymark.io", "radio.am", "radio.fm", "uk0.bigv.io", "dh.bytemark.co.uk", "vm.bytemark.co.uk", "cafjs.com", "canva-apps.cn", "*.my.canvasite.cn", "canva-apps.com", "*.my.canva.site", "drr.ac", "uwu.ai", "carrd.co", "crd.co", "ju.mp", "api.gov.uk", "cdn77-storage.com", "rsc.contentproxy9.cz", "r.cdn77.net", "cdn77-ssl.net", "c.cdn77.org", "rsc.cdn77.org", "ssl.origin.cdn77-secure.org", "za.bz", "br.com", "cn.com", "de.com", "eu.com", "jpn.com", "mex.com", "ru.com", "sa.com", "uk.com", "us.com", "za.com", "com.de", "gb.net", "hu.net", "jp.net", "se.net", "uk.net", "ae.org", "com.se", "cx.ua", "discourse.group", "discourse.team", "clerk.app", "clerkstage.app", "*.lcl.dev", "*.lclstage.dev", "*.stg.dev", "*.stgstage.dev", "cleverapps.cc", "*.services.clever-cloud.com", "cleverapps.io", "cleverapps.tech", "clickrising.net", "cloudns.asia", "cloudns.be", "cloud-ip.biz", "cloudns.biz", "cloudns.cc", "cloudns.ch", "cloudns.cl", "cloudns.club", "dnsabr.com", "ip-ddns.com", "cloudns.cx", "cloudns.eu", "cloudns.in", "cloudns.info", "ddns-ip.net", "dns-cloud.net", "dns-dynamic.net", "cloudns.nz", "cloudns.org", "ip-dynamic.org", "cloudns.ph", "cloudns.pro", "cloudns.pw", "cloudns.us", "c66.me", "cloud66.ws", "cloud66.zone", "jdevcloud.com", "wpdevcloud.com", "cloudaccess.host", "freesite.host", "cloudaccess.net", "*.cloudera.site", "cf-ipfs.com", "cloudflare-ipfs.com", "trycloudflare.com", "pages.dev", "r2.dev", "workers.dev", "cloudflare.net", "cdn.cloudflare.net", "cdn.cloudflareanycast.net", "cdn.cloudflarecn.net", "cdn.cloudflareglobal.net", "cust.cloudscale.ch", "objects.lpg.cloudscale.ch", "objects.rma.cloudscale.ch", "wnext.app", "cnpy.gdn", "*.otap.co", "co.ca", "co.com", "codeberg.page", "csb.app", "preview.csb.app", "co.nl", "co.no", "webhosting.be", "hosting-cluster.nl", "ctfcloud.net", "convex.site", "ac.ru", "edu.ru", "gov.ru", "int.ru", "mil.ru", "test.ru", "dyn.cosidns.de", "dnsupdater.de", "dynamisches-dns.de", "internet-dns.de", "l-o-g-i-n.de", "dynamic-dns.info", "feste-ip.net", "knx-server.net", "static-access.net", "craft.me", "realm.cz", "on.crisp.email", "*.cryptonomic.net", "curv.dev", "cfolks.pl", "cyon.link", "cyon.site", "platform0.app", "fnwk.site", "folionetwork.site", "biz.dk", "co.dk", "firm.dk", "reg.dk", "store.dk", "dyndns.dappnode.io", "builtwithdark.com", "darklang.io", "demo.datadetect.com", "instance.datadetect.com", "edgestack.me", "dattolocal.com", "dattorelay.com", "dattoweb.com", "mydatto.com", "dattolocal.net", "mydatto.net", "ddnss.de", "dyn.ddnss.de", "dyndns.ddnss.de", "dyn-ip24.de", "dyndns1.de", "home-webserver.de", "dyn.home-webserver.de", "myhome-server.de", "ddnss.org", "debian.net", "definima.io", "definima.net", "deno.dev", "deno-staging.dev", "dedyn.io", "deta.app", "deta.dev", "dfirma.pl", "dkonto.pl", "you2.pl", "ondigitalocean.app", "*.digitaloceanspaces.com", "us.kg", "rss.my.id", "diher.solutions", "discordsays.com", "discordsez.com", "jozi.biz", "dnshome.de", "online.th", "shop.th", "drayddns.com", "shoparena.pl", "dreamhosters.com", "durumis.com", "mydrobo.com", "drud.io", "drud.us", "duckdns.org", "dy.fi", "tunk.org", "dyndns.biz", "for-better.biz", "for-more.biz", "for-some.biz", "for-the.biz", "selfip.biz", "webhop.biz", "ftpaccess.cc", "game-server.cc", "myphotos.cc", "scrapping.cc", "blogdns.com", "cechire.com", "dnsalias.com", "dnsdojo.com", "doesntexist.com", "dontexist.com", "doomdns.com", "dyn-o-saur.com", "dynalias.com", "dyndns-at-home.com", "dyndns-at-work.com", "dyndns-blog.com", "dyndns-free.com", "dyndns-home.com", "dyndns-ip.com", "dyndns-mail.com", "dyndns-office.com", "dyndns-pics.com", "dyndns-remote.com", "dyndns-server.com", "dyndns-web.com", "dyndns-wiki.com", "dyndns-work.com", "est-a-la-maison.com", "est-a-la-masion.com", "est-le-patron.com", "est-mon-blogueur.com", "from-ak.com", "from-al.com", "from-ar.com", "from-ca.com", "from-ct.com", "from-dc.com", "from-de.com", "from-fl.com", "from-ga.com", "from-hi.com", "from-ia.com", "from-id.com", "from-il.com", "from-in.com", "from-ks.com", "from-ky.com", "from-ma.com", "from-md.com", "from-mi.com", "from-mn.com", "from-mo.com", "from-ms.com", "from-mt.com", "from-nc.com", "from-nd.com", "from-ne.com", "from-nh.com", "from-nj.com", "from-nm.com", "from-nv.com", "from-oh.com", "from-ok.com", "from-or.com", "from-pa.com", "from-pr.com", "from-ri.com", "from-sc.com", "from-sd.com", "from-tn.com", "from-tx.com", "from-ut.com", "from-va.com", "from-vt.com", "from-wa.com", "from-wi.com", "from-wv.com", "from-wy.com", "getmyip.com", "gotdns.com", "hobby-site.com", "homelinux.com", "homeunix.com", "iamallama.com", "is-a-anarchist.com", "is-a-blogger.com", "is-a-bookkeeper.com", "is-a-bulls-fan.com", "is-a-caterer.com", "is-a-chef.com", "is-a-conservative.com", "is-a-cpa.com", "is-a-cubicle-slave.com", "is-a-democrat.com", "is-a-designer.com", "is-a-doctor.com", "is-a-financialadvisor.com", "is-a-geek.com", "is-a-green.com", "is-a-guru.com", "is-a-hard-worker.com", "is-a-hunter.com", "is-a-landscaper.com", "is-a-lawyer.com", "is-a-liberal.com", "is-a-libertarian.com", "is-a-llama.com", "is-a-musician.com", "is-a-nascarfan.com", "is-a-nurse.com", "is-a-painter.com", "is-a-personaltrainer.com", "is-a-photographer.com", "is-a-player.com", "is-a-republican.com", "is-a-rockstar.com", "is-a-socialist.com", "is-a-student.com", "is-a-teacher.com", "is-a-techie.com", "is-a-therapist.com", "is-an-accountant.com", "is-an-actor.com", "is-an-actress.com", "is-an-anarchist.com", "is-an-artist.com", "is-an-engineer.com", "is-an-entertainer.com", "is-certified.com", "is-gone.com", "is-into-anime.com", "is-into-cars.com", "is-into-cartoons.com", "is-into-games.com", "is-leet.com", "is-not-certified.com", "is-slick.com", "is-uberleet.com", "is-with-theband.com", "isa-geek.com", "isa-hockeynut.com", "issmarterthanyou.com", "likes-pie.com", "likescandy.com", "neat-url.com", "saves-the-whales.com", "selfip.com", "sells-for-less.com", "sells-for-u.com", "servebbs.com", "simple-url.com", "space-to-rent.com", "teaches-yoga.com", "writesthisblog.com", "ath.cx", "fuettertdasnetz.de", "isteingeek.de", "istmein.de", "lebtimnetz.de", "leitungsen.de", "traeumtgerade.de", "barrel-of-knowledge.info", "barrell-of-knowledge.info", "dyndns.info", "for-our.info", "groks-the.info", "groks-this.info", "here-for-more.info", "knowsitall.info", "selfip.info", "webhop.info", "forgot.her.name", "forgot.his.name", "at-band-camp.net", "blogdns.net", "broke-it.net", "buyshouses.net", "dnsalias.net", "dnsdojo.net", "does-it.net", "dontexist.net", "dynalias.net", "dynathome.net", "endofinternet.net", "from-az.net", "from-co.net", "from-la.net", "from-ny.net", "gets-it.net", "ham-radio-op.net", "homeftp.net", "homeip.net", "homelinux.net", "homeunix.net", "in-the-band.net", "is-a-chef.net", "is-a-geek.net", "isa-geek.net", "kicks-ass.net", "office-on-the.net", "podzone.net", "scrapper-site.net", "selfip.net", "sells-it.net", "servebbs.net", "serveftp.net", "thruhere.net", "webhop.net", "merseine.nu", "mine.nu", "shacknet.nu", "blogdns.org", "blogsite.org", "boldlygoingnowhere.org", "dnsalias.org", "dnsdojo.org", "doesntexist.org", "dontexist.org", "doomdns.org", "dvrdns.org", "dynalias.org", "dyndns.org", "go.dyndns.org", "home.dyndns.org", "endofinternet.org", "endoftheinternet.org", "from-me.org", "game-host.org", "gotdns.org", "hobby-site.org", "homedns.org", "homeftp.org", "homelinux.org", "homeunix.org", "is-a-bruinsfan.org", "is-a-candidate.org", "is-a-celticsfan.org", "is-a-chef.org", "is-a-geek.org", "is-a-knight.org", "is-a-linux-user.org", "is-a-patsfan.org", "is-a-soxfan.org", "is-found.org", "is-lost.org", "is-saved.org", "is-very-bad.org", "is-very-evil.org", "is-very-good.org", "is-very-nice.org", "is-very-sweet.org", "isa-geek.org", "kicks-ass.org", "misconfused.org", "podzone.org", "readmyblog.org", "selfip.org", "sellsyourhome.org", "servebbs.org", "serveftp.org", "servegame.org", "stuff-4-sale.org", "webhop.org", "better-than.tv", "dyndns.tv", "on-the-web.tv", "worse-than.tv", "is-by.us", "land-4-sale.us", "stuff-4-sale.us", "dyndns.ws", "mypets.ws", "ddnsfree.com", "ddnsgeek.com", "giize.com", "gleeze.com", "kozow.com", "loseyourip.com", "ooguy.com", "theworkpc.com", "casacam.net", "dynu.net", "accesscam.org", "camdvr.org", "freeddns.org", "mywire.org", "webredirect.org", "myddns.rocks", "dynv6.net", "e4.cz", "easypanel.app", "easypanel.host", "*.ewp.live", "twmail.cc", "twmail.net", "twmail.org", "mymailer.com.tw", "url.tw", "at.emf.camp", "rt.ht", "elementor.cloud", "elementor.cool", "en-root.fr", "mytuleap.com", "tuleap-partners.com", "encr.app", "encoreapi.com", "eu.encoway.cloud", "eu.org", "al.eu.org", "asso.eu.org", "at.eu.org", "au.eu.org", "be.eu.org", "bg.eu.org", "ca.eu.org", "cd.eu.org", "ch.eu.org", "cn.eu.org", "cy.eu.org", "cz.eu.org", "de.eu.org", "dk.eu.org", "edu.eu.org", "ee.eu.org", "es.eu.org", "fi.eu.org", "fr.eu.org", "gr.eu.org", "hr.eu.org", "hu.eu.org", "ie.eu.org", "il.eu.org", "in.eu.org", "int.eu.org", "is.eu.org", "it.eu.org", "jp.eu.org", "kr.eu.org", "lt.eu.org", "lu.eu.org", "lv.eu.org", "me.eu.org", "mk.eu.org", "mt.eu.org", "my.eu.org", "net.eu.org", "ng.eu.org", "nl.eu.org", "no.eu.org", "nz.eu.org", "pl.eu.org", "pt.eu.org", "ro.eu.org", "ru.eu.org", "se.eu.org", "si.eu.org", "sk.eu.org", "tr.eu.org", "uk.eu.org", "us.eu.org", "eurodir.ru", "eu-1.evennode.com", "eu-2.evennode.com", "eu-3.evennode.com", "eu-4.evennode.com", "us-1.evennode.com", "us-2.evennode.com", "us-3.evennode.com", "us-4.evennode.com", "relay.evervault.app", "relay.evervault.dev", "expo.app", "staging.expo.app", "onfabrica.com", "ru.net", "adygeya.ru", "bashkiria.ru", "bir.ru", "cbg.ru", "com.ru", "dagestan.ru", "grozny.ru", "kalmykia.ru", "kustanai.ru", "marine.ru", "mordovia.ru", "msk.ru", "mytis.ru", "nalchik.ru", "nov.ru", "pyatigorsk.ru", "spb.ru", "vladikavkaz.ru", "vladimir.ru", "abkhazia.su", "adygeya.su", "aktyubinsk.su", "arkhangelsk.su", "armenia.su", "ashgabad.su", "azerbaijan.su", "balashov.su", "bashkiria.su", "bryansk.su", "bukhara.su", "chimkent.su", "dagestan.su", "east-kazakhstan.su", "exnet.su", "georgia.su", "grozny.su", "ivanovo.su", "jambyl.su", "kalmykia.su", "kaluga.su", "karacol.su", "karaganda.su", "karelia.su", "khakassia.su", "krasnodar.su", "kurgan.su", "kustanai.su", "lenug.su", "mangyshlak.su", "mordovia.su", "msk.su", "murmansk.su", "nalchik.su", "navoi.su", "north-kazakhstan.su", "nov.su", "obninsk.su", "penza.su", "pokrovsk.su", "sochi.su", "spb.su", "tashkent.su", "termez.su", "togliatti.su", "troitsk.su", "tselinograd.su", "tula.su", "tuva.su", "vladikavkaz.su", "vladimir.su", "vologda.su", "channelsdvr.net", "u.channelsdvr.net", "edgecompute.app", "fastly-edge.com", "fastly-terrarium.com", "freetls.fastly.net", "map.fastly.net", "a.prod.fastly.net", "global.prod.fastly.net", "a.ssl.fastly.net", "b.ssl.fastly.net", "global.ssl.fastly.net", "fastlylb.net", "map.fastlylb.net", "*.user.fm", "fastvps-server.com", "fastvps.host", "myfast.host", "fastvps.site", "myfast.space", "conn.uk", "copro.uk", "hosp.uk", "fedorainfracloud.org", "fedorapeople.org", "cloud.fedoraproject.org", "app.os.fedoraproject.org", "app.os.stg.fedoraproject.org", "mydobiss.com", "fh-muenster.io", "filegear.me", "firebaseapp.com", "fldrv.com", "flutterflow.app", "fly.dev", "shw.io", "edgeapp.net", "forgeblocks.com", "id.forgerock.io", "framer.ai", "framer.app", "framercanvas.com", "framer.media", "framer.photos", "framer.website", "framer.wiki", "0e.vc", "freebox-os.com", "freeboxos.com", "fbx-os.fr", "fbxos.fr", "freebox-os.fr", "freeboxos.fr", "freedesktop.org", "freemyip.com", "*.frusky.de", "wien.funkfeuer.at", "daemon.asia", "dix.asia", "mydns.bz", "0am.jp", "0g0.jp", "0j0.jp", "0t0.jp", "mydns.jp", "pgw.jp", "wjg.jp", "keyword-on.net", "live-on.net", "server-on.net", "mydns.tw", "mydns.vc", "*.futurecms.at", "*.ex.futurecms.at", "*.in.futurecms.at", "futurehosting.at", "futuremailing.at", "*.ex.ortsinfo.at", "*.kunden.ortsinfo.at", "*.statics.cloud", "aliases121.com", "campaign.gov.uk", "service.gov.uk", "independent-commission.uk", "independent-inquest.uk", "independent-inquiry.uk", "independent-panel.uk", "independent-review.uk", "public-inquiry.uk", "royal-commission.uk", "gehirn.ne.jp", "usercontent.jp", "gentapps.com", "gentlentapis.com", "lab.ms", "cdn-edges.net", "localcert.net", "localhostcert.net", "gsj.bz", "githubusercontent.com", "githubpreview.dev", "github.io", "gitlab.io", "gitapp.si", "gitpage.si", "glitch.me", "nog.community", "co.ro", "shop.ro", "lolipop.io", "angry.jp", "babyblue.jp", "babymilk.jp", "backdrop.jp", "bambina.jp", "bitter.jp", "blush.jp", "boo.jp", "boy.jp", "boyfriend.jp", "but.jp", "candypop.jp", "capoo.jp", "catfood.jp", "cheap.jp", "chicappa.jp", "chillout.jp", "chips.jp", "chowder.jp", "chu.jp", "ciao.jp", "cocotte.jp", "coolblog.jp", "cranky.jp", "cutegirl.jp", "daa.jp", "deca.jp", "deci.jp", "digick.jp", "egoism.jp", "fakefur.jp", "fem.jp", "flier.jp", "floppy.jp", "fool.jp", "frenchkiss.jp", "girlfriend.jp", "girly.jp", "gloomy.jp", "gonna.jp", "greater.jp", "hacca.jp", "heavy.jp", "her.jp", "hiho.jp", "hippy.jp", "holy.jp", "hungry.jp", "icurus.jp", "itigo.jp", "jellybean.jp", "kikirara.jp", "kill.jp", "kilo.jp", "kuron.jp", "littlestar.jp", "lolipopmc.jp", "lolitapunk.jp", "lomo.jp", "lovepop.jp", "lovesick.jp", "main.jp", "mods.jp", "mond.jp", "mongolian.jp", "moo.jp", "namaste.jp", "nikita.jp", "nobushi.jp", "noor.jp", "oops.jp", "parallel.jp", "parasite.jp", "pecori.jp", "peewee.jp", "penne.jp", "pepper.jp", "perma.jp", "pigboat.jp", "pinoko.jp", "punyu.jp", "pupu.jp", "pussycat.jp", "pya.jp", "raindrop.jp", "readymade.jp", "sadist.jp", "schoolbus.jp", "secret.jp", "staba.jp", "stripper.jp", "sub.jp", "sunnyday.jp", "thick.jp", "tonkotsu.jp", "under.jp", "upper.jp", "velvet.jp", "verse.jp", "versus.jp", "vivian.jp", "watson.jp", "weblike.jp", "whitesnow.jp", "zombie.jp", "heteml.net", "graphic.design", "goip.de", "blogspot.ae", "blogspot.al", "blogspot.am", "*.hosted.app", "*.run.app", "web.app", "blogspot.com.ar", "blogspot.co.at", "blogspot.com.au", "blogspot.ba", "blogspot.be", "blogspot.bg", "blogspot.bj", "blogspot.com.br", "blogspot.com.by", "blogspot.ca", "blogspot.cf", "blogspot.ch", "blogspot.cl", "blogspot.com.co", "*.0emm.com", "appspot.com", "*.r.appspot.com", "blogspot.com", "codespot.com", "googleapis.com", "googlecode.com", "pagespeedmobilizer.com", "withgoogle.com", "withyoutube.com", "blogspot.cv", "blogspot.com.cy", "blogspot.cz", "blogspot.de", "*.gateway.dev", "blogspot.dk", "blogspot.com.ee", "blogspot.com.eg", "blogspot.com.es", "blogspot.fi", "blogspot.fr", "cloud.goog", "translate.goog", "*.usercontent.goog", "blogspot.gr", "blogspot.hk", "blogspot.hr", "blogspot.hu", "blogspot.co.id", "blogspot.ie", "blogspot.co.il", "blogspot.in", "blogspot.is", "blogspot.it", "blogspot.jp", "blogspot.co.ke", "blogspot.kr", "blogspot.li", "blogspot.lt", "blogspot.lu", "blogspot.md", "blogspot.mk", "blogspot.com.mt", "blogspot.mx", "blogspot.my", "cloudfunctions.net", "blogspot.com.ng", "blogspot.nl", "blogspot.no", "blogspot.co.nz", "blogspot.pe", "blogspot.pt", "blogspot.qa", "blogspot.re", "blogspot.ro", "blogspot.rs", "blogspot.ru", "blogspot.se", "blogspot.sg", "blogspot.si", "blogspot.sk", "blogspot.sn", "blogspot.td", "blogspot.com.tr", "blogspot.tw", "blogspot.ug", "blogspot.co.uk", "blogspot.com.uy", "blogspot.vn", "blogspot.co.za", "goupile.fr", "pymnt.uk", "cloudapps.digital", "london.cloudapps.digital", "gov.nl", "grafana-dev.net", "grayjayleagues.com", "günstigbestellen.de", "günstigliefern.de", "fin.ci", "free.hr", "caa.li", "ua.rs", "conf.se", "häkkinen.fi", "hrsn.dev", "hashbang.sh", "hasura.app", "hasura-app.io", "hatenablog.com", "hatenadiary.com", "hateblo.jp", "hatenablog.jp", "hatenadiary.jp", "hatenadiary.org", "pages.it.hs-heilbronn.de", "pages-research.it.hs-heilbronn.de", "heiyu.space", "helioho.st", "heliohost.us", "hepforge.org", "herokuapp.com", "herokussl.com", "heyflow.page", "heyflow.site", "ravendb.cloud", "ravendb.community", "development.run", "ravendb.run", "homesklep.pl", "*.kin.one", "*.id.pub", "*.kin.pub", "secaas.hk", "hoplix.shop", "orx.biz", "biz.gl", "biz.ng", "co.biz.ng", "dl.biz.ng", "go.biz.ng", "lg.biz.ng", "on.biz.ng", "col.ng", "firm.ng", "gen.ng", "ltd.ng", "ngo.ng", "plc.ng", "ie.ua", "hostyhosting.io", "hf.space", "static.hf.space", "hypernode.io", "iobb.net", "co.cz", "*.moonscale.io", "moonscale.net", "gr.com", "iki.fi", "ibxos.it", "iliadboxos.it", "smushcdn.com", "wphostedmail.com", "wpmucdn.com", "tempurl.host", "wpmudev.host", "dyn-berlin.de", "in-berlin.de", "in-brb.de", "in-butter.de", "in-dsl.de", "in-vpn.de", "in-dsl.net", "in-vpn.net", "in-dsl.org", "in-vpn.org", "biz.at", "info.at", "info.cx", "ac.leg.br", "al.leg.br", "am.leg.br", "ap.leg.br", "ba.leg.br", "ce.leg.br", "df.leg.br", "es.leg.br", "go.leg.br", "ma.leg.br", "mg.leg.br", "ms.leg.br", "mt.leg.br", "pa.leg.br", "pb.leg.br", "pe.leg.br", "pi.leg.br", "pr.leg.br", "rj.leg.br", "rn.leg.br", "ro.leg.br", "rr.leg.br", "rs.leg.br", "sc.leg.br", "se.leg.br", "sp.leg.br", "to.leg.br", "pixolino.com", "na4u.ru", "apps-1and1.com", "live-website.com", "apps-1and1.net", "websitebuilder.online", "app-ionos.space", "iopsys.se", "*.dweb.link", "ipifony.net", "ir.md", "is-a-good.dev", "is-a.dev", "iservschule.de", "mein-iserv.de", "schulplattform.de", "schulserver.de", "test-iserv.de", "iserv.dev", "mel.cloudlets.com.au", "cloud.interhostsolutions.be", "alp1.ae.flow.ch", "appengine.flow.ch", "es-1.axarnet.cloud", "diadem.cloud", "vip.jelastic.cloud", "jele.cloud", "it1.eur.aruba.jenv-aruba.cloud", "it1.jenv-aruba.cloud", "keliweb.cloud", "cs.keliweb.cloud", "oxa.cloud", "tn.oxa.cloud", "uk.oxa.cloud", "primetel.cloud", "uk.primetel.cloud", "ca.reclaim.cloud", "uk.reclaim.cloud", "us.reclaim.cloud", "ch.trendhosting.cloud", "de.trendhosting.cloud", "jele.club", "dopaas.com", "paas.hosted-by-previder.com", "rag-cloud.hosteur.com", "rag-cloud-ch.hosteur.com", "jcloud.ik-server.com", "jcloud-ver-jpc.ik-server.com", "demo.jelastic.com", "paas.massivegrid.com", "jed.wafaicloud.com", "ryd.wafaicloud.com", "j.scaleforce.com.cy", "jelastic.dogado.eu", "fi.cloudplatform.fi", "demo.datacenter.fi", "paas.datacenter.fi", "jele.host", "mircloud.host", "paas.beebyte.io", "sekd1.beebyteapp.io", "jele.io", "jc.neen.it", "jcloud.kz", "cloudjiffy.net", "fra1-de.cloudjiffy.net", "west1-us.cloudjiffy.net", "jls-sto1.elastx.net", "jls-sto2.elastx.net", "jls-sto3.elastx.net", "fr-1.paas.massivegrid.net", "lon-1.paas.massivegrid.net", "lon-2.paas.massivegrid.net", "ny-1.paas.massivegrid.net", "ny-2.paas.massivegrid.net", "sg-1.paas.massivegrid.net", "jelastic.saveincloud.net", "nordeste-idc.saveincloud.net", "j.scaleforce.net", "sdscloud.pl", "unicloud.pl", "mircloud.ru", "enscaled.sg", "jele.site", "jelastic.team", "orangecloud.tn", "j.layershift.co.uk", "phx.enscaled.us", "mircloud.us", "myjino.ru", "*.hosting.myjino.ru", "*.landing.myjino.ru", "*.spectrum.myjino.ru", "*.vps.myjino.ru", "jotelulu.cloud", "webadorsite.com", "jouwweb.site", "*.cns.joyent.com", "*.triton.zone", "js.org", "kaas.gg", "khplay.nl", "kapsi.fi", "ezproxy.kuleuven.be", "kuleuven.cloud", "keymachine.de", "kinghost.net", "uni5.net", "knightpoint.systems", "koobin.events", "webthings.io", "krellian.net", "oya.to", "git-repos.de", "lcube-server.de", "svn-repos.de", "leadpages.co", "lpages.co", "lpusercontent.com", "lelux.site", "libp2p.direct", "runcontainers.dev", "co.business", "co.education", "co.events", "co.financial", "co.network", "co.place", "co.technology", "linkyard-cloud.ch", "linkyard.cloud", "members.linode.com", "*.nodebalancer.linode.com", "*.linodeobjects.com", "ip.linodeusercontent.com", "we.bs", "filegear-sg.me", "ggff.net", "*.user.localcert.dev", "lodz.pl", "pabianice.pl", "plock.pl", "sieradz.pl", "skierniewice.pl", "zgierz.pl", "loginline.app", "loginline.dev", "loginline.io", "loginline.services", "loginline.site", "lohmus.me", "servers.run", "krasnik.pl", "leczna.pl", "lubartow.pl", "lublin.pl", "poniatowa.pl", "swidnik.pl", "glug.org.uk", "lug.org.uk", "lugs.org.uk", "barsy.bg", "barsy.club", "barsycenter.com", "barsyonline.com", "barsy.de", "barsy.dev", "barsy.eu", "barsy.gr", "barsy.in", "barsy.info", "barsy.io", "barsy.me", "barsy.menu", "barsyonline.menu", "barsy.mobi", "barsy.net", "barsy.online", "barsy.org", "barsy.pro", "barsy.pub", "barsy.ro", "barsy.rs", "barsy.shop", "barsyonline.shop", "barsy.site", "barsy.store", "barsy.support", "barsy.uk", "barsy.co.uk", "barsyonline.co.uk", "*.magentosite.cloud", "hb.cldmail.ru", "matlab.cloud", "modelscape.com", "mwcloudnonprod.com", "polyspace.com", "mayfirst.info", "mayfirst.org", "mazeplay.com", "mcdir.me", "mcdir.ru", "vps.mcdir.ru", "mcpre.ru", "mediatech.by", "mediatech.dev", "hra.health", "medusajs.app", "miniserver.com", "memset.net", "messerli.app", "atmeta.com", "apps.fbsbx.com", "*.cloud.metacentrum.cz", "custom.metacentrum.cz", "flt.cloud.muni.cz", "usr.cloud.muni.cz", "meteorapp.com", "eu.meteorapp.com", "co.pl", "*.azurecontainer.io", "azure-api.net", "azure-mobile.net", "azureedge.net", "azurefd.net", "azurestaticapps.net", "1.azurestaticapps.net", "2.azurestaticapps.net", "3.azurestaticapps.net", "4.azurestaticapps.net", "5.azurestaticapps.net", "6.azurestaticapps.net", "7.azurestaticapps.net", "centralus.azurestaticapps.net", "eastasia.azurestaticapps.net", "eastus2.azurestaticapps.net", "westeurope.azurestaticapps.net", "westus2.azurestaticapps.net", "azurewebsites.net", "cloudapp.net", "trafficmanager.net", "blob.core.windows.net", "servicebus.windows.net", "routingthecloud.com", "sn.mynetname.net", "routingthecloud.net", "routingthecloud.org", "csx.cc", "mydbserver.com", "webspaceconfig.de", "mittwald.info", "mittwaldserver.info", "typo3server.info", "project.space", "modx.dev", "bmoattachments.org", "net.ru", "org.ru", "pp.ru", "hostedpi.com", "caracal.mythic-beasts.com", "customer.mythic-beasts.com", "fentiger.mythic-beasts.com", "lynx.mythic-beasts.com", "ocelot.mythic-beasts.com", "oncilla.mythic-beasts.com", "onza.mythic-beasts.com", "sphinx.mythic-beasts.com", "vs.mythic-beasts.com", "x.mythic-beasts.com", "yali.mythic-beasts.com", "cust.retrosnub.co.uk", "ui.nabu.casa", "cloud.nospamproxy.com", "netfy.app", "netlify.app", "4u.com", "nfshost.com", "ipfs.nftstorage.link", "ngo.us", "ngrok.app", "ngrok-free.app", "ngrok.dev", "ngrok-free.dev", "ngrok.io", "ap.ngrok.io", "au.ngrok.io", "eu.ngrok.io", "in.ngrok.io", "jp.ngrok.io", "sa.ngrok.io", "us.ngrok.io", "ngrok.pizza", "ngrok.pro", "torun.pl", "nh-serv.co.uk", "nimsite.uk", "mmafan.biz", "myftp.biz", "no-ip.biz", "no-ip.ca", "fantasyleague.cc", "gotdns.ch", "3utilities.com", "blogsyte.com", "ciscofreak.com", "damnserver.com", "ddnsking.com", "ditchyourip.com", "dnsiskinky.com", "dynns.com", "geekgalaxy.com", "health-carereform.com", "homesecuritymac.com", "homesecuritypc.com", "myactivedirectory.com", "mysecuritycamera.com", "myvnc.com", "net-freaks.com", "onthewifi.com", "point2this.com", "quicksytes.com", "securitytactics.com", "servebeer.com", "servecounterstrike.com", "serveexchange.com", "serveftp.com", "servegame.com", "servehalflife.com", "servehttp.com", "servehumour.com", "serveirc.com", "servemp3.com", "servep2p.com", "servepics.com", "servequake.com", "servesarcasm.com", "stufftoread.com", "unusualperson.com", "workisboring.com", "dvrcam.info", "ilovecollege.info", "no-ip.info", "brasilia.me", "ddns.me", "dnsfor.me", "hopto.me", "loginto.me", "noip.me", "webhop.me", "bounceme.net", "ddns.net", "eating-organic.net", "mydissent.net", "myeffect.net", "mymediapc.net", "mypsx.net", "mysecuritycamera.net", "nhlfan.net", "no-ip.net", "pgafan.net", "privatizehealthinsurance.net", "redirectme.net", "serveblog.net", "serveminecraft.net", "sytes.net", "cable-modem.org", "collegefan.org", "couchpotatofries.org", "hopto.org", "mlbfan.org", "myftp.org", "mysecuritycamera.org", "nflfan.org", "no-ip.org", "read-books.org", "ufcfan.org", "zapto.org", "no-ip.co.uk", "golffan.us", "noip.us", "pointto.us", "stage.nodeart.io", "*.developer.app", "noop.app", "*.northflank.app", "*.build.run", "*.code.run", "*.database.run", "*.migration.run", "noticeable.news", "notion.site", "dnsking.ch", "mypi.co", "n4t.co", "001www.com", "myiphost.com", "forumz.info", "soundcast.me", "tcp4.me", "dnsup.net", "hicam.net", "now-dns.net", "ownip.net", "vpndns.net", "dynserv.org", "now-dns.org", "x443.pw", "now-dns.top", "ntdll.top", "freeddns.us", "nsupdate.info", "nerdpol.ovh", "nyc.mn", "prvcy.page", "obl.ong", "observablehq.cloud", "static.observableusercontent.com", "omg.lol", "cloudycluster.net", "omniwe.site", "123webseite.at", "123website.be", "simplesite.com.br", "123website.ch", "simplesite.com", "123webseite.de", "123hjemmeside.dk", "123miweb.es", "123kotisivu.fi", "123siteweb.fr", "simplesite.gr", "123homepage.it", "123website.lu", "123website.nl", "123hjemmeside.no", "service.one", "simplesite.pl", "123paginaweb.pt", "123minsida.se", "is-a-fullstack.dev", "is-cool.dev", "is-not-a.dev", "localplayer.dev", "is-local.org", "opensocial.site", "opencraft.hosting", "16-b.it", "32-b.it", "64-b.it", "orsites.com", "operaunite.com", "*.customer-oci.com", "*.oci.customer-oci.com", "*.ocp.customer-oci.com", "*.ocs.customer-oci.com", "*.oraclecloudapps.com", "*.oraclegovcloudapps.com", "*.oraclegovcloudapps.uk", "tech.orange", "can.re", "authgear-staging.com", "authgearapps.com", "skygearapp.com", "outsystemscloud.com", "*.hosting.ovh.net", "*.webpaas.ovh.net", "ownprovider.com", "own.pm", "*.owo.codes", "ox.rs", "oy.lc", "pgfog.com", "pagexl.com", "gotpantheon.com", "pantheonsite.io", "*.paywhirl.com", "*.xmit.co", "xmit.dev", "madethis.site", "srv.us", "gh.srv.us", "gl.srv.us", "lk3.ru", "mypep.link", "perspecta.cloud", "on-web.fr", "*.upsun.app", "upsunapp.com", "ent.platform.sh", "eu.platform.sh", "us.platform.sh", "*.platformsh.site", "*.tst.site", "platter-app.com", "platter-app.dev", "platterp.us", "pley.games", "onporter.run", "co.bn", "postman-echo.com", "pstmn.io", "mock.pstmn.io", "httpbin.org", "prequalifyme.today", "xen.prgmr.com", "priv.at", "protonet.io", "chirurgiens-dentistes-en-france.fr", "byen.site", "pubtls.org", "pythonanywhere.com", "eu.pythonanywhere.com", "qa2.com", "qcx.io", "*.sys.qcx.io", "myqnapcloud.cn", "alpha-myqnapcloud.com", "dev-myqnapcloud.com", "mycloudnas.com", "mynascloud.com", "myqnapcloud.com", "qoto.io", "qualifioapp.com", "ladesk.com", "qbuser.com", "*.quipelements.com", "vapor.cloud", "vaporcloud.io", "rackmaze.com", "rackmaze.net", "cloudsite.builders", "myradweb.net", "servername.us", "web.in", "in.net", "myrdbx.io", "site.rb-hosting.io", "*.on-rancher.cloud", "*.on-k3s.io", "*.on-rio.io", "ravpage.co.il", "readthedocs-hosted.com", "readthedocs.io", "rhcloud.com", "instances.spawn.cc", "onrender.com", "app.render.com", "replit.app", "id.replit.app", "firewalledreplit.co", "id.firewalledreplit.co", "repl.co", "id.repl.co", "replit.dev", "archer.replit.dev", "bones.replit.dev", "canary.replit.dev", "global.replit.dev", "hacker.replit.dev", "id.replit.dev", "janeway.replit.dev", "kim.replit.dev", "kira.replit.dev", "kirk.replit.dev", "odo.replit.dev", "paris.replit.dev", "picard.replit.dev", "pike.replit.dev", "prerelease.replit.dev", "reed.replit.dev", "riker.replit.dev", "sisko.replit.dev", "spock.replit.dev", "staging.replit.dev", "sulu.replit.dev", "tarpit.replit.dev", "teams.replit.dev", "tucker.replit.dev", "wesley.replit.dev", "worf.replit.dev", "repl.run", "resindevice.io", "devices.resinstaging.io", "hzc.io", "adimo.co.uk", "itcouldbewor.se", "aus.basketball", "nz.basketball", "git-pages.rit.edu", "rocky.page", "rub.de", "ruhr-uni-bochum.de", "io.noc.ruhr-uni-bochum.de", "биз.рус", "ком.рус", "крым.рус", "мир.рус", "мск.рус", "орг.рус", "самара.рус", "сочи.рус", "спб.рус", "я.рус", "ras.ru", "nyat.app", "180r.com", "dojin.com", "sakuratan.com", "sakuraweb.com", "x0.com", "2-d.jp", "bona.jp", "crap.jp", "daynight.jp", "eek.jp", "flop.jp", "halfmoon.jp", "jeez.jp", "matrix.jp", "mimoza.jp", "ivory.ne.jp", "mail-box.ne.jp", "mints.ne.jp", "mokuren.ne.jp", "opal.ne.jp", "sakura.ne.jp", "sumomo.ne.jp", "topaz.ne.jp", "netgamers.jp", "nyanta.jp", "o0o0.jp", "rdy.jp", "rgr.jp", "rulez.jp", "s3.isk01.sakurastorage.jp", "s3.isk02.sakurastorage.jp", "saloon.jp", "sblo.jp", "skr.jp", "tank.jp", "uh-oh.jp", "undo.jp", "rs.webaccel.jp", "user.webaccel.jp", "websozai.jp", "xii.jp", "squares.net", "jpn.org", "kirara.st", "x0.to", "from.tv", "sakura.tv", "*.builder.code.com", "*.dev-builder.code.com", "*.stg-builder.code.com", "*.001.test.code-builder-stg.platform.salesforce.com", "*.d.crm.dev", "*.w.crm.dev", "*.wa.crm.dev", "*.wb.crm.dev", "*.wc.crm.dev", "*.wd.crm.dev", "*.we.crm.dev", "*.wf.crm.dev", "sandcats.io", "logoip.com", "logoip.de", "fr-par-1.baremetal.scw.cloud", "fr-par-2.baremetal.scw.cloud", "nl-ams-1.baremetal.scw.cloud", "cockpit.fr-par.scw.cloud", "fnc.fr-par.scw.cloud", "functions.fnc.fr-par.scw.cloud", "k8s.fr-par.scw.cloud", "nodes.k8s.fr-par.scw.cloud", "s3.fr-par.scw.cloud", "s3-website.fr-par.scw.cloud", "whm.fr-par.scw.cloud", "priv.instances.scw.cloud", "pub.instances.scw.cloud", "k8s.scw.cloud", "cockpit.nl-ams.scw.cloud", "k8s.nl-ams.scw.cloud", "nodes.k8s.nl-ams.scw.cloud", "s3.nl-ams.scw.cloud", "s3-website.nl-ams.scw.cloud", "whm.nl-ams.scw.cloud", "cockpit.pl-waw.scw.cloud", "k8s.pl-waw.scw.cloud", "nodes.k8s.pl-waw.scw.cloud", "s3.pl-waw.scw.cloud", "s3-website.pl-waw.scw.cloud", "scalebook.scw.cloud", "smartlabeling.scw.cloud", "dedibox.fr", "schokokeks.net", "gov.scot", "service.gov.scot", "scrysec.com", "client.scrypted.io", "firewall-gateway.com", "firewall-gateway.de", "my-gateway.de", "my-router.de", "spdns.de", "spdns.eu", "firewall-gateway.net", "my-firewall.org", "myfirewall.org", "spdns.org", "seidat.net", "sellfy.store", "minisite.ms", "senseering.net", "servebolt.cloud", "biz.ua", "co.ua", "pp.ua", "as.sh.cn", "sheezy.games", "shiftedit.io", "myshopblocks.com", "myshopify.com", "shopitsite.com", "shopware.shop", "shopware.store", "mo-siemens.io", "1kapp.com", "appchizi.com", "applinzi.com", "sinaapp.com", "vipsinaapp.com", "siteleaf.net", "small-web.org", "aeroport.fr", "avocat.fr", "chambagri.fr", "chirurgiens-dentistes.fr", "experts-comptables.fr", "medecin.fr", "notaires.fr", "pharmacien.fr", "port.fr", "veterinaire.fr", "vp4.me", "*.snowflake.app", "*.privatelink.snowflake.app", "streamlit.app", "streamlitapp.com", "try-snowplow.com", "mafelo.net", "playstation-cloud.com", "srht.site", "apps.lair.io", "*.stolos.io", "spacekit.io", "ind.mom", "customer.speedpartner.de", "myspreadshop.at", "myspreadshop.com.au", "myspreadshop.be", "myspreadshop.ca", "myspreadshop.ch", "myspreadshop.com", "myspreadshop.de", "myspreadshop.dk", "myspreadshop.es", "myspreadshop.fi", "myspreadshop.fr", "myspreadshop.ie", "myspreadshop.it", "myspreadshop.net", "myspreadshop.nl", "myspreadshop.no", "myspreadshop.pl", "myspreadshop.se", "myspreadshop.co.uk", "w-corp-staticblitz.com", "w-credentialless-staticblitz.com", "w-staticblitz.com", "stackhero-network.com", "runs.onstackit.cloud", "stackit.gg", "stackit.rocks", "stackit.run", "stackit.zone", "musician.io", "novecore.site", "api.stdlib.com", "feedback.ac", "forms.ac", "assessments.cx", "calculators.cx", "funnels.cx", "paynow.cx", "quizzes.cx", "researched.cx", "tests.cx", "surveys.so", "storebase.store", "storipress.app", "storj.farm", "strapiapp.com", "media.strapiapp.com", "vps-host.net", "atl.jelastic.vps-host.net", "njs.jelastic.vps-host.net", "ric.jelastic.vps-host.net", "streak-link.com", "streaklinks.com", "streakusercontent.com", "soc.srcf.net", "user.srcf.net", "utwente.io", "temp-dns.com", "supabase.co", "supabase.in", "supabase.net", "syncloud.it", "dscloud.biz", "direct.quickconnect.cn", "dsmynas.com", "familyds.com", "diskstation.me", "dscloud.me", "i234.me", "myds.me", "synology.me", "dscloud.mobi", "dsmynas.net", "familyds.net", "dsmynas.org", "familyds.org", "direct.quickconnect.to", "vpnplus.to", "mytabit.com", "mytabit.co.il", "tabitorder.co.il", "taifun-dns.de", "ts.net", "*.c.ts.net", "gda.pl", "gdansk.pl", "gdynia.pl", "med.pl", "sopot.pl", "taveusercontent.com", "p.tawk.email", "p.tawkto.email", "site.tb-hosting.com", "edugit.io", "s3.teckids.org", "telebit.app", "telebit.io", "*.telebit.xyz", "*.firenet.ch", "*.svc.firenet.ch", "reservd.com", "thingdustdata.com", "cust.dev.thingdust.io", "reservd.dev.thingdust.io", "cust.disrec.thingdust.io", "reservd.disrec.thingdust.io", "cust.prod.thingdust.io", "cust.testing.thingdust.io", "reservd.testing.thingdust.io", "tickets.io", "arvo.network", "azimuth.network", "tlon.network", "torproject.net", "pages.torproject.net", "townnews-staging.com", "12hp.at", "2ix.at", "4lima.at", "lima-city.at", "12hp.ch", "2ix.ch", "4lima.ch", "lima-city.ch", "trafficplex.cloud", "de.cool", "12hp.de", "2ix.de", "4lima.de", "lima-city.de", "1337.pictures", "clan.rip", "lima-city.rocks", "webspace.rocks", "lima.zone", "*.transurl.be", "*.transurl.eu", "site.transip.me", "*.transurl.nl", "tuxfamily.org", "dd-dns.de", "dray-dns.de", "draydns.de", "dyn-vpn.de", "dynvpn.de", "mein-vigor.de", "my-vigor.de", "my-wan.de", "syno-ds.de", "synology-diskstation.de", "synology-ds.de", "diskstation.eu", "diskstation.org", "typedream.app", "pro.typeform.com", "*.uberspace.de", "uber.space", "hk.com", "inc.hk", "ltd.hk", "hk.org", "it.com", "unison-services.cloud", "virtual-user.de", "virtualuser.de", "name.pm", "sch.tf", "biz.wf", "sch.wf", "org.yt", "rs.ba", "bielsko.pl", "upli.io", "urown.cloud", "dnsupdate.info", "us.org", "v.ua", "express.val.run", "web.val.run", "vercel.app", "v0.build", "vercel.dev", "vusercontent.net", "now.sh", "2038.io", "router.management", "v-info.info", "voorloper.cloud", "*.vultrobjects.com", "wafflecell.com", "webflow.io", "webflowtest.io", "*.webhare.dev", "bookonline.app", "hotelwithflight.com", "reserve-online.com", "reserve-online.net", "cprapid.com", "pleskns.com", "wp2.host", "pdns.page", "plesk.page", "wpsquared.site", "*.wadl.top", "remotewd.com", "box.ca", "pages.wiardweb.com", "toolforge.org", "wmcloud.org", "wmflabs.org", "wdh.app", "panel.gg", "daemon.panel.gg", "wixsite.com", "wixstudio.com", "editorx.io", "wixstudio.io", "wix.run", "messwithdns.com", "woltlab-demo.com", "myforum.community", "community-pro.de", "diskussionsbereich.de", "community-pro.net", "meinforum.net", "affinitylottery.org.uk", "raffleentry.org.uk", "weeklylottery.org.uk", "wpenginepowered.com", "js.wpenginepowered.com", "half.host", "xnbay.com", "u2.xnbay.com", "u2-local.xnbay.com", "cistron.nl", "demon.nl", "xs4all.space", "yandexcloud.net", "storage.yandexcloud.net", "website.yandexcloud.net", "official.academy", "yolasite.com", "yombo.me", "ynh.fr", "nohost.me", "noho.st", "za.net", "za.org", "zap.cloud", "zeabur.app", "bss.design", "basicserver.io", "virtualserver.io", "enterprisecloud.nu"];
    var Z = Y.reduce((e, s) => {
      const c = s.replace(/^(\*\.|\!)/, ""), o = A.toASCII(c), t = s.charAt(0);
      if (e.has(o)) throw new Error(`Multiple rules found for ${s} (${o})`);
      return e.set(o, { rule: s, suffix: c, punySuffix: o, wildcard: t === "*", exception: t === "!" }), e;
    }, /* @__PURE__ */ new Map());
    var aa = (e) => {
      const c = A.toASCII(e).split(".");
      for (let o = 0; o < c.length; o++) {
        const t = c.slice(o).join("."), d = Z.get(t);
        if (d) return d;
      }
      return null;
    };
    var H = { DOMAIN_TOO_SHORT: "Domain name too short.", DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.", LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.", LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.", LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.", LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.", LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes." };
    var oa = (e) => {
      const s = A.toASCII(e);
      if (s.length < 1) return "DOMAIN_TOO_SHORT";
      if (s.length > 255) return "DOMAIN_TOO_LONG";
      const c = s.split(".");
      let o;
      for (let t = 0; t < c.length; ++t) {
        if (o = c[t], !o.length) return "LABEL_TOO_SHORT";
        if (o.length > 63) return "LABEL_TOO_LONG";
        if (o.charAt(0) === "-") return "LABEL_STARTS_WITH_DASH";
        if (o.charAt(o.length - 1) === "-") return "LABEL_ENDS_WITH_DASH";
        if (!/^[a-z0-9\-_]+$/.test(o)) return "LABEL_INVALID_CHARS";
      }
    };
    var _ = (e) => {
      if (typeof e != "string") throw new TypeError("Domain name must be a string.");
      let s = e.slice(0).toLowerCase();
      s.charAt(s.length - 1) === "." && (s = s.slice(0, s.length - 1));
      const c = oa(s);
      if (c) return { input: e, error: { message: H[c], code: c } };
      const o = { input: e, tld: null, sld: null, domain: null, subdomain: null, listed: false }, t = s.split(".");
      if (t[t.length - 1] === "local") return o;
      const d = () => (/xn--/.test(s) && (o.domain && (o.domain = A.toASCII(o.domain)), o.subdomain && (o.subdomain = A.toASCII(o.subdomain))), o), z = aa(s);
      if (!z) return t.length < 2 ? o : (o.tld = t.pop(), o.sld = t.pop(), o.domain = [o.sld, o.tld].join("."), t.length && (o.subdomain = t.pop()), d());
      o.listed = true;
      const y = z.suffix.split("."), g2 = t.slice(0, t.length - y.length);
      return z.exception && g2.push(y.shift()), o.tld = y.join("."), !g2.length || (z.wildcard && (y.unshift(g2.pop()), o.tld = y.join(".")), !g2.length) || (o.sld = g2.pop(), o.domain = [o.sld, o.tld].join("."), g2.length && (o.subdomain = g2.join("."))), d();
    };
    var N = (e) => e && _(e).domain || null;
    var R = (e) => {
      const s = _(e);
      return !!(s.domain && s.listed);
    };
    var sa = { parse: _, get: N, isValid: R };
    exports2.default = sa;
    exports2.errorCodes = H;
    exports2.get = N;
    exports2.isValid = R;
    exports2.parse = _;
  }
});

// node_modules/tough-cookie/lib/pubsuffix-psl.js
var require_pubsuffix_psl = __commonJS({
  "node_modules/tough-cookie/lib/pubsuffix-psl.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var psl = require_psl();
    var SPECIAL_USE_DOMAINS = [
      "local",
      "example",
      "invalid",
      "localhost",
      "test"
    ];
    var SPECIAL_TREATMENT_DOMAINS = ["localhost", "invalid"];
    function getPublicSuffix(domain, options = {}) {
      const domainParts = domain.split(".");
      const topLevelDomain = domainParts[domainParts.length - 1];
      const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
      const ignoreError = !!options.ignoreError;
      if (allowSpecialUseDomain && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
        if (domainParts.length > 1) {
          const secondLevelDomain = domainParts[domainParts.length - 2];
          return `${secondLevelDomain}.${topLevelDomain}`;
        } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
          return `${topLevelDomain}`;
        }
      }
      if (!ignoreError && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
        throw new Error(
          `Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain:true, rejectPublicSuffixes: false}.`
        );
      }
      return psl.get(domain);
    }
    exports2.getPublicSuffix = getPublicSuffix;
  }
});

// node_modules/tough-cookie/lib/store.js
var require_store = __commonJS({
  "node_modules/tough-cookie/lib/store.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var Store = class {
      constructor() {
        this.synchronous = false;
      }
      findCookie(domain, path, key, cb) {
        throw new Error("findCookie is not implemented");
      }
      findCookies(domain, path, allowSpecialUseDomain, cb) {
        throw new Error("findCookies is not implemented");
      }
      putCookie(cookie, cb) {
        throw new Error("putCookie is not implemented");
      }
      updateCookie(oldCookie, newCookie, cb) {
        throw new Error("updateCookie is not implemented");
      }
      removeCookie(domain, path, key, cb) {
        throw new Error("removeCookie is not implemented");
      }
      removeCookies(domain, path, cb) {
        throw new Error("removeCookies is not implemented");
      }
      removeAllCookies(cb) {
        throw new Error("removeAllCookies is not implemented");
      }
      getAllCookies(cb) {
        throw new Error(
          "getAllCookies is not implemented (therefore jar cannot be serialized)"
        );
      }
    };
    exports2.Store = Store;
  }
});

// node_modules/tough-cookie/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/tough-cookie/node_modules/universalify/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function() {
        if (typeof arguments[arguments.length - 1] === "function") fn.apply(this, arguments);
        else {
          return new Promise((resolve, reject) => {
            arguments[arguments.length] = (err, res) => {
              if (err) return reject(err);
              resolve(res);
            };
            arguments.length++;
            fn.apply(this, arguments);
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function() {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== "function") return fn.apply(this, arguments);
        else {
          delete arguments[arguments.length - 1];
          arguments.length--;
          fn.apply(this, arguments).then((r2) => cb(null, r2), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain = __commonJS({
  "node_modules/tough-cookie/lib/permuteDomain.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var pubsuffix = require_pubsuffix_psl();
    function permuteDomain(domain, allowSpecialUseDomain) {
      const pubSuf = pubsuffix.getPublicSuffix(domain, {
        allowSpecialUseDomain
      });
      if (!pubSuf) {
        return null;
      }
      if (pubSuf == domain) {
        return [domain];
      }
      if (domain.slice(-1) == ".") {
        domain = domain.slice(0, -1);
      }
      const prefix = domain.slice(0, -(pubSuf.length + 1));
      const parts = prefix.split(".").reverse();
      let cur = pubSuf;
      const permutations = [cur];
      while (parts.length) {
        cur = `${parts.shift()}.${cur}`;
        permutations.push(cur);
      }
      return permutations;
    }
    exports2.permuteDomain = permuteDomain;
  }
});

// node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch = __commonJS({
  "node_modules/tough-cookie/lib/pathMatch.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    function pathMatch(reqPath, cookiePath) {
      if (cookiePath === reqPath) {
        return true;
      }
      const idx = reqPath.indexOf(cookiePath);
      if (idx === 0) {
        if (cookiePath.substr(-1) === "/") {
          return true;
        }
        if (reqPath.substr(cookiePath.length, 1) === "/") {
          return true;
        }
      }
      return false;
    }
    exports2.pathMatch = pathMatch;
  }
});

// node_modules/tough-cookie/lib/utilHelper.js
var require_utilHelper = __commonJS({
  "node_modules/tough-cookie/lib/utilHelper.js"(exports2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    function requireUtil() {
      try {
        return require_util();
      } catch (e) {
        return null;
      }
    }
    function lookupCustomInspectSymbol() {
      return Symbol.for("nodejs.util.inspect.custom");
    }
    function tryReadingCustomSymbolFromUtilInspect(options) {
      const _requireUtil = options.requireUtil || requireUtil;
      const util = _requireUtil();
      return util ? util.inspect.custom : null;
    }
    exports2.getUtilInspect = function getUtilInspect(fallback, options = {}) {
      const _requireUtil = options.requireUtil || requireUtil;
      const util = _requireUtil();
      return function inspect(value, showHidden, depth) {
        return util ? util.inspect(value, showHidden, depth) : fallback(value);
      };
    };
    exports2.getCustomInspectSymbol = function getCustomInspectSymbol(options = {}) {
      const _lookupCustomInspectSymbol = options.lookupCustomInspectSymbol || lookupCustomInspectSymbol;
      return _lookupCustomInspectSymbol() || tryReadingCustomSymbolFromUtilInspect(options);
    };
  }
});

// node_modules/tough-cookie/lib/memstore.js
var require_memstore = __commonJS({
  "node_modules/tough-cookie/lib/memstore.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var { fromCallback } = require_universalify();
    var Store = require_store().Store;
    var permuteDomain = require_permuteDomain().permuteDomain;
    var pathMatch = require_pathMatch().pathMatch;
    var { getCustomInspectSymbol, getUtilInspect } = require_utilHelper();
    var MemoryCookieStore = class extends Store {
      constructor() {
        super();
        this.synchronous = true;
        this.idx = /* @__PURE__ */ Object.create(null);
        const customInspectSymbol = getCustomInspectSymbol();
        if (customInspectSymbol) {
          this[customInspectSymbol] = this.inspect;
        }
      }
      inspect() {
        const util = { inspect: getUtilInspect(inspectFallback) };
        return `{ idx: ${util.inspect(this.idx, false, 2)} }`;
      }
      findCookie(domain, path, key, cb) {
        if (!this.idx[domain]) {
          return cb(null, void 0);
        }
        if (!this.idx[domain][path]) {
          return cb(null, void 0);
        }
        return cb(null, this.idx[domain][path][key] || null);
      }
      findCookies(domain, path, allowSpecialUseDomain, cb) {
        const results = [];
        if (typeof allowSpecialUseDomain === "function") {
          cb = allowSpecialUseDomain;
          allowSpecialUseDomain = true;
        }
        if (!domain) {
          return cb(null, []);
        }
        let pathMatcher;
        if (!path) {
          pathMatcher = function matchAll(domainIndex) {
            for (const curPath in domainIndex) {
              const pathIndex = domainIndex[curPath];
              for (const key in pathIndex) {
                results.push(pathIndex[key]);
              }
            }
          };
        } else {
          pathMatcher = function matchRFC(domainIndex) {
            Object.keys(domainIndex).forEach((cookiePath) => {
              if (pathMatch(path, cookiePath)) {
                const pathIndex = domainIndex[cookiePath];
                for (const key in pathIndex) {
                  results.push(pathIndex[key]);
                }
              }
            });
          };
        }
        const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];
        const idx = this.idx;
        domains.forEach((curDomain) => {
          const domainIndex = idx[curDomain];
          if (!domainIndex) {
            return;
          }
          pathMatcher(domainIndex);
        });
        cb(null, results);
      }
      putCookie(cookie, cb) {
        if (!this.idx[cookie.domain]) {
          this.idx[cookie.domain] = /* @__PURE__ */ Object.create(null);
        }
        if (!this.idx[cookie.domain][cookie.path]) {
          this.idx[cookie.domain][cookie.path] = /* @__PURE__ */ Object.create(null);
        }
        this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
        cb(null);
      }
      updateCookie(oldCookie, newCookie, cb) {
        this.putCookie(newCookie, cb);
      }
      removeCookie(domain, path, key, cb) {
        if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
          delete this.idx[domain][path][key];
        }
        cb(null);
      }
      removeCookies(domain, path, cb) {
        if (this.idx[domain]) {
          if (path) {
            delete this.idx[domain][path];
          } else {
            delete this.idx[domain];
          }
        }
        return cb(null);
      }
      removeAllCookies(cb) {
        this.idx = /* @__PURE__ */ Object.create(null);
        return cb(null);
      }
      getAllCookies(cb) {
        const cookies = [];
        const idx = this.idx;
        const domains = Object.keys(idx);
        domains.forEach((domain) => {
          const paths = Object.keys(idx[domain]);
          paths.forEach((path) => {
            const keys = Object.keys(idx[domain][path]);
            keys.forEach((key) => {
              if (key !== null) {
                cookies.push(idx[domain][path][key]);
              }
            });
          });
        });
        cookies.sort((a, b) => {
          return (a.creationIndex || 0) - (b.creationIndex || 0);
        });
        cb(null, cookies);
      }
    };
    [
      "findCookie",
      "findCookies",
      "putCookie",
      "updateCookie",
      "removeCookie",
      "removeCookies",
      "removeAllCookies",
      "getAllCookies"
    ].forEach((name) => {
      MemoryCookieStore.prototype[name] = fromCallback(
        MemoryCookieStore.prototype[name]
      );
    });
    exports2.MemoryCookieStore = MemoryCookieStore;
    function inspectFallback(val) {
      const domains = Object.keys(val);
      if (domains.length === 0) {
        return "[Object: null prototype] {}";
      }
      let result2 = "[Object: null prototype] {\n";
      Object.keys(val).forEach((domain, i) => {
        result2 += formatDomain(domain, val[domain]);
        if (i < domains.length - 1) {
          result2 += ",";
        }
        result2 += "\n";
      });
      result2 += "}";
      return result2;
    }
    function formatDomain(domainName, domainValue) {
      const indent = "  ";
      let result2 = `${indent}'${domainName}': [Object: null prototype] {
`;
      Object.keys(domainValue).forEach((path, i, paths) => {
        result2 += formatPath(path, domainValue[path]);
        if (i < paths.length - 1) {
          result2 += ",";
        }
        result2 += "\n";
      });
      result2 += `${indent}}`;
      return result2;
    }
    function formatPath(pathName, pathValue) {
      const indent = "    ";
      let result2 = `${indent}'${pathName}': [Object: null prototype] {
`;
      Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {
        const cookie = pathValue[cookieName];
        result2 += `      ${cookieName}: ${cookie.inspect()}`;
        if (i < cookieNames.length - 1) {
          result2 += ",";
        }
        result2 += "\n";
      });
      result2 += `${indent}}`;
      return result2;
    }
    exports2.inspectFallback = inspectFallback;
  }
});

// node_modules/tough-cookie/lib/validators.js
var require_validators = __commonJS({
  "node_modules/tough-cookie/lib/validators.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var toString4 = Object.prototype.toString;
    function isFunction(data) {
      return typeof data === "function";
    }
    function isNonEmptyString(data) {
      return isString(data) && data !== "";
    }
    function isDate(data) {
      return isInstanceStrict(data, Date) && isInteger3(data.getTime());
    }
    function isEmptyString(data) {
      return data === "" || data instanceof String && data.toString() === "";
    }
    function isString(data) {
      return typeof data === "string" || data instanceof String;
    }
    function isObject(data) {
      return toString4.call(data) === "[object Object]";
    }
    function isInstanceStrict(data, prototype2) {
      try {
        return data instanceof prototype2;
      } catch (error) {
        return false;
      }
    }
    function isUrlStringOrObject(data) {
      return isNonEmptyString(data) || isObject(data) && "hostname" in data && "pathname" in data && "protocol" in data || isInstanceStrict(data, URL);
    }
    function isInteger3(data) {
      return typeof data === "number" && data % 1 === 0;
    }
    function validate(bool, cb, options) {
      if (!isFunction(cb)) {
        options = cb;
        cb = null;
      }
      if (!isObject(options)) options = { Error: "Failed Check" };
      if (!bool) {
        if (cb) {
          cb(new ParameterError(options));
        } else {
          throw new ParameterError(options);
        }
      }
    }
    var ParameterError = class extends Error {
      constructor(...params) {
        super(...params);
      }
    };
    exports2.ParameterError = ParameterError;
    exports2.isFunction = isFunction;
    exports2.isNonEmptyString = isNonEmptyString;
    exports2.isDate = isDate;
    exports2.isEmptyString = isEmptyString;
    exports2.isString = isString;
    exports2.isObject = isObject;
    exports2.isUrlStringOrObject = isUrlStringOrObject;
    exports2.validate = validate;
  }
});

// node_modules/tough-cookie/lib/version.js
var require_version = __commonJS({
  "node_modules/tough-cookie/lib/version.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    module2.exports = "4.1.4";
  }
});

// node_modules/tough-cookie/lib/cookie.js
var require_cookie = __commonJS({
  "node_modules/tough-cookie/lib/cookie.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var punycode = require_punycode();
    var urlParse = require_url_parse();
    var pubsuffix = require_pubsuffix_psl();
    var Store = require_store().Store;
    var MemoryCookieStore = require_memstore().MemoryCookieStore;
    var pathMatch = require_pathMatch().pathMatch;
    var validators = require_validators();
    var VERSION = require_version();
    var { fromCallback } = require_universalify();
    var { getCustomInspectSymbol } = require_utilHelper();
    var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
    var CONTROL_CHARS = /[\x00-\x1F]/;
    var TERMINATORS = ["\n", "\r", "\0"];
    var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
    var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
    var MONTH_TO_NUM = {
      jan: 0,
      feb: 1,
      mar: 2,
      apr: 3,
      may: 4,
      jun: 5,
      jul: 6,
      aug: 7,
      sep: 8,
      oct: 9,
      nov: 10,
      dec: 11
    };
    var MAX_TIME = 2147483647e3;
    var MIN_TIME = 0;
    var SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
    function checkSameSiteContext(value) {
      validators.validate(validators.isNonEmptyString(value), value);
      const context = String(value).toLowerCase();
      if (context === "none" || context === "lax" || context === "strict") {
        return context;
      } else {
        return null;
      }
    }
    var PrefixSecurityEnum = Object.freeze({
      SILENT: "silent",
      STRICT: "strict",
      DISABLED: "unsafe-disabled"
    });
    var IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
    var IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);
    function parseDigits(token, minDigits, maxDigits, trailingOK) {
      let count3 = 0;
      while (count3 < token.length) {
        const c = token.charCodeAt(count3);
        if (c <= 47 || c >= 58) {
          break;
        }
        count3++;
      }
      if (count3 < minDigits || count3 > maxDigits) {
        return null;
      }
      if (!trailingOK && count3 != token.length) {
        return null;
      }
      return parseInt(token.substr(0, count3), 10);
    }
    function parseTime(token) {
      const parts = token.split(":");
      const result2 = [0, 0, 0];
      if (parts.length !== 3) {
        return null;
      }
      for (let i = 0; i < 3; i++) {
        const trailingOK = i == 2;
        const num2 = parseDigits(parts[i], 1, 2, trailingOK);
        if (num2 === null) {
          return null;
        }
        result2[i] = num2;
      }
      return result2;
    }
    function parseMonth(token) {
      token = String(token).substr(0, 3).toLowerCase();
      const num2 = MONTH_TO_NUM[token];
      return num2 >= 0 ? num2 : null;
    }
    function parseDate(str) {
      if (!str) {
        return;
      }
      const tokens = str.split(DATE_DELIM);
      if (!tokens) {
        return;
      }
      let hour = null;
      let minute = null;
      let second = null;
      let dayOfMonth = null;
      let month = null;
      let year = null;
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].trim();
        if (!token.length) {
          continue;
        }
        let result2;
        if (second === null) {
          result2 = parseTime(token);
          if (result2) {
            hour = result2[0];
            minute = result2[1];
            second = result2[2];
            continue;
          }
        }
        if (dayOfMonth === null) {
          result2 = parseDigits(token, 1, 2, true);
          if (result2 !== null) {
            dayOfMonth = result2;
            continue;
          }
        }
        if (month === null) {
          result2 = parseMonth(token);
          if (result2 !== null) {
            month = result2;
            continue;
          }
        }
        if (year === null) {
          result2 = parseDigits(token, 2, 4, true);
          if (result2 !== null) {
            year = result2;
            if (year >= 70 && year <= 99) {
              year += 1900;
            } else if (year >= 0 && year <= 69) {
              year += 2e3;
            }
          }
        }
      }
      if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
        return;
      }
      return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
    }
    function formatDate(date) {
      validators.validate(validators.isDate(date), date);
      return date.toUTCString();
    }
    function canonicalDomain(str) {
      if (str == null) {
        return null;
      }
      str = str.trim().replace(/^\./, "");
      if (IP_V6_REGEX_OBJECT.test(str)) {
        str = str.replace("[", "").replace("]", "");
      }
      if (punycode && /[^\u0001-\u007f]/.test(str)) {
        str = punycode.toASCII(str);
      }
      return str.toLowerCase();
    }
    function domainMatch(str, domStr, canonicalize) {
      if (str == null || domStr == null) {
        return null;
      }
      if (canonicalize !== false) {
        str = canonicalDomain(str);
        domStr = canonicalDomain(domStr);
      }
      if (str == domStr) {
        return true;
      }
      const idx = str.lastIndexOf(domStr);
      if (idx <= 0) {
        return false;
      }
      if (str.length !== domStr.length + idx) {
        return false;
      }
      if (str.substr(idx - 1, 1) !== ".") {
        return false;
      }
      if (IP_REGEX_LOWERCASE.test(str)) {
        return false;
      }
      return true;
    }
    function defaultPath(path) {
      if (!path || path.substr(0, 1) !== "/") {
        return "/";
      }
      if (path === "/") {
        return path;
      }
      const rightSlash = path.lastIndexOf("/");
      if (rightSlash === 0) {
        return "/";
      }
      return path.slice(0, rightSlash);
    }
    function trimTerminator(str) {
      if (validators.isEmptyString(str)) return str;
      for (let t = 0; t < TERMINATORS.length; t++) {
        const terminatorIdx = str.indexOf(TERMINATORS[t]);
        if (terminatorIdx !== -1) {
          str = str.substr(0, terminatorIdx);
        }
      }
      return str;
    }
    function parseCookiePair(cookiePair, looseMode) {
      cookiePair = trimTerminator(cookiePair);
      validators.validate(validators.isString(cookiePair), cookiePair);
      let firstEq = cookiePair.indexOf("=");
      if (looseMode) {
        if (firstEq === 0) {
          cookiePair = cookiePair.substr(1);
          firstEq = cookiePair.indexOf("=");
        }
      } else {
        if (firstEq <= 0) {
          return;
        }
      }
      let cookieName, cookieValue;
      if (firstEq <= 0) {
        cookieName = "";
        cookieValue = cookiePair.trim();
      } else {
        cookieName = cookiePair.substr(0, firstEq).trim();
        cookieValue = cookiePair.substr(firstEq + 1).trim();
      }
      if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
        return;
      }
      const c = new Cookie();
      c.key = cookieName;
      c.value = cookieValue;
      return c;
    }
    function parse3(str, options) {
      if (!options || typeof options !== "object") {
        options = {};
      }
      if (validators.isEmptyString(str) || !validators.isString(str)) {
        return null;
      }
      str = str.trim();
      const firstSemi = str.indexOf(";");
      const cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
      const c = parseCookiePair(cookiePair, !!options.loose);
      if (!c) {
        return;
      }
      if (firstSemi === -1) {
        return c;
      }
      const unparsed = str.slice(firstSemi + 1).trim();
      if (unparsed.length === 0) {
        return c;
      }
      const cookie_avs = unparsed.split(";");
      while (cookie_avs.length) {
        const av = cookie_avs.shift().trim();
        if (av.length === 0) {
          continue;
        }
        const av_sep = av.indexOf("=");
        let av_key, av_value;
        if (av_sep === -1) {
          av_key = av;
          av_value = null;
        } else {
          av_key = av.substr(0, av_sep);
          av_value = av.substr(av_sep + 1);
        }
        av_key = av_key.trim().toLowerCase();
        if (av_value) {
          av_value = av_value.trim();
        }
        switch (av_key) {
          case "expires":
            if (av_value) {
              const exp = parseDate(av_value);
              if (exp) {
                c.expires = exp;
              }
            }
            break;
          case "max-age":
            if (av_value) {
              if (/^-?[0-9]+$/.test(av_value)) {
                const delta = parseInt(av_value, 10);
                c.setMaxAge(delta);
              }
            }
            break;
          case "domain":
            if (av_value) {
              const domain = av_value.trim().replace(/^\./, "");
              if (domain) {
                c.domain = domain.toLowerCase();
              }
            }
            break;
          case "path":
            c.path = av_value && av_value[0] === "/" ? av_value : null;
            break;
          case "secure":
            c.secure = true;
            break;
          case "httponly":
            c.httpOnly = true;
            break;
          case "samesite":
            const enforcement = av_value ? av_value.toLowerCase() : "";
            switch (enforcement) {
              case "strict":
                c.sameSite = "strict";
                break;
              case "lax":
                c.sameSite = "lax";
                break;
              case "none":
                c.sameSite = "none";
                break;
              default:
                c.sameSite = void 0;
                break;
            }
            break;
          default:
            c.extensions = c.extensions || [];
            c.extensions.push(av);
            break;
        }
      }
      return c;
    }
    function isSecurePrefixConditionMet(cookie) {
      validators.validate(validators.isObject(cookie), cookie);
      return !cookie.key.startsWith("__Secure-") || cookie.secure;
    }
    function isHostPrefixConditionMet(cookie) {
      validators.validate(validators.isObject(cookie));
      return !cookie.key.startsWith("__Host-") || cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === "/";
    }
    function jsonParse(str) {
      let obj;
      try {
        obj = JSON.parse(str);
      } catch (e) {
        return e;
      }
      return obj;
    }
    function fromJSON(str) {
      if (!str || validators.isEmptyString(str)) {
        return null;
      }
      let obj;
      if (typeof str === "string") {
        obj = jsonParse(str);
        if (obj instanceof Error) {
          return null;
        }
      } else {
        obj = str;
      }
      const c = new Cookie();
      for (let i = 0; i < Cookie.serializableProperties.length; i++) {
        const prop = Cookie.serializableProperties[i];
        if (obj[prop] === void 0 || obj[prop] === cookieDefaults[prop]) {
          continue;
        }
        if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
          if (obj[prop] === null) {
            c[prop] = null;
          } else {
            c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
          }
        } else {
          c[prop] = obj[prop];
        }
      }
      return c;
    }
    function cookieCompare(a, b) {
      validators.validate(validators.isObject(a), a);
      validators.validate(validators.isObject(b), b);
      let cmp = 0;
      const aPathLen = a.path ? a.path.length : 0;
      const bPathLen = b.path ? b.path.length : 0;
      cmp = bPathLen - aPathLen;
      if (cmp !== 0) {
        return cmp;
      }
      const aTime = a.creation ? a.creation.getTime() : MAX_TIME;
      const bTime = b.creation ? b.creation.getTime() : MAX_TIME;
      cmp = aTime - bTime;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = a.creationIndex - b.creationIndex;
      return cmp;
    }
    function permutePath(path) {
      validators.validate(validators.isString(path));
      if (path === "/") {
        return ["/"];
      }
      const permutations = [path];
      while (path.length > 1) {
        const lindex = path.lastIndexOf("/");
        if (lindex === 0) {
          break;
        }
        path = path.substr(0, lindex);
        permutations.push(path);
      }
      permutations.push("/");
      return permutations;
    }
    function getCookieContext(url) {
      if (url instanceof Object) {
        return url;
      }
      try {
        url = decodeURI(url);
      } catch (err) {
      }
      return urlParse(url);
    }
    var cookieDefaults = {
      // the order in which the RFC has them:
      key: "",
      value: "",
      expires: "Infinity",
      maxAge: null,
      domain: null,
      path: null,
      secure: false,
      httpOnly: false,
      extensions: null,
      // set by the CookieJar:
      hostOnly: null,
      pathIsDefault: null,
      creation: null,
      lastAccessed: null,
      sameSite: void 0
    };
    var Cookie = class _Cookie {
      constructor(options = {}) {
        const customInspectSymbol = getCustomInspectSymbol();
        if (customInspectSymbol) {
          this[customInspectSymbol] = this.inspect;
        }
        Object.assign(this, cookieDefaults, options);
        this.creation = this.creation || /* @__PURE__ */ new Date();
        Object.defineProperty(this, "creationIndex", {
          configurable: false,
          enumerable: false,
          // important for assert.deepEqual checks
          writable: true,
          value: ++_Cookie.cookiesCreated
        });
      }
      inspect() {
        const now = Date.now();
        const hostOnly = this.hostOnly != null ? this.hostOnly : "?";
        const createAge = this.creation ? `${now - this.creation.getTime()}ms` : "?";
        const accessAge = this.lastAccessed ? `${now - this.lastAccessed.getTime()}ms` : "?";
        return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
      }
      toJSON() {
        const obj = {};
        for (const prop of _Cookie.serializableProperties) {
          if (this[prop] === cookieDefaults[prop]) {
            continue;
          }
          if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
            if (this[prop] === null) {
              obj[prop] = null;
            } else {
              obj[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString();
            }
          } else if (prop === "maxAge") {
            if (this[prop] !== null) {
              obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
            }
          } else {
            if (this[prop] !== cookieDefaults[prop]) {
              obj[prop] = this[prop];
            }
          }
        }
        return obj;
      }
      clone() {
        return fromJSON(this.toJSON());
      }
      validate() {
        if (!COOKIE_OCTETS.test(this.value)) {
          return false;
        }
        if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
          return false;
        }
        if (this.maxAge != null && this.maxAge <= 0) {
          return false;
        }
        if (this.path != null && !PATH_VALUE.test(this.path)) {
          return false;
        }
        const cdomain = this.cdomain();
        if (cdomain) {
          if (cdomain.match(/\.$/)) {
            return false;
          }
          const suffix = pubsuffix.getPublicSuffix(cdomain);
          if (suffix == null) {
            return false;
          }
        }
        return true;
      }
      setExpires(exp) {
        if (exp instanceof Date) {
          this.expires = exp;
        } else {
          this.expires = parseDate(exp) || "Infinity";
        }
      }
      setMaxAge(age) {
        if (age === Infinity || age === -Infinity) {
          this.maxAge = age.toString();
        } else {
          this.maxAge = age;
        }
      }
      cookieString() {
        let val = this.value;
        if (val == null) {
          val = "";
        }
        if (this.key === "") {
          return val;
        }
        return `${this.key}=${val}`;
      }
      // gives Set-Cookie header format
      toString() {
        let str = this.cookieString();
        if (this.expires != Infinity) {
          if (this.expires instanceof Date) {
            str += `; Expires=${formatDate(this.expires)}`;
          } else {
            str += `; Expires=${this.expires}`;
          }
        }
        if (this.maxAge != null && this.maxAge != Infinity) {
          str += `; Max-Age=${this.maxAge}`;
        }
        if (this.domain && !this.hostOnly) {
          str += `; Domain=${this.domain}`;
        }
        if (this.path) {
          str += `; Path=${this.path}`;
        }
        if (this.secure) {
          str += "; Secure";
        }
        if (this.httpOnly) {
          str += "; HttpOnly";
        }
        if (this.sameSite && this.sameSite !== "none") {
          const ssCanon = _Cookie.sameSiteCanonical[this.sameSite.toLowerCase()];
          str += `; SameSite=${ssCanon ? ssCanon : this.sameSite}`;
        }
        if (this.extensions) {
          this.extensions.forEach((ext) => {
            str += `; ${ext}`;
          });
        }
        return str;
      }
      // TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
      // elsewhere)
      // S5.3 says to give the "latest representable date" for which we use Infinity
      // For "expired" we use 0
      TTL(now) {
        if (this.maxAge != null) {
          return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
        }
        let expires = this.expires;
        if (expires != Infinity) {
          if (!(expires instanceof Date)) {
            expires = parseDate(expires) || Infinity;
          }
          if (expires == Infinity) {
            return Infinity;
          }
          return expires.getTime() - (now || Date.now());
        }
        return Infinity;
      }
      // expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
      // elsewhere)
      expiryTime(now) {
        if (this.maxAge != null) {
          const relativeTo = now || this.creation || /* @__PURE__ */ new Date();
          const age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
          return relativeTo.getTime() + age;
        }
        if (this.expires == Infinity) {
          return Infinity;
        }
        return this.expires.getTime();
      }
      // expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
      // elsewhere), except it returns a Date
      expiryDate(now) {
        const millisec = this.expiryTime(now);
        if (millisec == Infinity) {
          return new Date(MAX_TIME);
        } else if (millisec == -Infinity) {
          return new Date(MIN_TIME);
        } else {
          return new Date(millisec);
        }
      }
      // This replaces the "persistent-flag" parts of S5.3 step 3
      isPersistent() {
        return this.maxAge != null || this.expires != Infinity;
      }
      // Mostly S5.1.2 and S5.2.3:
      canonicalizedDomain() {
        if (this.domain == null) {
          return null;
        }
        return canonicalDomain(this.domain);
      }
      cdomain() {
        return this.canonicalizedDomain();
      }
    };
    Cookie.cookiesCreated = 0;
    Cookie.parse = parse3;
    Cookie.fromJSON = fromJSON;
    Cookie.serializableProperties = Object.keys(cookieDefaults);
    Cookie.sameSiteLevel = {
      strict: 3,
      lax: 2,
      none: 1
    };
    Cookie.sameSiteCanonical = {
      strict: "Strict",
      lax: "Lax"
    };
    function getNormalizedPrefixSecurity(prefixSecurity) {
      if (prefixSecurity != null) {
        const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
        switch (normalizedPrefixSecurity) {
          case PrefixSecurityEnum.STRICT:
          case PrefixSecurityEnum.SILENT:
          case PrefixSecurityEnum.DISABLED:
            return normalizedPrefixSecurity;
        }
      }
      return PrefixSecurityEnum.SILENT;
    }
    var CookieJar = class _CookieJar {
      constructor(store, options = { rejectPublicSuffixes: true }) {
        if (typeof options === "boolean") {
          options = { rejectPublicSuffixes: options };
        }
        validators.validate(validators.isObject(options), options);
        this.rejectPublicSuffixes = options.rejectPublicSuffixes;
        this.enableLooseMode = !!options.looseMode;
        this.allowSpecialUseDomain = typeof options.allowSpecialUseDomain === "boolean" ? options.allowSpecialUseDomain : true;
        this.store = store || new MemoryCookieStore();
        this.prefixSecurity = getNormalizedPrefixSecurity(options.prefixSecurity);
        this._cloneSync = syncWrap("clone");
        this._importCookiesSync = syncWrap("_importCookies");
        this.getCookiesSync = syncWrap("getCookies");
        this.getCookieStringSync = syncWrap("getCookieString");
        this.getSetCookieStringsSync = syncWrap("getSetCookieStrings");
        this.removeAllCookiesSync = syncWrap("removeAllCookies");
        this.setCookieSync = syncWrap("setCookie");
        this.serializeSync = syncWrap("serialize");
      }
      setCookie(cookie, url, options, cb) {
        validators.validate(validators.isUrlStringOrObject(url), cb, options);
        let err;
        if (validators.isFunction(url)) {
          cb = url;
          return cb(new Error("No URL was specified"));
        }
        const context = getCookieContext(url);
        if (validators.isFunction(options)) {
          cb = options;
          options = {};
        }
        validators.validate(validators.isFunction(cb), cb);
        if (!validators.isNonEmptyString(cookie) && !validators.isObject(cookie) && cookie instanceof String && cookie.length == 0) {
          return cb(null);
        }
        const host2 = canonicalDomain(context.hostname);
        const loose = options.loose || this.enableLooseMode;
        let sameSiteContext = null;
        if (options.sameSiteContext) {
          sameSiteContext = checkSameSiteContext(options.sameSiteContext);
          if (!sameSiteContext) {
            return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
          }
        }
        if (typeof cookie === "string" || cookie instanceof String) {
          cookie = Cookie.parse(cookie, { loose });
          if (!cookie) {
            err = new Error("Cookie failed to parse");
            return cb(options.ignoreError ? null : err);
          }
        } else if (!(cookie instanceof Cookie)) {
          err = new Error(
            "First argument to setCookie must be a Cookie object or string"
          );
          return cb(options.ignoreError ? null : err);
        }
        const now = options.now || /* @__PURE__ */ new Date();
        if (this.rejectPublicSuffixes && cookie.domain) {
          const suffix = pubsuffix.getPublicSuffix(cookie.cdomain(), {
            allowSpecialUseDomain: this.allowSpecialUseDomain,
            ignoreError: options.ignoreError
          });
          if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {
            err = new Error("Cookie has domain set to a public suffix");
            return cb(options.ignoreError ? null : err);
          }
        }
        if (cookie.domain) {
          if (!domainMatch(host2, cookie.cdomain(), false)) {
            err = new Error(
              `Cookie not in this host's domain. Cookie:${cookie.cdomain()} Request:${host2}`
            );
            return cb(options.ignoreError ? null : err);
          }
          if (cookie.hostOnly == null) {
            cookie.hostOnly = false;
          }
        } else {
          cookie.hostOnly = true;
          cookie.domain = host2;
        }
        if (!cookie.path || cookie.path[0] !== "/") {
          cookie.path = defaultPath(context.pathname);
          cookie.pathIsDefault = true;
        }
        if (options.http === false && cookie.httpOnly) {
          err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
          return cb(options.ignoreError ? null : err);
        }
        if (cookie.sameSite !== "none" && cookie.sameSite !== void 0 && sameSiteContext) {
          if (sameSiteContext === "none") {
            err = new Error(
              "Cookie is SameSite but this is a cross-origin request"
            );
            return cb(options.ignoreError ? null : err);
          }
        }
        const ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;
        const prefixSecurityDisabled = this.prefixSecurity === PrefixSecurityEnum.DISABLED;
        if (!prefixSecurityDisabled) {
          let errorFound = false;
          let errorMsg;
          if (!isSecurePrefixConditionMet(cookie)) {
            errorFound = true;
            errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
          } else if (!isHostPrefixConditionMet(cookie)) {
            errorFound = true;
            errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
          }
          if (errorFound) {
            return cb(
              options.ignoreError || ignoreErrorForPrefixSecurity ? null : new Error(errorMsg)
            );
          }
        }
        const store = this.store;
        if (!store.updateCookie) {
          store.updateCookie = function(oldCookie, newCookie, cb2) {
            this.putCookie(newCookie, cb2);
          };
        }
        function withCookie(err2, oldCookie) {
          if (err2) {
            return cb(err2);
          }
          const next = function(err3) {
            if (err3) {
              return cb(err3);
            } else {
              cb(null, cookie);
            }
          };
          if (oldCookie) {
            if (options.http === false && oldCookie.httpOnly) {
              err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
              return cb(options.ignoreError ? null : err2);
            }
            cookie.creation = oldCookie.creation;
            cookie.creationIndex = oldCookie.creationIndex;
            cookie.lastAccessed = now;
            store.updateCookie(oldCookie, cookie, next);
          } else {
            cookie.creation = cookie.lastAccessed = now;
            store.putCookie(cookie, next);
          }
        }
        store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
      }
      // RFC6365 S5.4
      getCookies(url, options, cb) {
        validators.validate(validators.isUrlStringOrObject(url), cb, url);
        const context = getCookieContext(url);
        if (validators.isFunction(options)) {
          cb = options;
          options = {};
        }
        validators.validate(validators.isObject(options), cb, options);
        validators.validate(validators.isFunction(cb), cb);
        const host2 = canonicalDomain(context.hostname);
        const path = context.pathname || "/";
        let secure = options.secure;
        if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
          secure = true;
        }
        let sameSiteLevel = 0;
        if (options.sameSiteContext) {
          const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
          sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];
          if (!sameSiteLevel) {
            return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
          }
        }
        let http = options.http;
        if (http == null) {
          http = true;
        }
        const now = options.now || Date.now();
        const expireCheck = options.expire !== false;
        const allPaths = !!options.allPaths;
        const store = this.store;
        function matchingCookie(c) {
          if (c.hostOnly) {
            if (c.domain != host2) {
              return false;
            }
          } else {
            if (!domainMatch(host2, c.domain, false)) {
              return false;
            }
          }
          if (!allPaths && !pathMatch(path, c.path)) {
            return false;
          }
          if (c.secure && !secure) {
            return false;
          }
          if (c.httpOnly && !http) {
            return false;
          }
          if (sameSiteLevel) {
            const cookieLevel = Cookie.sameSiteLevel[c.sameSite || "none"];
            if (cookieLevel > sameSiteLevel) {
              return false;
            }
          }
          if (expireCheck && c.expiryTime() <= now) {
            store.removeCookie(c.domain, c.path, c.key, () => {
            });
            return false;
          }
          return true;
        }
        store.findCookies(
          host2,
          allPaths ? null : path,
          this.allowSpecialUseDomain,
          (err, cookies) => {
            if (err) {
              return cb(err);
            }
            cookies = cookies.filter(matchingCookie);
            if (options.sort !== false) {
              cookies = cookies.sort(cookieCompare);
            }
            const now2 = /* @__PURE__ */ new Date();
            for (const cookie of cookies) {
              cookie.lastAccessed = now2;
            }
            cb(null, cookies);
          }
        );
      }
      getCookieString(...args) {
        const cb = args.pop();
        validators.validate(validators.isFunction(cb), cb);
        const next = function(err, cookies) {
          if (err) {
            cb(err);
          } else {
            cb(
              null,
              cookies.sort(cookieCompare).map((c) => c.cookieString()).join("; ")
            );
          }
        };
        args.push(next);
        this.getCookies.apply(this, args);
      }
      getSetCookieStrings(...args) {
        const cb = args.pop();
        validators.validate(validators.isFunction(cb), cb);
        const next = function(err, cookies) {
          if (err) {
            cb(err);
          } else {
            cb(
              null,
              cookies.map((c) => {
                return c.toString();
              })
            );
          }
        };
        args.push(next);
        this.getCookies.apply(this, args);
      }
      serialize(cb) {
        validators.validate(validators.isFunction(cb), cb);
        let type = this.store.constructor.name;
        if (validators.isObject(type)) {
          type = null;
        }
        const serialized = {
          // The version of tough-cookie that serialized this jar. Generally a good
          // practice since future versions can make data import decisions based on
          // known past behavior. When/if this matters, use `semver`.
          version: `tough-cookie@${VERSION}`,
          // add the store type, to make humans happy:
          storeType: type,
          // CookieJar configuration:
          rejectPublicSuffixes: !!this.rejectPublicSuffixes,
          enableLooseMode: !!this.enableLooseMode,
          allowSpecialUseDomain: !!this.allowSpecialUseDomain,
          prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
          // this gets filled from getAllCookies:
          cookies: []
        };
        if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
          return cb(
            new Error(
              "store does not support getAllCookies and cannot be serialized"
            )
          );
        }
        this.store.getAllCookies((err, cookies) => {
          if (err) {
            return cb(err);
          }
          serialized.cookies = cookies.map((cookie) => {
            cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;
            delete cookie.creationIndex;
            return cookie;
          });
          return cb(null, serialized);
        });
      }
      toJSON() {
        return this.serializeSync();
      }
      // use the class method CookieJar.deserialize instead of calling this directly
      _importCookies(serialized, cb) {
        let cookies = serialized.cookies;
        if (!cookies || !Array.isArray(cookies)) {
          return cb(new Error("serialized jar has no cookies array"));
        }
        cookies = cookies.slice();
        const putNext = (err) => {
          if (err) {
            return cb(err);
          }
          if (!cookies.length) {
            return cb(err, this);
          }
          let cookie;
          try {
            cookie = fromJSON(cookies.shift());
          } catch (e) {
            return cb(e);
          }
          if (cookie === null) {
            return putNext(null);
          }
          this.store.putCookie(cookie, putNext);
        };
        putNext();
      }
      clone(newStore, cb) {
        if (arguments.length === 1) {
          cb = newStore;
          newStore = null;
        }
        this.serialize((err, serialized) => {
          if (err) {
            return cb(err);
          }
          _CookieJar.deserialize(serialized, newStore, cb);
        });
      }
      cloneSync(newStore) {
        if (arguments.length === 0) {
          return this._cloneSync();
        }
        if (!newStore.synchronous) {
          throw new Error(
            "CookieJar clone destination store is not synchronous; use async API instead."
          );
        }
        return this._cloneSync(newStore);
      }
      removeAllCookies(cb) {
        validators.validate(validators.isFunction(cb), cb);
        const store = this.store;
        if (typeof store.removeAllCookies === "function" && store.removeAllCookies !== Store.prototype.removeAllCookies) {
          return store.removeAllCookies(cb);
        }
        store.getAllCookies((err, cookies) => {
          if (err) {
            return cb(err);
          }
          if (cookies.length === 0) {
            return cb(null);
          }
          let completedCount = 0;
          const removeErrors = [];
          function removeCookieCb(removeErr) {
            if (removeErr) {
              removeErrors.push(removeErr);
            }
            completedCount++;
            if (completedCount === cookies.length) {
              return cb(removeErrors.length ? removeErrors[0] : null);
            }
          }
          cookies.forEach((cookie) => {
            store.removeCookie(
              cookie.domain,
              cookie.path,
              cookie.key,
              removeCookieCb
            );
          });
        });
      }
      static deserialize(strOrObj, store, cb) {
        if (arguments.length !== 3) {
          cb = store;
          store = null;
        }
        validators.validate(validators.isFunction(cb), cb);
        let serialized;
        if (typeof strOrObj === "string") {
          serialized = jsonParse(strOrObj);
          if (serialized instanceof Error) {
            return cb(serialized);
          }
        } else {
          serialized = strOrObj;
        }
        const jar = new _CookieJar(store, {
          rejectPublicSuffixes: serialized.rejectPublicSuffixes,
          looseMode: serialized.enableLooseMode,
          allowSpecialUseDomain: serialized.allowSpecialUseDomain,
          prefixSecurity: serialized.prefixSecurity
        });
        jar._importCookies(serialized, (err) => {
          if (err) {
            return cb(err);
          }
          cb(null, jar);
        });
      }
      static deserializeSync(strOrObj, store) {
        const serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
        const jar = new _CookieJar(store, {
          rejectPublicSuffixes: serialized.rejectPublicSuffixes,
          looseMode: serialized.enableLooseMode
        });
        if (!jar.store.synchronous) {
          throw new Error(
            "CookieJar store is not synchronous; use async API instead."
          );
        }
        jar._importCookiesSync(serialized);
        return jar;
      }
    };
    CookieJar.fromJSON = CookieJar.deserializeSync;
    [
      "_importCookies",
      "clone",
      "getCookies",
      "getCookieString",
      "getSetCookieStrings",
      "removeAllCookies",
      "serialize",
      "setCookie"
    ].forEach((name) => {
      CookieJar.prototype[name] = fromCallback(CookieJar.prototype[name]);
    });
    CookieJar.deserialize = fromCallback(CookieJar.deserialize);
    function syncWrap(method) {
      return function(...args) {
        if (!this.store.synchronous) {
          throw new Error(
            "CookieJar store is not synchronous; use async API instead."
          );
        }
        let syncErr, syncResult;
        this[method](...args, (err, result2) => {
          syncErr = err;
          syncResult = result2;
        });
        if (syncErr) {
          throw syncErr;
        }
        return syncResult;
      };
    }
    exports2.version = VERSION;
    exports2.CookieJar = CookieJar;
    exports2.Cookie = Cookie;
    exports2.Store = Store;
    exports2.MemoryCookieStore = MemoryCookieStore;
    exports2.parseDate = parseDate;
    exports2.formatDate = formatDate;
    exports2.parse = parse3;
    exports2.fromJSON = fromJSON;
    exports2.domainMatch = domainMatch;
    exports2.defaultPath = defaultPath;
    exports2.pathMatch = pathMatch;
    exports2.getPublicSuffix = pubsuffix.getPublicSuffix;
    exports2.cookieCompare = cookieCompare;
    exports2.permuteDomain = require_permuteDomain().permuteDomain;
    exports2.permutePath = permutePath;
    exports2.canonicalDomain = canonicalDomain;
    exports2.PrefixSecurityEnum = PrefixSecurityEnum;
    exports2.ParameterError = validators.ParameterError;
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e
        );
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides2 = part.split("=");
        var key = sides2.shift().trimLeft().toLowerCase();
        var value2 = sides2.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else if (key === "partitioned") {
          cookie.partitioned = true;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse3(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module2.exports = parse3;
    module2.exports.parse = parse3;
    module2.exports.parseString = parseString;
    module2.exports.splitCookiesString = splitCookiesString;
  }
});

// node_modules/fetch-cookie/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/fetch-cookie/cjs/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __create2 = Object.create;
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from2, except, desc) => {
      if (from2 && typeof from2 === "object" || typeof from2 === "function") {
        for (let key of __getOwnPropNames2(from2))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc2(from2, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM3 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod2 || !mod2.__esModule ? __defProp3(target, "default", { value: mod2, enumerable: true }) : target,
      mod2
    ));
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod2);
    var src_exports = {};
    __export2(src_exports, {
      default: () => fetchCookie
    });
    module2.exports = __toCommonJS2(src_exports);
    var tough = __toESM3(require_cookie(), 1);
    var import_set_cookie_parser = require_set_cookie();
    function isDomainOrSubdomain(destination, original) {
      const orig = new URL(original).hostname;
      const dest = new URL(destination).hostname;
      return orig === dest || orig.endsWith(`.${dest}`);
    }
    var referrerPolicy = /* @__PURE__ */ new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    function parseReferrerPolicy(policyHeader) {
      const policyTokens = policyHeader.split(/[,\s]+/);
      let policy = "";
      for (const token of policyTokens) {
        if (token !== "" && referrerPolicy.has(token)) {
          policy = token;
        }
      }
      return policy;
    }
    function doNothing(init, name) {
    }
    function callDeleteMethod(init, name) {
      init.headers.delete(name);
    }
    function deleteFromObject(init, name) {
      const headers = init.headers;
      for (const key of Object.keys(headers)) {
        if (key.toLowerCase() === name) {
          delete headers[key];
        }
      }
    }
    function identifyDeleteHeader(init) {
      if (init.headers == null) {
        return doNothing;
      }
      if (typeof init.headers.delete === "function") {
        return callDeleteMethod;
      }
      return deleteFromObject;
    }
    var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    function isRedirect(status) {
      return redirectStatus.has(status);
    }
    async function handleRedirect(fetchImpl, init, response) {
      switch (init.redirect ?? "follow") {
        case "error":
          throw new TypeError(`URI requested responded with a redirect and redirect mode is set to error: ${response.url}`);
        case "manual":
          return response;
        case "follow":
          break;
        default:
          throw new TypeError(`Invalid redirect option: ${init.redirect}`);
      }
      const locationUrl = response.headers.get("location");
      if (locationUrl === null) {
        return response;
      }
      const requestUrl = response.url;
      const redirectUrl = new URL(locationUrl, requestUrl).toString();
      const redirectCount = init.redirectCount ?? 0;
      const maxRedirect = init.maxRedirect ?? 20;
      if (redirectCount >= maxRedirect) {
        throw new TypeError(`Reached maximum redirect of ${maxRedirect} for URL: ${requestUrl}`);
      }
      init = {
        ...init,
        redirectCount: redirectCount + 1
      };
      const deleteHeader = identifyDeleteHeader(init);
      if (!isDomainOrSubdomain(requestUrl, redirectUrl)) {
        for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
          deleteHeader(init, name);
        }
      }
      const maybeNodeStreamBody = init.body;
      const maybeStreamBody = init.body;
      if (response.status !== 303 && init.body != null && (typeof maybeNodeStreamBody.pipe === "function" || typeof maybeStreamBody.pipeTo === "function")) {
        throw new TypeError("Cannot follow redirect with body being a readable stream");
      }
      if (response.status === 303 || (response.status === 301 || response.status === 302) && init.method === "POST") {
        init.method = "GET";
        init.body = void 0;
        deleteHeader(init, "content-length");
      }
      if (response.headers.has("referrer-policy")) {
        init.referrerPolicy = parseReferrerPolicy(response.headers.get("referrer-policy"));
      }
      return await fetchImpl(redirectUrl, init);
    }
    function addCookiesToRequest(input, init, cookie) {
      if (cookie === "") {
        return init;
      }
      const maybeRequest = input;
      const maybeHeaders = init.headers;
      if (maybeRequest.headers && typeof maybeRequest.headers.append === "function") {
        maybeRequest.headers.append("cookie", cookie);
      } else if (maybeHeaders && typeof maybeHeaders.append === "function") {
        maybeHeaders.append("cookie", cookie);
      } else {
        init = { ...init, headers: { ...init.headers, cookie } };
      }
      return init;
    }
    function getCookiesFromResponse(response) {
      const maybeNodeFetchHeaders = response.headers;
      if (typeof maybeNodeFetchHeaders.getAll === "function") {
        return maybeNodeFetchHeaders.getAll("set-cookie");
      }
      if (typeof maybeNodeFetchHeaders.raw === "function") {
        const headers = maybeNodeFetchHeaders.raw();
        if (Array.isArray(headers["set-cookie"])) {
          return headers["set-cookie"];
        }
        return [];
      }
      const cookieString = response.headers.get("set-cookie");
      if (cookieString !== null) {
        return (0, import_set_cookie_parser.splitCookiesString)(cookieString);
      }
      return [];
    }
    function fetchCookie(fetch3, jar, ignoreError = true) {
      const actualFetch = fetch3;
      const actualJar = jar ?? new tough.CookieJar();
      async function fetchCookieWrapper(input, init) {
        const originalInit = init ?? {};
        init = { ...init, redirect: "manual" };
        const requestUrl = typeof input === "string" ? input : input.url ?? input.href;
        const cookie = await actualJar.getCookieString(requestUrl);
        init = addCookiesToRequest(input, init, cookie);
        const response = await actualFetch(input, init);
        const cookies = getCookiesFromResponse(response);
        await Promise.all(cookies.map(async (cookie2) => await actualJar.setCookie(cookie2, response.url, { ignoreError })));
        if ((init.redirectCount ?? 0) > 0) {
          Object.defineProperty(response, "redirected", { value: true });
        }
        if (!isRedirect(response.status)) {
          return response;
        }
        return await handleRedirect(fetchCookieWrapper, originalInit, response);
      }
      fetchCookieWrapper.toughCookie = tough;
      return fetchCookieWrapper;
    }
    fetchCookie.toughCookie = tough;
  }
});

// node_modules/whatwg-fetch/fetch.js
var fetch_exports = {};
__export(fetch_exports, {
  DOMException: () => DOMException,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response,
  fetch: () => fetch2
});
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
function consumed(body) {
  if (body._noBody) return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
      }
    }
  }
}
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split2 = bytes.split("=");
      var name = split2.shift().replace(/\+/g, " ");
      var value = split2.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders2(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
function fetch2(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders2(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
var import_dist811, import_dist812, import_dist813, g, support, viewClasses, isArrayBufferView, methods, redirectStatuses, DOMException;
var init_fetch = __esm({
  "node_modules/whatwg-fetch/fetch.js"() {
    import_dist811 = __toESM(require_dist());
    import_dist812 = __toESM(require_dist2());
    import_dist813 = __toESM(require_dist3());
    g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
    typeof global !== "undefined" && global || {};
    support = {
      searchParams: "URLSearchParams" in g,
      iterable: "Symbol" in g && "iterator" in Symbol,
      blob: "FileReader" in g && "Blob" in g && function() {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: "FormData" in g,
      arrayBuffer: "ArrayBuffer" in g
    };
    if (support.arrayBuffer) {
      viewClasses = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
      ];
      isArrayBufferView = ArrayBuffer.isView || function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }
    Headers.prototype.append = function(name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ", " + value : value;
    };
    Headers.prototype["delete"] = function(name) {
      delete this.map[normalizeName(name)];
    };
    Headers.prototype.get = function(name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null;
    };
    Headers.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };
    Headers.prototype.set = function(name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };
    Headers.prototype.forEach = function(callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };
    Headers.prototype.keys = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };
    Headers.prototype.values = function() {
      var items = [];
      this.forEach(function(value) {
        items.push(value);
      });
      return iteratorFor(items);
    };
    Headers.prototype.entries = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };
    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }
    methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
    Request.prototype.clone = function() {
      return new Request(this, { body: this._bodyInit });
    };
    Body.call(Request.prototype);
    Body.call(Response.prototype);
    Response.prototype.clone = function() {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };
    Response.error = function() {
      var response = new Response(null, { status: 200, statusText: "" });
      response.ok = false;
      response.status = 0;
      response.type = "error";
      return response;
    };
    redirectStatuses = [301, 302, 303, 307, 308];
    Response.redirect = function(url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError("Invalid status code");
      }
      return new Response(null, { status, headers: { location: url } });
    };
    DOMException = g.DOMException;
    try {
      new DOMException();
    } catch (err) {
      DOMException = function(message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
      };
      DOMException.prototype = Object.create(Error.prototype);
      DOMException.prototype.constructor = DOMException;
    }
    fetch2.polyfill = true;
    if (!g.fetch) {
      g.fetch = fetch2;
      g.Headers = Headers;
      g.Request = Request;
      g.Response = Response;
    }
  }
});

// node_modules/isomorphic-fetch/fetch-npm-browserify.js
var require_fetch_npm_browserify = __commonJS({
  "node_modules/isomorphic-fetch/fetch-npm-browserify.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    init_fetch();
    module2.exports = self.fetch.bind(self);
  }
});

// node_modules/ts-mixer/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Mixin: () => Mixin,
  decorate: () => decorate,
  hasMixin: () => hasMixin,
  mix: () => mix,
  settings: () => settings
});
function Mixin(...constructors) {
  var _a2, _b, _c;
  const prototypes = constructors.map((constructor) => constructor.prototype);
  const initFunctionName = settings.initFunction;
  if (initFunctionName !== null) {
    const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
    const combinedInitFunction = function(...args) {
      for (let initFunction of initFunctions)
        initFunction.apply(this, args);
    };
    const extraProto = { [initFunctionName]: combinedInitFunction };
    prototypes.push(extraProto);
  }
  function MixedClass(...args) {
    for (const constructor of constructors)
      copyProps(this, new constructor(...args));
    if (initFunctionName !== null && typeof this[initFunctionName] === "function")
      this[initFunctionName].apply(this, args);
  }
  MixedClass.prototype = settings.prototypeStrategy === "copy" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);
  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === "copy" ? hardMixProtos(constructors, null, ["prototype"]) : proxyMix(constructors, Function.prototype));
  let DecoratedMixedClass = MixedClass;
  if (settings.decoratorInheritance !== "none") {
    const classDecorators = settings.decoratorInheritance === "deep" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);
    for (let decorator of (_a2 = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a2 !== void 0 ? _a2 : []) {
      const result2 = decorator(DecoratedMixedClass);
      if (result2) {
        DecoratedMixedClass = result2;
      }
    }
    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
  }
  registerMixins(DecoratedMixedClass, constructors);
  return DecoratedMixedClass;
}
var import_dist814, import_dist815, import_dist816, copyProps, protoChain, nearestCommonProto, hardMixProtos, unique, getIngredientWithProp, proxyMix, softMixProtos, settings, mixins, getMixinsForClass, registerMixins, hasMixin, mergeObjectsOfDecorators, mergePropertyAndMethodDecorators, mergeDecorators, decorators, findAllConstituentClasses, deepDecoratorSearch, directDecoratorSearch, getDecoratorsForClass, decorateClass, decorateMember, decorate, applyPropAndMethodDecorators, mix;
var init_esm = __esm({
  "node_modules/ts-mixer/dist/esm/index.js"() {
    import_dist814 = __toESM(require_dist());
    import_dist815 = __toESM(require_dist2());
    import_dist816 = __toESM(require_dist3());
    copyProps = (dest, src, exclude = []) => {
      const props = Object.getOwnPropertyDescriptors(src);
      for (let prop of exclude)
        delete props[prop];
      Object.defineProperties(dest, props);
    };
    protoChain = (obj, currentChain = [obj]) => {
      const proto = Object.getPrototypeOf(obj);
      if (proto === null)
        return currentChain;
      return protoChain(proto, [...currentChain, proto]);
    };
    nearestCommonProto = (...objs) => {
      if (objs.length === 0)
        return void 0;
      let commonProto = void 0;
      const protoChains = objs.map((obj) => protoChain(obj));
      while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
        const protos = protoChains.map((protoChain2) => protoChain2.pop());
        const potentialCommonProto = protos[0];
        if (protos.every((proto) => proto === potentialCommonProto))
          commonProto = potentialCommonProto;
        else
          break;
      }
      return commonProto;
    };
    hardMixProtos = (ingredients, constructor, exclude = []) => {
      var _a2;
      const base = (_a2 = nearestCommonProto(...ingredients)) !== null && _a2 !== void 0 ? _a2 : Object.prototype;
      const mixedProto = Object.create(base);
      const visitedProtos = protoChain(base);
      for (let prototype2 of ingredients) {
        let protos = protoChain(prototype2);
        for (let i = protos.length - 1; i >= 0; i--) {
          let newProto = protos[i];
          if (visitedProtos.indexOf(newProto) === -1) {
            copyProps(mixedProto, newProto, ["constructor", ...exclude]);
            visitedProtos.push(newProto);
          }
        }
      }
      mixedProto.constructor = constructor;
      return mixedProto;
    };
    unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
    getIngredientWithProp = (prop, ingredients) => {
      const protoChains = ingredients.map((ingredient) => protoChain(ingredient));
      let protoDepth = 0;
      let protosAreLeftToSearch = true;
      while (protosAreLeftToSearch) {
        protosAreLeftToSearch = false;
        for (let i = ingredients.length - 1; i >= 0; i--) {
          const searchTarget = protoChains[i][protoDepth];
          if (searchTarget !== void 0 && searchTarget !== null) {
            protosAreLeftToSearch = true;
            if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
              return protoChains[i][0];
            }
          }
        }
        protoDepth++;
      }
      return void 0;
    };
    proxyMix = (ingredients, prototype2 = Object.prototype) => new Proxy({}, {
      getPrototypeOf() {
        return prototype2;
      },
      setPrototypeOf() {
        throw Error("Cannot set prototype of Proxies created by ts-mixer");
      },
      getOwnPropertyDescriptor(_, prop) {
        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);
      },
      defineProperty() {
        throw new Error("Cannot define new properties on Proxies created by ts-mixer");
      },
      has(_, prop) {
        return getIngredientWithProp(prop, ingredients) !== void 0 || prototype2[prop] !== void 0;
      },
      get(_, prop) {
        return (getIngredientWithProp(prop, ingredients) || prototype2)[prop];
      },
      set(_, prop, val) {
        const ingredientWithProp = getIngredientWithProp(prop, ingredients);
        if (ingredientWithProp === void 0)
          throw new Error("Cannot set new properties on Proxies created by ts-mixer");
        ingredientWithProp[prop] = val;
        return true;
      },
      deleteProperty() {
        throw new Error("Cannot delete properties on Proxies created by ts-mixer");
      },
      ownKeys() {
        return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
      }
    });
    softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);
    settings = {
      initFunction: null,
      staticsStrategy: "copy",
      prototypeStrategy: "copy",
      decoratorInheritance: "deep"
    };
    mixins = /* @__PURE__ */ new WeakMap();
    getMixinsForClass = (clazz) => mixins.get(clazz);
    registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
    hasMixin = (instance, mixin) => {
      if (instance instanceof mixin)
        return true;
      const constructor = instance.constructor;
      const visited = /* @__PURE__ */ new Set();
      let frontier = /* @__PURE__ */ new Set();
      frontier.add(constructor);
      while (frontier.size > 0) {
        if (frontier.has(mixin))
          return true;
        frontier.forEach((item) => visited.add(item));
        const newFrontier = /* @__PURE__ */ new Set();
        frontier.forEach((item) => {
          var _a2;
          const itemConstituents = (_a2 = mixins.get(item)) !== null && _a2 !== void 0 ? _a2 : protoChain(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
          if (itemConstituents)
            itemConstituents.forEach((constituent) => {
              if (!visited.has(constituent) && !frontier.has(constituent))
                newFrontier.add(constituent);
            });
        });
        frontier = newFrontier;
      }
      return false;
    };
    mergeObjectsOfDecorators = (o1, o2) => {
      var _a2, _b;
      const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
      const mergedObject = {};
      for (let key of allKeys)
        mergedObject[key] = unique([...(_a2 = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a2 !== void 0 ? _a2 : [], ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []]);
      return mergedObject;
    };
    mergePropertyAndMethodDecorators = (d1, d2) => {
      var _a2, _b, _c, _d;
      return {
        property: mergeObjectsOfDecorators((_a2 = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a2 !== void 0 ? _a2 : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
      };
    };
    mergeDecorators = (d1, d2) => {
      var _a2, _b, _c, _d, _e, _f;
      return {
        class: unique([...(_a2 = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a2 !== void 0 ? _a2 : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
      };
    };
    decorators = /* @__PURE__ */ new Map();
    findAllConstituentClasses = (...classes) => {
      var _a2;
      const allClasses = /* @__PURE__ */ new Set();
      const frontier = /* @__PURE__ */ new Set([...classes]);
      while (frontier.size > 0) {
        for (let clazz of frontier) {
          const protoChainClasses = protoChain(clazz.prototype).map((proto) => proto.constructor);
          const mixinClasses = (_a2 = getMixinsForClass(clazz)) !== null && _a2 !== void 0 ? _a2 : [];
          const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
          const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
          for (let newClass of newClasses)
            frontier.add(newClass);
          allClasses.add(clazz);
          frontier.delete(clazz);
        }
      }
      return [...allClasses];
    };
    deepDecoratorSearch = (...classes) => {
      const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
      if (decoratorsForClassChain.length == 0)
        return {};
      if (decoratorsForClassChain.length == 1)
        return decoratorsForClassChain[0];
      return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    directDecoratorSearch = (...classes) => {
      const classDecorators = classes.map((clazz) => getDecoratorsForClass(clazz));
      if (classDecorators.length === 0)
        return {};
      if (classDecorators.length === 1)
        return classDecorators[0];
      return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    getDecoratorsForClass = (clazz) => {
      let decoratorsForClass = decorators.get(clazz);
      if (!decoratorsForClass) {
        decoratorsForClass = {};
        decorators.set(clazz, decoratorsForClass);
      }
      return decoratorsForClass;
    };
    decorateClass = (decorator) => (clazz) => {
      const decoratorsForClass = getDecoratorsForClass(clazz);
      let classDecorators = decoratorsForClass.class;
      if (!classDecorators) {
        classDecorators = [];
        decoratorsForClass.class = classDecorators;
      }
      classDecorators.push(decorator);
      return decorator(clazz);
    };
    decorateMember = (decorator) => (object, key, ...otherArgs) => {
      var _a2, _b, _c;
      const decoratorTargetType = typeof object === "function" ? "static" : "instance";
      const decoratorType = typeof object[key] === "function" ? "method" : "property";
      const clazz = decoratorTargetType === "static" ? object : object.constructor;
      const decoratorsForClass = getDecoratorsForClass(clazz);
      const decoratorsForTargetType = (_a2 = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a2 !== void 0 ? _a2 : {};
      decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
      let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
      decoratorsForTargetType[decoratorType] = decoratorsForType;
      let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
      decoratorsForType[key] = decoratorsForKey;
      decoratorsForKey.push(decorator);
      return decorator(object, key, ...otherArgs);
    };
    decorate = (decorator) => (...args) => {
      if (args.length === 1)
        return decorateClass(decorator)(args[0]);
      return decorateMember(decorator)(...args);
    };
    applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
      const propDecorators = propAndMethodDecorators.property;
      const methodDecorators = propAndMethodDecorators.method;
      if (propDecorators)
        for (let key in propDecorators)
          for (let decorator of propDecorators[key])
            decorator(target, key);
      if (methodDecorators)
        for (let key in methodDecorators)
          for (let decorator of methodDecorators[key])
            decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
    };
    mix = (...ingredients) => (decoratedClass) => {
      const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
      Object.defineProperty(mixedClass, "name", {
        value: decoratedClass.name,
        writable: false
      });
      return mixedClass;
    };
  }
});

// node_modules/url-join/lib/url-join.js
var require_url_join = __commonJS({
  "node_modules/url-join/lib/url-join.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    (function(name, context, definition) {
      if (typeof module2 !== "undefined" && module2.exports) module2.exports = definition();
      else if (typeof define === "function" && define.amd) define(definition);
      else context[name] = definition();
    })("urljoin", exports2, function() {
      function normalize3(strArray) {
        var resultArray = [];
        if (strArray.length === 0) {
          return "";
        }
        if (typeof strArray[0] !== "string") {
          throw new TypeError("Url must be a string. Received " + strArray[0]);
        }
        if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
          var first = strArray.shift();
          strArray[0] = first + strArray[0];
        }
        if (strArray[0].match(/^file:\/\/\//)) {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///");
        } else {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
        }
        for (var i = 0; i < strArray.length; i++) {
          var component = strArray[i];
          if (typeof component !== "string") {
            throw new TypeError("Url must be a string. Received " + component);
          }
          if (component === "") {
            continue;
          }
          if (i > 0) {
            component = component.replace(/^[\/]+/, "");
          }
          if (i < strArray.length - 1) {
            component = component.replace(/[\/]+$/, "");
          } else {
            component = component.replace(/[\/]+$/, "/");
          }
          resultArray.push(component);
        }
        var str = resultArray.join("/");
        str = str.replace(/\/(\?|&|#[^!])/g, "$1");
        var parts = str.split("?");
        str = parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&");
        return str;
      }
      return function() {
        var input;
        if (typeof arguments[0] === "object") {
          input = arguments[0];
        } else {
          input = [].slice.call(arguments);
        }
        return normalize3(input);
      };
    });
  }
});

// node_modules/starknet/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/starknet/dist/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __create2 = Object.create;
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from2, except, desc) => {
      if (from2 && typeof from2 === "object" || typeof from2 === "function") {
        for (let key of __getOwnPropNames2(from2))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp3(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc2(from2, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod2, secondTarget) => (__copyProps2(target, mod2, "default"), secondTarget && __copyProps2(secondTarget, mod2, "default"));
    var __toESM3 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod2 || !mod2.__esModule ? __defProp3(target, "default", { value: mod2, enumerable: true }) : target,
      mod2
    ));
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp3({}, "__esModule", { value: true }), mod2);
    var src_exports = {};
    __export2(src_exports, {
      Account: () => Account,
      AccountInterface: () => AccountInterface,
      BlockStatus: () => BlockStatus,
      BlockTag: () => BlockTag,
      CairoCustomEnum: () => CairoCustomEnum,
      CairoOption: () => CairoOption,
      CairoOptionVariant: () => CairoOptionVariant,
      CairoResult: () => CairoResult,
      CairoResultVariant: () => CairoResultVariant,
      CairoUint256: () => CairoUint256,
      CairoUint512: () => CairoUint512,
      CallData: () => CallData,
      Contract: () => Contract,
      ContractFactory: () => ContractFactory,
      ContractInterface: () => ContractInterface,
      CustomError: () => CustomError,
      EntryPointType: () => EntryPointType,
      EthSigner: () => EthSigner,
      GatewayError: () => GatewayError,
      HttpError: () => HttpError,
      LibraryError: () => LibraryError,
      Literal: () => Literal,
      Provider: () => RpcProvider2,
      ProviderInterface: () => ProviderInterface,
      RPC: () => api_exports,
      RPC06: () => rpc_0_6_exports,
      RPC07: () => rpc_0_7_exports,
      RPCResponseParser: () => RPCResponseParser,
      ReceiptTx: () => ReceiptTx,
      ResponseParser: () => ResponseParser,
      RpcChannel: () => RpcChannel2,
      RpcProvider: () => RpcProvider2,
      Signer: () => Signer,
      SignerInterface: () => SignerInterface,
      TransactionExecutionStatus: () => TransactionExecutionStatus,
      TransactionFinalityStatus: () => TransactionFinalityStatus,
      TransactionStatus: () => TransactionStatus,
      TransactionType: () => TransactionType,
      TypedDataRevision: () => import_starknet_types_07.TypedDataRevision,
      UINT_128_MAX: () => UINT_128_MAX,
      UINT_128_MIN: () => UINT_128_MIN,
      UINT_256_HIGH_MAX: () => UINT_256_HIGH_MAX,
      UINT_256_HIGH_MIN: () => UINT_256_HIGH_MIN,
      UINT_256_LOW_MAX: () => UINT_256_LOW_MAX,
      UINT_256_LOW_MIN: () => UINT_256_LOW_MIN,
      UINT_256_MAX: () => UINT_256_MAX,
      UINT_256_MIN: () => UINT_256_MIN,
      UINT_512_MAX: () => UINT_512_MAX,
      UINT_512_MIN: () => UINT_512_MIN,
      Uint: () => Uint,
      ValidateType: () => ValidateType,
      WalletAccount: () => WalletAccount,
      addAddressPadding: () => addAddressPadding,
      buildUrl: () => buildUrl,
      byteArray: () => byteArray_exports,
      cairo: () => cairo_exports,
      constants: () => constants_exports,
      contractClassResponseToLegacyCompiledContract: () => contractClassResponseToLegacyCompiledContract,
      defaultProvider: () => defaultProvider,
      ec: () => ec_exports,
      encode: () => encode_exports,
      eth: () => eth_exports,
      events: () => events_exports,
      extractContractHashes: () => extractContractHashes,
      fixProto: () => fixProto,
      fixStack: () => fixStack,
      getCalldata: () => getCalldata,
      getChecksumAddress: () => getChecksumAddress2,
      hash: () => hash_exports,
      isSierra: () => isSierra,
      isUrl: () => isUrl,
      json: () => json_exports,
      merkle: () => merkle_exports,
      num: () => num_exports,
      number: () => number,
      parseCalldataField: () => parseCalldataField,
      provider: () => provider_exports,
      selector: () => selector_exports,
      shortString: () => shortString_exports,
      splitArgsAndOptions: () => splitArgsAndOptions,
      stark: () => stark_exports,
      starknetId: () => starknetId_exports,
      transaction: () => transaction_exports,
      typedData: () => typedData_exports,
      types: () => types_exports,
      uint256: () => uint256_exports,
      v2hash: () => v2_exports,
      v3hash: () => v3_exports,
      validateAndParseAddress: () => validateAndParseAddress,
      validateChecksumAddress: () => validateChecksumAddress,
      wallet: () => connect_exports
    });
    module2.exports = __toCommonJS2(src_exports);
    var constants_exports = {};
    __export2(constants_exports, {
      ADDR_BOUND: () => ADDR_BOUND,
      API_VERSION: () => API_VERSION,
      BaseUrl: () => BaseUrl,
      FeeMarginPercentage: () => FeeMarginPercentage,
      IS_BROWSER: () => IS_BROWSER,
      MASK_250: () => MASK_250,
      MAX_STORAGE_ITEM_SIZE: () => MAX_STORAGE_ITEM_SIZE,
      NetworkName: () => NetworkName,
      PRIME: () => PRIME,
      RANGE_FELT: () => RANGE_FELT,
      RANGE_I128: () => RANGE_I128,
      RANGE_U128: () => RANGE_U128,
      RPC_DEFAULT_VERSION: () => RPC_DEFAULT_VERSION,
      RPC_NODES: () => RPC_NODES,
      StarknetChainId: () => StarknetChainId,
      TEXT_TO_FELT_MAX_LEN: () => TEXT_TO_FELT_MAX_LEN,
      TRANSACTION_VERSION: () => api_exports.ETransactionVersion,
      TransactionHashPrefix: () => TransactionHashPrefix,
      UDC: () => UDC,
      ZERO: () => ZERO2
    });
    var api_exports = {};
    __export2(api_exports, {
      JRPC: () => jsonrpc_exports,
      RPCSPEC06: () => rpcspec_0_6_exports,
      RPCSPEC07: () => RPCSPEC07
    });
    var jsonrpc_exports = {};
    var rpcspec_0_6_exports = {};
    __export2(rpcspec_0_6_exports, {
      EBlockTag: () => EBlockTag,
      EDAMode: () => EDAMode,
      EDataAvailabilityMode: () => EDataAvailabilityMode,
      ESimulationFlag: () => ESimulationFlag,
      ETransactionExecutionStatus: () => ETransactionExecutionStatus,
      ETransactionFinalityStatus: () => ETransactionFinalityStatus,
      ETransactionStatus: () => ETransactionStatus,
      ETransactionType: () => ETransactionType,
      ETransactionVersion: () => ETransactionVersion,
      ETransactionVersion2: () => ETransactionVersion2,
      ETransactionVersion3: () => ETransactionVersion3,
      Errors: () => errors_exports,
      SPEC: () => components_exports
    });
    var errors_exports = {};
    var components_exports = {};
    var ETransactionType = ((ETransactionType2) => {
      ETransactionType2["DECLARE"] = "DECLARE";
      ETransactionType2["DEPLOY"] = "DEPLOY";
      ETransactionType2["DEPLOY_ACCOUNT"] = "DEPLOY_ACCOUNT";
      ETransactionType2["INVOKE"] = "INVOKE";
      ETransactionType2["L1_HANDLER"] = "L1_HANDLER";
      return ETransactionType2;
    })(ETransactionType || {});
    var ESimulationFlag = ((ESimulationFlag2) => {
      ESimulationFlag2["SKIP_VALIDATE"] = "SKIP_VALIDATE";
      ESimulationFlag2["SKIP_FEE_CHARGE"] = "SKIP_FEE_CHARGE";
      return ESimulationFlag2;
    })(ESimulationFlag || {});
    var ETransactionStatus = ((ETransactionStatus2) => {
      ETransactionStatus2["RECEIVED"] = "RECEIVED";
      ETransactionStatus2["REJECTED"] = "REJECTED";
      ETransactionStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
      ETransactionStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
      return ETransactionStatus2;
    })(ETransactionStatus || {});
    var ETransactionFinalityStatus = ((ETransactionFinalityStatus2) => {
      ETransactionFinalityStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
      ETransactionFinalityStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
      return ETransactionFinalityStatus2;
    })(ETransactionFinalityStatus || {});
    var ETransactionExecutionStatus = ((ETransactionExecutionStatus2) => {
      ETransactionExecutionStatus2["SUCCEEDED"] = "SUCCEEDED";
      ETransactionExecutionStatus2["REVERTED"] = "REVERTED";
      return ETransactionExecutionStatus2;
    })(ETransactionExecutionStatus || {});
    var EBlockTag = ((EBlockTag2) => {
      EBlockTag2["PENDING"] = "pending";
      EBlockTag2["LATEST"] = "latest";
      return EBlockTag2;
    })(EBlockTag || {});
    var EDataAvailabilityMode = ((EDataAvailabilityMode3) => {
      EDataAvailabilityMode3["L1"] = "L1";
      EDataAvailabilityMode3["L2"] = "L2";
      return EDataAvailabilityMode3;
    })(EDataAvailabilityMode || {});
    var EDAMode = ((EDAMode4) => {
      EDAMode4[EDAMode4["L1"] = 0] = "L1";
      EDAMode4[EDAMode4["L2"] = 1] = "L2";
      return EDAMode4;
    })(EDAMode || {});
    var ETransactionVersion = ((ETransactionVersion10) => {
      ETransactionVersion10["V0"] = "0x0";
      ETransactionVersion10["V1"] = "0x1";
      ETransactionVersion10["V2"] = "0x2";
      ETransactionVersion10["V3"] = "0x3";
      ETransactionVersion10["F0"] = "0x100000000000000000000000000000000";
      ETransactionVersion10["F1"] = "0x100000000000000000000000000000001";
      ETransactionVersion10["F2"] = "0x100000000000000000000000000000002";
      ETransactionVersion10["F3"] = "0x100000000000000000000000000000003";
      return ETransactionVersion10;
    })(ETransactionVersion || {});
    var ETransactionVersion2 = ((ETransactionVersion25) => {
      ETransactionVersion25["V0"] = "0x0";
      ETransactionVersion25["V1"] = "0x1";
      ETransactionVersion25["V2"] = "0x2";
      ETransactionVersion25["F0"] = "0x100000000000000000000000000000000";
      ETransactionVersion25["F1"] = "0x100000000000000000000000000000001";
      ETransactionVersion25["F2"] = "0x100000000000000000000000000000002";
      return ETransactionVersion25;
    })(ETransactionVersion2 || {});
    var ETransactionVersion3 = ((ETransactionVersion36) => {
      ETransactionVersion36["V3"] = "0x3";
      ETransactionVersion36["F3"] = "0x100000000000000000000000000000003";
      return ETransactionVersion36;
    })(ETransactionVersion3 || {});
    var RPCSPEC07 = __toESM3(require_cjs());
    __reExport(api_exports, require_cjs());
    var encode_exports = {};
    __export2(encode_exports, {
      IS_BROWSER: () => IS_BROWSER,
      addHexPrefix: () => addHexPrefix,
      arrayBufferToString: () => arrayBufferToString,
      atobUniversal: () => atobUniversal,
      btoaUniversal: () => btoaUniversal,
      buf2hex: () => buf2hex,
      calcByteLength: () => calcByteLength,
      padLeft: () => padLeft,
      pascalToSnake: () => pascalToSnake,
      removeHexPrefix: () => removeHexPrefix,
      sanitizeBytes: () => sanitizeBytes,
      sanitizeHex: () => sanitizeHex,
      stringToArrayBuffer: () => stringToArrayBuffer,
      utf8ToArray: () => utf8ToArray
    });
    var import_base = require_lib();
    var IS_BROWSER = typeof window !== "undefined";
    var STRING_ZERO = "0";
    function arrayBufferToString(array) {
      return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), "");
    }
    function utf8ToArray(str) {
      return new TextEncoder().encode(str);
    }
    function stringToArrayBuffer(str) {
      return utf8ToArray(str);
    }
    function atobUniversal(a) {
      return import_base.base64.decode(a);
    }
    function btoaUniversal(b) {
      return import_base.base64.encode(new Uint8Array(b));
    }
    function buf2hex(buffer) {
      return buffer.reduce((r2, x) => r2 + x.toString(16).padStart(2, "0"), "");
    }
    function removeHexPrefix(hex) {
      return hex.replace(/^0x/i, "");
    }
    function addHexPrefix(hex) {
      return `0x${removeHexPrefix(hex)}`;
    }
    function padString(str, length, left, padding = STRING_ZERO) {
      const diff = length - str.length;
      let result2 = str;
      if (diff > 0) {
        const pad = padding.repeat(diff);
        result2 = left ? pad + str : str + pad;
      }
      return result2;
    }
    function padLeft(str, length, padding = STRING_ZERO) {
      return padString(str, length, true, padding);
    }
    function calcByteLength(str, byteSize = 8) {
      const { length } = str;
      const remainder = length % byteSize;
      return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
    }
    function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
      return padLeft(str, calcByteLength(str, byteSize), padding);
    }
    function sanitizeHex(hex) {
      hex = removeHexPrefix(hex);
      hex = sanitizeBytes(hex, 2);
      if (hex) {
        hex = addHexPrefix(hex);
      }
      return hex;
    }
    var pascalToSnake = (text) => /[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join("_").toUpperCase() : text;
    var TEXT_TO_FELT_MAX_LEN = 31;
    var ZERO2 = 0n;
    var MASK_250 = 2n ** 250n - 1n;
    var API_VERSION = ZERO2;
    var PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;
    var MAX_STORAGE_ITEM_SIZE = 256n;
    var ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;
    var range = (min2, max2) => ({ min: min2, max: max2 });
    var RANGE_FELT = range(ZERO2, PRIME - 1n);
    var RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);
    var RANGE_U128 = range(ZERO2, 2n ** 128n - 1n);
    var BaseUrl = ((BaseUrl2) => {
      BaseUrl2["SN_MAIN"] = "https://alpha-mainnet.starknet.io";
      BaseUrl2["SN_SEPOLIA"] = "https://alpha-sepolia.starknet.io";
      return BaseUrl2;
    })(BaseUrl || {});
    var NetworkName = ((NetworkName2) => {
      NetworkName2["SN_MAIN"] = "SN_MAIN";
      NetworkName2["SN_SEPOLIA"] = "SN_SEPOLIA";
      return NetworkName2;
    })(NetworkName || {});
    var StarknetChainId = ((StarknetChainId6) => {
      StarknetChainId6["SN_MAIN"] = "0x534e5f4d41494e";
      StarknetChainId6["SN_SEPOLIA"] = "0x534e5f5345504f4c4941";
      return StarknetChainId6;
    })(StarknetChainId || {});
    var TransactionHashPrefix = ((TransactionHashPrefix2) => {
      TransactionHashPrefix2["DECLARE"] = "0x6465636c617265";
      TransactionHashPrefix2["DEPLOY"] = "0x6465706c6f79";
      TransactionHashPrefix2["DEPLOY_ACCOUNT"] = "0x6465706c6f795f6163636f756e74";
      TransactionHashPrefix2["INVOKE"] = "0x696e766f6b65";
      TransactionHashPrefix2["L1_HANDLER"] = "0x6c315f68616e646c6572";
      return TransactionHashPrefix2;
    })(TransactionHashPrefix || {});
    var FeeMarginPercentage = ((FeeMarginPercentage2) => {
      FeeMarginPercentage2[FeeMarginPercentage2["L1_BOUND_MAX_AMOUNT"] = 50] = "L1_BOUND_MAX_AMOUNT";
      FeeMarginPercentage2[FeeMarginPercentage2["L1_BOUND_MAX_PRICE_PER_UNIT"] = 50] = "L1_BOUND_MAX_PRICE_PER_UNIT";
      FeeMarginPercentage2[FeeMarginPercentage2["MAX_FEE"] = 50] = "MAX_FEE";
      return FeeMarginPercentage2;
    })(FeeMarginPercentage || {});
    var UDC = {
      ADDRESS: "0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",
      ENTRYPOINT: "deployContract"
    };
    var RPC_DEFAULT_VERSION = "v0_7";
    var RPC_NODES = {
      SN_MAIN: [
        `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,
        `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`
      ],
      SN_SEPOLIA: [
        `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,
        `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`
      ]
    };
    var import_utils22 = require_utils4();
    var import_sha3 = require_sha32();
    var rpc_0_6_exports = {};
    __export2(rpc_0_6_exports, {
      RpcChannel: () => RpcChannel
    });
    function fixStack(target, fn = target.constructor) {
      const { captureStackTrace } = Error;
      captureStackTrace && captureStackTrace(target, fn);
    }
    function fixProto(target, prototype2) {
      const { setPrototypeOf: setPrototypeOf2 } = Object;
      setPrototypeOf2 ? setPrototypeOf2(target, prototype2) : target.__proto__ = prototype2;
    }
    var CustomError = class extends Error {
      constructor(message) {
        super(message);
        __publicField(this, "name");
        Object.defineProperty(this, "name", {
          value: new.target.name,
          enumerable: false,
          configurable: true
        });
        fixProto(this, new.target.prototype);
        fixStack(this);
      }
    };
    var LibraryError = class extends CustomError {
    };
    var GatewayError = class extends LibraryError {
      constructor(message, errorCode) {
        super(message);
        this.errorCode = errorCode;
      }
    };
    var HttpError = class extends LibraryError {
      constructor(message, errorCode) {
        super(message);
        this.errorCode = errorCode;
      }
    };
    var types_exports = {};
    __export2(types_exports, {
      BlockStatus: () => BlockStatus,
      BlockTag: () => BlockTag,
      EntryPointType: () => EntryPointType,
      Literal: () => Literal,
      RPC: () => api_exports,
      TransactionExecutionStatus: () => TransactionExecutionStatus,
      TransactionFinalityStatus: () => TransactionFinalityStatus,
      TransactionStatus: () => TransactionStatus,
      TransactionType: () => TransactionType,
      TypedDataRevision: () => import_starknet_types_07.TypedDataRevision,
      Uint: () => Uint,
      ValidateType: () => ValidateType
    });
    var ValidateType = ((ValidateType2) => {
      ValidateType2["DEPLOY"] = "DEPLOY";
      ValidateType2["CALL"] = "CALL";
      ValidateType2["INVOKE"] = "INVOKE";
      return ValidateType2;
    })(ValidateType || {});
    var Uint = ((Uint2) => {
      Uint2["u8"] = "core::integer::u8";
      Uint2["u16"] = "core::integer::u16";
      Uint2["u32"] = "core::integer::u32";
      Uint2["u64"] = "core::integer::u64";
      Uint2["u128"] = "core::integer::u128";
      Uint2["u256"] = "core::integer::u256";
      Uint2["u512"] = "core::integer::u512";
      return Uint2;
    })(Uint || {});
    var Literal = ((Literal2) => {
      Literal2["ClassHash"] = "core::starknet::class_hash::ClassHash";
      Literal2["ContractAddress"] = "core::starknet::contract_address::ContractAddress";
      Literal2["Secp256k1Point"] = "core::starknet::secp256k1::Secp256k1Point";
      return Literal2;
    })(Literal || {});
    var EntryPointType = ((EntryPointType2) => {
      EntryPointType2["EXTERNAL"] = "EXTERNAL";
      EntryPointType2["L1_HANDLER"] = "L1_HANDLER";
      EntryPointType2["CONSTRUCTOR"] = "CONSTRUCTOR";
      return EntryPointType2;
    })(EntryPointType || {});
    var TransactionType = ((TransactionType2) => {
      TransactionType2["DECLARE"] = "DECLARE";
      TransactionType2["DEPLOY"] = "DEPLOY";
      TransactionType2["DEPLOY_ACCOUNT"] = "DEPLOY_ACCOUNT";
      TransactionType2["INVOKE"] = "INVOKE_FUNCTION";
      return TransactionType2;
    })(TransactionType || {});
    var TransactionStatus = ((TransactionStatus2) => {
      TransactionStatus2["NOT_RECEIVED"] = "NOT_RECEIVED";
      TransactionStatus2["RECEIVED"] = "RECEIVED";
      TransactionStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
      TransactionStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
      TransactionStatus2["REJECTED"] = "REJECTED";
      TransactionStatus2["REVERTED"] = "REVERTED";
      return TransactionStatus2;
    })(TransactionStatus || {});
    var TransactionFinalityStatus = ((TransactionFinalityStatus2) => {
      TransactionFinalityStatus2["NOT_RECEIVED"] = "NOT_RECEIVED";
      TransactionFinalityStatus2["RECEIVED"] = "RECEIVED";
      TransactionFinalityStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
      TransactionFinalityStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
      return TransactionFinalityStatus2;
    })(TransactionFinalityStatus || {});
    var TransactionExecutionStatus = ((TransactionExecutionStatus2) => {
      TransactionExecutionStatus2["REJECTED"] = "REJECTED";
      TransactionExecutionStatus2["REVERTED"] = "REVERTED";
      TransactionExecutionStatus2["SUCCEEDED"] = "SUCCEEDED";
      return TransactionExecutionStatus2;
    })(TransactionExecutionStatus || {});
    var BlockStatus = ((BlockStatus2) => {
      BlockStatus2["PENDING"] = "PENDING";
      BlockStatus2["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
      BlockStatus2["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
      BlockStatus2["REJECTED"] = "REJECTED";
      return BlockStatus2;
    })(BlockStatus || {});
    var BlockTag = ((BlockTag2) => {
      BlockTag2["PENDING"] = "pending";
      BlockTag2["LATEST"] = "latest";
      return BlockTag2;
    })(BlockTag || {});
    var import_starknet_types_07 = require_cjs();
    function assert5(condition, message) {
      if (!condition) {
        throw new Error(message || "Assertion failure");
      }
    }
    var num_exports = {};
    __export2(num_exports, {
      addPercent: () => addPercent,
      assertInRange: () => assertInRange,
      bigNumberishArrayToDecimalStringArray: () => bigNumberishArrayToDecimalStringArray,
      bigNumberishArrayToHexadecimalStringArray: () => bigNumberishArrayToHexadecimalStringArray,
      cleanHex: () => cleanHex,
      getDecimalString: () => getDecimalString,
      getHexString: () => getHexString,
      getHexStringArray: () => getHexStringArray,
      hexToBytes: () => hexToBytes,
      hexToDecimalString: () => hexToDecimalString,
      isBigInt: () => isBigInt,
      isBoolean: () => isBoolean,
      isHex: () => isHex,
      isNumber: () => isNumber2,
      isStringWholeNumber: () => isStringWholeNumber,
      toBigInt: () => toBigInt,
      toCairoBool: () => toCairoBool,
      toHex: () => toHex2,
      toHexString: () => toHexString,
      toStorageKey: () => toStorageKey
    });
    var import_utils16 = require_utils4();
    function isHex(hex) {
      return /^0x[0-9a-f]*$/i.test(hex);
    }
    function toBigInt(value) {
      return BigInt(value);
    }
    function isBigInt(value) {
      return typeof value === "bigint";
    }
    function toHex2(value) {
      return addHexPrefix(toBigInt(value).toString(16));
    }
    var toHexString = toHex2;
    function toStorageKey(number2) {
      return addHexPrefix(toBigInt(number2).toString(16).padStart(64, "0"));
    }
    function hexToDecimalString(hex) {
      return BigInt(addHexPrefix(hex)).toString(10);
    }
    function cleanHex(hex) {
      return hex.toLowerCase().replace(/^(0x)0+/, "$1");
    }
    function assertInRange(input, lowerBound, upperBound, inputName = "") {
      const messageSuffix = inputName === "" ? "invalid length" : `invalid ${inputName} length`;
      const inputBigInt = BigInt(input);
      const lowerBoundBigInt = BigInt(lowerBound);
      const upperBoundBigInt = BigInt(upperBound);
      assert5(
        inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,
        `Message not signable, ${messageSuffix}.`
      );
    }
    function bigNumberishArrayToDecimalStringArray(data) {
      return data.map((x) => toBigInt(x).toString(10));
    }
    function bigNumberishArrayToHexadecimalStringArray(data) {
      return data.map((x) => toHex2(x));
    }
    function isStringWholeNumber(str) {
      return /^\d+$/.test(str);
    }
    function getDecimalString(str) {
      if (isHex(str)) {
        return hexToDecimalString(str);
      }
      if (isStringWholeNumber(str)) {
        return str;
      }
      throw new Error(`${str} needs to be a hex-string or whole-number-string`);
    }
    function getHexString(str) {
      if (isHex(str)) {
        return str;
      }
      if (isStringWholeNumber(str)) {
        return toHexString(str);
      }
      throw new Error(`${str} needs to be a hex-string or whole-number-string`);
    }
    function getHexStringArray(array) {
      return array.map(getHexString);
    }
    function toCairoBool(value) {
      return (+value).toString();
    }
    function hexToBytes(str) {
      if (!isHex(str))
        throw new Error(`${str} needs to be a hex-string`);
      let adaptedValue = removeHexPrefix(str);
      if (adaptedValue.length % 2 !== 0) {
        adaptedValue = `0${adaptedValue}`;
      }
      return (0, import_utils16.hexToBytes)(adaptedValue);
    }
    function addPercent(number2, percent) {
      const bigIntNum = BigInt(number2);
      return bigIntNum + bigIntNum * BigInt(percent) / 100n;
    }
    function isNumber2(value) {
      return typeof value === "number";
    }
    function isBoolean(value) {
      return typeof value === "boolean";
    }
    var selector_exports = {};
    __export2(selector_exports, {
      getSelector: () => getSelector,
      getSelectorFromName: () => getSelectorFromName,
      keccakBn: () => keccakBn,
      starknetKeccak: () => starknetKeccak
    });
    var import_starknet = require_lib2();
    function keccakBn(value) {
      const hexWithoutPrefix = removeHexPrefix(toHex2(BigInt(value)));
      const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;
      return addHexPrefix((0, import_starknet.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));
    }
    function keccakHex(str) {
      return addHexPrefix((0, import_starknet.keccak)(utf8ToArray(str)).toString(16));
    }
    function starknetKeccak(str) {
      const hash2 = BigInt(keccakHex(str));
      return hash2 & MASK_250;
    }
    function getSelectorFromName(funcName) {
      return toHex2(starknetKeccak(funcName));
    }
    function getSelector(value) {
      if (isHex(value)) {
        return value;
      }
      if (isStringWholeNumber(value)) {
        return toHexString(value);
      }
      return getSelectorFromName(value);
    }
    var shortString_exports = {};
    __export2(shortString_exports, {
      decodeShortString: () => decodeShortString,
      encodeShortString: () => encodeShortString,
      isASCII: () => isASCII,
      isDecimalString: () => isDecimalString,
      isLongText: () => isLongText,
      isShortString: () => isShortString,
      isShortText: () => isShortText,
      isString: () => isString,
      isText: () => isText,
      splitLongString: () => splitLongString
    });
    function isASCII(str) {
      return /^[\x00-\x7F]*$/.test(str);
    }
    function isShortString(str) {
      return str.length <= TEXT_TO_FELT_MAX_LEN;
    }
    function isDecimalString(str) {
      return /^[0-9]*$/i.test(str);
    }
    function isString(value) {
      return typeof value === "string";
    }
    function isText(val) {
      return isString(val) && !isHex(val) && !isStringWholeNumber(val);
    }
    var isShortText = (val) => isText(val) && isShortString(val);
    var isLongText = (val) => isText(val) && !isShortString(val);
    function splitLongString(longStr) {
      const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, "g");
      return longStr.match(regex) || [];
    }
    function encodeShortString(str) {
      if (!isASCII(str))
        throw new Error(`${str} is not an ASCII string`);
      if (!isShortString(str))
        throw new Error(`${str} is too long`);
      return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));
    }
    function decodeShortString(str) {
      if (!isASCII(str))
        throw new Error(`${str} is not an ASCII string`);
      if (isHex(str)) {
        return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));
      }
      if (isDecimalString(str)) {
        return decodeShortString("0X".concat(BigInt(str).toString(16)));
      }
      throw new Error(`${str} is not Hex or decimal`);
    }
    var byteArray_exports = {};
    __export2(byteArray_exports, {
      byteArrayFromString: () => byteArrayFromString,
      stringFromByteArray: () => stringFromByteArray
    });
    function stringFromByteArray(myByteArray) {
      const pending_word = BigInt(myByteArray.pending_word) === 0n ? "" : decodeShortString(toHex2(myByteArray.pending_word));
      return myByteArray.data.reduce((cumuledString, encodedString) => {
        const add2 = BigInt(encodedString) === 0n ? "" : decodeShortString(toHex2(encodedString));
        return cumuledString + add2;
      }, "") + pending_word;
    }
    function byteArrayFromString(targetString) {
      const shortStrings = splitLongString(targetString);
      const remainder = shortStrings[shortStrings.length - 1];
      const shortStringsEncoded = shortStrings.map(encodeShortString);
      const [pendingWord, pendingWordLength] = remainder === void 0 || remainder.length === 31 ? ["0x00", 0] : [shortStringsEncoded.pop(), remainder.length];
      return {
        data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,
        pending_word: pendingWord,
        pending_word_len: pendingWordLength
      };
    }
    var cairo_exports = {};
    __export2(cairo_exports, {
      felt: () => felt,
      getAbiContractVersion: () => getAbiContractVersion,
      getArrayType: () => getArrayType,
      isCairo1Abi: () => isCairo1Abi,
      isCairo1Type: () => isCairo1Type,
      isLen: () => isLen,
      isTypeArray: () => isTypeArray,
      isTypeBool: () => isTypeBool,
      isTypeByteArray: () => isTypeByteArray,
      isTypeBytes31: () => isTypeBytes31,
      isTypeContractAddress: () => isTypeContractAddress,
      isTypeEnum: () => isTypeEnum,
      isTypeEthAddress: () => isTypeEthAddress,
      isTypeFelt: () => isTypeFelt,
      isTypeLiteral: () => isTypeLiteral,
      isTypeNamedTuple: () => isTypeNamedTuple,
      isTypeNonZero: () => isTypeNonZero,
      isTypeOption: () => isTypeOption,
      isTypeResult: () => isTypeResult,
      isTypeSecp256k1Point: () => isTypeSecp256k1Point,
      isTypeStruct: () => isTypeStruct,
      isTypeTuple: () => isTypeTuple,
      isTypeUint: () => isTypeUint,
      isTypeUint256: () => isTypeUint256,
      tuple: () => tuple,
      uint256: () => uint256,
      uint512: () => uint512
    });
    function CairoFelt(it) {
      if (isBigInt(it) || Number.isInteger(it)) {
        return it.toString();
      }
      if (isString(it)) {
        if (isHex(it)) {
          return BigInt(it).toString();
        }
        if (isText(it)) {
          if (!isShortString(it)) {
            throw new Error(
              `${it} is a long string > 31 chars. Please split it into an array of short strings.`
            );
          }
          return BigInt(encodeShortString(it)).toString();
        }
        if (isStringWholeNumber(it)) {
          return it;
        }
      }
      if (isBoolean(it)) {
        return `${+it}`;
      }
      throw new Error(`${it} can't be computed by felt()`);
    }
    var UINT_128_MAX = (1n << 128n) - 1n;
    var UINT_256_MAX = (1n << 256n) - 1n;
    var UINT_256_MIN = 0n;
    var UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;
    var UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;
    var UINT_256_LOW_MIN = 0n;
    var UINT_256_HIGH_MIN = 0n;
    var _a2;
    var CairoUint256 = (_a2 = class {
      constructor(...arr) {
        __publicField(this, "low");
        __publicField(this, "high");
        if (typeof arr[0] === "object" && arr.length === 1 && "low" in arr[0] && "high" in arr[0]) {
          const props = _a2.validateProps(arr[0].low, arr[0].high);
          this.low = props.low;
          this.high = props.high;
        } else if (arr.length === 1) {
          const bigInt = _a2.validate(arr[0]);
          this.low = bigInt & UINT_128_MAX;
          this.high = bigInt >> 128n;
        } else if (arr.length === 2) {
          const props = _a2.validateProps(arr[0], arr[1]);
          this.low = props.low;
          this.high = props.high;
        } else {
          throw Error("Incorrect constructor parameters");
        }
      }
      /**
       * Validate if BigNumberish can be represented as Unit256
       */
      static validate(bigNumberish) {
        const bigInt = BigInt(bigNumberish);
        if (bigInt < UINT_256_MIN)
          throw Error("bigNumberish is smaller than UINT_256_MIN");
        if (bigInt > UINT_256_MAX)
          throw new Error("bigNumberish is bigger than UINT_256_MAX");
        return bigInt;
      }
      /**
       * Validate if low and high can be represented as Unit256
       */
      static validateProps(low, high) {
        const bigIntLow = BigInt(low);
        const bigIntHigh = BigInt(high);
        if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {
          throw new Error("low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX");
        }
        if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {
          throw new Error("high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX");
        }
        return { low: bigIntLow, high: bigIntHigh };
      }
      /**
       * Check if BigNumberish can be represented as Unit256
       */
      static is(bigNumberish) {
        try {
          _a2.validate(bigNumberish);
        } catch (error) {
          return false;
        }
        return true;
      }
      /**
       * Check if provided abi type is this data type
       */
      static isAbiType(abiType) {
        return abiType === _a2.abiSelector;
      }
      /**
       * Return bigint representation
       */
      toBigInt() {
        return (this.high << 128n) + this.low;
      }
      /**
       * Return Uint256 structure with HexString props
       * {low: HexString, high: HexString}
       */
      toUint256HexString() {
        return {
          low: addHexPrefix(this.low.toString(16)),
          high: addHexPrefix(this.high.toString(16))
        };
      }
      /**
       * Return Uint256 structure with DecimalString props
       * {low: DecString, high: DecString}
       */
      toUint256DecimalString() {
        return {
          low: this.low.toString(10),
          high: this.high.toString(10)
        };
      }
      /**
       * Return api requests representation witch is felt array
       */
      toApiRequest() {
        return [CairoFelt(this.low), CairoFelt(this.high)];
      }
    }, __publicField(_a2, "abiSelector", "core::integer::u256"), _a2);
    var UINT_512_MAX = (1n << 512n) - 1n;
    var UINT_512_MIN = 0n;
    var UINT_128_MIN = 0n;
    var _a3;
    var CairoUint512 = (_a3 = class {
      constructor(...arr) {
        __publicField(this, "limb0");
        __publicField(this, "limb1");
        __publicField(this, "limb2");
        __publicField(this, "limb3");
        if (typeof arr[0] === "object" && arr.length === 1 && "limb0" in arr[0] && "limb1" in arr[0] && "limb2" in arr[0] && "limb3" in arr[0]) {
          const props = _a3.validateProps(
            arr[0].limb0,
            arr[0].limb1,
            arr[0].limb2,
            arr[0].limb3
          );
          this.limb0 = props.limb0;
          this.limb1 = props.limb1;
          this.limb2 = props.limb2;
          this.limb3 = props.limb3;
        } else if (arr.length === 1) {
          const bigInt = _a3.validate(arr[0]);
          this.limb0 = bigInt & UINT_128_MAX;
          this.limb1 = (bigInt & UINT_128_MAX << 128n) >> 128n;
          this.limb2 = (bigInt & UINT_128_MAX << 256n) >> 256n;
          this.limb3 = bigInt >> 384n;
        } else if (arr.length === 4) {
          const props = _a3.validateProps(arr[0], arr[1], arr[2], arr[3]);
          this.limb0 = props.limb0;
          this.limb1 = props.limb1;
          this.limb2 = props.limb2;
          this.limb3 = props.limb3;
        } else {
          throw Error("Incorrect Uint512 constructor parameters");
        }
      }
      /**
       * Validate if BigNumberish can be represented as Uint512
       */
      static validate(bigNumberish) {
        const bigInt = BigInt(bigNumberish);
        if (bigInt < UINT_512_MIN)
          throw Error("bigNumberish is smaller than UINT_512_MIN.");
        if (bigInt > UINT_512_MAX)
          throw Error("bigNumberish is bigger than UINT_512_MAX.");
        return bigInt;
      }
      /**
       * Validate if limbs can be represented as Uint512
       */
      static validateProps(limb0, limb1, limb2, limb3) {
        const l0 = BigInt(limb0);
        const l1 = BigInt(limb1);
        const l2 = BigInt(limb2);
        const l3 = BigInt(limb3);
        [l0, l1, l2, l3].forEach((value, index2) => {
          if (value < UINT_128_MIN || value > UINT_128_MAX) {
            throw Error(`limb${index2} is not in the range of a u128 number`);
          }
        });
        return { limb0: l0, limb1: l1, limb2: l2, limb3: l3 };
      }
      /**
       * Check if BigNumberish can be represented as Uint512
       */
      static is(bigNumberish) {
        try {
          _a3.validate(bigNumberish);
        } catch (error) {
          return false;
        }
        return true;
      }
      /**
       * Check if provided abi type is this data type
       */
      static isAbiType(abiType) {
        return abiType === _a3.abiSelector;
      }
      /**
       * Return bigint representation
       */
      toBigInt() {
        return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;
      }
      /**
       * Return Uint512 structure with HexString props
       * limbx: HexString
       */
      toUint512HexString() {
        return {
          limb0: addHexPrefix(this.limb0.toString(16)),
          limb1: addHexPrefix(this.limb1.toString(16)),
          limb2: addHexPrefix(this.limb2.toString(16)),
          limb3: addHexPrefix(this.limb3.toString(16))
        };
      }
      /**
       * Return Uint512 structure with DecimalString props
       * limbx DecString
       */
      toUint512DecimalString() {
        return {
          limb0: this.limb0.toString(10),
          limb1: this.limb1.toString(10),
          limb2: this.limb2.toString(10),
          limb3: this.limb3.toString(10)
        };
      }
      /**
       * Return api requests representation witch is felt array
       */
      toApiRequest() {
        return [
          CairoFelt(this.limb0),
          CairoFelt(this.limb1),
          CairoFelt(this.limb2),
          CairoFelt(this.limb3)
        ];
      }
    }, __publicField(_a3, "abiSelector", "core::integer::u512"), _a3);
    var isLen = (name) => /_len$/.test(name);
    var isTypeFelt = (type) => type === "felt" || type === "core::felt252";
    var isTypeArray = (type) => /\*/.test(type) || type.startsWith("core::array::Array::") || type.startsWith("core::array::Span::");
    var isTypeTuple = (type) => /^\(.*\)$/i.test(type);
    var isTypeNamedTuple = (type) => /\(.*\)/i.test(type) && type.includes(":");
    var isTypeStruct = (type, structs) => type in structs;
    var isTypeEnum = (type, enums) => type in enums;
    var isTypeOption = (type) => type.startsWith("core::option::Option::");
    var isTypeResult = (type) => type.startsWith("core::result::Result::");
    var isTypeUint = (type) => Object.values(Uint).includes(type);
    var isTypeUint256 = (type) => CairoUint256.isAbiType(type);
    var isTypeLiteral = (type) => Object.values(Literal).includes(type);
    var isTypeBool = (type) => type === "core::bool";
    var isTypeContractAddress = (type) => type === "core::starknet::contract_address::ContractAddress";
    var isTypeEthAddress = (type) => type === "core::starknet::eth_address::EthAddress";
    var isTypeBytes31 = (type) => type === "core::bytes_31::bytes31";
    var isTypeByteArray = (type) => type === "core::byte_array::ByteArray";
    var isTypeSecp256k1Point = (type) => type === "core::starknet::secp256k1::Secp256k1Point";
    var isCairo1Type = (type) => type.includes("::");
    var getArrayType = (type) => {
      if (isCairo1Type(type)) {
        return type.substring(type.indexOf("<") + 1, type.lastIndexOf(">"));
      }
      return type.replace("*", "");
    };
    function isCairo1Abi(abi) {
      const { cairo: cairo2 } = getAbiContractVersion(abi);
      if (cairo2 === void 0) {
        throw Error("Unable to determine Cairo version");
      }
      return cairo2 === "1";
    }
    function isTypeNonZero(type) {
      return type.startsWith("core::zeroable::NonZero::");
    }
    function getAbiContractVersion(abi) {
      if (abi.find((it) => it.type === "interface")) {
        return { cairo: "1", compiler: "2" };
      }
      const testFunction = abi.find(
        (it) => it.type === "function" && (it.inputs.length || it.outputs.length)
      );
      if (!testFunction) {
        return { cairo: void 0, compiler: void 0 };
      }
      const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;
      if (isCairo1Type(io[0].type)) {
        return { cairo: "1", compiler: "1" };
      }
      return { cairo: "0", compiler: "0" };
    }
    var uint256 = (it) => {
      return new CairoUint256(it).toUint256DecimalString();
    };
    var uint512 = (it) => {
      return new CairoUint512(it).toUint512DecimalString();
    };
    var tuple = (...args) => ({ ...args });
    function felt(it) {
      return CairoFelt(it);
    }
    var CairoCustomEnum = class {
      /**
       * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.
       */
      constructor(enumContent) {
        /**
         * direct readonly access to variants of the Cairo Custom Enum.
         * @returns a value of type any
         * @example
         * ```typescript
         * const successValue = myCairoEnum.variant.Success;
         */
        __publicField(this, "variant");
        const variantsList = Object.values(enumContent);
        if (variantsList.length === 0) {
          throw new Error("This Enum must have at least 1 variant");
        }
        const nbActiveVariants = variantsList.filter(
          (content) => typeof content !== "undefined"
        ).length;
        if (nbActiveVariants !== 1) {
          throw new Error("This Enum must have exactly one active variant");
        }
        this.variant = enumContent;
      }
      /**
       *
       * @returns the content of the valid variant of a Cairo custom Enum.
       */
      unwrap() {
        const variants = Object.entries(this.variant);
        const activeVariant = variants.find((item) => typeof item[1] !== "undefined");
        if (typeof activeVariant === "undefined") {
          return void 0;
        }
        return activeVariant[1];
      }
      /**
       *
       * @returns the name of the valid variant of a Cairo custom Enum.
       */
      activeVariant() {
        const variants = Object.entries(this.variant);
        const activeVariant = variants.find((item) => typeof item[1] !== "undefined");
        if (typeof activeVariant === "undefined") {
          return "";
        }
        return activeVariant[0];
      }
    };
    var CairoOptionVariant = ((CairoOptionVariant2) => {
      CairoOptionVariant2[CairoOptionVariant2["Some"] = 0] = "Some";
      CairoOptionVariant2[CairoOptionVariant2["None"] = 1] = "None";
      return CairoOptionVariant2;
    })(CairoOptionVariant || {});
    var CairoOption = class {
      constructor(variant, someContent) {
        __publicField(this, "Some");
        __publicField(this, "None");
        if (!(variant in CairoOptionVariant)) {
          throw new Error("Wrong variant : should be CairoOptionVariant.Some or .None.");
        }
        if (variant === 0) {
          if (typeof someContent === "undefined") {
            throw new Error(
              'The creation of a Cairo Option with "Some" variant needs a content as input.'
            );
          }
          this.Some = someContent;
          this.None = void 0;
        } else {
          this.Some = void 0;
          this.None = true;
        }
      }
      /**
       *
       * @returns the content of the valid variant of a Cairo custom Enum.
       *  If None, returns 'undefined'.
       */
      unwrap() {
        if (this.None) {
          return void 0;
        }
        return this.Some;
      }
      /**
       *
       * @returns true if the valid variant is 'isSome'.
       */
      isSome() {
        return !(typeof this.Some === "undefined");
      }
      /**
       *
       * @returns true if the valid variant is 'isNone'.
       */
      isNone() {
        return this.None === true;
      }
    };
    var CairoResultVariant = ((CairoResultVariant2) => {
      CairoResultVariant2[CairoResultVariant2["Ok"] = 0] = "Ok";
      CairoResultVariant2[CairoResultVariant2["Err"] = 1] = "Err";
      return CairoResultVariant2;
    })(CairoResultVariant || {});
    var CairoResult = class {
      constructor(variant, resultContent) {
        __publicField(this, "Ok");
        __publicField(this, "Err");
        if (!(variant in CairoResultVariant)) {
          throw new Error("Wrong variant : should be CairoResultVariant.Ok or .Err.");
        }
        if (variant === 0) {
          this.Ok = resultContent;
          this.Err = void 0;
        } else {
          this.Ok = void 0;
          this.Err = resultContent;
        }
      }
      /**
       *
       * @returns the content of the valid variant of a Cairo Result.
       */
      unwrap() {
        if (typeof this.Ok !== "undefined") {
          return this.Ok;
        }
        if (typeof this.Err !== "undefined") {
          return this.Err;
        }
        throw new Error("Both Result.Ok and .Err are undefined. Not authorized.");
      }
      /**
       *
       * @returns true if the valid variant is 'Ok'.
       */
      isOk() {
        return !(typeof this.Ok === "undefined");
      }
      /**
       *
       * @returns true if the valid variant is 'isErr'.
       */
      isErr() {
        return !(typeof this.Err === "undefined");
      }
    };
    var guard = {
      isBN: (data, type, key) => {
        if (!isBigInt(data[key]))
          throw new Error(
            `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`
          );
      },
      unknown: (data, type, key) => {
        throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);
      }
    };
    function formatter(data, type, sameType) {
      return Object.entries(data).reduce(
        (acc, [key, value]) => {
          const elType = sameType ?? type[key];
          if (!(key in type) && !sameType) {
            acc[key] = value;
            return acc;
          }
          if (elType === "string") {
            if (Array.isArray(data[key])) {
              const arrayStr = formatter(
                data[key],
                data[key].map((_) => elType)
              );
              acc[key] = Object.values(arrayStr).join("");
              return acc;
            }
            guard.isBN(data, type, key);
            acc[key] = decodeShortString(value);
            return acc;
          }
          if (elType === "number") {
            guard.isBN(data, type, key);
            acc[key] = Number(value);
            return acc;
          }
          if (typeof elType === "function") {
            acc[key] = elType(value);
            return acc;
          }
          if (Array.isArray(elType)) {
            const arrayObj = formatter(data[key], elType, elType[0]);
            acc[key] = Object.values(arrayObj);
            return acc;
          }
          if (typeof elType === "object") {
            acc[key] = formatter(data[key], elType);
            return acc;
          }
          guard.unknown(data, type, key);
          return acc;
        },
        {}
      );
    }
    var AbiParser1 = class {
      constructor(abi) {
        __publicField(this, "abi");
        this.abi = abi;
      }
      /**
       * abi method inputs length without '_len' inputs
       * cairo 0 reducer
       * @param abiMethod FunctionAbi
       * @returns number
       */
      methodInputsLength(abiMethod) {
        return abiMethod.inputs.reduce((acc, input) => !isLen(input.name) ? acc + 1 : acc, 0);
      }
      /**
       * get method definition from abi
       * @param name string
       * @returns FunctionAbi | undefined
       */
      getMethod(name) {
        return this.abi.find((it) => it.name === name);
      }
      /**
       * Get Abi in legacy format
       * @returns Abi
       */
      getLegacyFormat() {
        return this.abi;
      }
    };
    var AbiParser2 = class {
      constructor(abi) {
        __publicField(this, "abi");
        this.abi = abi;
      }
      /**
       * abi method inputs length
       * @param abiMethod FunctionAbi
       * @returns number
       */
      methodInputsLength(abiMethod) {
        return abiMethod.inputs.length;
      }
      /**
       * get method definition from abi
       * @param name string
       * @returns FunctionAbi | undefined
       */
      getMethod(name) {
        const intf = this.abi.find(
          (it) => it.type === "interface"
        );
        return intf.items.find((it) => it.name === name);
      }
      /**
       * Get Abi in legacy format
       * @returns Abi
       */
      getLegacyFormat() {
        return this.abi.flatMap((e) => {
          if (e.type === "interface") {
            return e.items;
          }
          return e;
        });
      }
    };
    function createAbiParser(abi) {
      const version7 = getAbiVersion(abi);
      if (version7 === 0 || version7 === 1) {
        return new AbiParser1(abi);
      }
      if (version7 === 2) {
        return new AbiParser2(abi);
      }
      throw Error(`Unsupported ABI version ${version7}`);
    }
    function getAbiVersion(abi) {
      if (abi.find((it) => it.type === "interface"))
        return 2;
      if (isCairo1Abi(abi))
        return 1;
      return 0;
    }
    function isNoConstructorValid(method, argsCalldata, abiMethod) {
      return method === "constructor" && !abiMethod && !argsCalldata.length;
    }
    function parseNamedTuple(namedTuple) {
      const name = namedTuple.substring(0, namedTuple.indexOf(":"));
      const type = namedTuple.substring(name.length + ":".length);
      return { name, type };
    }
    function parseSubTuple(s) {
      if (!s.includes("("))
        return { subTuple: [], result: s };
      const subTuple = [];
      let result2 = "";
      let i = 0;
      while (i < s.length) {
        if (s[i] === "(") {
          let counter = 1;
          const lBracket = i;
          i++;
          while (counter) {
            if (s[i] === ")")
              counter--;
            if (s[i] === "(")
              counter++;
            i++;
          }
          subTuple.push(s.substring(lBracket, i));
          result2 += " ";
          i--;
        } else {
          result2 += s[i];
        }
        i++;
      }
      return {
        subTuple,
        result: result2
      };
    }
    function extractCairo0Tuple(type) {
      const cleanType = type.replace(/\s/g, "").slice(1, -1);
      const { subTuple, result: result2 } = parseSubTuple(cleanType);
      let recomposed = result2.split(",").map((it) => {
        return subTuple.length ? it.replace(" ", subTuple.shift()) : it;
      });
      if (isTypeNamedTuple(type)) {
        recomposed = recomposed.reduce((acc, it) => {
          return acc.concat(parseNamedTuple(it));
        }, []);
      }
      return recomposed;
    }
    function getClosureOffset(input, open, close) {
      for (let i = 0, counter = 0; i < input.length; i++) {
        if (input[i] === open) {
          counter++;
        } else if (input[i] === close && --counter === 0) {
          return i;
        }
      }
      return Number.POSITIVE_INFINITY;
    }
    function extractCairo1Tuple(type) {
      const input = type.slice(1, -1);
      const result2 = [];
      let currentIndex = 0;
      let limitIndex;
      while (currentIndex < input.length) {
        switch (true) {
          case input[currentIndex] === "(": {
            limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), "(", ")") + 1;
            break;
          }
          case (input.startsWith("core::result::Result::<", currentIndex) || input.startsWith("core::array::Array::<", currentIndex) || input.startsWith("core::option::Option::<", currentIndex)): {
            limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), "<", ">") + 1;
            break;
          }
          default: {
            const commaIndex = input.indexOf(",", currentIndex);
            limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;
          }
        }
        result2.push(input.slice(currentIndex, limitIndex));
        currentIndex = limitIndex + 2;
      }
      return result2;
    }
    function extractTupleMemberTypes(type) {
      if (isCairo1Type(type)) {
        return extractCairo1Tuple(type);
      }
      return extractCairo0Tuple(type);
    }
    function errorU256(key) {
      return Error(
        `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`
      );
    }
    function errorU512(key) {
      return Error(
        `Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`
      );
    }
    function orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {
      const orderInput = (unorderedItem, abiType) => {
        if (isTypeArray(abiType)) {
          return orderArray(unorderedItem, abiType);
        }
        if (isTypeEnum(abiType, enums)) {
          const abiObj = enums[abiType];
          return orderEnum(unorderedItem, abiObj);
        }
        if (isTypeTuple(abiType)) {
          return orderTuple(unorderedItem, abiType);
        }
        if (isTypeEthAddress(abiType)) {
          return unorderedItem;
        }
        if (isTypeNonZero(abiType)) {
          return unorderedItem;
        }
        if (isTypeByteArray(abiType)) {
          return unorderedItem;
        }
        if (isTypeSecp256k1Point(abiType)) {
          return unorderedItem;
        }
        if (CairoUint256.isAbiType(abiType)) {
          const u256 = unorderedItem;
          if (typeof u256 !== "object") {
            return u256;
          }
          if (!("low" in u256 && "high" in u256)) {
            throw errorU256(abiType);
          }
          return { low: u256.low, high: u256.high };
        }
        if (CairoUint512.isAbiType(abiType)) {
          const u512 = unorderedItem;
          if (typeof u512 !== "object") {
            return u512;
          }
          if (!["limb0", "limb1", "limb2", "limb3"].every((key) => key in u512)) {
            throw errorU512(abiType);
          }
          return { limb0: u512.limb0, limb1: u512.limb1, limb2: u512.limb2, limb3: u512.limb3 };
        }
        if (isTypeStruct(abiType, structs)) {
          const abiOfStruct = structs[abiType].members;
          return orderStruct(unorderedItem, abiOfStruct);
        }
        return unorderedItem;
      };
      const orderStruct = (unorderedObject2, abiObject) => {
        const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {
          const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {
            enumerable: true,
            value: value ?? unorderedObject2[abiParam.name]
          });
          if (unorderedObject2[abiParam.name] === "undefined") {
            if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {
              throw Error(`Your object needs a property with key : ${abiParam.name} .`);
            }
          }
          setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));
          return orderedObject;
        }, {});
        return orderedObject2;
      };
      function orderArray(myArray, abiParam) {
        const typeInArray = getArrayType(abiParam);
        if (isString(myArray)) {
          return myArray;
        }
        return myArray.map((myElem) => orderInput(myElem, typeInArray));
      }
      function orderTuple(unorderedObject2, abiParam) {
        const typeList = extractTupleMemberTypes(abiParam);
        const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index2) => {
          const myObjKeys = Object.keys(unorderedObject2);
          const setProperty = (value) => Object.defineProperty(orderedObject, index2.toString(), {
            enumerable: true,
            value: value ?? unorderedObject2[myObjKeys[index2]]
          });
          const abiType = (abiTypeCairoX == null ? void 0 : abiTypeCairoX.type) ? abiTypeCairoX.type : abiTypeCairoX;
          setProperty(orderInput(unorderedObject2[myObjKeys[index2]], abiType));
          return orderedObject;
        }, {});
        return orderedObject2;
      }
      const orderEnum = (unorderedObject2, abiObject) => {
        if (isTypeResult(abiObject.name)) {
          const unorderedResult = unorderedObject2;
          const resultOkType = abiObject.name.substring(
            abiObject.name.indexOf("<") + 1,
            abiObject.name.lastIndexOf(",")
          );
          const resultErrType = abiObject.name.substring(
            abiObject.name.indexOf(",") + 1,
            abiObject.name.lastIndexOf(">")
          );
          if (unorderedResult.isOk()) {
            return new CairoResult(
              0,
              orderInput(unorderedObject2.unwrap(), resultOkType)
            );
          }
          return new CairoResult(
            1,
            orderInput(unorderedObject2.unwrap(), resultErrType)
          );
        }
        if (isTypeOption(abiObject.name)) {
          const unorderedOption = unorderedObject2;
          const resultSomeType = abiObject.name.substring(
            abiObject.name.indexOf("<") + 1,
            abiObject.name.lastIndexOf(">")
          );
          if (unorderedOption.isSome()) {
            return new CairoOption(
              0,
              orderInput(unorderedOption.unwrap(), resultSomeType)
            );
          }
          return new CairoOption(1, {});
        }
        const unorderedCustomEnum = unorderedObject2;
        const variants = Object.entries(unorderedCustomEnum.variant);
        const newEntries = variants.map((variant) => {
          if (typeof variant[1] === "undefined") {
            return variant;
          }
          const variantType = abiObject.type.substring(
            abiObject.type.lastIndexOf("<") + 1,
            abiObject.type.lastIndexOf(">")
          );
          if (variantType === "()") {
            return variant;
          }
          return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];
        });
        return new CairoCustomEnum(Object.fromEntries(newEntries));
      };
      const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {
        const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {
          enumerable: true,
          value
        });
        if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {
          return orderedObject;
        }
        setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));
        return orderedObject;
      }, {});
      return finalOrderedObject;
    }
    function parseBaseTypes(type, val) {
      switch (true) {
        case CairoUint256.isAbiType(type):
          return new CairoUint256(val).toApiRequest();
        case CairoUint512.isAbiType(type):
          return new CairoUint512(val).toApiRequest();
        case isTypeBytes31(type):
          return encodeShortString(val.toString());
        case isTypeSecp256k1Point(type): {
          const pubKeyETH = removeHexPrefix(toHex2(val)).padStart(128, "0");
          const pubKeyETHy = uint256(addHexPrefix(pubKeyETH.slice(-64)));
          const pubKeyETHx = uint256(addHexPrefix(pubKeyETH.slice(0, -64)));
          return [
            felt(pubKeyETHx.low),
            felt(pubKeyETHx.high),
            felt(pubKeyETHy.low),
            felt(pubKeyETHy.high)
          ];
        }
        default:
          return felt(val);
      }
    }
    function parseTuple(element, typeStr) {
      const memberTypes = extractTupleMemberTypes(typeStr);
      const elements = Object.values(element);
      if (elements.length !== memberTypes.length) {
        throw Error(
          `ParseTuple: provided and expected abi tuple size do not match.
      provided: ${elements} 
      expected: ${memberTypes}`
        );
      }
      return memberTypes.map((it, dx) => {
        return {
          element: elements[dx],
          type: it.type ?? it
        };
      });
    }
    function parseByteArray(element) {
      const myByteArray = byteArrayFromString(element);
      return [
        myByteArray.data.length.toString(),
        ...myByteArray.data.map((bn) => bn.toString()),
        myByteArray.pending_word.toString(),
        myByteArray.pending_word_len.toString()
      ];
    }
    function parseCalldataValue(element, type, structs, enums) {
      if (element === void 0) {
        throw Error(`Missing parameter for type ${type}`);
      }
      if (Array.isArray(element)) {
        const result2 = [];
        result2.push(felt(element.length));
        const arrayType = getArrayType(type);
        return element.reduce((acc, it) => {
          return acc.concat(parseCalldataValue(it, arrayType, structs, enums));
        }, result2);
      }
      if (structs[type] && structs[type].members.length) {
        if (CairoUint256.isAbiType(type)) {
          return new CairoUint256(element).toApiRequest();
        }
        if (CairoUint512.isAbiType(type)) {
          return new CairoUint512(element).toApiRequest();
        }
        if (type === "core::starknet::eth_address::EthAddress")
          return parseBaseTypes(type, element);
        if (type === "core::byte_array::ByteArray")
          return parseByteArray(element);
        const { members } = structs[type];
        const subElement = element;
        return members.reduce((acc, it) => {
          return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));
        }, []);
      }
      if (isTypeTuple(type)) {
        const tupled = parseTuple(element, type);
        return tupled.reduce((acc, it) => {
          const parsedData = parseCalldataValue(it.element, it.type, structs, enums);
          return acc.concat(parsedData);
        }, []);
      }
      if (CairoUint256.isAbiType(type)) {
        return new CairoUint256(element).toApiRequest();
      }
      if (CairoUint512.isAbiType(type)) {
        return new CairoUint512(element).toApiRequest();
      }
      if (isTypeEnum(type, enums)) {
        const { variants } = enums[type];
        if (isTypeOption(type)) {
          const myOption = element;
          if (myOption.isSome()) {
            const listTypeVariant2 = variants.find((variant) => variant.name === "Some");
            if (typeof listTypeVariant2 === "undefined") {
              throw Error(`Error in abi : Option has no 'Some' variant.`);
            }
            const typeVariantSome = listTypeVariant2.type;
            if (typeVariantSome === "()") {
              return 0 .toString();
            }
            const parsedParameter2 = parseCalldataValue(
              myOption.unwrap(),
              typeVariantSome,
              structs,
              enums
            );
            if (Array.isArray(parsedParameter2)) {
              return [0 .toString(), ...parsedParameter2];
            }
            return [0 .toString(), parsedParameter2];
          }
          return 1 .toString();
        }
        if (isTypeResult(type)) {
          const myResult = element;
          if (myResult.isOk()) {
            const listTypeVariant3 = variants.find((variant) => variant.name === "Ok");
            if (typeof listTypeVariant3 === "undefined") {
              throw Error(`Error in abi : Result has no 'Ok' variant.`);
            }
            const typeVariantOk = listTypeVariant3.type;
            if (typeVariantOk === "()") {
              return 0 .toString();
            }
            const parsedParameter3 = parseCalldataValue(
              myResult.unwrap(),
              typeVariantOk,
              structs,
              enums
            );
            if (Array.isArray(parsedParameter3)) {
              return [0 .toString(), ...parsedParameter3];
            }
            return [0 .toString(), parsedParameter3];
          }
          const listTypeVariant2 = variants.find((variant) => variant.name === "Err");
          if (typeof listTypeVariant2 === "undefined") {
            throw Error(`Error in abi : Result has no 'Err' variant.`);
          }
          const typeVariantErr = listTypeVariant2.type;
          if (typeVariantErr === "()") {
            return 1 .toString();
          }
          const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);
          if (Array.isArray(parsedParameter2)) {
            return [1 .toString(), ...parsedParameter2];
          }
          return [1 .toString(), parsedParameter2];
        }
        const myEnum = element;
        const activeVariant = myEnum.activeVariant();
        const listTypeVariant = variants.find((variant) => variant.name === activeVariant);
        if (typeof listTypeVariant === "undefined") {
          throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);
        }
        const typeActiveVariant = listTypeVariant.type;
        const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant);
        if (typeActiveVariant === "()") {
          return numActiveVariant.toString();
        }
        const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);
        if (Array.isArray(parsedParameter)) {
          return [numActiveVariant.toString(), ...parsedParameter];
        }
        return [numActiveVariant.toString(), parsedParameter];
      }
      if (isTypeNonZero(type)) {
        return parseBaseTypes(getArrayType(type), element);
      }
      if (typeof element === "object") {
        throw Error(`Parameter ${element} do not align with abi parameter ${type}`);
      }
      return parseBaseTypes(type, element);
    }
    function parseCalldataField(argsIterator, input, structs, enums) {
      const { name, type } = input;
      let { value } = argsIterator.next();
      switch (true) {
        case isTypeArray(type):
          if (!Array.isArray(value) && !isText(value)) {
            throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);
          }
          if (isString(value)) {
            value = splitLongString(value);
          }
          return parseCalldataValue(value, input.type, structs, enums);
        case isTypeNonZero(type):
          return parseBaseTypes(getArrayType(type), value);
        case type === "core::starknet::eth_address::EthAddress":
          return parseBaseTypes(type, value);
        case (isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type) || CairoUint256.isAbiType(type)):
          return parseCalldataValue(value, type, structs, enums);
        case isTypeEnum(type, enums):
          return parseCalldataValue(
            value,
            type,
            structs,
            enums
          );
        default:
          return parseBaseTypes(type, value);
      }
    }
    function parseBaseTypes2(type, it) {
      let temp;
      switch (true) {
        case isTypeBool(type):
          temp = it.next().value;
          return Boolean(BigInt(temp));
        case CairoUint256.isAbiType(type):
          const low = it.next().value;
          const high = it.next().value;
          return new CairoUint256(low, high).toBigInt();
        case CairoUint512.isAbiType(type):
          const limb0 = it.next().value;
          const limb1 = it.next().value;
          const limb2 = it.next().value;
          const limb3 = it.next().value;
          return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();
        case type === "core::starknet::eth_address::EthAddress":
          temp = it.next().value;
          return BigInt(temp);
        case type === "core::bytes_31::bytes31":
          temp = it.next().value;
          return decodeShortString(temp);
        case isTypeSecp256k1Point(type):
          const xLow = removeHexPrefix(it.next().value).padStart(32, "0");
          const xHigh = removeHexPrefix(it.next().value).padStart(32, "0");
          const yLow = removeHexPrefix(it.next().value).padStart(32, "0");
          const yHigh = removeHexPrefix(it.next().value).padStart(32, "0");
          const pubK = BigInt(addHexPrefix(xHigh + xLow + yHigh + yLow));
          return pubK;
        default:
          temp = it.next().value;
          return BigInt(temp);
      }
    }
    function parseResponseValue(responseIterator2, element, structs, enums) {
      if (element.type === "()") {
        return {};
      }
      if (CairoUint256.isAbiType(element.type)) {
        const low = responseIterator2.next().value;
        const high = responseIterator2.next().value;
        return new CairoUint256(low, high).toBigInt();
      }
      if (CairoUint512.isAbiType(element.type)) {
        const limb0 = responseIterator2.next().value;
        const limb1 = responseIterator2.next().value;
        const limb2 = responseIterator2.next().value;
        const limb3 = responseIterator2.next().value;
        return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();
      }
      if (isTypeByteArray(element.type)) {
        const parsedBytes31Arr = [];
        const bytes31ArrLen = BigInt(responseIterator2.next().value);
        while (parsedBytes31Arr.length < bytes31ArrLen) {
          parsedBytes31Arr.push(toHex2(responseIterator2.next().value));
        }
        const pending_word = toHex2(responseIterator2.next().value);
        const pending_word_len = BigInt(responseIterator2.next().value);
        const myByteArray = {
          data: parsedBytes31Arr,
          pending_word,
          pending_word_len
        };
        return stringFromByteArray(myByteArray);
      }
      if (isTypeArray(element.type)) {
        const parsedDataArr = [];
        const el = { name: "", type: getArrayType(element.type) };
        const len = BigInt(responseIterator2.next().value);
        while (parsedDataArr.length < len) {
          parsedDataArr.push(parseResponseValue(responseIterator2, el, structs, enums));
        }
        return parsedDataArr;
      }
      if (isTypeNonZero(element.type)) {
        const el = { name: "", type: getArrayType(element.type) };
        return parseResponseValue(responseIterator2, el, structs, enums);
      }
      if (structs && element.type in structs && structs[element.type]) {
        if (element.type === "core::starknet::eth_address::EthAddress") {
          return parseBaseTypes2(element.type, responseIterator2);
        }
        return structs[element.type].members.reduce((acc, el) => {
          acc[el.name] = parseResponseValue(responseIterator2, el, structs, enums);
          return acc;
        }, {});
      }
      if (enums && element.type in enums && enums[element.type]) {
        const variantNum = Number(responseIterator2.next().value);
        const rawEnum = enums[element.type].variants.reduce((acc, variant, num2) => {
          if (num2 === variantNum) {
            acc[variant.name] = parseResponseValue(
              responseIterator2,
              { name: "", type: variant.type },
              structs,
              enums
            );
            return acc;
          }
          acc[variant.name] = void 0;
          return acc;
        }, {});
        if (element.type.startsWith("core::option::Option")) {
          const content = variantNum === 0 ? rawEnum.Some : void 0;
          return new CairoOption(variantNum, content);
        }
        if (element.type.startsWith("core::result::Result")) {
          let content;
          if (variantNum === 0) {
            content = rawEnum.Ok;
          } else {
            content = rawEnum.Err;
          }
          return new CairoResult(variantNum, content);
        }
        const customEnum = new CairoCustomEnum(rawEnum);
        return customEnum;
      }
      if (isTypeTuple(element.type)) {
        const memberTypes = extractTupleMemberTypes(element.type);
        return memberTypes.reduce((acc, it, idx) => {
          const name = (it == null ? void 0 : it.name) ? it.name : idx;
          const type = (it == null ? void 0 : it.type) ? it.type : it;
          const el = { name, type };
          acc[name] = parseResponseValue(responseIterator2, el, structs, enums);
          return acc;
        }, {});
      }
      if (isTypeArray(element.type)) {
        const parsedDataArr = [];
        const el = { name: "", type: getArrayType(element.type) };
        const len = BigInt(responseIterator2.next().value);
        while (parsedDataArr.length < len) {
          parsedDataArr.push(parseResponseValue(responseIterator2, el, structs, enums));
        }
        return parsedDataArr;
      }
      return parseBaseTypes2(element.type, responseIterator2);
    }
    function responseParser(responseIterator2, output, structs, enums, parsedResult) {
      const { name, type } = output;
      let temp;
      switch (true) {
        case isLen(name):
          temp = responseIterator2.next().value;
          return BigInt(temp);
        case (structs && type in structs || isTypeTuple(type)):
          return parseResponseValue(responseIterator2, output, structs, enums);
        case (enums && isTypeEnum(type, enums)):
          return parseResponseValue(responseIterator2, output, structs, enums);
        case isTypeArray(type):
          if (isCairo1Type(type)) {
            return parseResponseValue(responseIterator2, output, structs, enums);
          }
          const parsedDataArr = [];
          if (parsedResult && parsedResult[`${name}_len`]) {
            const arrLen = parsedResult[`${name}_len`];
            while (parsedDataArr.length < arrLen) {
              parsedDataArr.push(
                parseResponseValue(
                  responseIterator2,
                  { name, type: output.type.replace("*", "") },
                  structs,
                  enums
                )
              );
            }
          }
          return parsedDataArr;
        case isTypeNonZero(type):
          return parseResponseValue(responseIterator2, output, structs, enums);
        default:
          return parseBaseTypes2(type, responseIterator2);
      }
    }
    var validateFelt = (parameter, input) => {
      assert5(
        isString(parameter) || isNumber2(parameter) || isBigInt(parameter),
        `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`
      );
      if (isString(parameter) && !isHex(parameter))
        return;
      const param = BigInt(parameter.toString(10));
      assert5(
        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266
        param >= 0n && param <= 2n ** 252n - 1n,
        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`
      );
    };
    var validateBytes31 = (parameter, input) => {
      assert5(isString(parameter), `Validate: arg ${input.name} should be a string.`);
      assert5(
        parameter.length < 32,
        `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`
      );
    };
    var validateByteArray = (parameter, input) => {
      assert5(isString(parameter), `Validate: arg ${input.name} should be a string.`);
    };
    var validateUint = (parameter, input) => {
      if (isNumber2(parameter)) {
        assert5(
          parameter <= Number.MAX_SAFE_INTEGER,
          `Validation: Parameter is to large to be typed as Number use (BigInt or String)`
        );
      }
      assert5(
        isString(parameter) || isNumber2(parameter) || isBigInt(parameter) || typeof parameter === "object" && "low" in parameter && "high" in parameter || typeof parameter === "object" && ["limb0", "limb1", "limb2", "limb3"].every((key) => key in parameter),
        `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`
      );
      let param;
      switch (input.type) {
        case "core::integer::u256":
          param = new CairoUint256(parameter).toBigInt();
          break;
        case "core::integer::u512":
          param = new CairoUint512(parameter).toBigInt();
          break;
        default:
          param = toBigInt(parameter);
      }
      switch (input.type) {
        case "core::integer::u8":
          assert5(
            param >= 0n && param <= 255n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`
          );
          break;
        case "core::integer::u16":
          assert5(
            param >= 0n && param <= 65535n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`
          );
          break;
        case "core::integer::u32":
          assert5(
            param >= 0n && param <= 4294967295n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`
          );
          break;
        case "core::integer::u64":
          assert5(
            param >= 0n && param <= 2n ** 64n - 1n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`
          );
          break;
        case "core::integer::u128":
          assert5(
            param >= 0n && param <= 2n ** 128n - 1n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`
          );
          break;
        case "core::integer::u256":
          assert5(
            param >= 0n && param <= 2n ** 256n - 1n,
            `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`
          );
          break;
        case "core::integer::u512":
          assert5(CairoUint512.is(param), `Validate: arg ${input.name} is ${input.type} 0 - 2^512-1`);
          break;
        case "core::starknet::class_hash::ClassHash":
          assert5(
            // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670
            param >= 0n && param <= 2n ** 252n - 1n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`
          );
          break;
        case "core::starknet::contract_address::ContractAddress":
          assert5(
            // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245
            param >= 0n && param <= 2n ** 252n - 1n,
            `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`
          );
          break;
        case "core::starknet::secp256k1::Secp256k1Point": {
          assert5(
            param >= 0n && param <= 2n ** 512n - 1n,
            `Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`
          );
          break;
        }
        default:
          break;
      }
    };
    var validateBool = (parameter, input) => {
      assert5(
        isBoolean(parameter),
        `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`
      );
    };
    var validateStruct = (parameter, input, structs) => {
      if (input.type === "core::integer::u256" || input.type === "core::integer::u512") {
        validateUint(parameter, input);
        return;
      }
      if (input.type === "core::starknet::eth_address::EthAddress") {
        assert5(
          typeof parameter !== "object",
          `EthAddress type is waiting a BigNumberish. Got ${parameter}`
        );
        const param = BigInt(parameter.toString(10));
        assert5(
          // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259
          param >= 0n && param <= 2n ** 160n - 1n,
          `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`
        );
        return;
      }
      assert5(
        typeof parameter === "object" && !Array.isArray(parameter),
        `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`
      );
      structs[input.type].members.forEach(({ name }) => {
        assert5(
          Object.keys(parameter).includes(name),
          `Validate: arg ${input.name} should have a property ${name}`
        );
      });
    };
    var validateEnum = (parameter, input) => {
      assert5(
        typeof parameter === "object" && !Array.isArray(parameter),
        `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`
      );
      const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));
      const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];
      if (isTypeOption(input.type) && keys.includes("isSome") && keys.includes("isNone")) {
        return;
      }
      if (isTypeResult(input.type) && keys.includes("isOk") && keys.includes("isErr")) {
        return;
      }
      if (keys.includes("variant") && keys.includes("activeVariant")) {
        return;
      }
      throw new Error(
        `Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`
      );
    };
    var validateTuple = (parameter, input) => {
      assert5(
        typeof parameter === "object" && !Array.isArray(parameter),
        `Validate: arg ${input.name} should be a tuple (defined as object)`
      );
    };
    var validateArray = (parameter, input, structs, enums) => {
      const baseType = getArrayType(input.type);
      if (isTypeFelt(baseType) && isLongText(parameter)) {
        return;
      }
      assert5(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);
      switch (true) {
        case isTypeFelt(baseType):
          parameter.forEach((param) => validateFelt(param, input));
          break;
        case isTypeTuple(baseType):
          parameter.forEach((it) => validateTuple(it, { name: input.name, type: baseType }));
          break;
        case isTypeArray(baseType):
          parameter.forEach(
            (param) => validateArray(param, { name: "", type: baseType }, structs, enums)
          );
          break;
        case isTypeStruct(baseType, structs):
          parameter.forEach(
            (it) => validateStruct(it, { name: input.name, type: baseType }, structs)
          );
          break;
        case isTypeEnum(baseType, enums):
          parameter.forEach((it) => validateEnum(it, { name: input.name, type: baseType }));
          break;
        case (isTypeUint(baseType) || isTypeLiteral(baseType)):
          parameter.forEach((param) => validateUint(param, { name: "", type: baseType }));
          break;
        case isTypeBool(baseType):
          parameter.forEach((param) => validateBool(param, input));
          break;
        default:
          throw new Error(
            `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`
          );
      }
    };
    var validateNonZero = (parameter, input) => {
      const baseType = getArrayType(input.type);
      assert5(
        isTypeUint(baseType) && baseType !== CairoUint512.abiSelector || isTypeFelt(baseType),
        `Validate: ${input.name} type is not authorized for NonZero type.`
      );
      switch (true) {
        case isTypeFelt(baseType):
          validateFelt(parameter, input);
          assert5(
            BigInt(parameter.toString(10)) > 0,
            "Validate: value 0 is not authorized in NonZero felt252 type."
          );
          break;
        case isTypeUint(baseType):
          validateUint(parameter, { name: "", type: baseType });
          switch (input.type) {
            case "core::integer::u256":
              assert5(
                new CairoUint256(parameter).toBigInt() > 0,
                "Validate: value 0 is not authorized in NonZero uint256 type."
              );
              break;
            default:
              assert5(
                toBigInt(parameter) > 0,
                "Validate: value 0 is not authorized in NonZero uint type."
              );
          }
          break;
        default:
          throw new Error(
            `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`
          );
      }
    };
    function validateFields(abiMethod, args, structs, enums) {
      abiMethod.inputs.reduce((acc, input) => {
        const parameter = args[acc];
        switch (true) {
          case isLen(input.name):
            return acc;
          case isTypeFelt(input.type):
            validateFelt(parameter, input);
            break;
          case isTypeBytes31(input.type):
            validateBytes31(parameter, input);
            break;
          case (isTypeUint(input.type) || isTypeLiteral(input.type)):
            validateUint(parameter, input);
            break;
          case isTypeBool(input.type):
            validateBool(parameter, input);
            break;
          case isTypeByteArray(input.type):
            validateByteArray(parameter, input);
            break;
          case isTypeArray(input.type):
            validateArray(parameter, input, structs, enums);
            break;
          case isTypeStruct(input.type, structs):
            validateStruct(parameter, input, structs);
            break;
          case isTypeEnum(input.type, enums):
            validateEnum(parameter, input);
            break;
          case isTypeTuple(input.type):
            validateTuple(parameter, input);
            break;
          case isTypeNonZero(input.type):
            validateNonZero(parameter, input);
            break;
          default:
            throw new Error(
              `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`
            );
        }
        return acc + 1;
      }, 0);
    }
    var CallData = class _CallData {
      constructor(abi) {
        __publicField(this, "abi");
        __publicField(this, "parser");
        __publicField(this, "structs");
        __publicField(this, "enums");
        this.structs = _CallData.getAbiStruct(abi);
        this.enums = _CallData.getAbiEnum(abi);
        this.parser = createAbiParser(abi);
        this.abi = this.parser.getLegacyFormat();
      }
      /**
       * Validate arguments passed to the method as corresponding to the ones in the abi
       * @param type ValidateType - type of the method
       * @param method string - name of the method
       * @param args ArgsOrCalldata - arguments that are passed to the method
       */
      validate(type, method, args = []) {
        if (type !== "DEPLOY") {
          const invocableFunctionNames = this.abi.filter((abi) => {
            if (abi.type !== "function")
              return false;
            const isView = abi.stateMutability === "view" || abi.state_mutability === "view";
            return type === "INVOKE" ? !isView : isView;
          }).map((abi) => abi.name);
          assert5(
            invocableFunctionNames.includes(method),
            `${type === "INVOKE" ? "invocable" : "viewable"} method not found in abi`
          );
        }
        const abiMethod = this.abi.find(
          (abi) => type === "DEPLOY" ? abi.name === method && abi.type === "constructor" : abi.name === method && abi.type === "function"
        );
        if (isNoConstructorValid(method, args, abiMethod)) {
          return;
        }
        const inputsLength = this.parser.methodInputsLength(abiMethod);
        if (args.length !== inputsLength) {
          throw Error(
            `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`
          );
        }
        validateFields(abiMethod, args, this.structs, this.enums);
      }
      /**
       * Compile contract callData with abi
       * Parse the calldata by using input fields from the abi for that method
       * @param method string - method name
       * @param argsCalldata RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).
       * @return Calldata - parsed arguments in format that contract is expecting
       * @example
       * ```typescript
       * const calldata = myCallData.compile("constructor", ["0x34a", [1, 3n]]);
       * ```
       * ```typescript
       * const calldata2 = myCallData.compile("constructor", {list:[1, 3n], balance:"0x34"}); // wrong order is valid
       * ```
       */
      compile(method, argsCalldata) {
        const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method);
        if (isNoConstructorValid(method, argsCalldata, abiMethod)) {
          return [];
        }
        let args;
        if (Array.isArray(argsCalldata)) {
          args = argsCalldata;
        } else {
          const orderedObject = orderPropsByAbi(
            argsCalldata,
            abiMethod.inputs,
            this.structs,
            this.enums
          );
          args = Object.values(orderedObject);
          validateFields(abiMethod, args, this.structs, this.enums);
        }
        const argsIterator = args[Symbol.iterator]();
        const callArray = abiMethod.inputs.reduce(
          (acc, input) => isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)),
          []
        );
        Object.defineProperty(callArray, "__compiled__", {
          enumerable: false,
          writable: false,
          value: true
        });
        return callArray;
      }
      /**
       * Compile contract callData without abi
       * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data
       * @returns Calldata
       */
      static compile(rawArgs) {
        const createTree = (obj) => {
          const getEntries = (o, prefix = ".") => {
            const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;
            return Object.entries(oe).flatMap(([k, v]) => {
              let value = v;
              if (k === "entrypoint")
                value = getSelectorFromName(value);
              else if (isLongText(value))
                value = byteArrayFromString(value);
              const kk = Array.isArray(oe) && k === "0" ? "$$len" : k;
              if (isBigInt(value))
                return [[`${prefix}${kk}`, felt(value)]];
              if (Object(value) === value) {
                const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));
                const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];
                if (keys.includes("isSome") && keys.includes("isNone")) {
                  const myOption = value;
                  const variantNb = myOption.isSome() ? 0 : 1;
                  if (myOption.isSome())
                    return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);
                  return [[`${prefix}${kk}`, felt(variantNb)]];
                }
                if (keys.includes("isOk") && keys.includes("isErr")) {
                  const myResult = value;
                  const variantNb = myResult.isOk() ? 0 : 1;
                  return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);
                }
                if (keys.includes("variant") && keys.includes("activeVariant")) {
                  const myEnum = value;
                  const activeVariant = myEnum.activeVariant();
                  const listVariants = Object.keys(myEnum.variant);
                  const activeVariantNb = listVariants.findIndex(
                    (variant) => variant === activeVariant
                  );
                  if (typeof myEnum.unwrap() === "object" && Object.keys(myEnum.unwrap()).length === 0) {
                    return [[`${prefix}${kk}`, felt(activeVariantNb)]];
                  }
                  return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);
                }
                return getEntries(value, `${prefix}${kk}.`);
              }
              return [[`${prefix}${kk}`, felt(value)]];
            });
          };
          const result2 = Object.fromEntries(getEntries(obj));
          return result2;
        };
        let callTreeArray;
        if (!Array.isArray(rawArgs)) {
          const callTree = createTree(rawArgs);
          callTreeArray = Object.values(callTree);
        } else {
          const callObj = { ...rawArgs };
          const callTree = createTree(callObj);
          callTreeArray = Object.values(callTree);
        }
        Object.defineProperty(callTreeArray, "__compiled__", {
          enumerable: false,
          writable: false,
          value: true
        });
        return callTreeArray;
      }
      /**
       * Parse elements of the response array and structuring them into response object
       * @param method string - method name
       * @param response string[] - response from the method
       * @return Result - parsed response corresponding to the abi
       */
      parse(method, response) {
        const { outputs } = this.abi.find((abi) => abi.name === method);
        const responseIterator2 = response.flat()[Symbol.iterator]();
        const parsed = outputs.flat().reduce((acc, output, idx) => {
          const propName = output.name ?? idx;
          acc[propName] = responseParser(responseIterator2, output, this.structs, this.enums, acc);
          if (acc[propName] && acc[`${propName}_len`]) {
            delete acc[`${propName}_len`];
          }
          return acc;
        }, {});
        return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;
      }
      /**
       * Format cairo method response data to native js values based on provided format schema
       * @param method string - cairo method name
       * @param response string[] - cairo method response
       * @param format object - formatter object schema
       * @returns Result - parsed and formatted response object
       */
      format(method, response, format) {
        const parsed = this.parse(method, response);
        return formatter(parsed, format);
      }
      /**
       * Helper to extract structs from abi
       * @param abi Abi
       * @returns AbiStructs - structs from abi
       */
      static getAbiStruct(abi) {
        return abi.filter((abiEntry) => abiEntry.type === "struct").reduce(
          (acc, abiEntry) => ({
            ...acc,
            [abiEntry.name]: abiEntry
          }),
          {}
        );
      }
      /**
       * Helper to extract enums from abi
       * @param abi Abi
       * @returns AbiEnums - enums from abi
       */
      static getAbiEnum(abi) {
        const fullEnumList = abi.filter((abiEntry) => abiEntry.type === "enum").reduce(
          (acc, abiEntry) => ({
            ...acc,
            [abiEntry.name]: abiEntry
          }),
          {}
        );
        delete fullEnumList["core::bool"];
        return fullEnumList;
      }
      /**
       * Helper: Compile HexCalldata | RawCalldata | RawArgs
       * @param rawCalldata HexCalldata | RawCalldata | RawArgs
       * @returns Calldata
       */
      static toCalldata(rawCalldata = []) {
        return _CallData.compile(rawCalldata);
      }
      /**
       * Helper: Convert raw to HexCalldata
       * @param raw HexCalldata | RawCalldata | RawArgs
       * @returns HexCalldata
       */
      static toHex(raw = []) {
        const calldata = _CallData.compile(raw);
        return calldata.map((it) => toHex2(it));
      }
      /**
       * Parse the elements of a contract response and structure them into one or several Result.
       * In Cairo 0, arrays are not supported.
       * @param typeCairo string or string[] - Cairo type name, ex : "hello::hello::UserData"
       * @param response string[] - serialized data corresponding to typeCairo.
       * @return Result or Result[] - parsed response corresponding to typeData.
       * @example
       * const res2=helloCallData.decodeParameters("hello::hello::UserData",["0x123456","0x1"]);
       * result = { address: 1193046n, is_claimed: true }
       */
      decodeParameters(typeCairo, response) {
        const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];
        const responseIterator2 = response.flat()[Symbol.iterator]();
        const decodedArray = typeCairoArray.map(
          (typeParam) => responseParser(
            responseIterator2,
            { name: "", type: typeParam },
            this.structs,
            this.enums
          )
        );
        return decodedArray.length === 1 ? decodedArray[0] : decodedArray;
      }
    };
    var hash_exports = {};
    __export2(hash_exports, {
      calculateContractAddressFromHash: () => calculateContractAddressFromHash,
      calculateDeclareTransactionHash: () => calculateDeclareTransactionHash3,
      calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash3,
      calculateInvokeTransactionHash: () => calculateInvokeTransactionHash2,
      computeCompiledClassHash: () => computeCompiledClassHash,
      computeContractClassHash: () => computeContractClassHash,
      computeHashOnElements: () => computeHashOnElements2,
      computeHintedClassHash: () => computeHintedClassHash,
      computeLegacyContractClassHash: () => computeLegacyContractClassHash,
      computePedersenHash: () => computePedersenHash,
      computePedersenHashOnElements: () => computePedersenHashOnElements,
      computePoseidonHash: () => computePoseidonHash,
      computePoseidonHashOnElements: () => computePoseidonHashOnElements,
      computeSierraContractClassHash: () => computeSierraContractClassHash,
      formatSpaces: () => formatSpaces,
      getSelector: () => getSelector,
      getSelectorFromName: () => getSelectorFromName,
      hashByteCodeSegments: () => hashByteCodeSegments,
      keccakBn: () => keccakBn,
      poseidon: () => poseidon,
      starknetKeccak: () => starknetKeccak
    });
    var poseidon = __toESM3(require_poseidon2());
    var v2_exports = {};
    __export2(v2_exports, {
      calculateDeclareTransactionHash: () => calculateDeclareTransactionHash,
      calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash,
      calculateTransactionHash: () => calculateTransactionHash,
      calculateTransactionHashCommon: () => calculateTransactionHashCommon,
      computeHashOnElements: () => computeHashOnElements
    });
    var ec_exports = {};
    __export2(ec_exports, {
      starkCurve: () => starkCurve,
      weierstrass: () => weierstrass
    });
    var starkCurve = __toESM3(require_lib2());
    var weierstrass = __toESM3(require_weierstrass3());
    function computeHashOnElements(data) {
      return [...data, data.length].reduce((x, y) => starkCurve.pedersen(toBigInt(x), toBigInt(y)), 0).toString();
    }
    function calculateTransactionHashCommon(txHashPrefix, version7, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {
      const calldataHash = computeHashOnElements(calldata);
      const dataToHash = [
        txHashPrefix,
        version7,
        contractAddress,
        entryPointSelector,
        calldataHash,
        maxFee,
        chainId,
        ...additionalData
      ];
      return computeHashOnElements(dataToHash);
    }
    function calculateDeclareTransactionHash(classHash, senderAddress, version7, maxFee, chainId, nonce, compiledClassHash) {
      return calculateTransactionHashCommon(
        "0x6465636c617265",
        version7,
        senderAddress,
        0,
        [classHash],
        maxFee,
        chainId,
        [nonce, ...compiledClassHash ? [compiledClassHash] : []]
      );
    }
    function calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version7, maxFee, chainId, nonce) {
      const calldata = [classHash, salt, ...constructorCalldata];
      return calculateTransactionHashCommon(
        "0x6465706c6f795f6163636f756e74",
        version7,
        contractAddress,
        0,
        calldata,
        maxFee,
        chainId,
        [nonce]
      );
    }
    function calculateTransactionHash(contractAddress, version7, calldata, maxFee, chainId, nonce) {
      return calculateTransactionHashCommon(
        "0x696e766f6b65",
        version7,
        contractAddress,
        0,
        calldata,
        maxFee,
        chainId,
        [nonce]
      );
    }
    var v3_exports = {};
    __export2(v3_exports, {
      calculateDeclareTransactionHash: () => calculateDeclareTransactionHash2,
      calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash2,
      calculateInvokeTransactionHash: () => calculateInvokeTransactionHash,
      calculateTransactionHashCommon: () => calculateTransactionHashCommon2,
      hashDAMode: () => hashDAMode,
      hashFeeField: () => hashFeeField
    });
    var import_starknet2 = require_lib2();
    var AToBI = (array) => array.map((it) => BigInt(it));
    var DATA_AVAILABILITY_MODE_BITS = 32n;
    var MAX_AMOUNT_BITS = 64n;
    var MAX_PRICE_PER_UNIT_BITS = 128n;
    var RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;
    var L1_GAS_NAME = BigInt(encodeShortString("L1_GAS"));
    var L2_GAS_NAME = BigInt(encodeShortString("L2_GAS"));
    function hashDAMode(nonceDAMode, feeDAMode) {
      return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);
    }
    function hashFeeField(tip, bounds) {
      const L1Bound = (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l1_gas.max_price_per_unit);
      const L2Bound = (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l2_gas.max_price_per_unit);
      return (0, import_starknet2.poseidonHashMany)([BigInt(tip), L1Bound, L2Bound]);
    }
    function calculateTransactionHashCommon2(txHashPrefix, version7, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, additionalData = []) {
      const feeFieldHash = hashFeeField(tip, resourceBounds);
      const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);
      const dataToHash = AToBI([
        txHashPrefix,
        version7,
        senderAddress,
        feeFieldHash,
        (0, import_starknet2.poseidonHashMany)(AToBI(paymasterData)),
        chainId,
        nonce,
        dAModeHash,
        ...AToBI(additionalData)
      ]);
      return toHex2((0, import_starknet2.poseidonHashMany)(dataToHash));
    }
    function calculateDeployAccountTransactionHash2(contractAddress, classHash, compiledConstructorCalldata, salt, version7, chainId, nonce, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {
      return calculateTransactionHashCommon2(
        "0x6465706c6f795f6163636f756e74",
        version7,
        contractAddress,
        chainId,
        nonce,
        tip,
        paymasterData,
        nonceDataAvailabilityMode,
        feeDataAvailabilityMode,
        resourceBounds,
        [(0, import_starknet2.poseidonHashMany)(AToBI(compiledConstructorCalldata)), classHash, salt]
      );
    }
    function calculateDeclareTransactionHash2(classHash, compiledClassHash, senderAddress, version7, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {
      return calculateTransactionHashCommon2(
        "0x6465636c617265",
        version7,
        senderAddress,
        chainId,
        nonce,
        tip,
        AToBI(paymasterData),
        nonceDataAvailabilityMode,
        feeDataAvailabilityMode,
        resourceBounds,
        [(0, import_starknet2.poseidonHashMany)(AToBI(accountDeploymentData)), classHash, compiledClassHash]
      );
    }
    function calculateInvokeTransactionHash(senderAddress, version7, compiledCalldata, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {
      return calculateTransactionHashCommon2(
        "0x696e766f6b65",
        version7,
        senderAddress,
        chainId,
        nonce,
        tip,
        paymasterData,
        nonceDataAvailabilityMode,
        feeDataAvailabilityMode,
        resourceBounds,
        [(0, import_starknet2.poseidonHashMany)(AToBI(accountDeploymentData)), (0, import_starknet2.poseidonHashMany)(AToBI(compiledCalldata))]
      );
    }
    function isV3InvokeTx(args) {
      return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);
    }
    function calculateInvokeTransactionHash2(args) {
      if (isV3InvokeTx(args)) {
        return calculateInvokeTransactionHash(
          args.senderAddress,
          args.version,
          args.compiledCalldata,
          args.chainId,
          args.nonce,
          args.accountDeploymentData,
          args.nonceDataAvailabilityMode,
          args.feeDataAvailabilityMode,
          args.resourceBounds,
          args.tip,
          args.paymasterData
        );
      }
      return calculateTransactionHash(
        args.senderAddress,
        args.version,
        args.compiledCalldata,
        args.maxFee,
        args.chainId,
        args.nonce
      );
    }
    function isV3DeclareTx(args) {
      return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);
    }
    function calculateDeclareTransactionHash3(args) {
      if (isV3DeclareTx(args)) {
        return calculateDeclareTransactionHash2(
          args.classHash,
          args.compiledClassHash,
          args.senderAddress,
          args.version,
          args.chainId,
          args.nonce,
          args.accountDeploymentData,
          args.nonceDataAvailabilityMode,
          args.feeDataAvailabilityMode,
          args.resourceBounds,
          args.tip,
          args.paymasterData
        );
      }
      return calculateDeclareTransactionHash(
        args.classHash,
        args.senderAddress,
        args.version,
        args.maxFee,
        args.chainId,
        args.nonce,
        args.compiledClassHash
      );
    }
    function isV3DeployAccountTx(args) {
      return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);
    }
    function calculateDeployAccountTransactionHash3(args) {
      if (isV3DeployAccountTx(args)) {
        return calculateDeployAccountTransactionHash2(
          args.contractAddress,
          args.classHash,
          args.compiledConstructorCalldata,
          args.salt,
          args.version,
          args.chainId,
          args.nonce,
          args.nonceDataAvailabilityMode,
          args.feeDataAvailabilityMode,
          args.resourceBounds,
          args.tip,
          args.paymasterData
        );
      }
      return calculateDeployAccountTransactionHash(
        args.contractAddress,
        args.classHash,
        args.constructorCalldata,
        args.salt,
        args.version,
        args.maxFee,
        args.chainId,
        args.nonce
      );
    }
    var import_starknet3 = require_lib2();
    var json_exports = {};
    __export2(json_exports, {
      parse: () => parse22,
      parseAlwaysAsBig: () => parseAlwaysAsBig,
      stringify: () => stringify2,
      stringifyAlwaysAsBig: () => stringifyAlwaysAsBig
    });
    var json = __toESM3(require_lossless_json());
    var parseIntAsNumberOrBigInt = (str) => {
      if (!json.isInteger(str))
        return parseFloat(str);
      const num2 = parseInt(str, 10);
      return Number.isSafeInteger(num2) ? num2 : BigInt(str);
    };
    var parse22 = (str) => json.parse(String(str), void 0, parseIntAsNumberOrBigInt);
    var parseAlwaysAsBig = (str) => json.parse(String(str), void 0, json.parseNumberAndBigInt);
    var stringify2 = (value, replacer, space, numberStringifiers) => json.stringify(value, replacer, space, numberStringifiers);
    var stringifyAlwaysAsBig = stringify2;
    function computePedersenHash(a, b) {
      return starkCurve.pedersen(BigInt(a), BigInt(b));
    }
    function computePoseidonHash(a, b) {
      return toHex2(starkCurve.poseidonHash(BigInt(a), BigInt(b)));
    }
    function computeHashOnElements2(data) {
      return [...data, data.length].reduce((x, y) => starkCurve.pedersen(BigInt(x), BigInt(y)), 0).toString();
    }
    var computePedersenHashOnElements = computeHashOnElements2;
    function computePoseidonHashOnElements(data) {
      return toHex2((0, import_starknet3.poseidonHashMany)(data.map((x) => BigInt(x))));
    }
    function calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {
      const compiledCalldata = CallData.compile(constructorCalldata);
      const constructorCalldataHash = computeHashOnElements2(compiledCalldata);
      const CONTRACT_ADDRESS_PREFIX = felt("0x535441524b4e45545f434f4e54524143545f41444452455353");
      const hash2 = computeHashOnElements2([
        CONTRACT_ADDRESS_PREFIX,
        deployerAddress,
        salt,
        classHash,
        constructorCalldataHash
      ]);
      return toHex2(BigInt(hash2) % ADDR_BOUND);
    }
    function nullSkipReplacer(key, value) {
      if (key === "attributes" || key === "accessible_scopes") {
        return Array.isArray(value) && value.length === 0 ? void 0 : value;
      }
      if (key === "debug_info") {
        return null;
      }
      return value === null ? void 0 : value;
    }
    function formatSpaces(json2) {
      let insideQuotes = false;
      const newString = [];
      for (const char of json2) {
        if (char === '"' && (newString.length > 0 && newString.slice(-1)[0] === "\\") === false) {
          insideQuotes = !insideQuotes;
        }
        if (insideQuotes) {
          newString.push(char);
        } else {
          newString.push(char === ":" ? ": " : char === "," ? ", " : char);
        }
      }
      return newString.join("");
    }
    function computeHintedClassHash(compiledContract) {
      const { abi, program } = compiledContract;
      const contractClass = { abi, program };
      const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));
      return addHexPrefix(starkCurve.keccak(utf8ToArray(serializedJson)).toString(16));
    }
    function computeLegacyContractClassHash(contract) {
      const compiledContract = isString(contract) ? parse22(contract) : contract;
      const apiVersion = toHex2(API_VERSION);
      const externalEntryPointsHash = computeHashOnElements2(
        compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])
      );
      const l1HandlerEntryPointsHash = computeHashOnElements2(
        compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])
      );
      const constructorEntryPointHash = computeHashOnElements2(
        compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])
      );
      const builtinsHash = computeHashOnElements2(
        compiledContract.program.builtins.map((s) => encodeShortString(s))
      );
      const hintedClassHash = computeHintedClassHash(compiledContract);
      const dataHash = computeHashOnElements2(compiledContract.program.data);
      return computeHashOnElements2([
        apiVersion,
        externalEntryPointsHash,
        l1HandlerEntryPointsHash,
        constructorEntryPointHash,
        builtinsHash,
        hintedClassHash,
        dataHash
      ]);
    }
    function hashBuiltins(builtins) {
      return (0, import_starknet3.poseidonHashMany)(
        builtins.flatMap((it) => {
          return BigInt(encodeShortString(it));
        })
      );
    }
    function hashEntryPoint(data) {
      const base = data.flatMap((it) => {
        return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];
      });
      return (0, import_starknet3.poseidonHashMany)(base);
    }
    function hashByteCodeSegments(casm) {
      const byteCode = casm.bytecode.map((n) => BigInt(n));
      const bytecodeSegmentLengths = casm.bytecode_segment_lengths ?? [];
      let segmentStart = 0;
      const hashLeaves = bytecodeSegmentLengths.flatMap((len) => {
        const segment = byteCode.slice(segmentStart, segmentStart += len);
        return [BigInt(len), (0, import_starknet3.poseidonHashMany)(segment)];
      });
      return 1n + (0, import_starknet3.poseidonHashMany)(hashLeaves);
    }
    function computeCompiledClassHash(casm) {
      const COMPILED_CLASS_VERSION = "COMPILED_CLASS_V1";
      const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));
      const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);
      const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);
      const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);
      const bytecode = casm.bytecode_segment_lengths ? hashByteCodeSegments(casm) : (0, import_starknet3.poseidonHashMany)(casm.bytecode.map((it) => BigInt(it)));
      return toHex2(
        (0, import_starknet3.poseidonHashMany)([
          compiledClassVersion,
          externalEntryPointsHash,
          l1Handlers,
          constructor,
          bytecode
        ])
      );
    }
    function hashEntryPointSierra(data) {
      const base = data.flatMap((it) => {
        return [BigInt(it.selector), BigInt(it.function_idx)];
      });
      return (0, import_starknet3.poseidonHashMany)(base);
    }
    function hashAbi(sierra) {
      const indentString = formatSpaces(stringify2(sierra.abi, null));
      return BigInt(addHexPrefix(starkCurve.keccak(utf8ToArray(indentString)).toString(16)));
    }
    function computeSierraContractClassHash(sierra) {
      const CONTRACT_CLASS_VERSION = "CONTRACT_CLASS_V0.1.0";
      const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));
      const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);
      const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);
      const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);
      const abiHash = hashAbi(sierra);
      const sierraProgram = (0, import_starknet3.poseidonHashMany)(sierra.sierra_program.map((it) => BigInt(it)));
      return toHex2(
        (0, import_starknet3.poseidonHashMany)([
          compiledClassVersion,
          externalEntryPointsHash,
          l1Handlers,
          constructor,
          abiHash,
          sierraProgram
        ])
      );
    }
    function computeContractClassHash(contract) {
      const compiledContract = isString(contract) ? parse22(contract) : contract;
      if ("sierra_program" in compiledContract) {
        return computeSierraContractClassHash(compiledContract);
      }
      return computeLegacyContractClassHash(compiledContract);
    }
    var stark_exports = {};
    __export2(stark_exports, {
      compressProgram: () => compressProgram,
      decompressProgram: () => decompressProgram,
      estimateFeeToBounds: () => estimateFeeToBounds,
      estimatedFeeToMaxFee: () => estimatedFeeToMaxFee,
      formatSignature: () => formatSignature,
      intDAM: () => intDAM,
      makeAddress: () => makeAddress,
      randomAddress: () => randomAddress,
      reduceV2: () => reduceV2,
      signatureToDecimalArray: () => signatureToDecimalArray,
      signatureToHexArray: () => signatureToHexArray,
      toFeeVersion: () => toFeeVersion,
      toTransactionVersion: () => toTransactionVersion,
      v3Details: () => v3Details
    });
    var import_starknet4 = require_lib2();
    var import_pako = require_pako();
    function compressProgram(jsonProgram) {
      const stringified = isString(jsonProgram) ? jsonProgram : stringify2(jsonProgram);
      const compressedProgram = (0, import_pako.gzip)(stringified);
      return btoaUniversal(compressedProgram);
    }
    function decompressProgram(base642) {
      if (Array.isArray(base642))
        return base642;
      const decompressed = arrayBufferToString((0, import_pako.ungzip)(atobUniversal(base642)));
      return parse22(decompressed);
    }
    function randomAddress() {
      const randomKeyPair = import_starknet4.utils.randomPrivateKey();
      return (0, import_starknet4.getStarkKey)(randomKeyPair);
    }
    function makeAddress(input) {
      return addHexPrefix(input).toLowerCase();
    }
    function formatSignature(sig) {
      if (!sig)
        throw Error("formatSignature: provided signature is undefined");
      if (Array.isArray(sig)) {
        return sig.map((it) => toHex2(it));
      }
      try {
        const { r: r2, s } = sig;
        return [toHex2(r2), toHex2(s)];
      } catch (e) {
        throw new Error("Signature need to be weierstrass.SignatureType or an array for custom");
      }
    }
    function signatureToDecimalArray(sig) {
      return bigNumberishArrayToDecimalStringArray(formatSignature(sig));
    }
    function signatureToHexArray(sig) {
      return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));
    }
    function estimatedFeeToMaxFee(estimatedFee, overhead = 50) {
      return addPercent(estimatedFee, overhead);
    }
    function estimateFeeToBounds(estimate, amountOverhead = 50, priceOverhead = 50) {
      if (isBigInt(estimate)) {
        return {
          l2_gas: { max_amount: "0x0", max_price_per_unit: "0x0" },
          l1_gas: { max_amount: "0x0", max_price_per_unit: "0x0" }
        };
      }
      if (typeof estimate.gas_consumed === "undefined" || typeof estimate.gas_price === "undefined") {
        throw Error("estimateFeeToBounds: estimate is undefined");
      }
      const maxUnits = estimate.data_gas_consumed !== void 0 && estimate.data_gas_price !== void 0 ? toHex2(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead)) : toHex2(addPercent(estimate.gas_consumed, amountOverhead));
      const maxUnitPrice = toHex2(addPercent(estimate.gas_price, priceOverhead));
      return {
        l2_gas: { max_amount: "0x0", max_price_per_unit: "0x0" },
        l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice }
      };
    }
    function intDAM(dam) {
      if (dam === api_exports.EDataAvailabilityMode.L1)
        return api_exports.EDAMode.L1;
      if (dam === api_exports.EDataAvailabilityMode.L2)
        return api_exports.EDAMode.L2;
      throw Error("EDAM conversion");
    }
    function toTransactionVersion(defaultVersion, providedVersion) {
      const providedVersion0xs = providedVersion ? toHex2(providedVersion) : void 0;
      const defaultVersion0xs = toHex2(defaultVersion);
      if (providedVersion && !Object.values(api_exports.ETransactionVersion).includes(providedVersion0xs)) {
        throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);
      }
      if (!Object.values(api_exports.ETransactionVersion).includes(defaultVersion0xs)) {
        throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);
      }
      return providedVersion ? providedVersion0xs : defaultVersion0xs;
    }
    function toFeeVersion(providedVersion) {
      if (!providedVersion)
        return void 0;
      const version7 = toHex2(providedVersion);
      if (version7 === api_exports.ETransactionVersion.V0)
        return api_exports.ETransactionVersion.F0;
      if (version7 === api_exports.ETransactionVersion.V1)
        return api_exports.ETransactionVersion.F1;
      if (version7 === api_exports.ETransactionVersion.V2)
        return api_exports.ETransactionVersion.F2;
      if (version7 === api_exports.ETransactionVersion.V3)
        return api_exports.ETransactionVersion.F3;
      throw Error(`toFeeVersion: ${version7} is not supported`);
    }
    function v3Details(details) {
      return {
        tip: details.tip || 0,
        paymasterData: details.paymasterData || [],
        accountDeploymentData: details.accountDeploymentData || [],
        nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,
        feeDataAvailabilityMode: details.feeDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,
        resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO2)
      };
    }
    function reduceV2(providedVersion) {
      if (providedVersion === api_exports.ETransactionVersion.F2)
        return api_exports.ETransactionVersion.F1;
      if (providedVersion === api_exports.ETransactionVersion.V2)
        return api_exports.ETransactionVersion.V1;
      return providedVersion;
    }
    function isSierra(contract) {
      const compiledContract = isString(contract) ? parse22(contract) : contract;
      return "sierra_program" in compiledContract;
    }
    function extractContractHashes(payload) {
      const response = { ...payload };
      if (isSierra(payload.contract)) {
        if (!payload.compiledClassHash && payload.casm) {
          response.compiledClassHash = computeCompiledClassHash(payload.casm);
        }
        if (!response.compiledClassHash)
          throw new Error(
            "Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash"
          );
      }
      response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);
      if (!response.classHash)
        throw new Error("Extract classHash failed, provide (CompiledContract).json file or classHash");
      return response;
    }
    function contractClassResponseToLegacyCompiledContract(ccr) {
      if (isSierra(ccr)) {
        throw Error("ContractClassResponse need to be LegacyContractClass (cairo0 response class)");
      }
      const contract = ccr;
      return { ...contract, program: decompressProgram(contract.program) };
    }
    var eth_exports = {};
    __export2(eth_exports, {
      ethRandomPrivateKey: () => ethRandomPrivateKey,
      validateAndParseEthAddress: () => validateAndParseEthAddress
    });
    var import_secp256k1 = require_secp256k12();
    function ethRandomPrivateKey() {
      return sanitizeHex(buf2hex(import_secp256k1.secp256k1.utils.randomPrivateKey()));
    }
    function validateAndParseEthAddress(address) {
      assertInRange(address, ZERO2, 2n ** 160n - 1n, "Ethereum Address ");
      const result2 = addHexPrefix(removeHexPrefix(toHex2(address)).padStart(40, "0"));
      assert5(Boolean(result2.match(/^(0x)?[0-9a-f]{40}$/)), "Invalid Ethereum Address Format");
      return result2;
    }
    var import_fetch_cookie = __toESM3(require_cjs2());
    var import_isomorphic_fetch = __toESM3(require_fetch_npm_browserify());
    var fetchPonyfill_default = typeof window !== "undefined" && window.fetch || // use buildin fetch in browser if available
    typeof global !== "undefined" && (0, import_fetch_cookie.default)(global.fetch) || // use buildin fetch in node, react-native and service worker if available
    import_isomorphic_fetch.default;
    var provider_exports = {};
    __export2(provider_exports, {
      Block: () => Block,
      createSierraContractClass: () => createSierraContractClass,
      getDefaultNodeUrl: () => getDefaultNodeUrl,
      isPendingBlock: () => isPendingBlock,
      isPendingStateUpdate: () => isPendingStateUpdate,
      isPendingTransaction: () => isPendingTransaction,
      isV3Tx: () => isV3Tx,
      isVersion: () => isVersion,
      parseContract: () => parseContract,
      validBlockTags: () => validBlockTags,
      wait: () => wait
    });
    function wait(delay) {
      return new Promise((res) => {
        setTimeout(res, delay);
      });
    }
    function createSierraContractClass(contract) {
      const result2 = { ...contract };
      delete result2.sierra_program_debug_info;
      result2.abi = formatSpaces(stringify2(contract.abi));
      result2.sierra_program = formatSpaces(stringify2(contract.sierra_program));
      result2.sierra_program = compressProgram(result2.sierra_program);
      return result2;
    }
    function parseContract(contract) {
      const parsedContract = isString(contract) ? parse22(contract) : contract;
      if (!isSierra(contract)) {
        return {
          ...parsedContract,
          ..."program" in parsedContract && { program: compressProgram(parsedContract.program) }
        };
      }
      return createSierraContractClass(parsedContract);
    }
    var getDefaultNodeUrl = (networkName, mute = false) => {
      if (!mute) {
        console.warn("Using default public node url, please provide nodeUrl in provider options!");
      }
      const nodes = RPC_NODES[
        networkName ?? "SN_SEPOLIA"
        /* SN_SEPOLIA */
      ];
      const randIdx = Math.floor(Math.random() * nodes.length);
      return nodes[randIdx];
    };
    var validBlockTags = Object.values(BlockTag);
    var Block = class {
      /**
       * Create a Block instance
       * @param {BlockIdentifier} _identifier  hex string and BigInt are detected as block hashes.
       * decimal string and number are detected as block numbers.
       * text string are detected as block tag.
       * null is considered as a 'pending' block tag.
       */
      constructor(_identifier) {
        /**
         * @param {BlockIdentifier} hash if not null, contains the block hash
         */
        __publicField(this, "hash", null);
        /**
         * @param {BlockIdentifier} number if not null, contains the block number
         */
        __publicField(this, "number", null);
        /**
         * @param {BlockIdentifier} tag if not null, contains "pending" or "latest"
         */
        __publicField(this, "tag", null);
        __publicField(this, "valueOf", () => this.number);
        __publicField(this, "toString", () => this.hash);
        this.setIdentifier(_identifier);
      }
      setIdentifier(__identifier) {
        if (isString(__identifier)) {
          if (isDecimalString(__identifier)) {
            this.number = parseInt(__identifier, 10);
          } else if (isHex(__identifier)) {
            this.hash = __identifier;
          } else if (validBlockTags.includes(__identifier)) {
            this.tag = __identifier;
          } else {
            throw TypeError(`Block identifier unmanaged: ${__identifier}`);
          }
        } else if (isBigInt(__identifier)) {
          this.hash = toHex2(__identifier);
        } else if (isNumber2(__identifier)) {
          this.number = __identifier;
        } else {
          this.tag = "pending";
        }
        if (isNumber2(this.number) && this.number < 0) {
          throw TypeError(`Block number (${this.number}) can't be negative`);
        }
      }
      // TODO: fix any
      /**
       * @returns {any} the identifier as a string
       * @example
       * ```typescript
       * const result = new provider.Block(123456n).queryIdentifier;
       * // result = "blockHash=0x1e240"
       * ```
       */
      get queryIdentifier() {
        if (this.number !== null) {
          return `blockNumber=${this.number}`;
        }
        if (this.hash !== null) {
          return `blockHash=${this.hash}`;
        }
        return `blockNumber=${this.tag}`;
      }
      // TODO: fix any
      /**
       * @returns {any} the identifier as an object
       * @example
       * ```typescript
       * const result = new provider.Block(56789).identifier;
       * // result = { block_number: 56789 }
       * ```
       */
      get identifier() {
        if (this.number !== null) {
          return { block_number: this.number };
        }
        if (this.hash !== null) {
          return { block_hash: this.hash };
        }
        return this.tag;
      }
      /**
       * change the identifier of an existing Block instance
       * @example
       * ```typescript
       * const myBlock = new provider.Block("latest");
       * myBlock.identifier ="0x3456789abc";
       * const result = myBlock.identifier;
       * // result = { block_hash: '0x3456789abc' }
       * ```
       */
      set identifier(_identifier) {
        this.setIdentifier(_identifier);
      }
    };
    function isV3Tx(details) {
      const version7 = details.version ? toHex2(details.version) : api_exports.ETransactionVersion.V3;
      return version7 === api_exports.ETransactionVersion.V3 || version7 === api_exports.ETransactionVersion.F3;
    }
    function isVersion(version7, response) {
      const [majorS, minorS] = version7.split(".");
      const [majorR, minorR] = response.split(".");
      return majorS === majorR && minorS === minorR;
    }
    function isPendingBlock(response) {
      return response.status === "PENDING";
    }
    function isPendingTransaction(response) {
      return !("block_hash" in response);
    }
    function isPendingStateUpdate(response) {
      return !("block_hash" in response);
    }
    var transaction_exports = {};
    __export2(transaction_exports, {
      buildUDCCall: () => buildUDCCall,
      fromCallsToExecuteCalldata: () => fromCallsToExecuteCalldata,
      fromCallsToExecuteCalldataWithNonce: () => fromCallsToExecuteCalldataWithNonce,
      fromCallsToExecuteCalldata_cairo1: () => fromCallsToExecuteCalldata_cairo1,
      getExecuteCalldata: () => getExecuteCalldata,
      getVersionsByType: () => getVersionsByType,
      transformCallsToMulticallArrays: () => transformCallsToMulticallArrays,
      transformCallsToMulticallArrays_cairo1: () => transformCallsToMulticallArrays_cairo1
    });
    var transformCallsToMulticallArrays = (calls) => {
      const callArray = [];
      const calldata = [];
      calls.forEach((call) => {
        const data = CallData.compile(call.calldata || []);
        callArray.push({
          to: toBigInt(call.contractAddress).toString(10),
          selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),
          data_offset: calldata.length.toString(),
          data_len: data.length.toString()
        });
        calldata.push(...data);
      });
      return {
        callArray,
        calldata: CallData.compile({ calldata })
      };
    };
    var fromCallsToExecuteCalldata = (calls) => {
      const { callArray, calldata } = transformCallsToMulticallArrays(calls);
      const compiledCalls = CallData.compile({ callArray });
      return [...compiledCalls, ...calldata];
    };
    var fromCallsToExecuteCalldataWithNonce = (calls, nonce) => {
      return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()];
    };
    var transformCallsToMulticallArrays_cairo1 = (calls) => {
      const callArray = calls.map((call) => ({
        to: toBigInt(call.contractAddress).toString(10),
        selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),
        calldata: CallData.compile(call.calldata || [])
      }));
      return callArray;
    };
    var fromCallsToExecuteCalldata_cairo1 = (calls) => {
      const orderCalls = calls.map((call) => ({
        contractAddress: call.contractAddress,
        entrypoint: call.entrypoint,
        calldata: Array.isArray(call.calldata) && "__compiled__" in call.calldata ? call.calldata : CallData.compile(call.calldata)
        // RawArgsObject | RawArgsArray type
      }));
      return CallData.compile({ orderCalls });
    };
    var getExecuteCalldata = (calls, cairoVersion = "0") => {
      if (cairoVersion === "1") {
        return fromCallsToExecuteCalldata_cairo1(calls);
      }
      return fromCallsToExecuteCalldata(calls);
    };
    function buildUDCCall(payload, address) {
      const params = [].concat(payload).map((it) => {
        const {
          classHash,
          salt,
          unique: unique2 = true,
          constructorCalldata = []
        } = it;
        const compiledConstructorCallData = CallData.compile(constructorCalldata);
        const deploySalt = salt ?? randomAddress();
        return {
          call: {
            contractAddress: UDC.ADDRESS,
            entrypoint: UDC.ENTRYPOINT,
            calldata: [
              classHash,
              deploySalt,
              toCairoBool(unique2),
              compiledConstructorCallData.length,
              ...compiledConstructorCallData
            ]
          },
          address: calculateContractAddressFromHash(
            unique2 ? starkCurve.pedersen(address, deploySalt) : deploySalt,
            classHash,
            compiledConstructorCallData,
            unique2 ? UDC.ADDRESS : 0
          )
        };
      });
      return {
        calls: params.map((it) => it.call),
        addresses: params.map((it) => it.address)
      };
    }
    function getVersionsByType(versionType) {
      return versionType === "fee" ? {
        v1: api_exports.ETransactionVersion.F1,
        v2: api_exports.ETransactionVersion.F2,
        v3: api_exports.ETransactionVersion.F3
      } : { v1: api_exports.ETransactionVersion.V1, v2: api_exports.ETransactionVersion.V2, v3: api_exports.ETransactionVersion.V3 };
    }
    var defaultOptions3 = {
      headers: { "Content-Type": "application/json" },
      blockIdentifier: "pending",
      retries: 200
    };
    var RpcChannel = class {
      // behave like web2 rpc and return when tx is processed
      constructor(optionsOrProvider) {
        __publicField(this, "nodeUrl");
        __publicField(this, "headers");
        __publicField(this, "retries");
        __publicField(this, "requestId");
        __publicField(this, "blockIdentifier");
        __publicField(this, "chainId");
        __publicField(this, "specVersion");
        __publicField(this, "waitMode");
        const { nodeUrl, retries, headers, blockIdentifier, chainId, specVersion, waitMode } = optionsOrProvider || {};
        if (Object.values(NetworkName).includes(nodeUrl)) {
          this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider == null ? void 0 : optionsOrProvider.default);
        } else if (nodeUrl) {
          this.nodeUrl = nodeUrl;
        } else {
          this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider == null ? void 0 : optionsOrProvider.default);
        }
        this.retries = retries || defaultOptions3.retries;
        this.headers = { ...defaultOptions3.headers, ...headers };
        this.blockIdentifier = blockIdentifier || defaultOptions3.blockIdentifier;
        this.chainId = chainId;
        this.specVersion = specVersion;
        this.waitMode = waitMode || false;
        this.requestId = 0;
      }
      setChainId(chainId) {
        this.chainId = chainId;
      }
      fetch(method, params, id = 0) {
        const rpcRequestBody = {
          id,
          jsonrpc: "2.0",
          method,
          ...params && { params }
        };
        return fetchPonyfill_default(this.nodeUrl, {
          method: "POST",
          body: stringify2(rpcRequestBody),
          headers: this.headers
        });
      }
      errorHandler(method, params, rpcError, otherError) {
        if (rpcError) {
          const { code, message, data } = rpcError;
          throw new LibraryError(
            `RPC: ${method} with params ${stringify2(params, null, 2)}

        ${code}: ${message}: ${stringify2(data)}`
          );
        }
        if (otherError instanceof LibraryError) {
          throw otherError;
        }
        if (otherError) {
          throw Error(otherError.message);
        }
      }
      async fetchEndpoint(method, params) {
        var _a4;
        try {
          const rawResult = await this.fetch(method, params, this.requestId += 1);
          const { error, result: result2 } = await rawResult.json();
          this.errorHandler(method, params, error);
          return result2;
        } catch (error) {
          this.errorHandler(method, params, (_a4 = error == null ? void 0 : error.response) == null ? void 0 : _a4.data, error);
          throw error;
        }
      }
      async getChainId() {
        this.chainId ?? (this.chainId = await this.fetchEndpoint("starknet_chainId"));
        return this.chainId;
      }
      async getSpecVersion() {
        this.specVersion ?? (this.specVersion = await this.fetchEndpoint("starknet_specVersion"));
        return this.specVersion;
      }
      getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {
        const contract_address = toHex2(contractAddress);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getNonce", {
          contract_address,
          block_id
        });
      }
      /**
       * Get the most recent accepted block hash and number
       */
      getBlockLatestAccepted() {
        return this.fetchEndpoint("starknet_blockHashAndNumber");
      }
      /**
       * Get the most recent accepted block number
       * redundant use getBlockLatestAccepted();
       * @returns Number of the latest block
       */
      getBlockNumber() {
        return this.fetchEndpoint("starknet_blockNumber");
      }
      getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getBlockWithTxHashes", { block_id });
      }
      getBlockWithTxs(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getBlockWithTxs", { block_id });
      }
      getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getStateUpdate", { block_id });
      }
      getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_traceBlockTransactions", { block_id });
      }
      getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getBlockTransactionCount", { block_id });
      }
      getTransactionByHash(txHash) {
        const transaction_hash = toHex2(txHash);
        return this.fetchEndpoint("starknet_getTransactionByHash", {
          transaction_hash
        });
      }
      getTransactionByBlockIdAndIndex(blockIdentifier, index2) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex", { block_id, index: index2 });
      }
      getTransactionReceipt(txHash) {
        const transaction_hash = toHex2(txHash);
        return this.fetchEndpoint("starknet_getTransactionReceipt", { transaction_hash });
      }
      getTransactionTrace(txHash) {
        const transaction_hash = toHex2(txHash);
        return this.fetchEndpoint("starknet_traceTransaction", { transaction_hash });
      }
      /**
       * Get the status of a transaction
       */
      getTransactionStatus(transactionHash) {
        const transaction_hash = toHex2(transactionHash);
        return this.fetchEndpoint("starknet_getTransactionStatus", { transaction_hash });
      }
      /**
       * @param invocations AccountInvocations
       * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>
       * - blockIdentifier<br/>
       * - skipValidate (default false)<br/>
       * - skipFeeCharge (default true)<br/>
       */
      simulateTransaction(invocations, simulateTransactionOptions = {}) {
        const {
          blockIdentifier = this.blockIdentifier,
          skipValidate = true,
          skipFeeCharge = true
        } = simulateTransactionOptions;
        const block_id = new Block(blockIdentifier).identifier;
        const simulationFlags = [];
        if (skipValidate)
          simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE);
        if (skipFeeCharge)
          simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_FEE_CHARGE);
        return this.fetchEndpoint("starknet_simulateTransactions", {
          block_id,
          transactions: invocations.map((it) => this.buildTransaction(it)),
          simulation_flags: simulationFlags
        });
      }
      async waitForTransaction(txHash, options) {
        const transactionHash = toHex2(txHash);
        let { retries } = this;
        let onchain = false;
        let isErrorState = false;
        const retryInterval = (options == null ? void 0 : options.retryInterval) ?? 5e3;
        const errorStates = (options == null ? void 0 : options.errorStates) ?? [
          rpcspec_0_6_exports.ETransactionStatus.REJECTED
          // TODO: commented out to preserve the long-standing behavior of "reverted" not being treated as an error by default
          // should decide which behavior to keep in the future
          // RPC.ETransactionExecutionStatus.REVERTED,
        ];
        const successStates = (options == null ? void 0 : options.successStates) ?? [
          rpcspec_0_6_exports.ETransactionExecutionStatus.SUCCEEDED,
          rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L2,
          rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L1
        ];
        let txStatus;
        while (!onchain) {
          await wait(retryInterval);
          try {
            txStatus = await this.getTransactionStatus(transactionHash);
            const executionStatus = txStatus.execution_status;
            const finalityStatus = txStatus.finality_status;
            if (!finalityStatus) {
              const error = new Error("waiting for transaction status");
              throw error;
            }
            if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {
              const message = `${executionStatus}: ${finalityStatus}`;
              const error = new Error(message);
              error.response = txStatus;
              isErrorState = true;
              throw error;
            } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {
              onchain = true;
            }
          } catch (error) {
            if (error instanceof Error && isErrorState) {
              throw error;
            }
            if (retries <= 0) {
              throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
            }
          }
          retries -= 1;
        }
        let txReceipt = null;
        while (txReceipt === null) {
          try {
            txReceipt = await this.getTransactionReceipt(transactionHash);
          } catch (error) {
            if (retries <= 0) {
              throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
            }
          }
          retries -= 1;
          await wait(retryInterval);
        }
        return txReceipt;
      }
      getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {
        const contract_address = toHex2(contractAddress);
        const parsedKey = toStorageKey(key);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getStorageAt", {
          contract_address,
          key: parsedKey,
          block_id
        });
      }
      getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {
        const contract_address = toHex2(contractAddress);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getClassHashAt", {
          block_id,
          contract_address
        });
      }
      getClass(classHash, blockIdentifier = this.blockIdentifier) {
        const class_hash = toHex2(classHash);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getClass", {
          class_hash,
          block_id
        });
      }
      getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {
        const contract_address = toHex2(contractAddress);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getClassAt", {
          block_id,
          contract_address
        });
      }
      async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {
        const block_id = new Block(blockIdentifier).identifier;
        let flags = {};
        if (!isVersion("0.5", await this.getSpecVersion())) {
          flags = {
            simulation_flags: skipValidate ? [rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE] : []
          };
        }
        return this.fetchEndpoint("starknet_estimateFee", {
          request: invocations.map((it) => this.buildTransaction(it, "fee")),
          block_id,
          ...flags
        });
      }
      async invoke(functionInvocation, details) {
        let promise;
        if (!isV3Tx(details)) {
          promise = this.fetchEndpoint("starknet_addInvokeTransaction", {
            invoke_transaction: {
              sender_address: functionInvocation.contractAddress,
              calldata: CallData.toHex(functionInvocation.calldata),
              type: rpcspec_0_6_exports.ETransactionType.INVOKE,
              max_fee: toHex2(details.maxFee || 0),
              version: rpcspec_0_6_exports.ETransactionVersion.V1,
              signature: signatureToHexArray(functionInvocation.signature),
              nonce: toHex2(details.nonce)
            }
          });
        } else {
          promise = this.fetchEndpoint("starknet_addInvokeTransaction", {
            invoke_transaction: {
              type: rpcspec_0_6_exports.ETransactionType.INVOKE,
              sender_address: functionInvocation.contractAddress,
              calldata: CallData.toHex(functionInvocation.calldata),
              version: rpcspec_0_6_exports.ETransactionVersion.V3,
              signature: signatureToHexArray(functionInvocation.signature),
              nonce: toHex2(details.nonce),
              resource_bounds: details.resourceBounds,
              tip: toHex2(details.tip),
              paymaster_data: details.paymasterData.map((it) => toHex2(it)),
              account_deployment_data: details.accountDeploymentData.map((it) => toHex2(it)),
              nonce_data_availability_mode: details.nonceDataAvailabilityMode,
              fee_data_availability_mode: details.feeDataAvailabilityMode
            }
          });
        }
        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
      }
      async declare({ contract, signature, senderAddress, compiledClassHash }, details) {
        let promise;
        if (!isSierra(contract) && !isV3Tx(details)) {
          promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
            declare_transaction: {
              type: rpcspec_0_6_exports.ETransactionType.DECLARE,
              contract_class: {
                program: contract.program,
                entry_points_by_type: contract.entry_points_by_type,
                abi: contract.abi
              },
              version: rpcspec_0_6_exports.ETransactionVersion.V1,
              max_fee: toHex2(details.maxFee || 0),
              signature: signatureToHexArray(signature),
              sender_address: senderAddress,
              nonce: toHex2(details.nonce)
            }
          });
        } else if (isSierra(contract) && !isV3Tx(details)) {
          promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
            declare_transaction: {
              type: rpcspec_0_6_exports.ETransactionType.DECLARE,
              contract_class: {
                sierra_program: decompressProgram(contract.sierra_program),
                contract_class_version: contract.contract_class_version,
                entry_points_by_type: contract.entry_points_by_type,
                abi: contract.abi
              },
              compiled_class_hash: compiledClassHash || "",
              version: rpcspec_0_6_exports.ETransactionVersion.V2,
              max_fee: toHex2(details.maxFee || 0),
              signature: signatureToHexArray(signature),
              sender_address: senderAddress,
              nonce: toHex2(details.nonce)
            }
          });
        } else if (isSierra(contract) && isV3Tx(details)) {
          promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
            declare_transaction: {
              type: rpcspec_0_6_exports.ETransactionType.DECLARE,
              sender_address: senderAddress,
              compiled_class_hash: compiledClassHash || "",
              version: rpcspec_0_6_exports.ETransactionVersion.V3,
              signature: signatureToHexArray(signature),
              nonce: toHex2(details.nonce),
              contract_class: {
                sierra_program: decompressProgram(contract.sierra_program),
                contract_class_version: contract.contract_class_version,
                entry_points_by_type: contract.entry_points_by_type,
                abi: contract.abi
              },
              resource_bounds: details.resourceBounds,
              tip: toHex2(details.tip),
              paymaster_data: details.paymasterData.map((it) => toHex2(it)),
              account_deployment_data: details.accountDeploymentData.map((it) => toHex2(it)),
              nonce_data_availability_mode: details.nonceDataAvailabilityMode,
              fee_data_availability_mode: details.feeDataAvailabilityMode
            }
          });
        } else {
          throw Error("declare unspotted parameters");
        }
        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
      }
      async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {
        let promise;
        if (!isV3Tx(details)) {
          promise = this.fetchEndpoint("starknet_addDeployAccountTransaction", {
            deploy_account_transaction: {
              constructor_calldata: CallData.toHex(constructorCalldata || []),
              class_hash: toHex2(classHash),
              contract_address_salt: toHex2(addressSalt || 0),
              type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,
              max_fee: toHex2(details.maxFee || 0),
              version: rpcspec_0_6_exports.ETransactionVersion.V1,
              signature: signatureToHexArray(signature),
              nonce: toHex2(details.nonce)
            }
          });
        } else {
          promise = this.fetchEndpoint("starknet_addDeployAccountTransaction", {
            deploy_account_transaction: {
              type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,
              version: rpcspec_0_6_exports.ETransactionVersion.V3,
              signature: signatureToHexArray(signature),
              nonce: toHex2(details.nonce),
              contract_address_salt: toHex2(addressSalt || 0),
              constructor_calldata: CallData.toHex(constructorCalldata || []),
              class_hash: toHex2(classHash),
              resource_bounds: details.resourceBounds,
              tip: toHex2(details.tip),
              paymaster_data: details.paymasterData.map((it) => toHex2(it)),
              nonce_data_availability_mode: details.nonceDataAvailabilityMode,
              fee_data_availability_mode: details.feeDataAvailabilityMode
            }
          });
        }
        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
      }
      callContract(call, blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_call", {
          request: {
            contract_address: call.contractAddress,
            entry_point_selector: getSelectorFromName(call.entrypoint),
            calldata: CallData.toHex(call.calldata)
          },
          block_id
        });
      }
      /**
       * NEW: Estimate the fee for a message from L1
       * @param message Message From L1
       */
      estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {
        const { from_address, to_address, entry_point_selector, payload } = message;
        const formattedMessage = {
          from_address: validateAndParseEthAddress(from_address),
          to_address: toHex2(to_address),
          entry_point_selector: getSelector(entry_point_selector),
          payload: getHexStringArray(payload)
        };
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_estimateMessageFee", {
          message: formattedMessage,
          block_id
        });
      }
      /**
       * Returns an object about the sync status, or false if the node is not synching
       * @returns Object with the stats data
       */
      getSyncingStats() {
        return this.fetchEndpoint("starknet_syncing");
      }
      /**
       * Returns all events matching the given filter
       * @returns events and the pagination of the events
       */
      getEvents(eventFilter) {
        return this.fetchEndpoint("starknet_getEvents", { filter: eventFilter });
      }
      buildTransaction(invocation, versionType) {
        const defaultVersions = getVersionsByType(versionType);
        let details;
        if (!isV3Tx(invocation)) {
          details = {
            signature: signatureToHexArray(invocation.signature),
            nonce: toHex2(invocation.nonce),
            max_fee: toHex2(invocation.maxFee || 0)
          };
        } else {
          details = {
            signature: signatureToHexArray(invocation.signature),
            nonce: toHex2(invocation.nonce),
            resource_bounds: invocation.resourceBounds,
            tip: toHex2(invocation.tip),
            paymaster_data: invocation.paymasterData.map((it) => toHex2(it)),
            nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,
            fee_data_availability_mode: invocation.feeDataAvailabilityMode,
            account_deployment_data: invocation.accountDeploymentData.map((it) => toHex2(it))
          };
        }
        if (invocation.type === "INVOKE_FUNCTION") {
          return {
            // v0 v1 v3
            type: rpcspec_0_6_exports.ETransactionType.INVOKE,
            sender_address: invocation.contractAddress,
            calldata: CallData.toHex(invocation.calldata),
            version: toHex2(invocation.version || defaultVersions.v3),
            ...details
          };
        }
        if (invocation.type === "DECLARE") {
          if (!isSierra(invocation.contract)) {
            return {
              type: invocation.type,
              contract_class: invocation.contract,
              sender_address: invocation.senderAddress,
              version: toHex2(invocation.version || defaultVersions.v1),
              ...details
            };
          }
          return {
            // Cairo 1 - v2 v3
            type: invocation.type,
            contract_class: {
              ...invocation.contract,
              sierra_program: decompressProgram(invocation.contract.sierra_program)
            },
            compiled_class_hash: invocation.compiledClassHash || "",
            sender_address: invocation.senderAddress,
            version: toHex2(invocation.version || defaultVersions.v3),
            ...details
          };
        }
        if (invocation.type === "DEPLOY_ACCOUNT") {
          const { account_deployment_data, ...restDetails } = details;
          return {
            type: invocation.type,
            constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),
            class_hash: toHex2(invocation.classHash),
            contract_address_salt: toHex2(invocation.addressSalt || 0),
            version: toHex2(invocation.version || defaultVersions.v3),
            ...restDetails
          };
        }
        throw Error("RPC buildTransaction received unknown TransactionType");
      }
    };
    var rpc_0_7_exports = {};
    __export2(rpc_0_7_exports, {
      RpcChannel: () => RpcChannel2
    });
    var defaultOptions22 = {
      headers: { "Content-Type": "application/json" },
      blockIdentifier: "pending",
      retries: 200
    };
    var RpcChannel2 = class {
      // behave like web2 rpc and return when tx is processed
      constructor(optionsOrProvider) {
        __publicField(this, "nodeUrl");
        __publicField(this, "headers");
        __publicField(this, "retries");
        __publicField(this, "requestId");
        __publicField(this, "blockIdentifier");
        __publicField(this, "chainId");
        __publicField(this, "specVersion");
        __publicField(this, "transactionRetryIntervalFallback");
        __publicField(this, "waitMode");
        const {
          nodeUrl,
          retries,
          headers,
          blockIdentifier,
          chainId,
          specVersion,
          waitMode,
          transactionRetryIntervalFallback
        } = optionsOrProvider || {};
        if (Object.values(NetworkName).includes(nodeUrl)) {
          this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider == null ? void 0 : optionsOrProvider.default);
        } else if (nodeUrl) {
          this.nodeUrl = nodeUrl;
        } else {
          this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider == null ? void 0 : optionsOrProvider.default);
        }
        this.retries = retries || defaultOptions22.retries;
        this.headers = { ...defaultOptions22.headers, ...headers };
        this.blockIdentifier = blockIdentifier || defaultOptions22.blockIdentifier;
        this.chainId = chainId;
        this.specVersion = specVersion;
        this.waitMode = waitMode || false;
        this.requestId = 0;
        this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;
      }
      get transactionRetryIntervalDefault() {
        return this.transactionRetryIntervalFallback ?? 5e3;
      }
      setChainId(chainId) {
        this.chainId = chainId;
      }
      fetch(method, params, id = 0) {
        const rpcRequestBody = {
          id,
          jsonrpc: "2.0",
          method,
          ...params && { params }
        };
        return fetchPonyfill_default(this.nodeUrl, {
          method: "POST",
          body: stringify2(rpcRequestBody),
          headers: this.headers
        });
      }
      errorHandler(method, params, rpcError, otherError) {
        if (rpcError) {
          const { code, message, data } = rpcError;
          throw new LibraryError(
            `RPC: ${method} with params ${stringify2(params, null, 2)}
 
        ${code}: ${message}: ${stringify2(data)}`
          );
        }
        if (otherError instanceof LibraryError) {
          throw otherError;
        }
        if (otherError) {
          throw Error(otherError.message);
        }
      }
      async fetchEndpoint(method, params) {
        var _a4;
        try {
          const rawResult = await this.fetch(method, params, this.requestId += 1);
          const { error, result: result2 } = await rawResult.json();
          this.errorHandler(method, params, error);
          return result2;
        } catch (error) {
          this.errorHandler(method, params, (_a4 = error == null ? void 0 : error.response) == null ? void 0 : _a4.data, error);
          throw error;
        }
      }
      async getChainId() {
        this.chainId ?? (this.chainId = await this.fetchEndpoint("starknet_chainId"));
        return this.chainId;
      }
      async getSpecVersion() {
        this.specVersion ?? (this.specVersion = await this.fetchEndpoint("starknet_specVersion"));
        return this.specVersion;
      }
      getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {
        const contract_address = toHex2(contractAddress);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getNonce", {
          contract_address,
          block_id
        });
      }
      /**
       * Get the most recent accepted block hash and number
       */
      getBlockLatestAccepted() {
        return this.fetchEndpoint("starknet_blockHashAndNumber");
      }
      /**
       * Get the most recent accepted block number
       * redundant use getBlockLatestAccepted();
       * @returns Number of the latest block
       */
      getBlockNumber() {
        return this.fetchEndpoint("starknet_blockNumber");
      }
      getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getBlockWithTxHashes", { block_id });
      }
      getBlockWithTxs(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getBlockWithTxs", { block_id });
      }
      getBlockWithReceipts(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getBlockWithReceipts", { block_id });
      }
      getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getStateUpdate", { block_id });
      }
      getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_traceBlockTransactions", { block_id });
      }
      getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getBlockTransactionCount", { block_id });
      }
      getTransactionByHash(txHash) {
        const transaction_hash = toHex2(txHash);
        return this.fetchEndpoint("starknet_getTransactionByHash", {
          transaction_hash
        });
      }
      getTransactionByBlockIdAndIndex(blockIdentifier, index2) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex", { block_id, index: index2 });
      }
      getTransactionReceipt(txHash) {
        const transaction_hash = toHex2(txHash);
        return this.fetchEndpoint("starknet_getTransactionReceipt", { transaction_hash });
      }
      getTransactionTrace(txHash) {
        const transaction_hash = toHex2(txHash);
        return this.fetchEndpoint("starknet_traceTransaction", { transaction_hash });
      }
      /**
       * Get the status of a transaction
       */
      getTransactionStatus(transactionHash) {
        const transaction_hash = toHex2(transactionHash);
        return this.fetchEndpoint("starknet_getTransactionStatus", { transaction_hash });
      }
      /**
       * @param invocations AccountInvocations
       * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>
       * - blockIdentifier<br/>
       * - skipValidate (default false)<br/>
       * - skipFeeCharge (default true)<br/>
       */
      simulateTransaction(invocations, simulateTransactionOptions = {}) {
        const {
          blockIdentifier = this.blockIdentifier,
          skipValidate = true,
          skipFeeCharge = true
        } = simulateTransactionOptions;
        const block_id = new Block(blockIdentifier).identifier;
        const simulationFlags = [];
        if (skipValidate)
          simulationFlags.push(RPCSPEC07.ESimulationFlag.SKIP_VALIDATE);
        if (skipFeeCharge)
          simulationFlags.push(RPCSPEC07.ESimulationFlag.SKIP_FEE_CHARGE);
        return this.fetchEndpoint("starknet_simulateTransactions", {
          block_id,
          transactions: invocations.map((it) => this.buildTransaction(it)),
          simulation_flags: simulationFlags
        });
      }
      async waitForTransaction(txHash, options) {
        const transactionHash = toHex2(txHash);
        let { retries } = this;
        let onchain = false;
        let isErrorState = false;
        const retryInterval = (options == null ? void 0 : options.retryInterval) ?? this.transactionRetryIntervalDefault;
        const errorStates = (options == null ? void 0 : options.errorStates) ?? [
          RPCSPEC07.ETransactionStatus.REJECTED
          // TODO: commented out to preserve the long-standing behavior of "reverted" not being treated as an error by default
          // should decide which behavior to keep in the future
          // RPC.ETransactionExecutionStatus.REVERTED,
        ];
        const successStates = (options == null ? void 0 : options.successStates) ?? [
          RPCSPEC07.ETransactionExecutionStatus.SUCCEEDED,
          RPCSPEC07.ETransactionStatus.ACCEPTED_ON_L2,
          RPCSPEC07.ETransactionStatus.ACCEPTED_ON_L1
        ];
        let txStatus;
        while (!onchain) {
          await wait(retryInterval);
          try {
            txStatus = await this.getTransactionStatus(transactionHash);
            const executionStatus = txStatus.execution_status;
            const finalityStatus = txStatus.finality_status;
            if (!finalityStatus) {
              const error = new Error("waiting for transaction status");
              throw error;
            }
            if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {
              const message = `${executionStatus}: ${finalityStatus}`;
              const error = new Error(message);
              error.response = txStatus;
              isErrorState = true;
              throw error;
            } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {
              onchain = true;
            }
          } catch (error) {
            if (error instanceof Error && isErrorState) {
              throw error;
            }
            if (retries <= 0) {
              throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
            }
          }
          retries -= 1;
        }
        let txReceipt = null;
        while (txReceipt === null) {
          try {
            txReceipt = await this.getTransactionReceipt(transactionHash);
          } catch (error) {
            if (retries <= 0) {
              throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);
            }
          }
          retries -= 1;
          await wait(retryInterval);
        }
        return txReceipt;
      }
      getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {
        const contract_address = toHex2(contractAddress);
        const parsedKey = toStorageKey(key);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getStorageAt", {
          contract_address,
          key: parsedKey,
          block_id
        });
      }
      getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {
        const contract_address = toHex2(contractAddress);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getClassHashAt", {
          block_id,
          contract_address
        });
      }
      getClass(classHash, blockIdentifier = this.blockIdentifier) {
        const class_hash = toHex2(classHash);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getClass", {
          class_hash,
          block_id
        });
      }
      getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {
        const contract_address = toHex2(contractAddress);
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_getClassAt", {
          block_id,
          contract_address
        });
      }
      async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {
        const block_id = new Block(blockIdentifier).identifier;
        let flags = {};
        if (!isVersion("0.5", await this.getSpecVersion())) {
          flags = {
            simulation_flags: skipValidate ? [RPCSPEC07.ESimulationFlag.SKIP_VALIDATE] : []
          };
        }
        return this.fetchEndpoint("starknet_estimateFee", {
          request: invocations.map((it) => this.buildTransaction(it, "fee")),
          block_id,
          ...flags
        });
      }
      async invoke(functionInvocation, details) {
        let promise;
        if (!isV3Tx(details)) {
          promise = this.fetchEndpoint("starknet_addInvokeTransaction", {
            invoke_transaction: {
              sender_address: functionInvocation.contractAddress,
              calldata: CallData.toHex(functionInvocation.calldata),
              type: RPCSPEC07.ETransactionType.INVOKE,
              max_fee: toHex2(details.maxFee || 0),
              version: RPCSPEC07.ETransactionVersion.V1,
              signature: signatureToHexArray(functionInvocation.signature),
              nonce: toHex2(details.nonce)
            }
          });
        } else {
          promise = this.fetchEndpoint("starknet_addInvokeTransaction", {
            invoke_transaction: {
              type: RPCSPEC07.ETransactionType.INVOKE,
              sender_address: functionInvocation.contractAddress,
              calldata: CallData.toHex(functionInvocation.calldata),
              version: RPCSPEC07.ETransactionVersion.V3,
              signature: signatureToHexArray(functionInvocation.signature),
              nonce: toHex2(details.nonce),
              resource_bounds: details.resourceBounds,
              tip: toHex2(details.tip),
              paymaster_data: details.paymasterData.map((it) => toHex2(it)),
              account_deployment_data: details.accountDeploymentData.map((it) => toHex2(it)),
              nonce_data_availability_mode: details.nonceDataAvailabilityMode,
              fee_data_availability_mode: details.feeDataAvailabilityMode
            }
          });
        }
        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
      }
      async declare({ contract, signature, senderAddress, compiledClassHash }, details) {
        let promise;
        if (!isSierra(contract) && !isV3Tx(details)) {
          promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
            declare_transaction: {
              type: RPCSPEC07.ETransactionType.DECLARE,
              contract_class: {
                program: contract.program,
                entry_points_by_type: contract.entry_points_by_type,
                abi: contract.abi
              },
              version: RPCSPEC07.ETransactionVersion.V1,
              max_fee: toHex2(details.maxFee || 0),
              signature: signatureToHexArray(signature),
              sender_address: senderAddress,
              nonce: toHex2(details.nonce)
            }
          });
        } else if (isSierra(contract) && !isV3Tx(details)) {
          promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
            declare_transaction: {
              type: RPCSPEC07.ETransactionType.DECLARE,
              contract_class: {
                sierra_program: decompressProgram(contract.sierra_program),
                contract_class_version: contract.contract_class_version,
                entry_points_by_type: contract.entry_points_by_type,
                abi: contract.abi
              },
              compiled_class_hash: compiledClassHash || "",
              version: RPCSPEC07.ETransactionVersion.V2,
              max_fee: toHex2(details.maxFee || 0),
              signature: signatureToHexArray(signature),
              sender_address: senderAddress,
              nonce: toHex2(details.nonce)
            }
          });
        } else if (isSierra(contract) && isV3Tx(details)) {
          promise = this.fetchEndpoint("starknet_addDeclareTransaction", {
            declare_transaction: {
              type: RPCSPEC07.ETransactionType.DECLARE,
              sender_address: senderAddress,
              compiled_class_hash: compiledClassHash || "",
              version: RPCSPEC07.ETransactionVersion.V3,
              signature: signatureToHexArray(signature),
              nonce: toHex2(details.nonce),
              contract_class: {
                sierra_program: decompressProgram(contract.sierra_program),
                contract_class_version: contract.contract_class_version,
                entry_points_by_type: contract.entry_points_by_type,
                abi: contract.abi
              },
              resource_bounds: details.resourceBounds,
              tip: toHex2(details.tip),
              paymaster_data: details.paymasterData.map((it) => toHex2(it)),
              account_deployment_data: details.accountDeploymentData.map((it) => toHex2(it)),
              nonce_data_availability_mode: details.nonceDataAvailabilityMode,
              fee_data_availability_mode: details.feeDataAvailabilityMode
            }
          });
        } else {
          throw Error("declare unspotted parameters");
        }
        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
      }
      async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {
        let promise;
        if (!isV3Tx(details)) {
          promise = this.fetchEndpoint("starknet_addDeployAccountTransaction", {
            deploy_account_transaction: {
              constructor_calldata: CallData.toHex(constructorCalldata || []),
              class_hash: toHex2(classHash),
              contract_address_salt: toHex2(addressSalt || 0),
              type: RPCSPEC07.ETransactionType.DEPLOY_ACCOUNT,
              max_fee: toHex2(details.maxFee || 0),
              version: RPCSPEC07.ETransactionVersion.V1,
              signature: signatureToHexArray(signature),
              nonce: toHex2(details.nonce)
            }
          });
        } else {
          promise = this.fetchEndpoint("starknet_addDeployAccountTransaction", {
            deploy_account_transaction: {
              type: RPCSPEC07.ETransactionType.DEPLOY_ACCOUNT,
              version: RPCSPEC07.ETransactionVersion.V3,
              signature: signatureToHexArray(signature),
              nonce: toHex2(details.nonce),
              contract_address_salt: toHex2(addressSalt || 0),
              constructor_calldata: CallData.toHex(constructorCalldata || []),
              class_hash: toHex2(classHash),
              resource_bounds: details.resourceBounds,
              tip: toHex2(details.tip),
              paymaster_data: details.paymasterData.map((it) => toHex2(it)),
              nonce_data_availability_mode: details.nonceDataAvailabilityMode,
              fee_data_availability_mode: details.feeDataAvailabilityMode
            }
          });
        }
        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;
      }
      callContract(call, blockIdentifier = this.blockIdentifier) {
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_call", {
          request: {
            contract_address: call.contractAddress,
            entry_point_selector: getSelectorFromName(call.entrypoint),
            calldata: CallData.toHex(call.calldata)
          },
          block_id
        });
      }
      /**
       * NEW: Estimate the fee for a message from L1
       * @param message Message From L1
       */
      estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {
        const { from_address, to_address, entry_point_selector, payload } = message;
        const formattedMessage = {
          from_address: validateAndParseEthAddress(from_address),
          to_address: toHex2(to_address),
          entry_point_selector: getSelector(entry_point_selector),
          payload: getHexStringArray(payload)
        };
        const block_id = new Block(blockIdentifier).identifier;
        return this.fetchEndpoint("starknet_estimateMessageFee", {
          message: formattedMessage,
          block_id
        });
      }
      /**
       * Returns an object about the sync status, or false if the node is not synching
       * @returns Object with the stats data
       */
      getSyncingStats() {
        return this.fetchEndpoint("starknet_syncing");
      }
      /**
       * Returns all events matching the given filter
       * @returns events and the pagination of the events
       */
      getEvents(eventFilter) {
        return this.fetchEndpoint("starknet_getEvents", { filter: eventFilter });
      }
      buildTransaction(invocation, versionType) {
        const defaultVersions = getVersionsByType(versionType);
        let details;
        if (!isV3Tx(invocation)) {
          details = {
            signature: signatureToHexArray(invocation.signature),
            nonce: toHex2(invocation.nonce),
            max_fee: toHex2(invocation.maxFee || 0)
          };
        } else {
          details = {
            signature: signatureToHexArray(invocation.signature),
            nonce: toHex2(invocation.nonce),
            resource_bounds: invocation.resourceBounds,
            tip: toHex2(invocation.tip),
            paymaster_data: invocation.paymasterData.map((it) => toHex2(it)),
            nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,
            fee_data_availability_mode: invocation.feeDataAvailabilityMode,
            account_deployment_data: invocation.accountDeploymentData.map((it) => toHex2(it))
          };
        }
        if (invocation.type === "INVOKE_FUNCTION") {
          return {
            // v0 v1 v3
            type: RPCSPEC07.ETransactionType.INVOKE,
            sender_address: invocation.contractAddress,
            calldata: CallData.toHex(invocation.calldata),
            version: toHex2(invocation.version || defaultVersions.v3),
            ...details
          };
        }
        if (invocation.type === "DECLARE") {
          if (!isSierra(invocation.contract)) {
            return {
              type: invocation.type,
              contract_class: invocation.contract,
              sender_address: invocation.senderAddress,
              version: toHex2(invocation.version || defaultVersions.v1),
              ...details
            };
          }
          return {
            // Cairo 1 - v2 v3
            type: invocation.type,
            contract_class: {
              ...invocation.contract,
              sierra_program: decompressProgram(invocation.contract.sierra_program)
            },
            compiled_class_hash: invocation.compiledClassHash || "",
            sender_address: invocation.senderAddress,
            version: toHex2(invocation.version || defaultVersions.v3),
            ...details
          };
        }
        if (invocation.type === "DEPLOY_ACCOUNT") {
          const { account_deployment_data, ...restDetails } = details;
          return {
            type: invocation.type,
            constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),
            class_hash: toHex2(invocation.classHash),
            contract_address_salt: toHex2(invocation.addressSalt || 0),
            version: toHex2(invocation.version || defaultVersions.v3),
            ...restDetails
          };
        }
        throw Error("RPC buildTransaction received unknown TransactionType");
      }
    };
    var RPCResponseParser = class {
      constructor(margin) {
        __publicField(this, "margin");
        this.margin = margin;
      }
      estimatedFeeToMaxFee(estimatedFee) {
        var _a4;
        return estimatedFeeToMaxFee(estimatedFee, (_a4 = this.margin) == null ? void 0 : _a4.maxFee);
      }
      estimateFeeToBounds(estimate) {
        var _a4, _b;
        return estimateFeeToBounds(
          estimate,
          (_a4 = this.margin) == null ? void 0 : _a4.l1BoundMaxAmount,
          (_b = this.margin) == null ? void 0 : _b.l1BoundMaxPricePerUnit
        );
      }
      parseGetBlockResponse(res) {
        return { status: "PENDING", ...res };
      }
      parseTransactionReceipt(res) {
        if ("actual_fee" in res && isString(res.actual_fee)) {
          return {
            ...res,
            actual_fee: {
              amount: res.actual_fee,
              unit: "FRI"
            }
          };
        }
        return res;
      }
      parseFeeEstimateResponse(res) {
        const val = res[0];
        return {
          overall_fee: toBigInt(val.overall_fee),
          gas_consumed: toBigInt(val.gas_consumed),
          gas_price: toBigInt(val.gas_price),
          unit: val.unit,
          suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),
          resourceBounds: this.estimateFeeToBounds(val),
          data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,
          data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n
        };
      }
      parseFeeEstimateBulkResponse(res) {
        return res.map((val) => ({
          overall_fee: toBigInt(val.overall_fee),
          gas_consumed: toBigInt(val.gas_consumed),
          gas_price: toBigInt(val.gas_price),
          unit: val.unit,
          suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),
          resourceBounds: this.estimateFeeToBounds(val),
          data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,
          data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n
        }));
      }
      parseSimulateTransactionResponse(res) {
        return res.map((it) => {
          return {
            ...it,
            suggestedMaxFee: this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),
            resourceBounds: this.estimateFeeToBounds(it.fee_estimation)
          };
        });
      }
      parseContractClassResponse(res) {
        return {
          ...res,
          abi: isString(res.abi) ? JSON.parse(res.abi) : res.abi
        };
      }
      parseL1GasPriceResponse(res) {
        return res.l1_gas_price.price_in_wei;
      }
    };
    var ReceiptTx = class _ReceiptTx {
      constructor(receipt) {
        __publicField(this, "statusReceipt");
        __publicField(this, "value");
        [this.statusReceipt, this.value] = _ReceiptTx.isSuccess(receipt) ? ["success", receipt] : _ReceiptTx.isReverted(receipt) ? ["reverted", receipt] : _ReceiptTx.isRejected(receipt) ? ["rejected", receipt] : ["error", new Error("Unknown response type")];
        for (const [key] of Object.entries(this)) {
          Object.defineProperty(this, key, {
            enumerable: false
          });
        }
        for (const [key, value] of Object.entries(receipt)) {
          Object.defineProperty(this, key, {
            enumerable: true,
            writable: false,
            value
          });
        }
      }
      match(callbacks) {
        if (this.statusReceipt in callbacks) {
          return callbacks[this.statusReceipt](this.value);
        }
        return callbacks._();
      }
      isSuccess() {
        return this.statusReceipt === "success";
      }
      isReverted() {
        return this.statusReceipt === "reverted";
      }
      isRejected() {
        return this.statusReceipt === "rejected";
      }
      isError() {
        return this.statusReceipt === "error";
      }
      static isSuccess(transactionReceipt) {
        return transactionReceipt.execution_status === "SUCCEEDED";
      }
      static isReverted(transactionReceipt) {
        return transactionReceipt.execution_status === "REVERTED";
      }
      static isRejected(transactionReceipt) {
        return transactionReceipt.status === "REJECTED";
      }
    };
    var RpcProvider = class {
      constructor(optionsOrProvider) {
        __publicField(this, "responseParser");
        __publicField(this, "channel");
        __publicField(this, "getStateUpdate", this.getBlockStateUpdate);
        if (optionsOrProvider && "channel" in optionsOrProvider) {
          this.channel = optionsOrProvider.channel;
          this.responseParser = "responseParser" in optionsOrProvider ? optionsOrProvider.responseParser : new RPCResponseParser();
        } else {
          this.channel = new RpcChannel2({ ...optionsOrProvider, waitMode: false });
          this.responseParser = new RPCResponseParser(optionsOrProvider == null ? void 0 : optionsOrProvider.feeMarginPercentage);
        }
      }
      fetch(method, params, id = 0) {
        return this.channel.fetch(method, params, id);
      }
      async getChainId() {
        return this.channel.getChainId();
      }
      async getSpecVersion() {
        return this.channel.getSpecVersion();
      }
      async getNonceForAddress(contractAddress, blockIdentifier) {
        return this.channel.getNonceForAddress(contractAddress, blockIdentifier);
      }
      async getBlock(blockIdentifier) {
        return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);
      }
      /**
       * Get the most recent accepted block hash and number
       */
      async getBlockLatestAccepted() {
        return this.channel.getBlockLatestAccepted();
      }
      /**
       * Get the most recent accepted block number
       * redundant use getBlockLatestAccepted();
       * @returns Number of the latest block
       */
      async getBlockNumber() {
        return this.channel.getBlockNumber();
      }
      async getBlockWithTxHashes(blockIdentifier) {
        return this.channel.getBlockWithTxHashes(blockIdentifier);
      }
      async getBlockWithTxs(blockIdentifier) {
        return this.channel.getBlockWithTxs(blockIdentifier);
      }
      /**
       * Pause the execution of the script until a specified block is created.
       * @param {BlockIdentifier} blockIdentifier bloc number (BigNumberisk) or 'pending' or 'latest'.
       * Use of 'latest" or of a block already created will generate no pause.
       * @param {number} [retryInterval] number of milliseconds between 2 requests to the node
       * @example
       * ```typescript
       * await myProvider.waitForBlock();
       * // wait the creation of the pending block
       * ```
       */
      async waitForBlock(blockIdentifier = "pending", retryInterval = 5e3) {
        if (blockIdentifier === "latest")
          return;
        const currentBlock = await this.getBlockNumber();
        const targetBlock = blockIdentifier === "pending" ? currentBlock + 1 : Number(toHex2(blockIdentifier));
        if (targetBlock <= currentBlock)
          return;
        const { retries } = this.channel;
        let retriesCount = retries;
        let isTargetBlock = false;
        while (!isTargetBlock) {
          const currBlock = await this.getBlockNumber();
          if (currBlock === targetBlock) {
            isTargetBlock = true;
          } else {
            await wait(retryInterval);
          }
          retriesCount -= 1;
          if (retriesCount <= 0) {
            throw new Error(`waitForBlock() timed-out after ${retries} tries.`);
          }
        }
      }
      async getL1GasPrice(blockIdentifier) {
        return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseL1GasPriceResponse);
      }
      async getL1MessageHash(l2TxHash) {
        const transaction2 = await this.channel.getTransactionByHash(l2TxHash);
        assert5(transaction2.type === "L1_HANDLER", "This L2 transaction is not a L1 message.");
        const { calldata, contract_address, entry_point_selector, nonce } = transaction2;
        const params = [
          calldata[0],
          contract_address,
          nonce,
          entry_point_selector,
          calldata.length - 1,
          ...calldata.slice(1)
        ];
        const myEncode = addHexPrefix(
          params.reduce(
            (res, par) => res + removeHexPrefix(toHex2(par)).padStart(64, "0"),
            ""
          )
        );
        return addHexPrefix((0, import_utils22.bytesToHex)((0, import_sha3.keccak_256)(hexToBytes(myEncode))));
      }
      async getBlockWithReceipts(blockIdentifier) {
        if (this.channel instanceof rpc_0_6_exports.RpcChannel)
          throw new LibraryError("Unsupported method for RPC version");
        return this.channel.getBlockWithReceipts(blockIdentifier);
      }
      async getBlockStateUpdate(blockIdentifier) {
        return this.channel.getBlockStateUpdate(blockIdentifier);
      }
      async getBlockTransactionsTraces(blockIdentifier) {
        return this.channel.getBlockTransactionsTraces(blockIdentifier);
      }
      async getBlockTransactionCount(blockIdentifier) {
        return this.channel.getBlockTransactionCount(blockIdentifier);
      }
      /**
       * Return transactions from pending block
       * @deprecated Instead use getBlock(BlockTag.PENDING); (will be removed in next minor version)
       * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);
       */
      async getPendingTransactions() {
        const { transactions } = await this.getBlockWithTxHashes(
          "pending"
          /* PENDING */
        ).then(
          this.responseParser.parseGetBlockResponse
        );
        return Promise.all(transactions.map((it) => this.getTransactionByHash(it)));
      }
      async getTransaction(txHash) {
        return this.channel.getTransactionByHash(txHash);
      }
      async getTransactionByHash(txHash) {
        return this.channel.getTransactionByHash(txHash);
      }
      async getTransactionByBlockIdAndIndex(blockIdentifier, index2) {
        return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index2);
      }
      async getTransactionReceipt(txHash) {
        const txReceiptWoHelper = await this.channel.getTransactionReceipt(txHash);
        const txReceiptWoHelperModified = this.responseParser.parseTransactionReceipt(txReceiptWoHelper);
        return new ReceiptTx(txReceiptWoHelperModified);
      }
      async getTransactionTrace(txHash) {
        return this.channel.getTransactionTrace(txHash);
      }
      /**
       * Get the status of a transaction
       */
      async getTransactionStatus(transactionHash) {
        return this.channel.getTransactionStatus(transactionHash);
      }
      /**
       * @param invocations AccountInvocations
       * @param options blockIdentifier and flags to skip validation and fee charge<br/>
       * - blockIdentifier<br/>
       * - skipValidate (default false)<br/>
       * - skipFeeCharge (default true)<br/>
       */
      async getSimulateTransaction(invocations, options) {
        return this.channel.simulateTransaction(invocations, options).then((r2) => this.responseParser.parseSimulateTransactionResponse(r2));
      }
      async waitForTransaction(txHash, options) {
        const receiptWoHelper = await this.channel.waitForTransaction(
          txHash,
          options
        );
        return new ReceiptTx(receiptWoHelper);
      }
      async getStorageAt(contractAddress, key, blockIdentifier) {
        return this.channel.getStorageAt(contractAddress, key, blockIdentifier);
      }
      async getClassHashAt(contractAddress, blockIdentifier) {
        return this.channel.getClassHashAt(contractAddress, blockIdentifier);
      }
      async getClassByHash(classHash) {
        return this.getClass(classHash);
      }
      async getClass(classHash, blockIdentifier) {
        return this.channel.getClass(classHash, blockIdentifier).then(this.responseParser.parseContractClassResponse);
      }
      async getClassAt(contractAddress, blockIdentifier) {
        return this.channel.getClassAt(contractAddress, blockIdentifier).then(this.responseParser.parseContractClassResponse);
      }
      async getContractVersion(contractAddress, classHash, {
        blockIdentifier = this.channel.blockIdentifier,
        compiler = true
      } = {}) {
        let contractClass;
        if (contractAddress) {
          contractClass = await this.getClassAt(contractAddress, blockIdentifier);
        } else if (classHash) {
          contractClass = await this.getClass(classHash, blockIdentifier);
        } else {
          throw Error("getContractVersion require contractAddress or classHash");
        }
        if (isSierra(contractClass)) {
          if (compiler) {
            const abiTest = getAbiContractVersion(contractClass.abi);
            return { cairo: "1", compiler: abiTest.compiler };
          }
          return { cairo: "1", compiler: void 0 };
        }
        return { cairo: "0", compiler: "0" };
      }
      /**
       * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)
       */
      async getEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {
        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);
      }
      async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {
        return this.channel.getEstimateFee(
          [
            {
              type: "INVOKE_FUNCTION",
              ...invocation,
              ...invocationDetails
            }
          ],
          { blockIdentifier, skipValidate }
        ).then((r2) => this.responseParser.parseFeeEstimateResponse(r2));
      }
      async getDeclareEstimateFee(invocation, details, blockIdentifier, skipValidate) {
        return this.channel.getEstimateFee(
          [
            {
              type: "DECLARE",
              ...invocation,
              ...details
            }
          ],
          { blockIdentifier, skipValidate }
        ).then((r2) => this.responseParser.parseFeeEstimateResponse(r2));
      }
      async getDeployAccountEstimateFee(invocation, details, blockIdentifier, skipValidate) {
        return this.channel.getEstimateFee(
          [
            {
              type: "DEPLOY_ACCOUNT",
              ...invocation,
              ...details
            }
          ],
          { blockIdentifier, skipValidate }
        ).then((r2) => this.responseParser.parseFeeEstimateResponse(r2));
      }
      async getEstimateFeeBulk(invocations, options) {
        return this.channel.getEstimateFee(invocations, options).then((r2) => this.responseParser.parseFeeEstimateBulkResponse(r2));
      }
      async invokeFunction(functionInvocation, details) {
        return this.channel.invoke(functionInvocation, details);
      }
      async declareContract(transaction2, details) {
        return this.channel.declare(transaction2, details);
      }
      async deployAccountContract(transaction2, details) {
        return this.channel.deployAccount(
          transaction2,
          details
        );
      }
      async callContract(call, blockIdentifier) {
        return this.channel.callContract(call, blockIdentifier);
      }
      /**
       * NEW: Estimate the fee for a message from L1
       * @param message Message From L1
       */
      async estimateMessageFee(message, blockIdentifier) {
        return this.channel.estimateMessageFee(message, blockIdentifier);
      }
      /**
       * Returns an object about the sync status, or false if the node is not synching
       * @returns Object with the stats data
       */
      async getSyncingStats() {
        return this.channel.getSyncingStats();
      }
      /**
       * Returns all events matching the given filter
       * @returns events and the pagination of the events
       */
      async getEvents(eventFilter) {
        return this.channel.getEvents(eventFilter);
      }
    };
    var import_ts_mixer = (init_esm(), __toCommonJS(esm_exports));
    var starknetId_exports = {};
    __export2(starknetId_exports, {
      StarknetIdContract: () => StarknetIdContract,
      StarknetIdIdentityContract: () => StarknetIdIdentityContract,
      StarknetIdMulticallContract: () => StarknetIdMulticallContract,
      StarknetIdPfpContract: () => StarknetIdPfpContract,
      StarknetIdPopContract: () => StarknetIdPopContract,
      StarknetIdVerifierContract: () => StarknetIdVerifierContract,
      dynamicCallData: () => dynamicCallData,
      dynamicFelt: () => dynamicFelt,
      execution: () => execution,
      getStarknetIdContract: () => getStarknetIdContract,
      getStarknetIdIdentityContract: () => getStarknetIdIdentityContract,
      getStarknetIdMulticallContract: () => getStarknetIdMulticallContract,
      getStarknetIdPfpContract: () => getStarknetIdPfpContract,
      getStarknetIdPopContract: () => getStarknetIdPopContract,
      getStarknetIdVerifierContract: () => getStarknetIdVerifierContract,
      useDecoded: () => useDecoded,
      useEncoded: () => useEncoded
    });
    var basicAlphabet = "abcdefghijklmnopqrstuvwxyz0123456789-";
    var basicSizePlusOne = BigInt(basicAlphabet.length + 1);
    var bigAlphabet = "这来";
    var basicAlphabetSize = BigInt(basicAlphabet.length);
    var bigAlphabetSize = BigInt(bigAlphabet.length);
    var bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);
    function extractStars(str) {
      let k = 0;
      while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {
        str = str.substring(0, str.length - 1);
        k += 1;
      }
      return [str, k];
    }
    function useDecoded(encoded) {
      let decoded = "";
      encoded.forEach((subdomain) => {
        while (subdomain !== ZERO2) {
          const code = subdomain % basicSizePlusOne;
          subdomain /= basicSizePlusOne;
          if (code === BigInt(basicAlphabet.length)) {
            const nextSubdomain = subdomain / bigAlphabetSizePlusOne;
            if (nextSubdomain === ZERO2) {
              const code2 = subdomain % bigAlphabetSizePlusOne;
              subdomain = nextSubdomain;
              if (code2 === ZERO2)
                decoded += basicAlphabet[0];
              else
                decoded += bigAlphabet[Number(code2) - 1];
            } else {
              const code2 = subdomain % bigAlphabetSize;
              decoded += bigAlphabet[Number(code2)];
              subdomain /= bigAlphabetSize;
            }
          } else
            decoded += basicAlphabet[Number(code)];
        }
        const [str, k] = extractStars(decoded);
        if (k)
          decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));
        decoded += ".";
      });
      if (!decoded) {
        return decoded;
      }
      return decoded.concat("stark");
    }
    function useEncoded(decoded) {
      let encoded = BigInt(0);
      let multiplier = BigInt(1);
      if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {
        const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));
        decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));
      } else {
        const [str, k] = extractStars(decoded);
        if (k)
          decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));
      }
      for (let i = 0; i < decoded.length; i += 1) {
        const char = decoded[i];
        const index2 = basicAlphabet.indexOf(char);
        const bnIndex = BigInt(basicAlphabet.indexOf(char));
        if (index2 !== -1) {
          if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {
            encoded += multiplier * basicAlphabetSize;
            multiplier *= basicSizePlusOne;
            multiplier *= basicSizePlusOne;
          } else {
            encoded += multiplier * bnIndex;
            multiplier *= basicSizePlusOne;
          }
        } else if (bigAlphabet.indexOf(char) !== -1) {
          encoded += multiplier * basicAlphabetSize;
          multiplier *= basicSizePlusOne;
          const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);
          encoded += multiplier * BigInt(newid);
          multiplier *= bigAlphabetSize;
        }
      }
      return encoded;
    }
    var StarknetIdContract = ((StarknetIdContract2) => {
      StarknetIdContract2["MAINNET"] = "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
      StarknetIdContract2["TESTNET_SEPOLIA"] = "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474";
      return StarknetIdContract2;
    })(StarknetIdContract || {});
    function getStarknetIdContract(chainId) {
      switch (chainId) {
        case "0x534e5f4d41494e":
          return "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
        case "0x534e5f5345504f4c4941":
          return "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474";
        default:
          throw new Error("Starknet.id is not yet deployed on this network");
      }
    }
    var StarknetIdIdentityContract = ((StarknetIdIdentityContract2) => {
      StarknetIdIdentityContract2["MAINNET"] = "0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af";
      StarknetIdIdentityContract2["TESTNET_SEPOLIA"] = "0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda";
      return StarknetIdIdentityContract2;
    })(StarknetIdIdentityContract || {});
    function getStarknetIdIdentityContract(chainId) {
      switch (chainId) {
        case "0x534e5f4d41494e":
          return "0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af";
        case "0x534e5f5345504f4c4941":
          return "0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda";
        default:
          throw new Error("Starknet.id verifier contract is not yet deployed on this network");
      }
    }
    var StarknetIdMulticallContract = "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970";
    function getStarknetIdMulticallContract(chainId) {
      switch (chainId) {
        case "0x534e5f4d41494e":
          return StarknetIdMulticallContract;
        case "0x534e5f5345504f4c4941":
          return StarknetIdMulticallContract;
        default:
          throw new Error("Starknet.id multicall contract is not yet deployed on this network");
      }
    }
    var StarknetIdVerifierContract = ((StarknetIdVerifierContract2) => {
      StarknetIdVerifierContract2["MAINNET"] = "0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf";
      StarknetIdVerifierContract2["TESTNET_SEPOLIA"] = "0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566";
      return StarknetIdVerifierContract2;
    })(StarknetIdVerifierContract || {});
    function getStarknetIdVerifierContract(chainId) {
      switch (chainId) {
        case "0x534e5f4d41494e":
          return "0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf";
        case "0x534e5f5345504f4c4941":
          return "0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566";
        default:
          throw new Error("Starknet.id verifier contract is not yet deployed on this network");
      }
    }
    var StarknetIdPfpContract = ((StarknetIdPfpContract2) => {
      StarknetIdPfpContract2["MAINNET"] = "0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7";
      StarknetIdPfpContract2["TESTNET_SEPOLIA"] = "0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02";
      return StarknetIdPfpContract2;
    })(StarknetIdPfpContract || {});
    function getStarknetIdPfpContract(chainId) {
      switch (chainId) {
        case "0x534e5f4d41494e":
          return "0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7";
        case "0x534e5f5345504f4c4941":
          return "0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02";
        default:
          throw new Error(
            "Starknet.id profile picture verifier contract is not yet deployed on this network"
          );
      }
    }
    var StarknetIdPopContract = ((StarknetIdPopContract2) => {
      StarknetIdPopContract2["MAINNET"] = "0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4";
      StarknetIdPopContract2["TESTNET_SEPOLIA"] = "0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a";
      return StarknetIdPopContract2;
    })(StarknetIdPopContract || {});
    function getStarknetIdPopContract(chainId) {
      switch (chainId) {
        case "0x534e5f4d41494e":
          return "0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4";
        case "0x534e5f5345504f4c4941":
          return "0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a";
        default:
          throw new Error(
            "Starknet.id proof of personhood verifier contract is not yet deployed on this network"
          );
      }
    }
    function execution(staticEx, ifEqual = void 0, ifNotEqual = void 0) {
      return new CairoCustomEnum({
        Static: staticEx,
        IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : void 0,
        IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : void 0
      });
    }
    function dynamicFelt(hardcoded, reference = void 0) {
      return new CairoCustomEnum({
        Hardcoded: hardcoded,
        Reference: reference ? tuple(reference[0], reference[1]) : void 0
      });
    }
    function dynamicCallData(hardcoded, reference = void 0, arrayReference = void 0) {
      return new CairoCustomEnum({
        Hardcoded: hardcoded,
        Reference: reference ? tuple(reference[0], reference[1]) : void 0,
        ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : void 0
      });
    }
    var StarknetId = class _StarknetId {
      async getStarkName(address, StarknetIdContract2) {
        return _StarknetId.getStarkName(
          // After Mixin, this is ProviderInterface
          this,
          address,
          StarknetIdContract2
        );
      }
      async getAddressFromStarkName(name, StarknetIdContract2) {
        return _StarknetId.getAddressFromStarkName(
          // After Mixin, this is ProviderInterface
          this,
          name,
          StarknetIdContract2
        );
      }
      async getStarkProfile(address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {
        return _StarknetId.getStarkProfile(
          // After Mixin, this is ProviderInterface
          this,
          address,
          StarknetIdContract2,
          StarknetIdIdentityContract2,
          StarknetIdVerifierContract2,
          StarknetIdPfpContract2,
          StarknetIdPopContract2,
          StarknetIdMulticallContract2
        );
      }
      static async getStarkName(provider2, address, StarknetIdContract2) {
        const chainId = await provider2.getChainId();
        const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);
        try {
          const hexDomain = await provider2.callContract({
            contractAddress: contract,
            entrypoint: "address_to_domain",
            calldata: CallData.compile({
              address,
              hint: []
            })
          });
          const decimalDomain = hexDomain.map((element) => BigInt(element)).slice(1);
          const stringDomain = useDecoded(decimalDomain);
          if (!stringDomain) {
            throw Error("Starkname not found");
          }
          return stringDomain;
        } catch (e) {
          if (e instanceof Error && e.message === "Starkname not found") {
            throw e;
          }
          throw Error("Could not get stark name");
        }
      }
      static async getAddressFromStarkName(provider2, name, StarknetIdContract2) {
        const chainId = await provider2.getChainId();
        const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);
        try {
          const encodedDomain = name.replace(".stark", "").split(".").map((part) => useEncoded(part).toString(10));
          const addressData = await provider2.callContract({
            contractAddress: contract,
            entrypoint: "domain_to_address",
            calldata: CallData.compile({ domain: encodedDomain, hint: [] })
          });
          return addressData[0];
        } catch {
          throw Error("Could not get address from stark name");
        }
      }
      static async getStarkProfile(provider2, address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {
        const chainId = await provider2.getChainId();
        const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);
        const identityContract = StarknetIdIdentityContract2 ?? getStarknetIdIdentityContract(chainId);
        const verifierContract = StarknetIdVerifierContract2 ?? getStarknetIdVerifierContract(chainId);
        const pfpContract = StarknetIdPfpContract2 ?? getStarknetIdPfpContract(chainId);
        const popContract = StarknetIdPopContract2 ?? getStarknetIdPopContract(chainId);
        const multicallAddress = StarknetIdMulticallContract2 ?? getStarknetIdMulticallContract(chainId);
        try {
          const calls = [
            {
              execution: execution({}),
              to: dynamicCallData(contract),
              selector: dynamicCallData(getSelectorFromName("address_to_domain")),
              calldata: [dynamicCallData(address), dynamicCallData("0")]
            },
            {
              execution: execution({}),
              to: dynamicFelt(contract),
              selector: dynamicFelt(getSelectorFromName("domain_to_id")),
              calldata: [dynamicCallData(void 0, void 0, [0, 0])]
            },
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName("get_verifier_data")),
              calldata: [
                dynamicCallData(void 0, [1, 0]),
                dynamicCallData(encodeShortString("twitter")),
                dynamicCallData(verifierContract),
                dynamicCallData("0")
              ]
            },
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName("get_verifier_data")),
              calldata: [
                dynamicCallData(void 0, [1, 0]),
                dynamicCallData(encodeShortString("github")),
                dynamicCallData(verifierContract),
                dynamicCallData("0")
              ]
            },
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName("get_verifier_data")),
              calldata: [
                dynamicCallData(void 0, [1, 0]),
                dynamicCallData(encodeShortString("discord")),
                dynamicCallData(verifierContract),
                dynamicCallData("0")
              ]
            },
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName("get_verifier_data")),
              calldata: [
                dynamicCallData(void 0, [1, 0]),
                dynamicCallData(encodeShortString("proof_of_personhood")),
                dynamicCallData(popContract),
                dynamicCallData("0")
              ]
            },
            // PFP
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName("get_verifier_data")),
              calldata: [
                dynamicCallData(void 0, [1, 0]),
                dynamicCallData(encodeShortString("nft_pp_contract")),
                dynamicCallData(pfpContract),
                dynamicCallData("0")
              ]
            },
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName("get_extended_verifier_data")),
              calldata: [
                dynamicCallData(void 0, [1, 0]),
                dynamicCallData(encodeShortString("nft_pp_id")),
                dynamicCallData("2"),
                dynamicCallData(pfpContract),
                dynamicCallData("0")
              ]
            },
            {
              execution: execution(void 0, void 0, [6, 0, 0]),
              to: dynamicFelt(void 0, [6, 0]),
              selector: dynamicFelt(getSelectorFromName("tokenURI")),
              calldata: [dynamicCallData(void 0, [7, 1]), dynamicCallData(void 0, [7, 2])]
            }
          ];
          const data = await provider2.callContract({
            contractAddress: multicallAddress,
            entrypoint: "aggregate",
            calldata: CallData.compile({
              calls
            })
          });
          if (Array.isArray(data)) {
            const size4 = parseInt(data[0], 16);
            const finalArray = [];
            let index2 = 1;
            for (let i = 0; i < size4; i += 1) {
              if (index2 < data.length) {
                const subArraySize = parseInt(data[index2], 16);
                index2 += 1;
                const subArray = data.slice(index2, index2 + subArraySize);
                finalArray.push(subArray);
                index2 += subArraySize;
              } else {
                break;
              }
            }
            const name = useDecoded(finalArray[0].slice(1).map((hexString) => BigInt(hexString)));
            const twitter = finalArray[2][0] !== "0x0" ? BigInt(finalArray[2][0]).toString() : void 0;
            const github = finalArray[3][0] !== "0x0" ? BigInt(finalArray[3][0]).toString() : void 0;
            const discord = finalArray[4][0] !== "0x0" ? BigInt(finalArray[4][0]).toString() : void 0;
            const proofOfPersonhood = finalArray[5][0] === "0x1";
            const profilePictureMetadata = data[0] === "0x9" ? finalArray[8].slice(1).map((val) => decodeShortString(val)).join("") : void 0;
            const profilePicture = profilePictureMetadata || `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;
            return {
              name,
              twitter,
              github,
              discord,
              proofOfPersonhood,
              profilePicture
            };
          }
          throw Error("Error while calling aggregate function");
        } catch (e) {
          if (e instanceof Error) {
            throw e;
          }
          throw Error("Could not get user stark profile data from address");
        }
      }
    };
    var RpcProvider2 = class extends (0, import_ts_mixer.Mixin)(RpcProvider, StarknetId) {
    };
    var ProviderInterface = class {
    };
    var defaultProvider = new RpcProvider({ default: true });
    var SignerInterface = class {
    };
    var typedData_exports = {};
    __export2(typedData_exports, {
      TypedDataRevision: () => import_starknet_types_07.TypedDataRevision,
      encodeData: () => encodeData,
      encodeType: () => encodeType,
      encodeValue: () => encodeValue,
      getDependencies: () => getDependencies,
      getMessageHash: () => getMessageHash,
      getStructHash: () => getStructHash,
      getTypeHash: () => getTypeHash,
      isMerkleTreeType: () => isMerkleTreeType,
      prepareSelector: () => prepareSelector
    });
    var merkle_exports = {};
    __export2(merkle_exports, {
      MerkleTree: () => MerkleTree,
      proofMerklePath: () => proofMerklePath
    });
    var MerkleTree = class _MerkleTree {
      /**
       * Create a Merkle tree
       *
       * @param leafHashes hex-string array
       * @param hashMethod hash method to use, default: Pedersen
       * @returns created Merkle tree
       * @example
       * ```typescript
       * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];
       * const tree = new MerkleTree(leaves);
       * // tree = {
       * //   branches: [['0x5bb9440e2...', '0x262697b88...', ...], ['0x38118a340...', ...], ...],
       * //   leaves: ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'],
       * //   root: '0x7f748c75e5bdb7ae28013f076b8ab650c4e01d3530c6e5ab665f9f1accbe7d4',
       * //   hashMethod: [Function computePedersenHash],
       * // }
       * ```
       */
      constructor(leafHashes, hashMethod = computePedersenHash) {
        __publicField(this, "leaves");
        __publicField(this, "branches", []);
        __publicField(this, "root");
        __publicField(this, "hashMethod");
        this.hashMethod = hashMethod;
        this.leaves = leafHashes;
        this.root = this.build(leafHashes);
      }
      /** @ignore */
      build(leaves) {
        if (leaves.length === 1) {
          return leaves[0];
        }
        if (leaves.length !== this.leaves.length) {
          this.branches.push(leaves);
        }
        const newLeaves = [];
        for (let i = 0; i < leaves.length; i += 2) {
          if (i + 1 === leaves.length) {
            newLeaves.push(_MerkleTree.hash(leaves[i], "0x0", this.hashMethod));
          } else {
            newLeaves.push(_MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));
          }
        }
        return this.build(newLeaves);
      }
      /**
       * Calculate hash from ordered a and b, Pedersen hash default
       *
       * @param a first value
       * @param b second value
       * @param hashMethod hash method to use, default: Pedersen
       * @returns result of the hash function
       * @example
       * ```typescript
       * const result1 = MerkleTree.hash('0xabc', '0xdef');
       * // result1 = '0x484f029da7914ada038b1adf67fc83632364a3ebc2cd9349b41ab61626d9e82'
       *
       * const customHashMethod = (a, b) => `custom_${a}_${b}`;
       * const result2 = MerkleTree.hash('0xabc', '0xdef', customHashMethod);
       * // result2 = 'custom_2748_3567'
       * ```
       */
      static hash(a, b, hashMethod = computePedersenHash) {
        const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) => x >= y ? 1 : -1);
        return hashMethod(aSorted, bSorted);
      }
      /**
       * Calculates the merkle membership proof path
       *
       * @param leaf hex-string
       * @param branch hex-string array
       * @param hashPath hex-string array
       * @returns collection of merkle proof hex-string hashes
       * @example
       * ```typescript
       * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];
       * const tree = new MerkleTree(leaves);
       * const result = tree.getProof('0x3');
       * // result = [
       * //   '0x4',
       * //   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',
       * //   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',
       * // ]
       * ```
       */
      getProof(leaf, branch = this.leaves, hashPath = []) {
        const index2 = branch.indexOf(leaf);
        if (index2 === -1) {
          throw new Error("leaf not found");
        }
        if (branch.length === 1) {
          return hashPath;
        }
        const isLeft = index2 % 2 === 0;
        const neededBranch = (isLeft ? branch[index2 + 1] : branch[index2 - 1]) ?? "0x0";
        const newHashPath = [...hashPath, neededBranch];
        const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b) => b.length === branch.length);
        const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];
        return this.getProof(
          _MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod),
          nextBranch,
          newHashPath
        );
      }
    };
    function proofMerklePath(root2, leaf, path, hashMethod = computePedersenHash) {
      if (path.length === 0) {
        return root2 === leaf;
      }
      const [next, ...rest] = path;
      return proofMerklePath(root2, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);
    }
    var presetTypes = {
      u256: JSON.parse('[{ "name": "low", "type": "u128" }, { "name": "high", "type": "u128" }]'),
      TokenAmount: JSON.parse(
        '[{ "name": "token_address", "type": "ContractAddress" }, { "name": "amount", "type": "u256" }]'
      ),
      NftId: JSON.parse(
        '[{ "name": "collection_address", "type": "ContractAddress" }, { "name": "token_id", "type": "u256" }]'
      )
    };
    var revisionConfiguration = {
      [import_starknet_types_07.TypedDataRevision.ACTIVE]: {
        domain: "StarknetDomain",
        hashMethod: computePoseidonHashOnElements,
        hashMerkleMethod: computePoseidonHash,
        escapeTypeString: (s) => `"${s}"`,
        presetTypes
      },
      [import_starknet_types_07.TypedDataRevision.LEGACY]: {
        domain: "StarkNetDomain",
        hashMethod: computePedersenHashOnElements,
        hashMerkleMethod: computePedersenHash,
        escapeTypeString: (s) => s,
        presetTypes: {}
      }
    };
    function assertRange(data, type, { min: min2, max: max2 }) {
      const value = BigInt(data);
      assert5(value >= min2 && value <= max2, `${value} (${type}) is out of bounds [${min2}, ${max2}]`);
    }
    function identifyRevision({ types: types2, domain }) {
      if (revisionConfiguration[import_starknet_types_07.TypedDataRevision.ACTIVE].domain in types2 && domain.revision === import_starknet_types_07.TypedDataRevision.ACTIVE)
        return import_starknet_types_07.TypedDataRevision.ACTIVE;
      if (revisionConfiguration[import_starknet_types_07.TypedDataRevision.LEGACY].domain in types2 && (domain.revision ?? import_starknet_types_07.TypedDataRevision.LEGACY) === import_starknet_types_07.TypedDataRevision.LEGACY)
        return import_starknet_types_07.TypedDataRevision.LEGACY;
      return void 0;
    }
    function getHex(value) {
      try {
        return toHex2(value);
      } catch (e) {
        if (isString(value)) {
          return toHex2(encodeShortString(value));
        }
        throw new Error(`Invalid BigNumberish: ${value}`);
      }
    }
    function validateTypedData(data) {
      const typedData2 = data;
      return Boolean(
        typedData2.message && typedData2.primaryType && typedData2.types && identifyRevision(typedData2)
      );
    }
    function prepareSelector(selector2) {
      return isHex(selector2) ? selector2 : getSelectorFromName(selector2);
    }
    function isMerkleTreeType(type) {
      return type.type === "merkletree";
    }
    function getDependencies(types2, type, dependencies = [], contains = "", revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
      if (type[type.length - 1] === "*") {
        type = type.slice(0, -1);
      } else if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
        if (type === "enum") {
          type = contains;
        } else if (type.match(/^\(.*\)$/)) {
          type = type.slice(1, -1);
        }
      }
      if (dependencies.includes(type) || !types2[type]) {
        return dependencies;
      }
      return [
        type,
        ...types2[type].reduce(
          (previous, t) => [
            ...previous,
            ...getDependencies(types2, t.type, previous, t.contains, revision).filter(
              (dependency) => !previous.includes(dependency)
            )
          ],
          []
        )
      ];
    }
    function getMerkleTreeType(types2, ctx) {
      if (ctx.parent && ctx.key) {
        const parentType = types2[ctx.parent];
        const merkleType = parentType.find((t) => t.name === ctx.key);
        const isMerkleTree = isMerkleTreeType(merkleType);
        if (!isMerkleTree) {
          throw new Error(`${ctx.key} is not a merkle tree`);
        }
        if (merkleType.contains.endsWith("*")) {
          throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);
        }
        return merkleType.contains;
      }
      return "raw";
    }
    function encodeType(types2, type, revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
      const allTypes = revision === import_starknet_types_07.TypedDataRevision.ACTIVE ? { ...types2, ...revisionConfiguration[revision].presetTypes } : types2;
      const [primary, ...dependencies] = getDependencies(
        allTypes,
        type,
        void 0,
        void 0,
        revision
      );
      const newTypes = !primary ? [] : [primary, ...dependencies.sort()];
      const esc = revisionConfiguration[revision].escapeTypeString;
      return newTypes.map((dependency) => {
        const dependencyElements = allTypes[dependency].map((t) => {
          const targetType = t.type === "enum" && revision === import_starknet_types_07.TypedDataRevision.ACTIVE ? t.contains : t.type;
          const typeString = targetType.match(/^\(.*\)$/) ? `(${targetType.slice(1, -1).split(",").map((e) => e ? esc(e) : e).join(",")})` : esc(targetType);
          return `${esc(t.name)}:${typeString}`;
        });
        return `${esc(dependency)}(${dependencyElements})`;
      }).join("");
    }
    function getTypeHash(types2, type, revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
      return getSelectorFromName(encodeType(types2, type, revision));
    }
    function encodeValue(types2, type, data, ctx = {}, revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
      if (types2[type]) {
        return [type, getStructHash(types2, type, data, revision)];
      }
      if (revisionConfiguration[revision].presetTypes[type]) {
        return [
          type,
          getStructHash(
            revisionConfiguration[revision].presetTypes,
            type,
            data,
            revision
          )
        ];
      }
      if (type.endsWith("*")) {
        const hashes = data.map(
          (entry) => encodeValue(types2, type.slice(0, -1), entry, void 0, revision)[1]
        );
        return [type, revisionConfiguration[revision].hashMethod(hashes)];
      }
      switch (type) {
        case "enum": {
          if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
            const [variantKey, variantData] = Object.entries(data)[0];
            const parentType = types2[ctx.parent][0];
            const enumType = types2[parentType.contains];
            const variantType = enumType.find((t) => t.name === variantKey);
            const variantIndex = enumType.indexOf(variantType);
            const encodedSubtypes = variantType.type.slice(1, -1).split(",").map((subtype, index2) => {
              if (!subtype)
                return subtype;
              const subtypeData = variantData[index2];
              return encodeValue(types2, subtype, subtypeData, void 0, revision)[1];
            });
            return [
              type,
              revisionConfiguration[revision].hashMethod([variantIndex, ...encodedSubtypes])
            ];
          }
          return [type, getHex(data)];
        }
        case "merkletree": {
          const merkleTreeType = getMerkleTreeType(types2, ctx);
          const structHashes = data.map((struct) => {
            return encodeValue(types2, merkleTreeType, struct, void 0, revision)[1];
          });
          const { root: root2 } = new MerkleTree(
            structHashes,
            revisionConfiguration[revision].hashMerkleMethod
          );
          return ["felt", root2];
        }
        case "selector": {
          return ["felt", prepareSelector(data)];
        }
        case "string": {
          if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
            const byteArray2 = byteArrayFromString(data);
            const elements = [
              byteArray2.data.length,
              ...byteArray2.data,
              byteArray2.pending_word,
              byteArray2.pending_word_len
            ];
            return [type, revisionConfiguration[revision].hashMethod(elements)];
          }
          return [type, getHex(data)];
        }
        case "i128": {
          if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
            const value = BigInt(data);
            assertRange(value, type, RANGE_I128);
            return [type, getHex(value < 0n ? PRIME + value : value)];
          }
          return [type, getHex(data)];
        }
        case "timestamp":
        case "u128": {
          if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
            assertRange(data, type, RANGE_U128);
          }
          return [type, getHex(data)];
        }
        case "felt":
        case "shortstring": {
          if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
            assertRange(getHex(data), type, RANGE_FELT);
          }
          return [type, getHex(data)];
        }
        case "ClassHash":
        case "ContractAddress": {
          if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
            assertRange(data, type, RANGE_FELT);
          }
          return [type, getHex(data)];
        }
        case "bool": {
          if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
            assert5(typeof data === "boolean", `Type mismatch for ${type} ${data}`);
          }
          return [type, getHex(data)];
        }
        default: {
          if (revision === import_starknet_types_07.TypedDataRevision.ACTIVE) {
            throw new Error(`Unsupported type: ${type}`);
          }
          return [type, getHex(data)];
        }
      }
    }
    function encodeData(types2, type, data, revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
      const targetType = types2[type] ?? revisionConfiguration[revision].presetTypes[type];
      const [returnTypes, values] = targetType.reduce(
        ([ts, vs], field) => {
          if (data[field.name] === void 0 || data[field.name] === null && field.type !== "enum") {
            throw new Error(`Cannot encode data: missing data for '${field.name}'`);
          }
          const value = data[field.name];
          const ctx = { parent: type, key: field.name };
          const [t, encodedValue] = encodeValue(types2, field.type, value, ctx, revision);
          return [
            [...ts, t],
            [...vs, encodedValue]
          ];
        },
        [["felt"], [getTypeHash(types2, type, revision)]]
      );
      return [returnTypes, values];
    }
    function getStructHash(types2, type, data, revision = import_starknet_types_07.TypedDataRevision.LEGACY) {
      return revisionConfiguration[revision].hashMethod(encodeData(types2, type, data, revision)[1]);
    }
    function getMessageHash(typedData2, account) {
      if (!validateTypedData(typedData2)) {
        throw new Error("Typed data does not match JSON schema");
      }
      const revision = identifyRevision(typedData2);
      const { domain, hashMethod } = revisionConfiguration[revision];
      const message = [
        encodeShortString("StarkNet Message"),
        getStructHash(typedData2.types, domain, typedData2.domain, revision),
        account,
        getStructHash(typedData2.types, typedData2.primaryType, typedData2.message, revision)
      ];
      return hashMethod(message);
    }
    var Signer = class {
      constructor(pk = starkCurve.utils.randomPrivateKey()) {
        __publicField(this, "pk");
        this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex2(pk);
      }
      async getPubKey() {
        return starkCurve.getStarkKey(this.pk);
      }
      async signMessage(typedData2, accountAddress) {
        const msgHash = getMessageHash(typedData2, accountAddress);
        return this.signRaw(msgHash);
      }
      async signTransaction(transactions, details) {
        const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);
        let msgHash;
        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
          const det = details;
          msgHash = calculateInvokeTransactionHash2({
            ...det,
            senderAddress: det.walletAddress,
            compiledCalldata,
            version: det.version
          });
        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
          const det = details;
          msgHash = calculateInvokeTransactionHash2({
            ...det,
            senderAddress: det.walletAddress,
            compiledCalldata,
            version: det.version,
            nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
            feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
          });
        } else {
          throw Error("unsupported signTransaction version");
        }
        return this.signRaw(msgHash);
      }
      async signDeployAccountTransaction(details) {
        const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);
        let msgHash;
        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
          const det = details;
          msgHash = calculateDeployAccountTransactionHash3({
            ...det,
            salt: det.addressSalt,
            constructorCalldata: compiledConstructorCalldata,
            version: det.version
          });
        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
          const det = details;
          msgHash = calculateDeployAccountTransactionHash3({
            ...det,
            salt: det.addressSalt,
            compiledConstructorCalldata,
            version: det.version,
            nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
            feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
          });
        } else {
          throw Error("unsupported signDeployAccountTransaction version");
        }
        return this.signRaw(msgHash);
      }
      async signDeclareTransaction(details) {
        let msgHash;
        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
          const det = details;
          msgHash = calculateDeclareTransactionHash3({
            ...det,
            version: det.version
          });
        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
          const det = details;
          msgHash = calculateDeclareTransactionHash3({
            ...det,
            version: det.version,
            nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
            feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
          });
        } else {
          throw Error("unsupported signDeclareTransaction version");
        }
        return this.signRaw(msgHash);
      }
      async signRaw(msgHash) {
        return starkCurve.sign(msgHash, this.pk);
      }
    };
    var import_secp256k12 = require_secp256k12();
    var uint256_exports = {};
    __export2(uint256_exports, {
      UINT_128_MAX: () => UINT_128_MAX,
      UINT_256_MAX: () => UINT_256_MAX,
      bnToUint256: () => bnToUint256,
      isUint256: () => isUint256,
      uint256ToBN: () => uint256ToBN
    });
    function uint256ToBN(uint2562) {
      return new CairoUint256(uint2562).toBigInt();
    }
    function isUint256(bn) {
      return CairoUint256.is(bn);
    }
    function bnToUint256(bn) {
      return new CairoUint256(bn).toUint256HexString();
    }
    var EthSigner = class {
      // hex string without 0x and with an odd number of characters
      constructor(pk = ethRandomPrivateKey()) {
        __publicField(this, "pk");
        this.pk = pk instanceof Uint8Array ? buf2hex(pk).padStart(64, "0") : removeHexPrefix(toHex2(pk)).padStart(64, "0");
      }
      /**
       * provides the Ethereum full public key (without parity prefix)
       * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.
       */
      async getPubKey() {
        return addHexPrefix(
          buf2hex(import_secp256k12.secp256k1.getPublicKey(this.pk, false)).padStart(130, "0").slice(2)
        );
      }
      async signMessage(typedData2, accountAddress) {
        const msgHash = getMessageHash(typedData2, accountAddress);
        const signature = import_secp256k12.secp256k1.sign(
          removeHexPrefix(sanitizeHex(msgHash)),
          this.pk
        );
        return this.formatEthSignature(signature);
      }
      async signTransaction(transactions, details) {
        const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);
        let msgHash;
        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
          const det = details;
          msgHash = calculateInvokeTransactionHash2({
            ...det,
            senderAddress: det.walletAddress,
            compiledCalldata,
            version: det.version
          });
        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
          const det = details;
          msgHash = calculateInvokeTransactionHash2({
            ...det,
            senderAddress: det.walletAddress,
            compiledCalldata,
            version: det.version,
            nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
            feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
          });
        } else {
          throw Error("unsupported signTransaction version");
        }
        const signature = import_secp256k12.secp256k1.sign(
          removeHexPrefix(sanitizeHex(msgHash)),
          this.pk
        );
        return this.formatEthSignature(signature);
      }
      async signDeployAccountTransaction(details) {
        const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);
        let msgHash;
        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
          const det = details;
          msgHash = calculateDeployAccountTransactionHash3({
            ...det,
            salt: det.addressSalt,
            constructorCalldata: compiledConstructorCalldata,
            version: det.version
          });
        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
          const det = details;
          msgHash = calculateDeployAccountTransactionHash3({
            ...det,
            salt: det.addressSalt,
            compiledConstructorCalldata,
            version: det.version,
            nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
            feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
          });
        } else {
          throw Error("unsupported signDeployAccountTransaction version");
        }
        const signature = import_secp256k12.secp256k1.sign(
          removeHexPrefix(sanitizeHex(msgHash)),
          this.pk
        );
        return this.formatEthSignature(signature);
      }
      async signDeclareTransaction(details) {
        let msgHash;
        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {
          const det = details;
          msgHash = calculateDeclareTransactionHash3({
            ...det,
            version: det.version
          });
        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {
          const det = details;
          msgHash = calculateDeclareTransactionHash3({
            ...det,
            version: det.version,
            nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
            feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)
          });
        } else {
          throw Error("unsupported signDeclareTransaction version");
        }
        const signature = import_secp256k12.secp256k1.sign(
          removeHexPrefix(sanitizeHex(msgHash)),
          this.pk
        );
        return this.formatEthSignature(signature);
      }
      /**
       * Serialize the signature in conformity with starknet::eth_signature::Signature
       * @param ethSignature secp256k1 signature from Noble curves library
       * @return an array of felts, representing a Cairo Eth Signature.
       */
      formatEthSignature(ethSignature) {
        const r2 = bnToUint256(ethSignature.r);
        const s = bnToUint256(ethSignature.s);
        return [
          toHex2(r2.low),
          toHex2(r2.high),
          toHex2(s.low),
          toHex2(s.high),
          toHex2(ethSignature.recovery)
        ];
      }
    };
    var events_exports = {};
    __export2(events_exports, {
      getAbiEvents: () => getAbiEvents,
      isAbiEvent: () => isAbiEvent,
      isObject: () => isObject,
      parseEvents: () => parseEvents,
      parseUDCEvent: () => parseUDCEvent
    });
    function isAbiEvent(object) {
      return object.type === "event";
    }
    function getCairo0AbiEvents(abi) {
      return abi.filter((abiEntry) => abiEntry.type === "event").reduce((acc, abiEntry) => {
        const entryName = abiEntry.name;
        const abiEntryMod = { ...abiEntry };
        abiEntryMod.name = entryName;
        return {
          ...acc,
          [addHexPrefix(starkCurve.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod
        };
      }, {});
    }
    function getCairo1AbiEvents(abi) {
      const abiEventsStructs = abi.filter((obj) => isAbiEvent(obj) && obj.kind === "struct");
      const abiEventsEnums = abi.filter((obj) => isAbiEvent(obj) && obj.kind === "enum");
      const abiEventsData = abiEventsStructs.reduce((acc, event) => {
        let nameList = [];
        let { name } = event;
        let flat = false;
        const findName = (variant) => variant.type === name;
        while (true) {
          const eventEnum = abiEventsEnums.find((eventE) => eventE.variants.some(findName));
          if (typeof eventEnum === "undefined")
            break;
          const variant = eventEnum.variants.find(findName);
          nameList.unshift(variant.name);
          if (variant.kind === "flat")
            flat = true;
          name = eventEnum.name;
        }
        if (nameList.length === 0) {
          throw new Error("inconsistency in ABI events definition.");
        }
        if (flat)
          nameList = [nameList[nameList.length - 1]];
        const final = nameList.pop();
        let result2 = {
          [addHexPrefix(starkCurve.keccak(utf8ToArray(final)).toString(16))]: event
        };
        while (nameList.length > 0) {
          result2 = {
            [addHexPrefix(starkCurve.keccak(utf8ToArray(nameList.pop())).toString(16))]: result2
          };
        }
        result2 = { ...result2 };
        return mergeAbiEvents(acc, result2);
      }, {});
      return abiEventsData;
    }
    function getAbiEvents(abi) {
      return isCairo1Abi(abi) ? getCairo1AbiEvents(abi) : getCairo0AbiEvents(abi);
    }
    function isObject(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
    function mergeAbiEvents(target, source) {
      const output = { ...target };
      if (isObject(target) && isObject(source)) {
        Object.keys(source).forEach((key) => {
          if (isObject(source[key])) {
            if (!(key in target))
              Object.assign(output, { [key]: source[key] });
            else
              output[key] = mergeAbiEvents(target[key], source[key]);
          } else {
            Object.assign(output, { [key]: source[key] });
          }
        });
      }
      return output;
    }
    function parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {
      const ret = providerReceivedEvents.flat().reduce((acc, recEvent) => {
        var _a4, _b;
        let abiEvent = abiEvents[recEvent.keys.shift() ?? 0];
        if (!abiEvent) {
          return acc;
        }
        while (!abiEvent.name) {
          const hashName = recEvent.keys.shift();
          assert5(!!hashName, 'Not enough data in "key" property of this event.');
          abiEvent = abiEvent[hashName];
        }
        const parsedEvent = {};
        parsedEvent[abiEvent.name] = {};
        const keysIter = recEvent.keys[Symbol.iterator]();
        const dataIter = recEvent.data[Symbol.iterator]();
        const abiEventKeys = ((_a4 = abiEvent.members) == null ? void 0 : _a4.filter((it) => it.kind === "key")) || abiEvent.keys;
        const abiEventData = ((_b = abiEvent.members) == null ? void 0 : _b.filter((it) => it.kind === "data")) || abiEvent.data;
        abiEventKeys.forEach((key) => {
          parsedEvent[abiEvent.name][key.name] = responseParser(
            keysIter,
            key,
            abiStructs,
            abiEnums,
            parsedEvent[abiEvent.name]
          );
        });
        abiEventData.forEach((data) => {
          parsedEvent[abiEvent.name][data.name] = responseParser(
            dataIter,
            data,
            abiStructs,
            abiEnums,
            parsedEvent[abiEvent.name]
          );
        });
        acc.push(parsedEvent);
        return acc;
      }, []);
      return ret;
    }
    function parseUDCEvent(txReceipt) {
      if (!txReceipt.events) {
        throw new Error("UDC emitted event is empty");
      }
      const event = txReceipt.events.find(
        (it) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)
      ) || {
        data: []
      };
      return {
        transaction_hash: txReceipt.transaction_hash,
        contract_address: event.data[0],
        address: event.data[0],
        deployer: event.data[1],
        unique: event.data[2],
        classHash: event.data[3],
        calldata_len: event.data[4],
        calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),
        salt: event.data[event.data.length - 1]
      };
    }
    var Account = class extends RpcProvider2 {
      constructor(providerOrOptions, address, pkOrSigner, cairoVersion, transactionVersion = api_exports.ETransactionVersion.V2) {
        super(providerOrOptions);
        __publicField(this, "signer");
        __publicField(this, "address");
        __publicField(this, "cairoVersion");
        __publicField(this, "transactionVersion");
        __publicField(this, "deploySelf", this.deployAccount);
        this.address = address.toLowerCase();
        this.signer = isString(pkOrSigner) || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;
        if (cairoVersion) {
          this.cairoVersion = cairoVersion.toString();
        }
        this.transactionVersion = transactionVersion;
      }
      // provided version or contract based preferred transactionVersion
      getPreferredVersion(type12, type3) {
        if (this.transactionVersion === api_exports.ETransactionVersion.V3)
          return type3;
        if (this.transactionVersion === api_exports.ETransactionVersion.V2)
          return type12;
        return api_exports.ETransactionVersion.V3;
      }
      async getNonce(blockIdentifier) {
        return super.getNonceForAddress(this.address, blockIdentifier);
      }
      async getNonceSafe(nonce) {
        try {
          return toBigInt(nonce ?? await this.getNonce());
        } catch (error) {
          return 0n;
        }
      }
      /**
       * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor.
       * @param classHash if provided detects Cairo version from classHash, otherwise from the account address
       */
      async getCairoVersion(classHash) {
        if (!this.cairoVersion) {
          const { cairo: cairo2 } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);
          this.cairoVersion = cairo2;
        }
        return this.cairoVersion;
      }
      async estimateFee(calls, estimateFeeDetails = {}) {
        return this.estimateInvokeFee(calls, estimateFeeDetails);
      }
      async estimateInvokeFee(calls, details = {}) {
        const {
          nonce: providedNonce,
          blockIdentifier,
          version: providedVersion,
          skipValidate = true
        } = details;
        const transactions = Array.isArray(calls) ? calls : [calls];
        const nonce = toBigInt(providedNonce ?? await this.getNonce());
        const version7 = toTransactionVersion(
          this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3),
          toFeeVersion(providedVersion)
        );
        const chainId = await this.getChainId();
        const signerDetails = {
          ...v3Details(details),
          walletAddress: this.address,
          nonce,
          maxFee: ZERO2,
          version: version7,
          chainId,
          cairoVersion: await this.getCairoVersion(),
          skipValidate
        };
        const invocation = await this.buildInvocation(transactions, signerDetails);
        return super.getInvokeEstimateFee(
          { ...invocation },
          { ...v3Details(details), version: version7, nonce },
          blockIdentifier,
          details.skipValidate
        );
      }
      async estimateDeclareFee(payload, details = {}) {
        const {
          blockIdentifier,
          nonce: providedNonce,
          version: providedVersion,
          skipValidate = true
        } = details;
        const nonce = toBigInt(providedNonce ?? await this.getNonce());
        const version7 = toTransactionVersion(
          !isSierra(payload.contract) ? api_exports.ETransactionVersion.F1 : this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3),
          toFeeVersion(providedVersion)
        );
        const chainId = await this.getChainId();
        const declareContractTransaction = await this.buildDeclarePayload(payload, {
          ...v3Details(details),
          nonce,
          chainId,
          version: version7,
          walletAddress: this.address,
          maxFee: ZERO2,
          cairoVersion: void 0,
          // unused parameter
          skipValidate
        });
        return super.getDeclareEstimateFee(
          declareContractTransaction,
          { ...v3Details(details), version: version7, nonce },
          blockIdentifier,
          details.skipValidate
        );
      }
      async estimateAccountDeployFee({
        classHash,
        addressSalt = 0,
        constructorCalldata = [],
        contractAddress
      }, details = {}) {
        const { blockIdentifier, version: providedVersion, skipValidate = true } = details;
        const version7 = toTransactionVersion(
          this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3),
          toFeeVersion(providedVersion)
        );
        const nonce = ZERO2;
        const chainId = await this.getChainId();
        const payload = await this.buildAccountDeployPayload(
          { classHash, addressSalt, constructorCalldata, contractAddress },
          {
            ...v3Details(details),
            nonce,
            chainId,
            version: version7,
            walletAddress: this.address,
            // unused parameter
            maxFee: ZERO2,
            cairoVersion: void 0,
            // unused parameter,
            skipValidate
          }
        );
        return super.getDeployAccountEstimateFee(
          { ...payload },
          { ...v3Details(details), version: version7, nonce },
          blockIdentifier,
          details.skipValidate
        );
      }
      async estimateDeployFee(payload, details = {}) {
        const calls = this.buildUDCContractPayload(payload);
        return this.estimateInvokeFee(calls, details);
      }
      async estimateFeeBulk(invocations, details = {}) {
        const { nonce, blockIdentifier, version: version7, skipValidate } = details;
        const accountInvocations = await this.accountInvocationsFactory(invocations, {
          ...v3Details(details),
          versions: [
            api_exports.ETransactionVersion.F1,
            // non-sierra
            toTransactionVersion(
              this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3),
              version7
            )
            // sierra
          ],
          nonce,
          blockIdentifier,
          skipValidate
        });
        return super.getEstimateFeeBulk(accountInvocations, {
          blockIdentifier,
          skipValidate
        });
      }
      async simulateTransaction(invocations, details = {}) {
        const { nonce, blockIdentifier, skipValidate = true, skipExecute, version: version7 } = details;
        const accountInvocations = await this.accountInvocationsFactory(invocations, {
          ...v3Details(details),
          versions: [
            api_exports.ETransactionVersion.V1,
            // non-sierra
            toTransactionVersion(
              this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3),
              version7
            )
          ],
          nonce,
          blockIdentifier,
          skipValidate
        });
        return super.getSimulateTransaction(accountInvocations, {
          blockIdentifier,
          skipValidate,
          skipExecute
        });
      }
      async execute(transactions, arg2, transactionsDetail = {}) {
        const details = arg2 === void 0 || Array.isArray(arg2) ? transactionsDetail : arg2;
        const calls = Array.isArray(transactions) ? transactions : [transactions];
        const nonce = toBigInt(details.nonce ?? await this.getNonce());
        const version7 = toTransactionVersion(
          this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3),
          // TODO: does this depend on cairo version ?
          details.version
        );
        const estimate = await this.getUniversalSuggestedFee(
          version7,
          { type: "INVOKE_FUNCTION", payload: transactions },
          {
            ...details,
            version: version7
          }
        );
        const chainId = await this.getChainId();
        const signerDetails = {
          ...v3Details(details),
          resourceBounds: estimate.resourceBounds,
          walletAddress: this.address,
          nonce,
          maxFee: estimate.maxFee,
          version: version7,
          chainId,
          cairoVersion: await this.getCairoVersion()
        };
        const signature = await this.signer.signTransaction(calls, signerDetails);
        const calldata = getExecuteCalldata(calls, await this.getCairoVersion());
        return this.invokeFunction(
          { contractAddress: this.address, calldata, signature },
          {
            ...v3Details(details),
            resourceBounds: estimate.resourceBounds,
            nonce,
            maxFee: estimate.maxFee,
            version: version7
          }
        );
      }
      /**
       * First check if contract is already declared, if not declare it
       * If contract already declared returned transaction_hash is ''.
       * Method will pass even if contract is already declared
       * @param transactionsDetail (optional)
       */
      async declareIfNot(payload, transactionsDetail = {}) {
        const declareContractPayload = extractContractHashes(payload);
        try {
          await this.getClassByHash(declareContractPayload.classHash);
        } catch (error) {
          return this.declare(payload, transactionsDetail);
        }
        return {
          transaction_hash: "",
          class_hash: declareContractPayload.classHash
        };
      }
      async declare(payload, details = {}) {
        const declareContractPayload = extractContractHashes(payload);
        const { nonce, version: providedVersion } = details;
        const version7 = toTransactionVersion(
          !isSierra(payload.contract) ? api_exports.ETransactionVersion.V1 : this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3),
          providedVersion
        );
        const estimate = await this.getUniversalSuggestedFee(
          version7,
          {
            type: "DECLARE",
            payload: declareContractPayload
          },
          {
            ...details,
            version: version7
          }
        );
        const declareDetails = {
          ...v3Details(details),
          resourceBounds: estimate.resourceBounds,
          maxFee: estimate.maxFee,
          nonce: toBigInt(nonce ?? await this.getNonce()),
          version: version7,
          chainId: await this.getChainId(),
          walletAddress: this.address,
          cairoVersion: void 0
        };
        const declareContractTransaction = await this.buildDeclarePayload(
          declareContractPayload,
          declareDetails
        );
        return this.declareContract(declareContractTransaction, declareDetails);
      }
      async deploy(payload, details = {}) {
        const { calls, addresses } = buildUDCCall(payload, this.address);
        const invokeResponse = await this.execute(calls, void 0, details);
        return {
          ...invokeResponse,
          contract_address: addresses
        };
      }
      async deployContract(payload, details = {}) {
        const deployTx = await this.deploy(payload, details);
        const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);
        return parseUDCEvent(txReceipt);
      }
      async declareAndDeploy(payload, details = {}) {
        const { constructorCalldata, salt, unique: unique2 } = payload;
        let declare = await this.declareIfNot(payload, details);
        if (declare.transaction_hash !== "") {
          const tx = await this.waitForTransaction(declare.transaction_hash);
          declare = { ...declare, ...tx };
        }
        const deploy = await this.deployContract(
          { classHash: declare.class_hash, salt, unique: unique2, constructorCalldata },
          details
        );
        return { declare: { ...declare }, deploy };
      }
      async deployAccount({
        classHash,
        constructorCalldata = [],
        addressSalt = 0,
        contractAddress: providedContractAddress
      }, details = {}) {
        const version7 = toTransactionVersion(
          this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3),
          details.version
        );
        const nonce = ZERO2;
        const chainId = await this.getChainId();
        const compiledCalldata = CallData.compile(constructorCalldata);
        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);
        const estimate = await this.getUniversalSuggestedFee(
          version7,
          {
            type: "DEPLOY_ACCOUNT",
            payload: {
              classHash,
              constructorCalldata: compiledCalldata,
              addressSalt,
              contractAddress
            }
          },
          details
        );
        const signature = await this.signer.signDeployAccountTransaction({
          ...v3Details(details),
          classHash,
          constructorCalldata: compiledCalldata,
          contractAddress,
          addressSalt,
          chainId,
          resourceBounds: estimate.resourceBounds,
          maxFee: estimate.maxFee,
          version: version7,
          nonce
        });
        return this.deployAccountContract(
          { classHash, addressSalt, constructorCalldata, signature },
          {
            ...v3Details(details),
            nonce,
            resourceBounds: estimate.resourceBounds,
            maxFee: estimate.maxFee,
            version: version7
          }
        );
      }
      async signMessage(typedData2) {
        return this.signer.signMessage(typedData2, this.address);
      }
      async hashMessage(typedData2) {
        return getMessageHash(typedData2, this.address);
      }
      async verifyMessageHash(hash2, signature, signatureVerificationFunctionName, signatureVerificationResponse) {
        const knownSigVerificationFName = signatureVerificationFunctionName ? [signatureVerificationFunctionName] : ["isValidSignature", "is_valid_signature"];
        const knownSignatureResponse = signatureVerificationResponse || {
          okResponse: [
            // any non-nok response is true
          ],
          nokResponse: [
            "0x0",
            // Devnet
            "0x00"
            // OpenZeppelin 0.7.0 to 0.9.0 invalid signature
          ],
          error: [
            "argent/invalid-signature",
            // ArgentX 0.3.0 to 0.3.1
            "is invalid, with respect to the public key",
            // OpenZeppelin until 0.6.1, Braavos 0.0.11
            "INVALID_SIG"
            // Braavos 1.0.0
          ]
        };
        let error;
        for (const SigVerificationFName of knownSigVerificationFName) {
          try {
            const resp = await this.callContract({
              contractAddress: this.address,
              entrypoint: SigVerificationFName,
              calldata: CallData.compile({
                hash: toBigInt(hash2).toString(),
                signature: formatSignature(signature)
              })
            });
            if (knownSignatureResponse.nokResponse.includes(resp[0].toString())) {
              return false;
            }
            if (knownSignatureResponse.okResponse.length === 0 || knownSignatureResponse.okResponse.includes(resp[0].toString())) {
              return true;
            }
            throw Error("signatureVerificationResponse Error: response is not part of known responses");
          } catch (err) {
            if (knownSignatureResponse.error.some(
              (errMessage) => err.message.includes(errMessage)
            )) {
              return false;
            }
            error = err;
          }
        }
        throw Error(`Signature verification Error: ${error}`);
      }
      async verifyMessage(typedData2, signature, signatureVerificationFunctionName, signatureVerificationResponse) {
        const hash2 = await this.hashMessage(typedData2);
        return this.verifyMessageHash(
          hash2,
          signature,
          signatureVerificationFunctionName,
          signatureVerificationResponse
        );
      }
      /*
       * Support methods
       */
      async getUniversalSuggestedFee(version7, { type, payload }, details) {
        let maxFee = 0;
        let resourceBounds = estimateFeeToBounds(ZERO2);
        if (version7 === api_exports.ETransactionVersion.V3) {
          resourceBounds = details.resourceBounds ?? (await this.getSuggestedFee({ type, payload }, details)).resourceBounds;
        } else {
          maxFee = details.maxFee ?? (await this.getSuggestedFee({ type, payload }, details)).suggestedMaxFee;
        }
        return {
          maxFee,
          resourceBounds
        };
      }
      async getSuggestedFee({ type, payload }, details) {
        let feeEstimate;
        switch (type) {
          case "INVOKE_FUNCTION":
            feeEstimate = await this.estimateInvokeFee(payload, details);
            break;
          case "DECLARE":
            feeEstimate = await this.estimateDeclareFee(payload, details);
            break;
          case "DEPLOY_ACCOUNT":
            feeEstimate = await this.estimateAccountDeployFee(payload, details);
            break;
          case "DEPLOY":
            feeEstimate = await this.estimateDeployFee(payload, details);
            break;
          default:
            feeEstimate = {
              gas_consumed: 0n,
              gas_price: 0n,
              overall_fee: ZERO2,
              unit: "FRI",
              suggestedMaxFee: ZERO2,
              resourceBounds: estimateFeeToBounds(ZERO2),
              data_gas_consumed: 0n,
              data_gas_price: 0n
            };
            break;
        }
        return feeEstimate;
      }
      async buildInvocation(call, details) {
        const calldata = getExecuteCalldata(call, await this.getCairoVersion());
        const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];
        return {
          ...v3Details(details),
          contractAddress: this.address,
          calldata,
          signature
        };
      }
      async buildDeclarePayload(payload, details) {
        const { classHash, contract, compiledClassHash } = extractContractHashes(payload);
        const compressedCompiledContract = parseContract(contract);
        if (typeof compiledClassHash === "undefined" && (details.version === api_exports.ETransactionVersion3.F3 || details.version === api_exports.ETransactionVersion3.V3)) {
          throw Error("V3 Transaction work with Cairo1 Contracts and require compiledClassHash");
        }
        const signature = !details.skipValidate ? await this.signer.signDeclareTransaction({
          ...details,
          ...v3Details(details),
          classHash,
          compiledClassHash,
          // TODO: TS, cast because optional for v2 and required for v3, thrown if not present
          senderAddress: details.walletAddress
        }) : [];
        return {
          senderAddress: details.walletAddress,
          signature,
          contract: compressedCompiledContract,
          compiledClassHash
        };
      }
      async buildAccountDeployPayload({
        classHash,
        addressSalt = 0,
        constructorCalldata = [],
        contractAddress: providedContractAddress
      }, details) {
        const compiledCalldata = CallData.compile(constructorCalldata);
        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);
        const signature = !details.skipValidate ? await this.signer.signDeployAccountTransaction({
          ...details,
          ...v3Details(details),
          classHash,
          contractAddress,
          addressSalt,
          constructorCalldata: compiledCalldata
        }) : [];
        return {
          ...v3Details(details),
          classHash,
          addressSalt,
          constructorCalldata: compiledCalldata,
          signature
        };
      }
      buildUDCContractPayload(payload) {
        const calls = [].concat(payload).map((it) => {
          const {
            classHash,
            salt = "0",
            unique: unique2 = true,
            constructorCalldata = []
          } = it;
          const compiledConstructorCallData = CallData.compile(constructorCalldata);
          return {
            contractAddress: UDC.ADDRESS,
            entrypoint: UDC.ENTRYPOINT,
            calldata: [
              classHash,
              salt,
              toCairoBool(unique2),
              compiledConstructorCallData.length,
              ...compiledConstructorCallData
            ]
          };
        });
        return calls;
      }
      async accountInvocationsFactory(invocations, details) {
        const { nonce, blockIdentifier, skipValidate = true } = details;
        const safeNonce = await this.getNonceSafe(nonce);
        const chainId = await this.getChainId();
        const versions = details.versions.map((it) => toTransactionVersion(it));
        const tx0Payload = "payload" in invocations[0] ? invocations[0].payload : invocations[0];
        const cairoVersion = invocations[0].type === "DEPLOY_ACCOUNT" ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();
        return Promise.all(
          [].concat(invocations).map(async (transaction2, index2) => {
            const txPayload = "payload" in transaction2 ? transaction2.payload : transaction2;
            const signerDetails = {
              ...v3Details(details),
              walletAddress: this.address,
              nonce: toBigInt(Number(safeNonce) + index2),
              maxFee: ZERO2,
              chainId,
              cairoVersion,
              version: "",
              skipValidate
            };
            const common = {
              type: transaction2.type,
              nonce: toBigInt(Number(safeNonce) + index2),
              blockIdentifier,
              version: ""
            };
            if (transaction2.type === "INVOKE_FUNCTION") {
              const versionX = reduceV2(versions[1]);
              signerDetails.version = versionX;
              common.version = versionX;
              const payload = await this.buildInvocation(
                [].concat(txPayload),
                signerDetails
              );
              return {
                ...common,
                ...payload
              };
            }
            if (transaction2.type === "DEPLOY") {
              const versionX = reduceV2(versions[1]);
              signerDetails.version = versionX;
              common.version = versionX;
              const calls = this.buildUDCContractPayload(txPayload);
              const payload = await this.buildInvocation(calls, signerDetails);
              return {
                ...common,
                ...payload,
                type: "INVOKE_FUNCTION"
                /* INVOKE */
              };
            }
            if (transaction2.type === "DECLARE") {
              const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];
              signerDetails.version = versionX;
              common.version = versionX;
              const payload = await this.buildDeclarePayload(txPayload, signerDetails);
              return {
                ...common,
                ...payload
              };
            }
            if (transaction2.type === "DEPLOY_ACCOUNT") {
              const versionX = reduceV2(versions[1]);
              signerDetails.version = versionX;
              common.version = versionX;
              const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);
              return {
                ...common,
                ...payload
              };
            }
            throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction2}`);
          })
        );
      }
      async getStarkName(address = this.address, StarknetIdContract2) {
        return super.getStarkName(address, StarknetIdContract2);
      }
    };
    var AccountInterface = class extends ProviderInterface {
    };
    var connect_exports = {};
    __export2(connect_exports, {
      addDeclareTransaction: () => addDeclareTransaction,
      addInvokeTransaction: () => addInvokeTransaction,
      addStarknetChain: () => addStarknetChain,
      deploymentData: () => deploymentData,
      getPermissions: () => getPermissions,
      onAccountChange: () => onAccountChange,
      onNetworkChanged: () => onNetworkChanged,
      requestAccounts: () => requestAccounts,
      requestChainId: () => requestChainId,
      signMessage: () => signMessage,
      supportedSpecs: () => supportedSpecs,
      switchStarknetChain: () => switchStarknetChain,
      watchAsset: () => watchAsset
    });
    function requestAccounts(swo, silent_mode = false) {
      return swo.request({
        type: "wallet_requestAccounts",
        params: {
          silent_mode
        }
      });
    }
    function getPermissions(swo) {
      return swo.request({ type: "wallet_getPermissions" });
    }
    function watchAsset(swo, asset) {
      return swo.request({
        type: "wallet_watchAsset",
        params: asset
      });
    }
    function addStarknetChain(swo, chain) {
      return swo.request({
        type: "wallet_addStarknetChain",
        params: chain
      });
    }
    function switchStarknetChain(swo, chainId) {
      return swo.request({
        type: "wallet_switchStarknetChain",
        params: {
          chainId
        }
      });
    }
    function requestChainId(swo) {
      return swo.request({ type: "wallet_requestChainId" });
    }
    function deploymentData(swo) {
      return swo.request({ type: "wallet_deploymentData" });
    }
    function addInvokeTransaction(swo, params) {
      return swo.request({
        type: "wallet_addInvokeTransaction",
        params
      });
    }
    function addDeclareTransaction(swo, params) {
      return swo.request({
        type: "wallet_addDeclareTransaction",
        params
      });
    }
    function signMessage(swo, typedData2) {
      return swo.request({
        type: "wallet_signTypedData",
        params: typedData2
      });
    }
    function supportedSpecs(swo) {
      return swo.request({ type: "wallet_supportedSpecs" });
    }
    function onAccountChange(swo, callback) {
      swo.on("accountsChanged", callback);
    }
    function onNetworkChanged(swo, callback) {
      swo.on("networkChanged", callback);
    }
    var WalletAccount = class extends Account {
      constructor(providerOrOptions, walletProvider, cairoVersion) {
        super(providerOrOptions, "", "", cairoVersion);
        __publicField(this, "address", "");
        __publicField(this, "walletProvider");
        this.walletProvider = walletProvider;
        this.walletProvider.on("accountsChanged", (res) => {
          if (!res)
            return;
          this.address = res[0].toLowerCase();
        });
        this.walletProvider.on("networkChanged", (res) => {
          if (!res)
            return;
          this.channel.setChainId(res);
        });
        walletProvider.request({
          type: "wallet_requestAccounts",
          params: {
            silent_mode: false
          }
        }).then((res) => {
          this.address = res[0].toLowerCase();
        });
      }
      /**
       * WALLET EVENTS
       */
      onAccountChange(callback) {
        onAccountChange(this.walletProvider, callback);
      }
      onNetworkChanged(callback) {
        onNetworkChanged(this.walletProvider, callback);
      }
      /**
       * WALLET SPECIFIC METHODS
       */
      requestAccounts(silentMode = false) {
        return requestAccounts(this.walletProvider, silentMode);
      }
      getPermissions() {
        return getPermissions(this.walletProvider);
      }
      switchStarknetChain(chainId) {
        return switchStarknetChain(this.walletProvider, chainId);
      }
      watchAsset(asset) {
        return watchAsset(this.walletProvider, asset);
      }
      addStarknetChain(chain) {
        return addStarknetChain(this.walletProvider, chain);
      }
      /**
       * ACCOUNT METHODS
       */
      execute(calls) {
        const txCalls = [].concat(calls).map((it) => {
          const { contractAddress, entrypoint, calldata } = it;
          return {
            contract_address: contractAddress,
            entry_point: entrypoint,
            calldata
          };
        });
        const params = {
          calls: txCalls
        };
        return addInvokeTransaction(this.walletProvider, params);
      }
      declare(payload) {
        const declareContractPayload = extractContractHashes(payload);
        const pContract = payload.contract;
        const cairo1Contract = {
          ...pContract,
          abi: stringify2(pContract.abi)
        };
        if (!declareContractPayload.compiledClassHash) {
          throw Error("compiledClassHash is required");
        }
        const params = {
          compiled_class_hash: declareContractPayload.compiledClassHash,
          contract_class: cairo1Contract
        };
        return addDeclareTransaction(this.walletProvider, params);
      }
      async deploy(payload) {
        const { calls, addresses } = buildUDCCall(payload, this.address);
        const invokeResponse = await this.execute(calls);
        return {
          ...invokeResponse,
          contract_address: addresses
        };
      }
      signMessage(typedData2) {
        return signMessage(this.walletProvider, typedData2);
      }
      // TODO: MISSING ESTIMATES
    };
    var splitArgsAndOptions = (args) => {
      const options = [
        "blockIdentifier",
        "parseRequest",
        "parseResponse",
        "formatResponse",
        "maxFee",
        "nonce",
        "signature",
        "addressSalt"
      ];
      const lastArg = args[args.length - 1];
      if (typeof lastArg === "object" && options.some((x) => x in lastArg)) {
        return { args, options: args.pop() };
      }
      return { args };
    };
    function buildCall(contract, functionAbi) {
      return async function(...args) {
        const params = splitArgsAndOptions(args);
        return contract.call(functionAbi.name, params.args, {
          parseRequest: true,
          parseResponse: true,
          ...params.options
        });
      };
    }
    function buildInvoke(contract, functionAbi) {
      return async function(...args) {
        const params = splitArgsAndOptions(args);
        return contract.invoke(functionAbi.name, params.args, {
          parseRequest: true,
          ...params.options
        });
      };
    }
    function buildDefault(contract, functionAbi) {
      if (functionAbi.stateMutability === "view" || functionAbi.state_mutability === "view") {
        return buildCall(contract, functionAbi);
      }
      return buildInvoke(contract, functionAbi);
    }
    function buildPopulate(contract, functionAbi) {
      return function(...args) {
        return contract.populate(functionAbi.name, args);
      };
    }
    function buildEstimate(contract, functionAbi) {
      return function(...args) {
        return contract.estimate(functionAbi.name, args);
      };
    }
    function getCalldata(args, callback) {
      if (Array.isArray(args) && "__compiled__" in args)
        return args;
      if (Array.isArray(args) && Array.isArray(args[0]) && "__compiled__" in args[0])
        return args[0];
      return callback();
    }
    var Contract = class {
      /**
       * Contract class to handle contract methods
       *
       * @param abi - Abi of the contract object
       * @param address (optional) - address to connect to
       * @param providerOrAccount (optional) - Provider or Account to attach to
       */
      constructor(abi, address, providerOrAccount = defaultProvider) {
        __publicField(this, "abi");
        __publicField(this, "address");
        __publicField(this, "providerOrAccount");
        __publicField(this, "deployTransactionHash");
        __publicField(this, "structs");
        __publicField(this, "events");
        __publicField(this, "functions");
        __publicField(this, "callStatic");
        __publicField(this, "populateTransaction");
        __publicField(this, "estimateFee");
        __publicField(this, "callData");
        this.address = address && address.toLowerCase();
        this.providerOrAccount = providerOrAccount;
        this.callData = new CallData(abi);
        this.structs = CallData.getAbiStruct(abi);
        this.events = getAbiEvents(abi);
        const parser2 = createAbiParser(abi);
        this.abi = parser2.getLegacyFormat();
        const options = { enumerable: true, value: {}, writable: false };
        Object.defineProperties(this, {
          functions: { enumerable: true, value: {}, writable: false },
          callStatic: { enumerable: true, value: {}, writable: false },
          populateTransaction: { enumerable: true, value: {}, writable: false },
          estimateFee: { enumerable: true, value: {}, writable: false }
        });
        this.abi.forEach((abiElement) => {
          if (abiElement.type !== "function")
            return;
          const signature = abiElement.name;
          if (!this[signature]) {
            Object.defineProperty(this, signature, {
              ...options,
              value: buildDefault(this, abiElement)
            });
          }
          if (!this.functions[signature]) {
            Object.defineProperty(this.functions, signature, {
              ...options,
              value: buildDefault(this, abiElement)
            });
          }
          if (!this.callStatic[signature]) {
            Object.defineProperty(this.callStatic, signature, {
              ...options,
              value: buildCall(this, abiElement)
            });
          }
          if (!this.populateTransaction[signature]) {
            Object.defineProperty(this.populateTransaction, signature, {
              ...options,
              value: buildPopulate(this, abiElement)
            });
          }
          if (!this.estimateFee[signature]) {
            Object.defineProperty(this.estimateFee, signature, {
              ...options,
              value: buildEstimate(this, abiElement)
            });
          }
        });
      }
      attach(address) {
        this.address = address;
      }
      connect(providerOrAccount) {
        this.providerOrAccount = providerOrAccount;
      }
      async deployed() {
        if (this.deployTransactionHash) {
          await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);
          this.deployTransactionHash = void 0;
        }
        return this;
      }
      async call(method, args = [], {
        parseRequest = true,
        parseResponse = true,
        formatResponse = void 0,
        blockIdentifier = void 0
      } = {}) {
        assert5(this.address !== null, "contract is not connected to an address");
        const calldata = getCalldata(args, () => {
          if (parseRequest) {
            this.callData.validate("CALL", method, args);
            return this.callData.compile(method, args);
          }
          console.warn("Call skipped parsing but provided rawArgs, possible malfunction request");
          return args;
        });
        return this.providerOrAccount.callContract(
          {
            contractAddress: this.address,
            calldata,
            entrypoint: method
          },
          blockIdentifier
        ).then((it) => {
          if (!parseResponse) {
            return it;
          }
          if (formatResponse) {
            return this.callData.format(method, it, formatResponse);
          }
          return this.callData.parse(method, it);
        });
      }
      invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {
        assert5(this.address !== null, "contract is not connected to an address");
        const calldata = getCalldata(args, () => {
          if (parseRequest) {
            this.callData.validate("INVOKE", method, args);
            return this.callData.compile(method, args);
          }
          console.warn("Invoke skipped parsing but provided rawArgs, possible malfunction request");
          return args;
        });
        const invocation = {
          contractAddress: this.address,
          calldata,
          entrypoint: method
        };
        if ("execute" in this.providerOrAccount) {
          return this.providerOrAccount.execute(invocation, void 0, {
            maxFee,
            nonce
          });
        }
        if (!nonce)
          throw new Error(`Nonce is required when invoking a function without an account`);
        console.warn(`Invoking ${method} without an account. This will not work on a public node.`);
        return this.providerOrAccount.invokeFunction(
          {
            ...invocation,
            signature
          },
          {
            nonce
          }
        );
      }
      async estimate(method, args = []) {
        assert5(this.address !== null, "contract is not connected to an address");
        if (!getCalldata(args, () => false)) {
          this.callData.validate("INVOKE", method, args);
        }
        const invocation = this.populate(method, args);
        if ("estimateInvokeFee" in this.providerOrAccount) {
          return this.providerOrAccount.estimateInvokeFee(invocation);
        }
        throw Error("Contract must be connected to the account contract to estimate");
      }
      populate(method, args = []) {
        const calldata = getCalldata(args, () => this.callData.compile(method, args));
        return {
          contractAddress: this.address,
          entrypoint: method,
          calldata
        };
      }
      parseEvents(receipt) {
        var _a4;
        return parseEvents(
          ((_a4 = receipt.events) == null ? void 0 : _a4.filter(
            (event) => cleanHex(event.from_address) === cleanHex(this.address),
            []
          )) || [],
          this.events,
          this.structs,
          CallData.getAbiEnum(this.abi)
        );
      }
      isCairo1() {
        return cairo_exports.isCairo1Abi(this.abi);
      }
      async getVersion() {
        return this.providerOrAccount.getContractVersion(this.address);
      }
      typedv2(tAbi) {
        return this;
      }
    };
    var ContractInterface = class {
      constructor() {
        __publicField(this, "functions");
        __publicField(this, "callStatic");
        __publicField(this, "populateTransaction");
        __publicField(this, "estimateFee");
      }
    };
    var ContractFactory = class {
      /**
       * @param params CFParams
       *  - compiledContract: CompiledContract;
       *  - account: AccountInterface;
       *  - casm?: CairoAssembly;
       *  - classHash?: string;
       *  - compiledClassHash?: string;
       *  - abi?: Abi;
       */
      constructor(params) {
        __publicField(this, "compiledContract");
        __publicField(this, "account");
        __publicField(this, "abi");
        __publicField(this, "classHash");
        __publicField(this, "casm");
        __publicField(this, "compiledClassHash");
        __publicField(this, "CallData");
        this.compiledContract = params.compiledContract;
        this.account = params.account;
        this.casm = params.casm;
        this.abi = params.abi ?? params.compiledContract.abi;
        this.classHash = params.classHash;
        this.compiledClassHash = params.compiledClassHash;
        this.CallData = new CallData(this.abi);
      }
      /**
       * Deploys contract and returns new instance of the Contract
       *
       * If contract is not declared it will first declare it, and then deploy
       */
      async deploy(...args) {
        const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);
        const constructorCalldata = getCalldata(param, () => {
          if (options.parseRequest) {
            this.CallData.validate("DEPLOY", "constructor", param);
            return this.CallData.compile("constructor", param);
          }
          console.warn("Call skipped parsing but provided rawArgs, possible malfunction request");
          return param;
        });
        const {
          deploy: { contract_address, transaction_hash }
        } = await this.account.declareAndDeploy({
          contract: this.compiledContract,
          casm: this.casm,
          classHash: this.classHash,
          compiledClassHash: this.compiledClassHash,
          constructorCalldata,
          salt: options.addressSalt
        });
        assert5(Boolean(contract_address), "Deployment of the contract failed");
        const contractInstance = new Contract(
          this.compiledContract.abi,
          contract_address,
          this.account
        );
        contractInstance.deployTransactionHash = transaction_hash;
        return contractInstance;
      }
      /**
       * Attaches to new Account
       *
       * @param account - new Account to attach to
       */
      connect(account) {
        this.account = account;
        return this;
      }
      /**
       * Attaches current abi and account to the new address
       */
      attach(address) {
        return new Contract(this.abi, address, this.account);
      }
      // ethers.js' getDeployTransaction can't be supported as it requires the account or signer to return a signed transaction which is not possible with the current implementation
    };
    var ResponseParser = class {
    };
    var import_utils32 = require_utils4();
    function addAddressPadding(address) {
      const hex = toHex2(addHexPrefix(address.toString()));
      const padded = removeHexPrefix(hex).padStart(64, "0");
      return addHexPrefix(padded);
    }
    function validateAndParseAddress(address) {
      const result2 = addAddressPadding(address);
      if (!result2.match(/^(0x)?[0-9a-fA-F]{64}$/)) {
        throw new Error("Invalid Address Format");
      }
      assertInRange(result2, ZERO2, ADDR_BOUND - 1n, "Starknet Address");
      return result2;
    }
    function getChecksumAddress2(address) {
      const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split("");
      const hex = removeHexPrefix(keccakBn(address));
      const hashed = (0, import_utils32.hexToBytes)(hex.padStart(64, "0"));
      for (let i = 0; i < chars.length; i += 2) {
        if (hashed[i >> 1] >> 4 >= 8) {
          chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 15) >= 8) {
          chars[i + 1] = chars[i + 1].toUpperCase();
        }
      }
      return addHexPrefix(chars.join(""));
    }
    function validateChecksumAddress(address) {
      return getChecksumAddress2(address) === address;
    }
    var import_url_join = __toESM3(require_url_join());
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s.]+\.\S{2,}$/;
    function isUrl(s) {
      if (!s) {
        return false;
      }
      if (typeof s !== "string") {
        return false;
      }
      const match = s.match(protocolAndDomainRE);
      if (!match) {
        return false;
      }
      const everythingAfterProtocol = match[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
    function buildUrl(baseUrl, defaultPath, urlOrPath) {
      return isUrl(urlOrPath) ? urlOrPath : (0, import_url_join.default)(baseUrl, urlOrPath ?? defaultPath);
    }
    var number = num_exports;
  }
});

// node_modules/@keplr-wallet/crypto/build/key.js
var require_key = __commonJS({
  "node_modules/@keplr-wallet/crypto/build/key.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result2 = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result2, mod2, k);
      }
      __setModuleDefault(result2, mod2);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PubKeySecp256k1 = exports2.PubKeyStarknet = exports2.PrivKeySecp256k1 = void 0;
    var secp256k1_1 = require_secp256k1();
    var utils = __importStar(require_utils3());
    var sha2_1 = require_sha22();
    var ripemd160_1 = require_ripemd160();
    var buffer_1 = require_dist();
    var hash_1 = require_hash2();
    var starknet_1 = require_dist5();
    var PrivKeySecp256k12 = class _PrivKeySecp256k1 {
      static generateRandomKey() {
        return new _PrivKeySecp256k1(secp256k1_1.secp256k1.utils.randomPrivateKey());
      }
      constructor(privKey) {
        this.privKey = privKey;
      }
      toBytes() {
        return new Uint8Array(this.privKey);
      }
      getPubKey() {
        return new PubKeySecp256k1(secp256k1_1.secp256k1.getPublicKey(this.privKey, true));
      }
      signDigest32(digest) {
        if (digest.length !== 32) {
          throw new Error(`Invalid length of digest to sign: ${digest.length}`);
        }
        const signature = secp256k1_1.secp256k1.sign(digest, this.privKey, {
          lowS: true
        });
        return {
          r: utils.numberToBytesBE(signature.r, 32),
          s: utils.numberToBytesBE(signature.s, 32),
          v: signature.recovery
        };
      }
    };
    exports2.PrivKeySecp256k1 = PrivKeySecp256k12;
    var PubKeyStarknet = class {
      constructor(pubKey) {
        this.pubKey = pubKey;
        if (pubKey.length !== 64) {
          throw new Error(`Invalid length of public key: ${pubKey.length}`);
        }
      }
      toBytes() {
        return new Uint8Array(this.pubKey);
      }
      getStarknetPubKey() {
        return this.pubKey.slice(0, 32);
      }
      getStarknetAddress(salt, classHash) {
        const starknetPubKey = this.getStarknetPubKey();
        let calculated = starknet_1.hash.calculateContractAddressFromHash("0x" + buffer_1.Buffer.from(salt).toString("hex"), "0x" + buffer_1.Buffer.from(classHash).toString("hex"), ["0x" + buffer_1.Buffer.from(starknetPubKey).toString("hex")], "0x00").replace("0x", "");
        const padZero = 64 - calculated.length;
        if (padZero > 0) {
          calculated = "0".repeat(padZero) + calculated;
        } else if (padZero < 0) {
          throw new Error("Invalid length of calculated address");
        }
        return new Uint8Array(buffer_1.Buffer.from(calculated, "hex"));
      }
      getStarknetAddressParams() {
        return {
          xLow: this.pubKey.slice(16, 32),
          xHigh: this.pubKey.slice(0, 16),
          yLow: this.pubKey.slice(48, 64),
          yHigh: this.pubKey.slice(32, 48)
        };
      }
    };
    exports2.PubKeyStarknet = PubKeyStarknet;
    var PubKeySecp256k1 = class {
      constructor(pubKey) {
        this.pubKey = pubKey;
        if (pubKey.length !== 33 && pubKey.length !== 65) {
          throw new Error(`Invalid length of public key: ${pubKey.length}`);
        }
      }
      toBytes(uncompressed) {
        if (uncompressed && this.pubKey.length === 65) {
          return this.pubKey;
        }
        if (!uncompressed && this.pubKey.length === 33) {
          return this.pubKey;
        }
        if (uncompressed) {
          return secp256k1_1.secp256k1.ProjectivePoint.fromHex(buffer_1.Buffer.from(this.pubKey).toString("hex")).toRawBytes(false);
        } else {
          return secp256k1_1.secp256k1.ProjectivePoint.fromHex(buffer_1.Buffer.from(this.pubKey).toString("hex")).toRawBytes(true);
        }
      }
      /**
       * @deprecated Use `getCosmosAddress()` instead.
       */
      getAddress() {
        return this.getCosmosAddress();
      }
      getCosmosAddress() {
        return (0, ripemd160_1.ripemd160)((0, sha2_1.sha256)(this.toBytes(false)));
      }
      getEthAddress() {
        return hash_1.Hash.keccak256(this.toBytes(true).slice(1)).slice(-20);
      }
      getStarknetAddress(salt, classHash) {
        const pubBytes = this.toBytes(true).slice(1);
        const xLow = pubBytes.slice(16, 32);
        const xHigh = pubBytes.slice(0, 16);
        const yLow = pubBytes.slice(48, 64);
        const yHigh = pubBytes.slice(32, 48);
        let calculated = starknet_1.hash.calculateContractAddressFromHash("0x" + buffer_1.Buffer.from(salt).toString("hex"), "0x" + buffer_1.Buffer.from(classHash).toString("hex"), [
          "0x" + buffer_1.Buffer.from(xLow).toString("hex"),
          "0x" + buffer_1.Buffer.from(xHigh).toString("hex"),
          "0x" + buffer_1.Buffer.from(yLow).toString("hex"),
          "0x" + buffer_1.Buffer.from(yHigh).toString("hex")
        ], "0x00").replace("0x", "");
        const padZero = 64 - calculated.length;
        if (padZero > 0) {
          calculated = "0".repeat(padZero) + calculated;
        } else if (padZero < 0) {
          throw new Error("Invalid length of calculated address");
        }
        return new Uint8Array(buffer_1.Buffer.from(calculated, "hex"));
      }
      getStarknetAddressParams() {
        const pubBytes = this.toBytes(true).slice(1);
        return {
          xLow: pubBytes.slice(16, 32),
          xHigh: pubBytes.slice(0, 16),
          yLow: pubBytes.slice(48, 64),
          yHigh: pubBytes.slice(32, 48)
        };
      }
      getStarknetPubKey() {
        return this.pubKey.slice(1);
      }
      verifyDigest32(digest, signature) {
        if (digest.length !== 32) {
          throw new Error(`Invalid length of digest to verify: ${digest.length}`);
        }
        if (signature.length !== 64) {
          throw new Error(`Invalid length of signature: ${signature.length}`);
        }
        const r2 = signature.slice(0, 32);
        const s = signature.slice(32);
        return secp256k1_1.secp256k1.verify({
          r: utils.bytesToNumberBE(r2),
          s: utils.bytesToNumberBE(s)
        }, digest, this.pubKey);
      }
    };
    exports2.PubKeySecp256k1 = PubKeySecp256k1;
  }
});

// node_modules/@keplr-wallet/crypto/build/index.js
var require_build10 = __commonJS({
  "node_modules/@keplr-wallet/crypto/build/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_mnemonic(), exports2);
    __exportStar(require_key(), exports2);
    __exportStar(require_hash2(), exports2);
  }
});

// node_modules/big-integer/BigInteger.js
var require_BigInteger = __commonJS({
  "node_modules/big-integer/BigInteger.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var bigInt = function(undefined2) {
      "use strict";
      var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
      var supportsNativeBigInt = typeof BigInt === "function";
      function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
      }
      function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
      }
      BigInteger.prototype = Object.create(Integer.prototype);
      function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
      }
      SmallInteger.prototype = Object.create(Integer.prototype);
      function NativeBigInt(value) {
        this.value = value;
      }
      NativeBigInt.prototype = Object.create(Integer.prototype);
      function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
      }
      function smallToArray(n) {
        if (n < 1e7)
          return [n];
        if (n < 1e14)
          return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
      }
      function arrayToSmall(arr) {
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
          switch (length) {
            case 0:
              return 0;
            case 1:
              return arr[0];
            case 2:
              return arr[0] + arr[1] * BASE;
            default:
              return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
          }
        }
        return arr;
      }
      function trim(v) {
        var i2 = v.length;
        while (v[--i2] === 0) ;
        v.length = i2 + 1;
      }
      function createArray(length) {
        var x = new Array(length);
        var i2 = -1;
        while (++i2 < length) {
          x[i2] = 0;
        }
        return x;
      }
      function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
      }
      function add2(a, b) {
        var l_a = a.length, l_b = b.length, r2 = new Array(l_a), carry = 0, base = BASE, sum, i2;
        for (i2 = 0; i2 < l_b; i2++) {
          sum = a[i2] + b[i2] + carry;
          carry = sum >= base ? 1 : 0;
          r2[i2] = sum - carry * base;
        }
        while (i2 < l_a) {
          sum = a[i2] + carry;
          carry = sum === base ? 1 : 0;
          r2[i2++] = sum - carry * base;
        }
        if (carry > 0) r2.push(carry);
        return r2;
      }
      function addAny(a, b) {
        if (a.length >= b.length) return add2(a, b);
        return add2(b, a);
      }
      function addSmall(a, carry) {
        var l = a.length, r2 = new Array(l), base = BASE, sum, i2;
        for (i2 = 0; i2 < l; i2++) {
          sum = a[i2] - base + carry;
          carry = Math.floor(sum / base);
          r2[i2] = sum - carry * base;
          carry += 1;
        }
        while (carry > 0) {
          r2[i2++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r2;
      }
      BigInteger.prototype.add = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
          return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
          return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
      };
      BigInteger.prototype.plus = BigInteger.prototype.add;
      SmallInteger.prototype.add = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
          return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
          if (isPrecise(a + b)) return new SmallInteger(a + b);
          b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
      };
      SmallInteger.prototype.plus = SmallInteger.prototype.add;
      NativeBigInt.prototype.add = function(v) {
        return new NativeBigInt(this.value + parseValue(v).value);
      };
      NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
      function subtract2(a, b) {
        var a_l = a.length, b_l = b.length, r2 = new Array(a_l), borrow = 0, base = BASE, i2, difference;
        for (i2 = 0; i2 < b_l; i2++) {
          difference = a[i2] - borrow - b[i2];
          if (difference < 0) {
            difference += base;
            borrow = 1;
          } else borrow = 0;
          r2[i2] = difference;
        }
        for (i2 = b_l; i2 < a_l; i2++) {
          difference = a[i2] - borrow;
          if (difference < 0) difference += base;
          else {
            r2[i2++] = difference;
            break;
          }
          r2[i2] = difference;
        }
        for (; i2 < a_l; i2++) {
          r2[i2] = a[i2];
        }
        trim(r2);
        return r2;
      }
      function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
          value = subtract2(a, b);
        } else {
          value = subtract2(b, a);
          sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
          if (sign) value = -value;
          return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
      }
      function subtractSmall(a, b, sign) {
        var l = a.length, r2 = new Array(l), carry = -b, base = BASE, i2, difference;
        for (i2 = 0; i2 < l; i2++) {
          difference = a[i2] + carry;
          carry = Math.floor(difference / base);
          difference %= base;
          r2[i2] = difference < 0 ? difference + base : difference;
        }
        r2 = arrayToSmall(r2);
        if (typeof r2 === "number") {
          if (sign) r2 = -r2;
          return new SmallInteger(r2);
        }
        return new BigInteger(r2, sign);
      }
      BigInteger.prototype.subtract = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
          return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
          return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
      };
      BigInteger.prototype.minus = BigInteger.prototype.subtract;
      SmallInteger.prototype.subtract = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
          return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
          return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
      };
      SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
      NativeBigInt.prototype.subtract = function(v) {
        return new NativeBigInt(this.value - parseValue(v).value);
      };
      NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
      BigInteger.prototype.negate = function() {
        return new BigInteger(this.value, !this.sign);
      };
      SmallInteger.prototype.negate = function() {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
      };
      NativeBigInt.prototype.negate = function() {
        return new NativeBigInt(-this.value);
      };
      BigInteger.prototype.abs = function() {
        return new BigInteger(this.value, false);
      };
      SmallInteger.prototype.abs = function() {
        return new SmallInteger(Math.abs(this.value));
      };
      NativeBigInt.prototype.abs = function() {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
      };
      function multiplyLong(a, b) {
        var a_l = a.length, b_l = b.length, l = a_l + b_l, r2 = createArray(l), base = BASE, product, carry, i2, a_i, b_j;
        for (i2 = 0; i2 < a_l; ++i2) {
          a_i = a[i2];
          for (var j = 0; j < b_l; ++j) {
            b_j = b[j];
            product = a_i * b_j + r2[i2 + j];
            carry = Math.floor(product / base);
            r2[i2 + j] = product - carry * base;
            r2[i2 + j + 1] += carry;
          }
        }
        trim(r2);
        return r2;
      }
      function multiplySmall(a, b) {
        var l = a.length, r2 = new Array(l), base = BASE, carry = 0, product, i2;
        for (i2 = 0; i2 < l; i2++) {
          product = a[i2] * b + carry;
          carry = Math.floor(product / base);
          r2[i2] = product - carry * base;
        }
        while (carry > 0) {
          r2[i2++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r2;
      }
      function shiftLeft2(x, n) {
        var r2 = [];
        while (n-- > 0) r2.push(0);
        return r2.concat(x);
      }
      function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);
        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);
        var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
        var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
        var product = addAny(addAny(ac, shiftLeft2(subtract2(subtract2(abcd, ac), bd), n)), shiftLeft2(bd, 2 * n));
        trim(product);
        return product;
      }
      function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;
      }
      BigInteger.prototype.multiply = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;
        if (n.isSmall) {
          if (b === 0) return Integer[0];
          if (b === 1) return this;
          if (b === -1) return this.negate();
          abs = Math.abs(b);
          if (abs < BASE) {
            return new BigInteger(multiplySmall(a, abs), sign);
          }
          b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length))
          return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
      };
      BigInteger.prototype.times = BigInteger.prototype.multiply;
      function multiplySmallAndArray(a, b, sign) {
        if (a < BASE) {
          return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
      }
      SmallInteger.prototype._multiplyBySmall = function(a) {
        if (isPrecise(a.value * this.value)) {
          return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
      };
      BigInteger.prototype._multiplyBySmall = function(a) {
        if (a.value === 0) return Integer[0];
        if (a.value === 1) return this;
        if (a.value === -1) return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
      };
      SmallInteger.prototype.multiply = function(v) {
        return parseValue(v)._multiplyBySmall(this);
      };
      SmallInteger.prototype.times = SmallInteger.prototype.multiply;
      NativeBigInt.prototype.multiply = function(v) {
        return new NativeBigInt(this.value * parseValue(v).value);
      };
      NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
      function square(a) {
        var l = a.length, r2 = createArray(l + l), base = BASE, product, carry, i2, a_i, a_j;
        for (i2 = 0; i2 < l; i2++) {
          a_i = a[i2];
          carry = 0 - a_i * a_i;
          for (var j = i2; j < l; j++) {
            a_j = a[j];
            product = 2 * (a_i * a_j) + r2[i2 + j] + carry;
            carry = Math.floor(product / base);
            r2[i2 + j] = product - carry * base;
          }
          r2[i2 + l] = carry;
        }
        trim(r2);
        return r2;
      }
      BigInteger.prototype.square = function() {
        return new BigInteger(square(this.value), false);
      };
      SmallInteger.prototype.square = function() {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
      };
      NativeBigInt.prototype.square = function(v) {
        return new NativeBigInt(this.value * this.value);
      };
      function divMod1(a, b) {
        var a_l = a.length, b_l = b.length, base = BASE, result2 = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift4, carry, borrow, i2, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift4 = a_l - b_l; shift4 >= 0; shift4--) {
          quotientDigit = base - 1;
          if (remainder[shift4 + b_l] !== divisorMostSignificantDigit) {
            quotientDigit = Math.floor((remainder[shift4 + b_l] * base + remainder[shift4 + b_l - 1]) / divisorMostSignificantDigit);
          }
          carry = 0;
          borrow = 0;
          l = divisor.length;
          for (i2 = 0; i2 < l; i2++) {
            carry += quotientDigit * divisor[i2];
            q = Math.floor(carry / base);
            borrow += remainder[shift4 + i2] - (carry - q * base);
            carry = q;
            if (borrow < 0) {
              remainder[shift4 + i2] = borrow + base;
              borrow = -1;
            } else {
              remainder[shift4 + i2] = borrow;
              borrow = 0;
            }
          }
          while (borrow !== 0) {
            quotientDigit -= 1;
            carry = 0;
            for (i2 = 0; i2 < l; i2++) {
              carry += remainder[shift4 + i2] - base + divisor[i2];
              if (carry < 0) {
                remainder[shift4 + i2] = carry + base;
                carry = 0;
              } else {
                remainder[shift4 + i2] = carry;
                carry = 1;
              }
            }
            borrow += carry;
          }
          result2[shift4] = quotientDigit;
        }
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result2), arrayToSmall(remainder)];
      }
      function divMod2(a, b) {
        var a_l = a.length, b_l = b.length, result2 = [], part = [], base = BASE, guess, xlen, highx, highy, check2;
        while (a_l) {
          part.unshift(a[--a_l]);
          trim(part);
          if (compareAbs(part, b) < 0) {
            result2.push(0);
            continue;
          }
          xlen = part.length;
          highx = part[xlen - 1] * base + part[xlen - 2];
          highy = b[b_l - 1] * base + b[b_l - 2];
          if (xlen > b_l) {
            highx = (highx + 1) * base;
          }
          guess = Math.ceil(highx / highy);
          do {
            check2 = multiplySmall(b, guess);
            if (compareAbs(check2, part) <= 0) break;
            guess--;
          } while (guess);
          result2.push(guess);
          part = subtract2(part, check2);
        }
        result2.reverse();
        return [arrayToSmall(result2), arrayToSmall(part)];
      }
      function divModSmall(value, lambda) {
        var length = value.length, quotient = createArray(length), base = BASE, i2, q, remainder, divisor;
        remainder = 0;
        for (i2 = length - 1; i2 >= 0; --i2) {
          divisor = remainder * base + value[i2];
          q = truncate(divisor / lambda);
          remainder = divisor - q * lambda;
          quotient[i2] = q | 0;
        }
        return [quotient, remainder | 0];
      }
      function divModAny(self2, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
          return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];
        }
        var a = self2.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self2.isSmall) {
          if (n.isSmall) {
            return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
          }
          return [Integer[0], self2];
        }
        if (n.isSmall) {
          if (b === 1) return [self2, Integer[0]];
          if (b == -1) return [self2.negate(), Integer[0]];
          var abs = Math.abs(b);
          if (abs < BASE) {
            value = divModSmall(a, abs);
            quotient = arrayToSmall(value[0]);
            var remainder = value[1];
            if (self2.sign) remainder = -remainder;
            if (typeof quotient === "number") {
              if (self2.sign !== n.sign) quotient = -quotient;
              return [new SmallInteger(quotient), new SmallInteger(remainder)];
            }
            return [new BigInteger(quotient, self2.sign !== n.sign), new SmallInteger(remainder)];
          }
          b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self2];
        if (comparison === 0) return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];
        if (a.length + b.length <= 200)
          value = divMod1(a, b);
        else value = divMod2(a, b);
        quotient = value[0];
        var qSign = self2.sign !== n.sign, mod2 = value[1], mSign = self2.sign;
        if (typeof quotient === "number") {
          if (qSign) quotient = -quotient;
          quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod2 === "number") {
          if (mSign) mod2 = -mod2;
          mod2 = new SmallInteger(mod2);
        } else mod2 = new BigInteger(mod2, mSign);
        return [quotient, mod2];
      }
      BigInteger.prototype.divmod = function(v) {
        var result2 = divModAny(this, v);
        return {
          quotient: result2[0],
          remainder: result2[1]
        };
      };
      NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
      BigInteger.prototype.divide = function(v) {
        return divModAny(this, v)[0];
      };
      NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
        return new NativeBigInt(this.value / parseValue(v).value);
      };
      SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
      BigInteger.prototype.mod = function(v) {
        return divModAny(this, v)[1];
      };
      NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
        return new NativeBigInt(this.value % parseValue(v).value);
      };
      SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
      BigInteger.prototype.pow = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
          return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
          if (isPrecise(value = Math.pow(a, b)))
            return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
          if (b & true) {
            y = y.times(x);
            --b;
          }
          if (b === 0) break;
          b /= 2;
          x = x.square();
        }
        return y;
      };
      SmallInteger.prototype.pow = BigInteger.prototype.pow;
      NativeBigInt.prototype.pow = function(v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
        if (b === _0) return Integer[1];
        if (a === _0) return Integer[0];
        if (a === _1) return Integer[1];
        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative()) return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];
        while (true) {
          if ((b & _1) === _1) {
            y = y.times(x);
            --b;
          }
          if (b === _0) break;
          b /= _2;
          x = x.square();
        }
        return y;
      };
      BigInteger.prototype.modPow = function(exp, mod2) {
        exp = parseValue(exp);
        mod2 = parseValue(mod2);
        if (mod2.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r2 = Integer[1], base = this.mod(mod2);
        if (exp.isNegative()) {
          exp = exp.multiply(Integer[-1]);
          base = base.modInv(mod2);
        }
        while (exp.isPositive()) {
          if (base.isZero()) return Integer[0];
          if (exp.isOdd()) r2 = r2.multiply(base).mod(mod2);
          exp = exp.divide(2);
          base = base.square().mod(mod2);
        }
        return r2;
      };
      NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
      function compareAbs(a, b) {
        if (a.length !== b.length) {
          return a.length > b.length ? 1 : -1;
        }
        for (var i2 = a.length - 1; i2 >= 0; i2--) {
          if (a[i2] !== b[i2]) return a[i2] > b[i2] ? 1 : -1;
        }
        return 0;
      }
      BigInteger.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
      };
      SmallInteger.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = Math.abs(this.value), b = n.value;
        if (n.isSmall) {
          b = Math.abs(b);
          return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
      };
      NativeBigInt.prototype.compareAbs = function(v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
      };
      BigInteger.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (this.sign !== n.sign) {
          return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
          return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
      };
      BigInteger.prototype.compareTo = BigInteger.prototype.compare;
      SmallInteger.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall) {
          return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
          return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
      };
      SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
      NativeBigInt.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
      };
      NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
      BigInteger.prototype.equals = function(v) {
        return this.compare(v) === 0;
      };
      NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
      BigInteger.prototype.notEquals = function(v) {
        return this.compare(v) !== 0;
      };
      NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
      BigInteger.prototype.greater = function(v) {
        return this.compare(v) > 0;
      };
      NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
      BigInteger.prototype.lesser = function(v) {
        return this.compare(v) < 0;
      };
      NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
      BigInteger.prototype.greaterOrEquals = function(v) {
        return this.compare(v) >= 0;
      };
      NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
      BigInteger.prototype.lesserOrEquals = function(v) {
        return this.compare(v) <= 0;
      };
      NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
      BigInteger.prototype.isEven = function() {
        return (this.value[0] & 1) === 0;
      };
      SmallInteger.prototype.isEven = function() {
        return (this.value & 1) === 0;
      };
      NativeBigInt.prototype.isEven = function() {
        return (this.value & BigInt(1)) === BigInt(0);
      };
      BigInteger.prototype.isOdd = function() {
        return (this.value[0] & 1) === 1;
      };
      SmallInteger.prototype.isOdd = function() {
        return (this.value & 1) === 1;
      };
      NativeBigInt.prototype.isOdd = function() {
        return (this.value & BigInt(1)) === BigInt(1);
      };
      BigInteger.prototype.isPositive = function() {
        return !this.sign;
      };
      SmallInteger.prototype.isPositive = function() {
        return this.value > 0;
      };
      NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
      BigInteger.prototype.isNegative = function() {
        return this.sign;
      };
      SmallInteger.prototype.isNegative = function() {
        return this.value < 0;
      };
      NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
      BigInteger.prototype.isUnit = function() {
        return false;
      };
      SmallInteger.prototype.isUnit = function() {
        return Math.abs(this.value) === 1;
      };
      NativeBigInt.prototype.isUnit = function() {
        return this.abs().value === BigInt(1);
      };
      BigInteger.prototype.isZero = function() {
        return false;
      };
      SmallInteger.prototype.isZero = function() {
        return this.value === 0;
      };
      NativeBigInt.prototype.isZero = function() {
        return this.value === BigInt(0);
      };
      BigInteger.prototype.isDivisibleBy = function(v) {
        var n = parseValue(v);
        if (n.isZero()) return false;
        if (n.isUnit()) return true;
        if (n.compareAbs(2) === 0) return this.isEven();
        return this.mod(n).isZero();
      };
      NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
      function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(49)) return true;
      }
      function millerRabinTest(n, a) {
        var nPrev = n.prev(), b = nPrev, r2 = 0, d, t, i2, x;
        while (b.isEven()) b = b.divide(2), r2++;
        next: for (i2 = 0; i2 < a.length; i2++) {
          if (n.lesser(a[i2])) continue;
          x = bigInt(a[i2]).modPow(b, n);
          if (x.isUnit() || x.equals(nPrev)) continue;
          for (d = r2 - 1; d != 0; d--) {
            x = x.square().mod(n);
            if (x.isUnit()) return false;
            if (x.equals(nPrev)) continue next;
          }
          return false;
        }
        return true;
      }
      BigInteger.prototype.isPrime = function(strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined2) return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64)
          return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
        for (var a = [], i2 = 0; i2 < t; i2++) {
          a.push(bigInt(i2 + 2));
        }
        return millerRabinTest(n, a);
      };
      NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
      BigInteger.prototype.isProbablePrime = function(iterations, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined2) return isPrime;
        var n = this.abs();
        var t = iterations === undefined2 ? 5 : iterations;
        for (var a = [], i2 = 0; i2 < t; i2++) {
          a.push(bigInt.randBetween(2, n.minus(2), rng));
        }
        return millerRabinTest(n, a);
      };
      NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
      BigInteger.prototype.modInv = function(n) {
        var t = bigInt.zero, newT = bigInt.one, r2 = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
          q = r2.divide(newR);
          lastT = t;
          lastR = r2;
          t = newT;
          r2 = newR;
          newT = lastT.subtract(q.multiply(newT));
          newR = lastR.subtract(q.multiply(newR));
        }
        if (!r2.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
          t = t.add(n);
        }
        if (this.isNegative()) {
          return t.negate();
        }
        return t;
      };
      NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
      BigInteger.prototype.next = function() {
        var value = this.value;
        if (this.sign) {
          return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
      };
      SmallInteger.prototype.next = function() {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
      };
      NativeBigInt.prototype.next = function() {
        return new NativeBigInt(this.value + BigInt(1));
      };
      BigInteger.prototype.prev = function() {
        var value = this.value;
        if (this.sign) {
          return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
      };
      SmallInteger.prototype.prev = function() {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
      };
      NativeBigInt.prototype.prev = function() {
        return new NativeBigInt(this.value - BigInt(1));
      };
      var powersOfTwo = [1];
      while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
      var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
      function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
      }
      BigInteger.prototype.shiftLeft = function(v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftRight(-n);
        var result2 = this;
        if (result2.isZero()) return result2;
        while (n >= powers2Length) {
          result2 = result2.multiply(highestPower2);
          n -= powers2Length - 1;
        }
        return result2.multiply(powersOfTwo[n]);
      };
      NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
      BigInteger.prototype.shiftRight = function(v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftLeft(-n);
        var result2 = this;
        while (n >= powers2Length) {
          if (result2.isZero() || result2.isNegative() && result2.isUnit()) return result2;
          remQuo = divModAny(result2, highestPower2);
          result2 = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
          n -= powers2Length - 1;
        }
        remQuo = divModAny(result2, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
      };
      NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
      function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result2 = [];
        while (!xRem.isZero() || !yRem.isZero()) {
          xDivMod = divModAny(xRem, highestPower2);
          xDigit = xDivMod[1].toJSNumber();
          if (xSign) {
            xDigit = highestPower2 - 1 - xDigit;
          }
          yDivMod = divModAny(yRem, highestPower2);
          yDigit = yDivMod[1].toJSNumber();
          if (ySign) {
            yDigit = highestPower2 - 1 - yDigit;
          }
          xRem = xDivMod[0];
          yRem = yDivMod[0];
          result2.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i2 = result2.length - 1; i2 >= 0; i2 -= 1) {
          sum = sum.multiply(highestPower2).add(bigInt(result2[i2]));
        }
        return sum;
      }
      BigInteger.prototype.not = function() {
        return this.negate().prev();
      };
      NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
      BigInteger.prototype.and = function(n) {
        return bitwise(this, n, function(a, b) {
          return a & b;
        });
      };
      NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
      BigInteger.prototype.or = function(n) {
        return bitwise(this, n, function(a, b) {
          return a | b;
        });
      };
      NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
      BigInteger.prototype.xor = function(n) {
        return bitwise(this, n, function(a, b) {
          return a ^ b;
        });
      };
      NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
      var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
      function roughLOB(n) {
        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
      }
      function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
          var tmp = integerLogarithm(value, base.square(base));
          var p = tmp.p;
          var e = tmp.e;
          var t = p.multiply(base);
          return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };
        }
        return { p: bigInt(1), e: 0 };
      }
      BigInteger.prototype.bitLength = function() {
        var n = this;
        if (n.compareTo(bigInt(0)) < 0) {
          n = n.negate().subtract(bigInt(1));
        }
        if (n.compareTo(bigInt(0)) === 0) {
          return bigInt(0);
        }
        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
      };
      NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
      function max2(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
      }
      function min2(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
      }
      function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
          d = min2(roughLOB(a), roughLOB(b));
          a = a.divide(d);
          b = b.divide(d);
          c = c.multiply(d);
        }
        while (a.isEven()) {
          a = a.divide(roughLOB(a));
        }
        do {
          while (b.isEven()) {
            b = b.divide(roughLOB(b));
          }
          if (a.greater(b)) {
            t = b;
            b = a;
            a = t;
          }
          b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
      }
      function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
      }
      function randBetween(a, b, rng) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng || Math.random;
        var low = min2(a, b), high = max2(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result2 = [], restricted = true;
        for (var i2 = 0; i2 < digits.length; i2++) {
          var top = restricted ? digits[i2] + (i2 + 1 < digits.length ? digits[i2 + 1] / BASE : 0) : BASE;
          var digit = truncate(usedRNG() * top);
          result2.push(digit);
          if (digit < digits[i2]) restricted = false;
        }
        return low.add(Integer.fromArray(result2, BASE, false));
      }
      var parseBase = function(text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
          text = text.toLowerCase();
          alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i2;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i2 = 0; i2 < alphabet.length; i2++) {
          alphabetValues[alphabet[i2]] = i2;
        }
        for (i2 = 0; i2 < length; i2++) {
          var c = text[i2];
          if (c === "-") continue;
          if (c in alphabetValues) {
            if (alphabetValues[c] >= absBase) {
              if (c === "1" && absBase === 1) continue;
              throw new Error(c + " is not a valid digit in base " + base + ".");
            }
          }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative2 = text[0] === "-";
        for (i2 = isNegative2 ? 1 : 0; i2 < text.length; i2++) {
          var c = text[i2];
          if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
          else if (c === "<") {
            var start = i2;
            do {
              i2++;
            } while (text[i2] !== ">" && i2 < text.length);
            digits.push(parseValue(text.slice(start + 1, i2)));
          } else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative2);
      };
      function parseBaseFromArray(digits, base, isNegative2) {
        var val = Integer[0], pow = Integer[1], i2;
        for (i2 = digits.length - 1; i2 >= 0; i2--) {
          val = val.add(digits[i2].times(pow));
          pow = pow.times(base);
        }
        return isNegative2 ? val.negate() : val;
      }
      function stringify2(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
          return alphabet[digit];
        }
        return "<" + digit + ">";
      }
      function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
          if (n.isZero()) return { value: [0], isNegative: false };
          throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
          if (n.isZero()) return { value: [0], isNegative: false };
          if (n.isNegative())
            return {
              value: [].concat.apply(
                [],
                Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
              ),
              isNegative: false
            };
          var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
          arr.unshift([1]);
          return {
            value: [].concat.apply([], arr),
            isNegative: false
          };
        }
        var neg = false;
        if (n.isNegative() && base.isPositive()) {
          neg = true;
          n = n.abs();
        }
        if (base.isUnit()) {
          if (n.isZero()) return { value: [0], isNegative: false };
          return {
            value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
            isNegative: neg
          };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
          divmod = left.divmod(base);
          left = divmod.quotient;
          var digit = divmod.remainder;
          if (digit.isNegative()) {
            digit = base.minus(digit).abs();
            left = left.next();
          }
          out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
      }
      function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
          return stringify2(x, alphabet);
        }).join("");
      }
      BigInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      SmallInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      NativeBigInt.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      BigInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined2) radix = 10;
        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);
        var v = this.value, l = v.length, str = String(v[--l]), zeros2 = "0000000", digit;
        while (--l >= 0) {
          digit = String(v[l]);
          str += zeros2.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
      };
      SmallInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined2) radix = 10;
        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);
        return String(this.value);
      };
      NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
      NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
        return this.toString();
      };
      BigInteger.prototype.valueOf = function() {
        return parseInt(this.toString(), 10);
      };
      BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
      SmallInteger.prototype.valueOf = function() {
        return this.value;
      };
      SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
      NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
        return parseInt(this.toString(), 10);
      };
      function parseStringValue(v) {
        if (isPrecise(+v)) {
          var x = +v;
          if (x === truncate(x))
            return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
          throw new Error("Invalid integer: " + v);
        }
        var sign = v[0] === "-";
        if (sign) v = v.slice(1);
        var split2 = v.split(/e/i);
        if (split2.length > 2) throw new Error("Invalid integer: " + split2.join("e"));
        if (split2.length === 2) {
          var exp = split2[1];
          if (exp[0] === "+") exp = exp.slice(1);
          exp = +exp;
          if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
          var text = split2[0];
          var decimalPlace = text.indexOf(".");
          if (decimalPlace >= 0) {
            exp -= text.length - decimalPlace - 1;
            text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
          }
          if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
          text += new Array(exp + 1).join("0");
          v = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid) throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }
        var r2 = [], max3 = v.length, l = LOG_BASE, min3 = max3 - l;
        while (max3 > 0) {
          r2.push(+v.slice(min3, max3));
          min3 -= l;
          if (min3 < 0) min3 = 0;
          max3 -= l;
        }
        trim(r2);
        return new BigInteger(r2, sign);
      }
      function parseNumberValue(v) {
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
          if (v !== truncate(v)) throw new Error(v + " is not an integer.");
          return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
      }
      function parseValue(v) {
        if (typeof v === "number") {
          return parseNumberValue(v);
        }
        if (typeof v === "string") {
          return parseStringValue(v);
        }
        if (typeof v === "bigint") {
          return new NativeBigInt(v);
        }
        return v;
      }
      for (var i = 0; i < 1e3; i++) {
        Integer[i] = parseValue(i);
        if (i > 0) Integer[-i] = parseValue(-i);
      }
      Integer.one = Integer[1];
      Integer.zero = Integer[0];
      Integer.minusOne = Integer[-1];
      Integer.max = max2;
      Integer.min = min2;
      Integer.gcd = gcd;
      Integer.lcm = lcm;
      Integer.isInstance = function(x) {
        return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
      };
      Integer.randBetween = randBetween;
      Integer.fromArray = function(digits, base, isNegative2) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative2);
      };
      return Integer;
    }();
    if (typeof module2 !== "undefined" && module2.hasOwnProperty("exports")) {
      module2.exports = bigInt;
    }
    if (typeof define === "function" && define.amd) {
      define(function() {
        return bigInt;
      });
    }
  }
});

// node_modules/@keplr-wallet/unit/build/etc.js
var require_etc = __commonJS({
  "node_modules/@keplr-wallet/unit/build/etc.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exponentDecStringToDecString = exports2.isExponentDecString = exports2.isValidDecimalString = exports2.isValidIntegerString = void 0;
    var regexIntString = /^-?\d+$/;
    var regexDecString = /^-?\d+.?\d*$/;
    var regexExponentDecString = /^(-?)([\d.]+)e([-+])([\d]+)$/;
    function isValidIntegerString(str) {
      return regexIntString.test(str);
    }
    exports2.isValidIntegerString = isValidIntegerString;
    function isValidDecimalString(str) {
      return regexDecString.test(str);
    }
    exports2.isValidDecimalString = isValidDecimalString;
    function isExponentDecString(str) {
      return regexExponentDecString.test(str);
    }
    exports2.isExponentDecString = isExponentDecString;
    function makeZerosStr(len) {
      let r2 = "";
      for (let i = 0; i < len; i++) {
        r2 += "0";
      }
      return r2;
    }
    function removeHeadZeros(str) {
      while (str.length > 0 && str[0] === "0") {
        str = str.slice(1);
      }
      if (str.length === 0 || str[0] === ".") {
        return "0" + str;
      }
      return str;
    }
    function exponentDecStringToDecString(str) {
      const split2 = str.split(regexExponentDecString);
      if (split2.length !== 6) {
        return str;
      }
      const isNeg = split2[1] === "-";
      let numStr = split2[2];
      const numStrFractionIndex = numStr.indexOf(".");
      const exponentStr = split2[4];
      let exponent = parseInt(exponentStr) * (split2[3] === "-" ? -1 : 1);
      if (numStrFractionIndex >= 0) {
        const fractionLen = numStr.length - numStrFractionIndex - 1;
        exponent = exponent - fractionLen;
        numStr = removeHeadZeros(numStr.replace(".", ""));
      }
      const prefix = isNeg ? "-" : "";
      if (exponent < 0) {
        if (numStr.length > -exponent) {
          const fractionPosition = numStr.length + exponent;
          return prefix + (numStr.slice(0, fractionPosition) + "." + numStr.slice(fractionPosition));
        }
        return prefix + "0." + makeZerosStr(-(numStr.length + exponent)) + numStr;
      } else {
        return prefix + numStr + makeZerosStr(exponent);
      }
    }
    exports2.exponentDecStringToDecString = exponentDecStringToDecString;
  }
});

// node_modules/@keplr-wallet/unit/build/int.js
var require_int = __commonJS({
  "node_modules/@keplr-wallet/unit/build/int.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Uint = exports2.Int = void 0;
    var big_integer_1 = __importDefault(require_BigInteger());
    var etc_1 = require_etc();
    var Int = class _Int {
      /**
       * @param int - Parse a number | bigInteger | string into a bigInt.
       */
      constructor(int) {
        if (typeof int === "number") {
          int = int.toString();
        }
        if (typeof int === "string") {
          if (!(0, etc_1.isValidIntegerString)(int)) {
            if ((0, etc_1.isExponentDecString)(int)) {
              int = (0, etc_1.exponentDecStringToDecString)(int);
            } else {
              throw new Error(`invalid integer: ${int}`);
            }
          }
          this.int = (0, big_integer_1.default)(int);
        } else if (typeof int === "bigint") {
          this.int = (0, big_integer_1.default)(int);
        } else {
          this.int = (0, big_integer_1.default)(int);
        }
        this.checkBitLen();
      }
      checkBitLen() {
        if (this.int.abs().gt(_Int.maxInt)) {
          throw new Error(`Integer out of range ${this.int.toString()}`);
        }
      }
      toString() {
        return this.int.toString(10);
      }
      isNegative() {
        return this.int.isNegative();
      }
      isPositive() {
        return this.int.isPositive();
      }
      isZero() {
        return this.int.eq((0, big_integer_1.default)(0));
      }
      equals(i) {
        return this.int.equals(i.int);
      }
      gt(i) {
        return this.int.gt(i.int);
      }
      gte(i) {
        return this.int.greaterOrEquals(i.int);
      }
      lt(i) {
        return this.int.lt(i.int);
      }
      lte(i) {
        return this.int.lesserOrEquals(i.int);
      }
      abs() {
        return new _Int(this.int.abs());
      }
      absUInt() {
        return new Uint(this.int.abs());
      }
      add(i) {
        return new _Int(this.int.add(i.int));
      }
      sub(i) {
        return new _Int(this.int.subtract(i.int));
      }
      mul(i) {
        return new _Int(this.int.multiply(i.int));
      }
      div(i) {
        return new _Int(this.int.divide(i.int));
      }
      mod(i) {
        return new _Int(this.int.mod(i.int));
      }
      neg() {
        return new _Int(this.int.negate());
      }
      pow(i) {
        return new _Int(this.int.pow(i.toBigNumber()));
      }
      toBigNumber() {
        return this.int;
      }
    };
    Int.maxInt = (0, big_integer_1.default)("115792089237316195423570985008687907853269984665640564039457584007913129639935");
    exports2.Int = Int;
    var Uint = class _Uint {
      /**
       * @param uint - Parse a number | bigInteger | string into a bigUint.
       */
      constructor(uint) {
        if (typeof uint === "number") {
          uint = uint.toString();
        }
        if (typeof uint === "string") {
          if (!(0, etc_1.isValidIntegerString)(uint)) {
            if ((0, etc_1.isExponentDecString)(uint)) {
              uint = (0, etc_1.exponentDecStringToDecString)(uint);
            } else {
              throw new Error(`invalid integer: ${uint}`);
            }
          }
          this.uint = (0, big_integer_1.default)(uint);
        } else if (typeof uint === "bigint") {
          this.uint = (0, big_integer_1.default)(uint);
        } else {
          this.uint = (0, big_integer_1.default)(uint);
        }
        if (this.uint.isNegative()) {
          throw new TypeError("Uint should not be negative");
        }
        this.checkBitLen();
      }
      checkBitLen() {
        if (this.uint.abs().bitLength().gt(256)) {
          throw new Error(`Integer out of range ${this.uint.toString()}`);
        }
      }
      toString() {
        return this.uint.toString(10);
      }
      isZero() {
        return this.uint.eq((0, big_integer_1.default)(0));
      }
      equals(i) {
        return this.uint.equals(i.uint);
      }
      gt(i) {
        return this.uint.gt(i.uint);
      }
      gte(i) {
        return this.uint.greaterOrEquals(i.uint);
      }
      lt(i) {
        return this.uint.lt(i.uint);
      }
      lte(i) {
        return this.uint.lesserOrEquals(i.uint);
      }
      add(i) {
        return new _Uint(this.uint.add(i.uint));
      }
      sub(i) {
        return new _Uint(this.uint.subtract(i.uint));
      }
      mul(i) {
        return new _Uint(this.uint.multiply(i.uint));
      }
      div(i) {
        return new _Uint(this.uint.divide(i.uint));
      }
      mod(i) {
        return new _Uint(this.uint.mod(i.uint));
      }
      pow(i) {
        return new _Uint(this.uint.pow(i.toBigNumber()));
      }
      toBigNumber() {
        return this.uint;
      }
    };
    exports2.Uint = Uint;
  }
});

// node_modules/@keplr-wallet/unit/build/utils.js
var require_utils8 = __commonJS({
  "node_modules/@keplr-wallet/unit/build/utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.integerStringToUSLocaleString = void 0;
    function integerStringToUSLocaleString(numberStr) {
      if (numberStr.indexOf(".") >= 0) {
        throw new Error(`${numberStr} is not integer`);
      }
      if (typeof BigInt !== "undefined") {
        return BigInt(numberStr).toLocaleString("en-US");
      }
      const integer = numberStr;
      const chunks = [];
      for (let i = integer.length; i > 0; i -= 3) {
        chunks.push(integer.slice(Math.max(0, i - 3), i));
      }
      return chunks.reverse().join(",");
    }
    exports2.integerStringToUSLocaleString = integerStringToUSLocaleString;
  }
});

// node_modules/@keplr-wallet/unit/build/decimal.js
var require_decimal = __commonJS({
  "node_modules/@keplr-wallet/unit/build/decimal.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Dec = void 0;
    var big_integer_1 = __importDefault(require_BigInteger());
    var int_1 = require_int();
    var etc_1 = require_etc();
    var utils_1 = require_utils8();
    var Dec = class _Dec {
      static calcPrecisionMultiplier(prec) {
        if (prec < 0) {
          throw new Error("Invalid prec");
        }
        if (prec > _Dec.precision) {
          throw new Error("Too much precision");
        }
        const key = prec.toString();
        const cached = _Dec.precisionMultipliers.get(key);
        if (cached) {
          return cached;
        }
        const zerosToAdd = _Dec.precision - prec;
        const multiplier = (0, big_integer_1.default)(10).pow(zerosToAdd);
        _Dec.precisionMultipliers.set(key, multiplier);
        return multiplier;
      }
      static reduceDecimalsFromString(str) {
        const decimalPointIndex = str.indexOf(".");
        if (decimalPointIndex < 0) {
          return {
            res: str,
            isDownToZero: false
          };
        }
        const exceededDecimals = str.length - 1 - decimalPointIndex - _Dec.precision;
        if (exceededDecimals <= 0) {
          return {
            res: str,
            isDownToZero: false
          };
        }
        const res = str.slice(0, str.length - exceededDecimals);
        return {
          res,
          isDownToZero: /^[0.]*$/.test(res)
        };
      }
      /**
       * Create a new Dec from integer with decimal place at prec
       * @param int - Parse a number | bigInteger | string into a Dec.
       * If int is string and contains dot(.), prec is ignored and automatically calculated.
       * @param prec - Precision
       */
      constructor(int, prec = 0) {
        if (typeof int === "number") {
          int = int.toString();
        }
        if (typeof int === "string") {
          if (int.length === 0) {
            throw new Error("empty string");
          }
          if (!(0, etc_1.isValidDecimalString)(int)) {
            if ((0, etc_1.isExponentDecString)(int)) {
              int = (0, etc_1.exponentDecStringToDecString)(int);
            } else {
              throw new Error(`invalid decimal: ${int}`);
            }
          }
          const reduced = _Dec.reduceDecimalsFromString(int);
          if (reduced.isDownToZero) {
            console.log(`WARNING: Got ${int}. Dec can only handle up to 18 decimals. However, since the decimal point of the input exceeds 18 digits, the remainder is discarded. As a result, input becomes 0.`);
          }
          int = reduced.res;
          if (int.indexOf(".") >= 0) {
            prec = int.length - int.indexOf(".") - 1;
            int = int.replace(".", "");
          }
          this.int = (0, big_integer_1.default)(int);
        } else if (int instanceof int_1.Int) {
          this.int = (0, big_integer_1.default)(int.toString());
        } else if (int instanceof int_1.Uint) {
          this.int = (0, big_integer_1.default)(int.toString());
        } else if (typeof int === "bigint") {
          this.int = (0, big_integer_1.default)(int);
        } else {
          this.int = (0, big_integer_1.default)(int);
        }
        this.int = this.int.multiply(_Dec.calcPrecisionMultiplier(prec));
        this.checkBitLen();
      }
      checkBitLen() {
        if (this.int.abs().gt(_Dec.maxDec)) {
          throw new Error(`Integer out of range ${this.int.toString()}`);
        }
      }
      isZero() {
        return this.int.eq((0, big_integer_1.default)(0));
      }
      isNegative() {
        return this.int.isNegative();
      }
      isPositive() {
        return this.int.isPositive();
      }
      equals(d2) {
        return this.int.eq(d2.int);
      }
      /**
       * Alias for the greater method.
       */
      gt(d2) {
        return this.int.gt(d2.int);
      }
      /**
       * Alias for the greaterOrEquals method.
       */
      gte(d2) {
        return this.int.geq(d2.int);
      }
      /**
       * Alias for the lesser method.
       */
      lt(d2) {
        return this.int.lt(d2.int);
      }
      /**
       * Alias for the lesserOrEquals method.
       */
      lte(d2) {
        return this.int.leq(d2.int);
      }
      /**
       * reverse the decimal sign.
       */
      neg() {
        return new _Dec(this.int.negate(), _Dec.precision);
      }
      /**
       * Returns the absolute value of a decimals.
       */
      abs() {
        return new _Dec(this.int.abs(), _Dec.precision);
      }
      add(d2) {
        return new _Dec(this.int.add(d2.int), _Dec.precision);
      }
      sub(d2) {
        return new _Dec(this.int.subtract(d2.int), _Dec.precision);
      }
      pow(n) {
        if (n.isZero()) {
          return new _Dec(1);
        }
        if (n.isNegative()) {
          return new _Dec(1).quo(this.pow(n.abs()));
        }
        let base = new _Dec(this.int, _Dec.precision);
        let tmp = new _Dec(1);
        for (let i = n; i.gt(new int_1.Int(1)); i = i.div(new int_1.Int(2))) {
          if (!i.mod(new int_1.Int(2)).isZero()) {
            tmp = tmp.mul(base);
          }
          base = base.mul(base);
        }
        return base.mul(tmp);
      }
      approxSqrt() {
        return this.approxRoot(2);
      }
      approxRoot(root2, maxIters = 300) {
        if (this.isNegative()) {
          return this.neg().approxRoot(root2).neg();
        }
        if (root2 === 1 || this.isZero() || this.equals(_Dec.one)) {
          return this;
        }
        if (root2 === 0) {
          return _Dec.one;
        }
        let [guess, delta] = [_Dec.one, _Dec.one];
        for (let i = 0; delta.abs().gt(_Dec.smallestDec) && i < maxIters; i++) {
          let prev = guess.pow(new int_1.Int(root2 - 1));
          if (prev.isZero()) {
            prev = _Dec.smallestDec;
          }
          delta = this.quo(prev);
          delta = delta.sub(guess);
          delta = delta.quoTruncate(new _Dec(root2));
          guess = guess.add(delta);
        }
        return guess;
      }
      mul(d2) {
        return new _Dec(this.mulRaw(d2).chopPrecisionAndRound(1), _Dec.precision);
      }
      mulTruncate(d2) {
        return new _Dec(this.mulRaw(d2).chopPrecisionAndTruncate(), _Dec.precision);
      }
      mulRoundUp(d2) {
        return new _Dec(this.mulRaw(d2).chopPrecisionAndRoundUp(), _Dec.precision);
      }
      mulRaw(d2) {
        return new _Dec(this.int.multiply(d2.int), _Dec.precision);
      }
      quo(d2) {
        return new _Dec(this.quoRaw(d2).chopPrecisionAndRound(1), _Dec.precision);
      }
      quoTruncate(d2) {
        return new _Dec(this.quoRaw(d2).chopPrecisionAndTruncate(), _Dec.precision);
      }
      quoRoundUp(d2) {
        return new _Dec(this.quoRaw(d2).chopPrecisionAndRoundUp(), _Dec.precision);
      }
      quoRaw(d2) {
        const precision = _Dec.calcPrecisionMultiplier(0);
        const mul = this.int.multiply(precision).multiply(precision);
        return new _Dec(mul.divide(d2.int), _Dec.precision);
      }
      isInteger() {
        const precision = _Dec.calcPrecisionMultiplier(0);
        return this.int.remainder(precision).equals((0, big_integer_1.default)(0));
      }
      /**
       * Remove a Precision amount of rightmost digits and perform bankers rounding
       * on the remainder (gaussian rounding) on the digits which have been removed.
       */
      chopPrecisionAndRound(decimalPlace) {
        if (this.isNegative()) {
          const absoulteDec = this.abs();
          const choped = absoulteDec.chopPrecisionAndRound(decimalPlace);
          return choped.negate();
        }
        const precision = _Dec.calcPrecisionMultiplier(decimalPlace - 1);
        const fivePrecision = precision.divide((0, big_integer_1.default)(2));
        const { quotient, remainder } = this.int.divmod(precision);
        if (remainder.equals((0, big_integer_1.default)(0))) {
          return quotient;
        }
        if (remainder.lt(fivePrecision)) {
          return quotient;
        } else if (remainder.gt(fivePrecision)) {
          return quotient.add((0, big_integer_1.default)(1));
        } else {
          if (quotient.divide((0, big_integer_1.default)(2)).equals((0, big_integer_1.default)(0))) {
            return quotient;
          } else {
            return quotient.add((0, big_integer_1.default)(1));
          }
        }
      }
      chopPrecisionAndRoundUp() {
        if (this.isNegative()) {
          const absoulteDec = this.abs();
          const choped = absoulteDec.chopPrecisionAndTruncate();
          return choped.negate();
        }
        const precision = _Dec.calcPrecisionMultiplier(0);
        const { quotient, remainder } = this.int.divmod(precision);
        if (remainder.equals((0, big_integer_1.default)(0))) {
          return quotient;
        }
        return quotient.add((0, big_integer_1.default)(1));
      }
      /**
       * Similar to chopPrecisionAndRound, but always rounds down
       */
      chopPrecisionAndTruncate() {
        const precision = _Dec.calcPrecisionMultiplier(0);
        return this.int.divide(precision);
      }
      toString(prec = _Dec.precision, locale = false) {
        const precision = _Dec.calcPrecisionMultiplier(0);
        const int = this.int.abs();
        const { quotient: integer, remainder: fraction } = int.divmod(precision);
        let fractionStr = fraction.toString(10);
        for (let i = 0, l = fractionStr.length; i < _Dec.precision - l; i++) {
          fractionStr = "0" + fractionStr;
        }
        fractionStr = fractionStr.substring(0, prec);
        const isNegative2 = this.isNegative() && !(integer.eq((0, big_integer_1.default)(0)) && fractionStr.length === 0);
        const integerStr = locale ? (0, utils_1.integerStringToUSLocaleString)(integer.toString()) : integer.toString();
        return `${isNegative2 ? "-" : ""}${integerStr}${fractionStr.length > 0 ? "." + fractionStr : ""}`;
      }
      round() {
        return new int_1.Int(this.chopPrecisionAndRound(1));
      }
      roundTo(decimalPlace) {
        return new _Dec(this.chopPrecisionAndRound(decimalPlace), decimalPlace - 1);
      }
      roundUp() {
        return new int_1.Int(this.chopPrecisionAndRoundUp());
      }
      truncate() {
        return new int_1.Int(this.chopPrecisionAndTruncate());
      }
      roundDec() {
        return new _Dec(this.chopPrecisionAndRound(1), 0);
      }
      roundUpDec() {
        return new _Dec(this.chopPrecisionAndRoundUp(), 0);
      }
      truncateDec() {
        return new _Dec(this.chopPrecisionAndTruncate(), 0);
      }
    };
    Dec.precision = 18;
    Dec.decimalPrecisionBits = 60;
    Dec.maxDec = (0, big_integer_1.default)("133499189745056880149688856635597007162669032647290798121690100488888732861290034376435130433535");
    Dec.precisionMultipliers = /* @__PURE__ */ new Map();
    Dec.zero = new Dec(0);
    Dec.smallestDec = new Dec("1", Dec.precision);
    Dec.one = new Dec(1);
    exports2.Dec = Dec;
    int_1.Int.prototype.toDec = function() {
      return new Dec(this);
    };
    int_1.Uint.prototype.toDec = function() {
      return new Dec(this);
    };
  }
});

// node_modules/@keplr-wallet/unit/build/dec-utils.js
var require_dec_utils = __commonJS({
  "node_modules/@keplr-wallet/unit/build/dec-utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DecUtils = void 0;
    var decimal_1 = require_decimal();
    var int_1 = require_int();
    var DecUtils = class _DecUtils {
      static trim(dec) {
        let decStr = typeof dec === "string" ? dec : dec.toString();
        if (decStr.indexOf(".") < 0) {
          return decStr;
        }
        for (let i = decStr.length - 1; i >= 0; i--) {
          if (decStr[i] === "0") {
            decStr = decStr.slice(0, i);
          } else {
            break;
          }
        }
        if (decStr.length > 0) {
          if (decStr[decStr.length - 1] === ".") {
            decStr = decStr.slice(0, decStr.length - 1);
          }
        }
        return decStr;
      }
      static getTenExponentN(n) {
        if (n < -decimal_1.Dec.precision) {
          throw new Error("Too little precision");
        }
        if (_DecUtils.tenExponentNs[n.toString()]) {
          return _DecUtils.tenExponentNs[n.toString()];
        }
        const dec = new decimal_1.Dec(10).pow(new int_1.Int(n));
        _DecUtils.tenExponentNs[n.toString()] = dec;
        return dec;
      }
      static getTenExponentNInPrecisionRange(n) {
        if (n > decimal_1.Dec.precision) {
          throw new Error("Too much precision");
        }
        return _DecUtils.getTenExponentN(n);
      }
      /**
       * @deprecated Use`getTenExponentNInPrecisionRange`
       */
      static getPrecisionDec(precision) {
        return _DecUtils.getTenExponentNInPrecisionRange(precision);
      }
    };
    DecUtils.tenExponentNs = {};
    exports2.DecUtils = DecUtils;
  }
});

// node_modules/@keplr-wallet/unit/build/coin.js
var require_coin = __commonJS({
  "node_modules/@keplr-wallet/unit/build/coin.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Coin = void 0;
    var int_1 = require_int();
    var Coin2 = class _Coin {
      static parse(str) {
        const re = new RegExp("([0-9]+)[ ]*([a-zA-Z]+)$");
        const execed = re.exec(str);
        if (!execed || execed.length !== 3) {
          throw new Error("Invalid coin str");
        }
        const denom = execed[2];
        const amount = execed[1];
        return new _Coin(denom, amount);
      }
      constructor(denom, amount) {
        this.denom = denom;
        this.amount = amount instanceof int_1.Int ? amount : new int_1.Int(amount);
      }
      toString() {
        return `${this.amount.toString()}${this.denom}`;
      }
    };
    exports2.Coin = Coin2;
  }
});

// node_modules/@keplr-wallet/unit/build/coin-utils.js
var require_coin_utils = __commonJS({
  "node_modules/@keplr-wallet/unit/build/coin-utils.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CoinUtils = void 0;
    var coin_1 = require_coin();
    var int_1 = require_int();
    var decimal_1 = require_decimal();
    var dec_utils_1 = require_dec_utils();
    var utils_1 = require_utils8();
    var CoinUtils = class _CoinUtils {
      static createCoinsFromPrimitives(coinPrimitives) {
        return coinPrimitives.map((primitive) => {
          return new coin_1.Coin(primitive.denom, primitive.amount);
        });
      }
      static amountOf(coins2, denom) {
        const coin = coins2.find((coin2) => {
          return coin2.denom === denom;
        });
        if (!coin) {
          return new int_1.Int(0);
        } else {
          return coin.amount;
        }
      }
      static exclude(coins2, demons) {
        return coins2.filter((coin) => {
          return demons.indexOf(coin.denom) === 0;
        });
      }
      static concat(...coins2) {
        if (coins2.length === 0) {
          return [];
        }
        const arr = coins2.slice();
        const reducer = (accumulator, coin) => {
          const find = accumulator.find((c) => c.denom === coin.denom);
          if (find) {
            const newCoin = new coin_1.Coin(find.denom, find.amount.add(coin.amount));
            accumulator.push(newCoin);
          } else {
            const newCoin = new coin_1.Coin(coin.denom, coin.amount);
            accumulator.push(newCoin);
          }
          return accumulator;
        };
        return arr.reduce(reducer, []);
      }
      static getCoinFromDecimals(currencies, decAmountStr, denom) {
        const currency = currencies.find((currency2) => {
          return currency2.coinDenom === denom;
        });
        if (!currency) {
          throw new Error("Invalid currency");
        }
        let precision = new decimal_1.Dec(1);
        for (let i = 0; i < currency.coinDecimals; i++) {
          precision = precision.mul(new decimal_1.Dec(10));
        }
        let decAmount = new decimal_1.Dec(decAmountStr);
        decAmount = decAmount.mul(precision);
        if (!new decimal_1.Dec(decAmount.truncate()).equals(decAmount)) {
          throw new Error("Can't divide anymore");
        }
        return new coin_1.Coin(currency.coinMinimalDenom, decAmount.truncate());
      }
      static parseDecAndDenomFromCoin(currencies, coin) {
        let currency = currencies.find((currency2) => {
          return currency2.coinMinimalDenom === coin.denom;
        });
        if (!currency) {
          currency = {
            coinDecimals: 0,
            coinDenom: coin.denom,
            coinMinimalDenom: coin.denom
          };
        }
        let precision = new decimal_1.Dec(1);
        for (let i = 0; i < currency.coinDecimals; i++) {
          precision = precision.mul(new decimal_1.Dec(10));
        }
        const decAmount = new decimal_1.Dec(coin.amount).quoTruncate(precision);
        return {
          amount: decAmount.toString(currency.coinDecimals),
          denom: currency.coinDenom
        };
      }
      static shrinkDecimals(dec, minDecimals, maxDecimals, locale = false) {
        if (dec.equals(new decimal_1.Dec(0))) {
          return "0";
        }
        const isNeg = dec.isNegative();
        const integer = dec.abs().truncate();
        const fraction = dec.abs().sub(new decimal_1.Dec(integer));
        const decimals = Math.max(maxDecimals - integer.toString().length + 1, minDecimals);
        const fractionStr = decimals === 0 ? "" : fraction.toString(decimals).replace("0.", "");
        const integerStr = locale ? _CoinUtils.integerStringToUSLocaleString(integer.toString()) : integer.toString();
        return (isNeg ? "-" : "") + integerStr + (fractionStr.length > 0 ? "." : "") + fractionStr;
      }
      static coinToTrimmedString(coin, currency, separator = " ") {
        const dec = new decimal_1.Dec(coin.amount).quoTruncate(dec_utils_1.DecUtils.getPrecisionDec(currency.coinDecimals));
        return `${dec_utils_1.DecUtils.trim(dec)}${separator}${currency.coinDenom}`;
      }
    };
    CoinUtils.integerStringToUSLocaleString = utils_1.integerStringToUSLocaleString;
    exports2.CoinUtils = CoinUtils;
  }
});

// node_modules/@keplr-wallet/unit/build/int-pretty.js
var require_int_pretty = __commonJS({
  "node_modules/@keplr-wallet/unit/build/int-pretty.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntPretty = void 0;
    var decimal_1 = require_decimal();
    var dec_utils_1 = require_dec_utils();
    var coin_utils_1 = require_coin_utils();
    var IntPretty = class _IntPretty {
      constructor(num2) {
        this.floatingDecimalPointRight = 0;
        this._options = {
          maxDecimals: 0,
          trim: false,
          shrink: false,
          ready: true,
          locale: true,
          inequalitySymbol: false,
          inequalitySymbolSeparator: " ",
          sign: false,
          roundTo: void 0
        };
        if (typeof num2 === "object" && "toDec" in num2) {
          num2 = num2.toDec();
        } else if (!(num2 instanceof decimal_1.Dec)) {
          num2 = new decimal_1.Dec(num2);
        }
        if (num2.isZero()) {
          this.dec = num2;
          return;
        }
        const decStr = num2.toString();
        const decimalIndex = decStr.indexOf(".");
        if (decimalIndex === -1) {
          this.dec = num2;
          this._options.maxDecimals = 0;
          return;
        }
        const decimalPart = decStr.slice(decimalIndex + 1);
        let trailingZeros = 0;
        for (let i = decimalPart.length - 1; i >= 0 && decimalPart[i] === "0"; i--) {
          trailingZeros++;
        }
        const decPrecision = decimalPart.length - trailingZeros;
        this.dec = num2;
        this._options.maxDecimals = decPrecision;
      }
      get options() {
        return this._options;
      }
      moveDecimalPointLeft(delta) {
        const pretty = this.clone();
        pretty.floatingDecimalPointRight += -delta;
        return pretty;
      }
      moveDecimalPointRight(delta) {
        const pretty = this.clone();
        pretty.floatingDecimalPointRight += delta;
        return pretty;
      }
      /**
       * @deprecated Use`moveDecimalPointLeft`
       */
      increasePrecision(delta) {
        return this.moveDecimalPointLeft(delta);
      }
      /**
       * @deprecated Use`moveDecimalPointRight`
       */
      decreasePrecision(delta) {
        return this.moveDecimalPointRight(delta);
      }
      maxDecimals(max2) {
        const pretty = this.clone();
        pretty._options.maxDecimals = max2;
        return pretty;
      }
      inequalitySymbol(bool) {
        const pretty = this.clone();
        pretty._options.inequalitySymbol = bool;
        return pretty;
      }
      inequalitySymbolSeparator(str) {
        const pretty = this.clone();
        pretty._options.inequalitySymbolSeparator = str;
        return pretty;
      }
      trim(bool) {
        const pretty = this.clone();
        pretty._options.trim = bool;
        return pretty;
      }
      shrink(bool) {
        const pretty = this.clone();
        pretty._options.shrink = bool;
        return pretty;
      }
      locale(locale) {
        const pretty = this.clone();
        pretty._options.locale = locale;
        return pretty;
      }
      sign(sign) {
        const pretty = this.clone();
        pretty._options.sign = sign;
        return pretty;
      }
      roundTo(roundTo) {
        const pretty = this.clone();
        pretty._options.roundTo = roundTo;
        return pretty;
      }
      /**
       * Ready indicates the actual value is ready to show the users.
       * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).
       * The method that returns prettied value may return `undefined` or `null` if the value is not ready.
       * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.
       * @param bool
       */
      ready(bool) {
        const pretty = this.clone();
        pretty._options.ready = bool;
        return pretty;
      }
      get isReady() {
        return this._options.ready;
      }
      add(target) {
        if (!(target instanceof decimal_1.Dec)) {
          target = target.toDec();
        }
        const pretty = new _IntPretty(this.toDec().add(target));
        pretty._options = Object.assign({}, this._options);
        return pretty;
      }
      sub(target) {
        if (!(target instanceof decimal_1.Dec)) {
          target = target.toDec();
        }
        const pretty = new _IntPretty(this.toDec().sub(target));
        pretty._options = Object.assign({}, this._options);
        return pretty;
      }
      mul(target) {
        if (!(target instanceof decimal_1.Dec)) {
          target = target.toDec();
        }
        const pretty = new _IntPretty(this.toDec().mul(target));
        pretty._options = Object.assign({}, this._options);
        return pretty;
      }
      quo(target) {
        if (!(target instanceof decimal_1.Dec)) {
          target = target.toDec();
        }
        const pretty = new _IntPretty(this.toDec().quo(target));
        pretty._options = Object.assign({}, this._options);
        return pretty;
      }
      toDec() {
        if (this.floatingDecimalPointRight === 0) {
          return this.dec;
        } else if (this.floatingDecimalPointRight > 0) {
          return this.dec.mulTruncate(dec_utils_1.DecUtils.getTenExponentN(this.floatingDecimalPointRight));
        } else {
          let i = -this.floatingDecimalPointRight;
          let dec = this.dec;
          while (i > 0) {
            if (i >= decimal_1.Dec.precision) {
              dec = dec.mulTruncate(dec_utils_1.DecUtils.getTenExponentN(-decimal_1.Dec.precision));
              i -= decimal_1.Dec.precision;
            } else {
              dec = dec.mulTruncate(dec_utils_1.DecUtils.getTenExponentN(-(i % decimal_1.Dec.precision)));
              break;
            }
          }
          return dec;
        }
      }
      toString() {
        return this.toStringWithSymbols("", "");
      }
      toStringWithSymbols(prefix, suffix) {
        let dec = this.toDec();
        if (this._options.roundTo != null && this._options.roundTo >= 1 && this._options.roundTo <= 19) {
          dec = dec.roundTo(this._options.roundTo);
        }
        if (this._options.inequalitySymbol && !dec.isZero() && dec.abs().lt(dec_utils_1.DecUtils.getTenExponentN(-this._options.maxDecimals))) {
          const isNeg2 = dec.isNegative();
          let sign = "";
          if (isNeg2) {
            sign = "-";
          } else if (this._options.sign && !dec.isZero()) {
            sign = "+";
          }
          return `${isNeg2 ? ">" : "<"}${this._options.inequalitySymbolSeparator}${sign}${prefix}${dec_utils_1.DecUtils.getTenExponentN(-this._options.maxDecimals).toString(this._options.maxDecimals, this._options.locale)}${suffix}`;
        }
        let result2;
        if (!this._options.shrink) {
          result2 = dec.toString(this._options.maxDecimals, this._options.locale);
        } else {
          result2 = coin_utils_1.CoinUtils.shrinkDecimals(dec, 0, this._options.maxDecimals, this._options.locale);
        }
        if (this._options.trim) {
          result2 = dec_utils_1.DecUtils.trim(result2);
        }
        const isNeg = result2.charAt(0) === "-";
        if (isNeg) {
          result2 = result2.slice(1);
        } else if (this._options.sign && !dec.isZero()) {
          result2 = `+${result2}`;
        }
        return `${isNeg ? "-" : ""}${prefix}${result2}${suffix}`;
      }
      clone() {
        return Object.setPrototypeOf({
          dec: this.dec,
          floatingDecimalPointRight: this.floatingDecimalPointRight,
          _options: Object.assign({}, this._options)
        }, _IntPretty.prototype);
      }
    };
    exports2.IntPretty = IntPretty;
  }
});

// node_modules/@keplr-wallet/unit/build/coin-pretty.js
var require_coin_pretty = __commonJS({
  "node_modules/@keplr-wallet/unit/build/coin-pretty.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CoinPretty = void 0;
    var int_pretty_1 = require_int_pretty();
    var decimal_1 = require_decimal();
    var dec_utils_1 = require_dec_utils();
    var CoinPretty = class _CoinPretty {
      constructor(_currency, amount) {
        this._currency = _currency;
        this._options = {
          separator: " ",
          upperCase: false,
          lowerCase: false,
          hideDenom: false,
          hideIBCMetadata: false
        };
        if (typeof amount === "object" && "toDec" in amount) {
          amount = amount.toDec();
        } else if (!(amount instanceof decimal_1.Dec)) {
          amount = new decimal_1.Dec(amount);
        }
        this.intPretty = new int_pretty_1.IntPretty(amount.quoTruncate(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(_currency.coinDecimals))).maxDecimals(_currency.coinDecimals);
      }
      get options() {
        return Object.assign(Object.assign({}, this._options), this.intPretty.options);
      }
      get denom() {
        return this.currency.coinDenom;
      }
      get currency() {
        return this._currency;
      }
      setCurrency(currency) {
        const pretty = this.clone();
        pretty.intPretty = this.intPretty.moveDecimalPointRight(this._currency.coinDecimals - currency.coinDecimals);
        pretty._currency = currency;
        return pretty;
      }
      separator(str) {
        const pretty = this.clone();
        pretty._options.separator = str;
        return pretty;
      }
      upperCase(bool) {
        const pretty = this.clone();
        pretty._options.upperCase = bool;
        pretty._options.lowerCase = !bool;
        return pretty;
      }
      lowerCase(bool) {
        const pretty = this.clone();
        pretty._options.lowerCase = bool;
        pretty._options.upperCase = !bool;
        return pretty;
      }
      hideDenom(bool) {
        const pretty = this.clone();
        pretty._options.hideDenom = bool;
        return pretty;
      }
      hideIBCMetadata(bool) {
        const pretty = this.clone();
        pretty._options.hideIBCMetadata = bool;
        return pretty;
      }
      moveDecimalPointLeft(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointLeft(delta);
        return pretty;
      }
      moveDecimalPointRight(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointRight(delta);
        return pretty;
      }
      /**
       * @deprecated Use`moveDecimalPointLeft`
       */
      increasePrecision(delta) {
        return this.moveDecimalPointLeft(delta);
      }
      /**
       * @deprecated Use`moveDecimalPointRight`
       */
      decreasePrecision(delta) {
        return this.moveDecimalPointRight(delta);
      }
      maxDecimals(max2) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.maxDecimals(max2);
        return pretty;
      }
      inequalitySymbol(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbol(bool);
        return pretty;
      }
      inequalitySymbolSeparator(str) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbolSeparator(str);
        return pretty;
      }
      trim(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.trim(bool);
        return pretty;
      }
      shrink(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.shrink(bool);
        return pretty;
      }
      locale(locale) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.locale(locale);
        return pretty;
      }
      roundTo(roundTo) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.roundTo(roundTo);
        return pretty;
      }
      /**
       * Ready indicates the actual value is ready to show the users.
       * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).
       * The method that returns prettied value may return `undefined` or `null` if the value is not ready.
       * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.
       * @param bool
       */
      ready(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.ready(bool);
        return pretty;
      }
      get isReady() {
        return this.intPretty.isReady;
      }
      add(target) {
        const isCoinPretty = target instanceof _CoinPretty;
        if (isCoinPretty) {
          if ("currency" in target && this.currency.coinMinimalDenom !== target.currency.coinMinimalDenom) {
            return this.clone();
          }
        }
        if ("toDec" in target) {
          target = target.toDec();
        }
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.add(isCoinPretty ? target : target.mul(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(-this._currency.coinDecimals)));
        return pretty;
      }
      sub(target) {
        const isCoinPretty = target instanceof _CoinPretty;
        if (isCoinPretty) {
          if ("currency" in target && this.currency.coinMinimalDenom !== target.currency.coinMinimalDenom) {
            return this.clone();
          }
        }
        if ("toDec" in target) {
          target = target.toDec();
        }
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.sub(isCoinPretty ? target : target.mul(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(-this._currency.coinDecimals)));
        return pretty;
      }
      mul(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.mul(target);
        return pretty;
      }
      quo(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.quo(target);
        return pretty;
      }
      toDec() {
        return this.intPretty.toDec();
      }
      toCoin() {
        const amount = this.toDec().mulTruncate(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(this.currency.coinDecimals)).truncate();
        return {
          denom: this.currency.coinMinimalDenom,
          amount: amount.toString()
        };
      }
      toString() {
        let denom = this.denom;
        if (this._options.hideIBCMetadata && "originCurrency" in this.currency && this.currency.originCurrency) {
          denom = this.currency.originCurrency.coinDenom;
        }
        if (this._options.upperCase) {
          denom = denom.toUpperCase();
        }
        if (this._options.lowerCase) {
          denom = denom.toLowerCase();
        }
        let separator = this._options.separator;
        if (this._options.hideDenom) {
          denom = "";
          separator = "";
        }
        return this.intPretty.toStringWithSymbols("", `${separator}${denom}`);
      }
      clone() {
        const pretty = new _CoinPretty(this._currency, 0);
        pretty._options = Object.assign({}, this._options);
        pretty.intPretty = this.intPretty.clone();
        return pretty;
      }
    };
    exports2.CoinPretty = CoinPretty;
  }
});

// node_modules/@keplr-wallet/unit/build/price-pretty.js
var require_price_pretty = __commonJS({
  "node_modules/@keplr-wallet/unit/build/price-pretty.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PricePretty = void 0;
    var int_pretty_1 = require_int_pretty();
    var dec_utils_1 = require_dec_utils();
    var PricePretty = class _PricePretty {
      constructor(_fiatCurrency, amount) {
        this._fiatCurrency = _fiatCurrency;
        this._options = {
          separator: "",
          upperCase: false,
          lowerCase: false,
          locale: "en-US"
        };
        this.intPretty = new int_pretty_1.IntPretty(amount).maxDecimals(_fiatCurrency.maxDecimals).shrink(true).trim(true).locale(false).inequalitySymbol(true);
        this._options.locale = _fiatCurrency.locale;
      }
      get options() {
        return Object.assign(Object.assign({}, this.intPretty.options), this._options);
      }
      get symbol() {
        return this._fiatCurrency.symbol;
      }
      get fiatCurrency() {
        return this._fiatCurrency;
      }
      separator(str) {
        const pretty = this.clone();
        pretty._options.separator = str;
        return pretty;
      }
      upperCase(bool) {
        const pretty = this.clone();
        pretty._options.upperCase = bool;
        pretty._options.lowerCase = !bool;
        return pretty;
      }
      lowerCase(bool) {
        const pretty = this.clone();
        pretty._options.lowerCase = bool;
        pretty._options.upperCase = !bool;
        return pretty;
      }
      moveDecimalPointLeft(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointLeft(delta);
        return pretty;
      }
      moveDecimalPointRight(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointRight(delta);
        return pretty;
      }
      /**
       * @deprecated Use`moveDecimalPointLeft`
       */
      increasePrecision(delta) {
        return this.moveDecimalPointLeft(delta);
      }
      /**
       * @deprecated Use`moveDecimalPointRight`
       */
      decreasePrecision(delta) {
        return this.moveDecimalPointRight(delta);
      }
      maxDecimals(max2) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.maxDecimals(max2);
        return pretty;
      }
      inequalitySymbol(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbol(bool);
        return pretty;
      }
      inequalitySymbolSeparator(str) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbolSeparator(str);
        return pretty;
      }
      trim(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.trim(bool);
        return pretty;
      }
      shrink(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.shrink(bool);
        return pretty;
      }
      locale(locale) {
        const pretty = this.clone();
        pretty._options.locale = locale;
        return pretty;
      }
      roundTo(roundTo) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.roundTo(roundTo);
        return pretty;
      }
      /**
       * Ready indicates the actual value is ready to show the users.
       * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).
       * The method that returns prettied value may return `undefined` or `null` if the value is not ready.
       * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.
       * @param bool
       */
      ready(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.ready(bool);
        return pretty;
      }
      get isReady() {
        return this.intPretty.isReady;
      }
      add(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.add(target);
        return pretty;
      }
      sub(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.sub(target);
        return pretty;
      }
      mul(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.mul(target);
        return pretty;
      }
      quo(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.quo(target);
        return pretty;
      }
      toDec() {
        return this.intPretty.toDec();
      }
      toString() {
        let symbol = this.symbol;
        if (this._options.upperCase) {
          symbol = symbol.toUpperCase();
        }
        if (this._options.lowerCase) {
          symbol = symbol.toLowerCase();
        }
        const dec = this.toDec();
        const options = this.options;
        if (options.inequalitySymbol && !dec.isZero() && dec.abs().lt(dec_utils_1.DecUtils.getTenExponentN(-options.maxDecimals))) {
          return this.intPretty.toStringWithSymbols(`${symbol}${this._options.separator}`, "");
        }
        let localeString = parseFloat(this.intPretty.toString()).toLocaleString(options.locale, {
          maximumFractionDigits: options.maxDecimals
        });
        const isNeg = localeString.charAt(0) === "-";
        if (isNeg) {
          localeString = localeString.slice(1);
        }
        return `${isNeg ? "-" : ""}${symbol}${this._options.separator}${localeString}`;
      }
      clone() {
        const pretty = new _PricePretty(this._fiatCurrency, 0);
        pretty._options = Object.assign({}, this._options);
        pretty.intPretty = this.intPretty.clone();
        return pretty;
      }
    };
    exports2.PricePretty = PricePretty;
  }
});

// node_modules/@keplr-wallet/unit/build/rate-pretty.js
var require_rate_pretty = __commonJS({
  "node_modules/@keplr-wallet/unit/build/rate-pretty.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RatePretty = void 0;
    var int_pretty_1 = require_int_pretty();
    var RatePretty = class _RatePretty {
      constructor(amount) {
        this._options = {
          separator: "",
          symbol: "%"
        };
        this.intPretty = new int_pretty_1.IntPretty(amount);
        this.intPretty = this.intPretty.maxDecimals(3).shrink(false).trim(true).locale(true).inequalitySymbol(true);
      }
      get options() {
        return Object.assign(Object.assign({}, this.intPretty.options), this._options);
      }
      separator(str) {
        const pretty = this.clone();
        pretty._options.separator = str;
        return pretty;
      }
      symbol(str) {
        const pretty = this.clone();
        pretty._options.symbol = str;
        return pretty;
      }
      moveDecimalPointLeft(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointLeft(delta);
        return pretty;
      }
      moveDecimalPointRight(delta) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.moveDecimalPointRight(delta);
        return pretty;
      }
      maxDecimals(max2) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.maxDecimals(max2);
        return pretty;
      }
      inequalitySymbol(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbol(bool);
        return pretty;
      }
      inequalitySymbolSeparator(str) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.inequalitySymbolSeparator(str);
        return pretty;
      }
      trim(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.trim(bool);
        return pretty;
      }
      shrink(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.shrink(bool);
        return pretty;
      }
      locale(locale) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.locale(locale);
        return pretty;
      }
      sign(sign) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.sign(sign);
        return pretty;
      }
      /**
       * Ready indicates the actual value is ready to show the users.
       * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).
       * The method that returns prettied value may return `undefined` or `null` if the value is not ready.
       * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.
       * @param bool
       */
      ready(bool) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.ready(bool);
        return pretty;
      }
      get isReady() {
        return this.intPretty.isReady;
      }
      add(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.add(target);
        return pretty;
      }
      sub(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.sub(target);
        return pretty;
      }
      mul(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.mul(target);
        return pretty;
      }
      quo(target) {
        const pretty = this.clone();
        pretty.intPretty = pretty.intPretty.quo(target);
        return pretty;
      }
      toDec() {
        return this.intPretty.toDec();
      }
      toString() {
        return this.intPretty.moveDecimalPointRight(2).toStringWithSymbols("", `${this._options.separator}${this._options.symbol}`);
      }
      clone() {
        const pretty = new _RatePretty(0);
        pretty._options = Object.assign({}, this._options);
        pretty.intPretty = this.intPretty.clone();
        return pretty;
      }
    };
    exports2.RatePretty = RatePretty;
  }
});

// node_modules/@keplr-wallet/unit/build/index.js
var require_build11 = __commonJS({
  "node_modules/@keplr-wallet/unit/build/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_int_pretty(), exports2);
    __exportStar(require_coin_pretty(), exports2);
    __exportStar(require_coin(), exports2);
    __exportStar(require_int(), exports2);
    __exportStar(require_decimal(), exports2);
    __exportStar(require_coin_utils(), exports2);
    __exportStar(require_dec_utils(), exports2);
    __exportStar(require_price_pretty(), exports2);
    __exportStar(require_rate_pretty(), exports2);
  }
});

// node_modules/@keplr-wallet/simple-fetch/build/error.js
var require_error = __commonJS({
  "node_modules/@keplr-wallet/simple-fetch/build/error.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSimpleFetchError = exports2.SimpleFetchError = void 0;
    var SimpleFetchError = class _SimpleFetchError extends Error {
      constructor(baseURL, url, response) {
        super(`Failed to get response from ${new URL(url, baseURL).toString()}`);
        this.baseURL = baseURL;
        this.url = url;
        this.response = response;
        Object.setPrototypeOf(this, _SimpleFetchError.prototype);
      }
    };
    exports2.SimpleFetchError = SimpleFetchError;
    function isSimpleFetchError(payload) {
      return payload instanceof SimpleFetchError;
    }
    exports2.isSimpleFetchError = isSimpleFetchError;
  }
});

// node_modules/@keplr-wallet/simple-fetch/build/fetch.js
var require_fetch = __commonJS({
  "node_modules/@keplr-wallet/simple-fetch/build/fetch.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest2 = exports2 && exports2.__rest || function(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.simpleFetch = exports2.makeURL = void 0;
    var error_1 = require_error();
    function makeURL(baseURL, url) {
      const baseURLInstance = new URL(baseURL);
      baseURL = removeLastSlashIfIs(baseURLInstance.origin);
      url = removeLastSlashIfIs(baseURLInstance.pathname) + "/" + removeFirstSlashIfIs(url);
      url = url + (() => {
        if (Array.from(baseURLInstance.searchParams.keys()).length > 0) {
          if (url.includes("?")) {
            return "&" + baseURLInstance.searchParams.toString();
          } else {
            return "?" + baseURLInstance.searchParams.toString();
          }
        }
        return "";
      })();
      return removeLastSlashIfIs(baseURL + "/" + removeFirstSlashIfIs(url));
    }
    exports2.makeURL = makeURL;
    function removeFirstSlashIfIs(str) {
      if (str.length > 0 && str[0] === "/") {
        return str.slice(1);
      }
      return str;
    }
    function removeLastSlashIfIs(str) {
      if (str.length > 0 && str[str.length - 1] === "/") {
        return str.slice(0, str.length - 1);
      }
      return str;
    }
    function simpleFetch(baseURL, url, options) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (typeof url !== "string") {
          if (url) {
            options = url;
          }
          url = "";
        }
        if (url === "/") {
          url = "";
        }
        const actualURL = makeURL(baseURL, url);
        const _a2 = options || {}, { headers: optionHeaders } = _a2, otherOptions = __rest2(_a2, ["headers"]);
        const fetched = yield fetch(actualURL, Object.assign({ headers: Object.assign({ accept: "application/json, text/plain, */*" }, optionHeaders) }, otherOptions));
        let data;
        if (fetched.status === 204) {
          data = void 0;
        } else {
          const contentType = fetched.headers.get("content-type") || "";
          if (contentType.startsWith("application/json")) {
            data = yield fetched.json();
          } else {
            const r2 = yield fetched.text();
            const trim = r2.trim();
            if (trim.startsWith("{") && trim.endsWith("}")) {
              data = JSON.parse(trim);
            } else {
              data = r2;
            }
          }
        }
        const res = {
          url: actualURL,
          data,
          headers: fetched.headers,
          status: fetched.status,
          statusText: fetched.statusText
        };
        const validateStatusFn = (options === null || options === void 0 ? void 0 : options.validateStatus) || defaultValidateStatusFn;
        if (!validateStatusFn(fetched.status)) {
          throw new error_1.SimpleFetchError(baseURL, url, res);
        }
        return res;
      });
    }
    exports2.simpleFetch = simpleFetch;
    function defaultValidateStatusFn(status) {
      return status >= 200 && status < 300;
    }
  }
});

// node_modules/@keplr-wallet/simple-fetch/build/types.js
var require_types = __commonJS({
  "node_modules/@keplr-wallet/simple-fetch/build/types.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@keplr-wallet/simple-fetch/build/index.js
var require_build12 = __commonJS({
  "node_modules/@keplr-wallet/simple-fetch/build/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_fetch(), exports2);
    __exportStar(require_error(), exports2);
    __exportStar(require_types(), exports2);
  }
});

// node_modules/@keplr-wallet/cosmos/build/account/index.js
var require_account = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/account/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseAccount = void 0;
    var unit_1 = require_build11();
    var simple_fetch_1 = require_build12();
    var BaseAccount = class _BaseAccount {
      static fetchFromRest(rest, address, defaultBech32Address = false) {
        return __awaiter2(this, void 0, void 0, function* () {
          const result2 = yield (0, simple_fetch_1.simpleFetch)(rest, `/cosmos/auth/v1beta1/accounts/${address}`, {
            validateStatus: function(status) {
              return status >= 200 && status < 300 || status === 404;
            }
          });
          return _BaseAccount.fromProtoJSON(result2.data, defaultBech32Address ? address : "");
        });
      }
      static fromProtoJSON(obj, defaultBech32Address = "") {
        if (!obj.account) {
          if (!defaultBech32Address) {
            throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);
          }
          return new _BaseAccount("", defaultBech32Address, new unit_1.Int(0), new unit_1.Int(0));
        }
        let value = obj.account;
        const type = value["@type"] || "";
        const baseAccount = value.BaseAccount || value.baseAccount || value.base_account;
        if (baseAccount) {
          value = baseAccount;
        }
        const embedAccount = value.account;
        if (embedAccount) {
          value = embedAccount;
        }
        let baseVestingAccount = value.BaseVestingAccount || value.baseVestingAccount || value.base_vesting_account;
        while (baseVestingAccount) {
          value = baseVestingAccount;
          const baseAccount2 = value.BaseAccount || value.baseAccount || value.base_account;
          if (baseAccount2) {
            value = baseAccount2;
          }
          baseVestingAccount = value.BaseVestingAccount || value.baseVestingAccount || value.base_vesting_account;
        }
        let address = value.address;
        if (!address) {
          if (!defaultBech32Address) {
            throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);
          }
          address = defaultBech32Address;
        }
        const accountNumber = value.account_number;
        const sequence = value.sequence;
        return new _BaseAccount(type, address, new unit_1.Int(accountNumber || "0"), new unit_1.Int(sequence || "0"));
      }
      constructor(type, address, accountNumber, sequence) {
        this.type = type;
        this.address = address;
        this.accountNumber = accountNumber;
        this.sequence = sequence;
      }
      getType() {
        return this.type;
      }
      getAddress() {
        return this.address;
      }
      getAccountNumber() {
        return this.accountNumber;
      }
      getSequence() {
        return this.sequence;
      }
    };
    exports2.BaseAccount = BaseAccount;
  }
});

// node_modules/@keplr-wallet/cosmos/node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/@keplr-wallet/cosmos/node_modules/bech32/index.js"(exports2, module2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z = 0; z < ALPHABET.length; z++) {
      x = ALPHABET.charAt(z);
      if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
      ALPHABET_MAP[x] = z;
    }
    var x;
    var z;
    function polymodStep(pre) {
      var b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i = 0; i < prefix.length; ++i) {
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (i = 0; i < prefix.length; ++i) {
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function encode3(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT) throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string") throw new Error(chk);
      var result2 = prefix + "1";
      for (var i = 0; i < words.length; ++i) {
        var x2 = words[i];
        if (x2 >> 5 !== 0) throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x2;
        result2 += ALPHABET.charAt(x2);
      }
      for (i = 0; i < 6; ++i) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i = 0; i < 6; ++i) {
        var v = chk >> (5 - i) * 5 & 31;
        result2 += ALPHABET.charAt(v);
      }
      return result2;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8) return str + " too short";
      if (str.length > LIMIT) return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered) return "Mixed-case string " + str;
      str = lowered;
      var split2 = str.lastIndexOf("1");
      if (split2 === -1) return "No separator character for " + str;
      if (split2 === 0) return "Missing prefix for " + str;
      var prefix = str.slice(0, split2);
      var wordChars = str.slice(split2 + 1);
      if (wordChars.length < 6) return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string") return chk;
      var words = [];
      for (var i = 0; i < wordChars.length; ++i) {
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === void 0) return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        if (i + 6 >= wordChars.length) continue;
        words.push(v);
      }
      if (chk !== 1) return "Invalid checksum for " + str;
      return { prefix, words };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object") return res;
    }
    function decode2(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object") return res;
      throw new Error(res);
    }
    function convert(data, inBits, outBits, pad) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result2 = [];
      for (var i = 0; i < data.length; ++i) {
        value = value << inBits | data[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result2.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result2.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits) return "Excess padding";
        if (value << outBits - bits & maxV) return "Non-zero padding";
      }
      return result2;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res)) return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res)) return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res)) return res;
    }
    function fromWords(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res)) return res;
      throw new Error(res);
    }
    module2.exports = {
      decodeUnsafe,
      decode: decode2,
      encode: encode3,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/@ethersproject/logger/lib.esm/_version.js
var import_dist817, import_dist818, import_dist819, version2;
var init_version = __esm({
  "node_modules/@ethersproject/logger/lib.esm/_version.js"() {
    import_dist817 = __toESM(require_dist());
    import_dist818 = __toESM(require_dist2());
    import_dist819 = __toESM(require_dist3());
    version2 = "logger/5.7.0";
  }
});

// node_modules/@ethersproject/logger/lib.esm/index.js
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var import_dist820, import_dist821, import_dist822, _permanentCensorErrors, _censorErrors, LogLevels, _logLevel, _globalLogger, _normalizeError, LogLevel, ErrorCode, HEX, Logger;
var init_lib = __esm({
  "node_modules/@ethersproject/logger/lib.esm/index.js"() {
    "use strict";
    import_dist820 = __toESM(require_dist());
    import_dist821 = __toESM(require_dist2());
    import_dist822 = __toESM(require_dist3());
    init_version();
    _permanentCensorErrors = false;
    _censorErrors = false;
    LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    _logLevel = LogLevels["default"];
    _globalLogger = null;
    _normalizeError = _checkNormalize();
    (function(LogLevel2) {
      LogLevel2["DEBUG"] = "DEBUG";
      LogLevel2["INFO"] = "INFO";
      LogLevel2["WARNING"] = "WARNING";
      LogLevel2["ERROR"] = "ERROR";
      LogLevel2["OFF"] = "OFF";
    })(LogLevel || (LogLevel = {}));
    (function(ErrorCode2) {
      ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode2["TIMEOUT"] = "TIMEOUT";
      ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
    })(ErrorCode || (ErrorCode = {}));
    HEX = "0123456789abcdef";
    Logger = class _Logger {
      constructor(version7) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version7,
          writable: false
        });
      }
      _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
          return;
        }
        console.log.apply(console, args);
      }
      debug(...args) {
        this._log(_Logger.levels.DEBUG, args);
      }
      info(...args) {
        this._log(_Logger.levels.INFO, args);
      }
      warn(...args) {
        this._log(_Logger.levels.WARNING, args);
      }
      makeError(message, code, params) {
        if (_censorErrors) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = _Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
          const value = params[key];
          try {
            if (value instanceof Uint8Array) {
              let hex = "";
              for (let i = 0; i < value.length; i++) {
                hex += HEX[value[i] >> 4];
                hex += HEX[value[i] & 15];
              }
              messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
            } else {
              messageDetails.push(key + "=" + JSON.stringify(value));
            }
          } catch (error2) {
            messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
          }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
          case ErrorCode.NUMERIC_FAULT: {
            url = "NUMERIC_FAULT";
            const fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode.CALL_EXCEPTION:
          case ErrorCode.INSUFFICIENT_FUNDS:
          case ErrorCode.MISSING_NEW:
          case ErrorCode.NONCE_EXPIRED:
          case ErrorCode.REPLACEMENT_UNDERPRICED:
          case ErrorCode.TRANSACTION_REPLACED:
          case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
            url = code;
            break;
        }
        if (url) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key) {
          error[key] = params[key];
        });
        return error;
      }
      throwError(message, code, params) {
        throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name, value) {
        return this.throwError(message, _Logger.errors.INVALID_ARGUMENT, {
          argument: name,
          value
        });
      }
      assert(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      }
      assertArgument(condition, message, name, value) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name, value);
      }
      checkNormalize(message) {
        if (message == null) {
          message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
          this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
          });
        }
      }
      checkSafeUint53(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      }
      checkArgumentCount(count3, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count3 < expectedCount) {
          this.throwError("missing argument" + message, _Logger.errors.MISSING_ARGUMENT, {
            count: count3,
            expectedCount
          });
        }
        if (count3 > expectedCount) {
          this.throwError("too many arguments" + message, _Logger.errors.UNEXPECTED_ARGUMENT, {
            count: count3,
            expectedCount
          });
        }
      }
      checkNew(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      checkAbstract(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      static globalLogger() {
        if (!_globalLogger) {
          _globalLogger = new _Logger(version2);
        }
        return _globalLogger;
      }
      static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
      }
      static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
          _Logger.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel = level;
      }
      static from(version7) {
        return new _Logger(version7);
      }
    };
    Logger.errors = ErrorCode;
    Logger.levels = LogLevel;
  }
});

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var import_dist823, import_dist824, import_dist825, version3;
var init_version2 = __esm({
  "node_modules/@ethersproject/bytes/lib.esm/_version.js"() {
    import_dist823 = __toESM(require_dist());
    import_dist824 = __toESM(require_dist2());
    import_dist825 = __toESM(require_dist3());
    version3 = "bytes/5.7.0";
  }
});

// node_modules/@ethersproject/bytes/lib.esm/index.js
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger2(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger2(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger2(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result2 = [];
    while (value) {
      result2.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result2.length === 0) {
      result2.push(0);
    }
    return addSlice(new Uint8Array(result2));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result2 = [];
    for (let i = 0; i < hex.length; i += 2) {
      result2.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result2));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat2(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result2 = new Uint8Array(length);
  objects.reduce((offset4, object) => {
    result2.set(object, offset4);
    return offset4 + object.length;
  }, 0);
  return addSlice(result2);
}
function stripZeros(value) {
  let result2 = arrayify(value);
  if (result2.length === 0) {
    return result2;
  }
  let start = 0;
  while (start < result2.length && result2[start] === 0) {
    start++;
  }
  if (start) {
    result2 = result2.slice(start);
  }
  return result2;
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result2 = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result2 += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result2;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset4, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }
  offset4 = 2 + 2 * offset4;
  if (endOffset != null) {
    return "0x" + data.substring(offset4, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset4);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
var import_dist826, import_dist827, import_dist828, logger, HexCharacters;
var init_lib2 = __esm({
  "node_modules/@ethersproject/bytes/lib.esm/index.js"() {
    "use strict";
    import_dist826 = __toESM(require_dist());
    import_dist827 = __toESM(require_dist2());
    import_dist828 = __toESM(require_dist3());
    init_lib();
    init_version2();
    logger = new Logger(version3);
    HexCharacters = "0123456789abcdef";
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/_version.js
var import_dist829, import_dist830, import_dist831, version4;
var init_version3 = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/_version.js"() {
    import_dist829 = __toESM(require_dist());
    import_dist830 = __toESM(require_dist2());
    import_dist831 = __toESM(require_dist3());
    version4 = "bignumber/5.7.0";
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}
var import_dist832, import_dist833, import_dist834, import_bn, BN, logger2, _constructorGuard, MAX_SAFE, _warnedToStringRadix, BigNumber;
var init_bignumber = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/bignumber.js"() {
    "use strict";
    import_dist832 = __toESM(require_dist());
    import_dist833 = __toESM(require_dist2());
    import_dist834 = __toESM(require_dist3());
    import_bn = __toESM(require_bn());
    init_lib2();
    init_lib();
    init_version3();
    BN = import_bn.default.BN;
    logger2 = new Logger(version4);
    _constructorGuard = {};
    MAX_SAFE = 9007199254740991;
    _warnedToStringRadix = false;
    BigNumber = class _BigNumber {
      constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard) {
          logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
          });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
      }
      fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
      }
      toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
      }
      abs() {
        if (this._hex[0] === "-") {
          return _BigNumber.from(this._hex.substring(1));
        }
        return this;
      }
      add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
      }
      sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
      }
      div(other) {
        const o = _BigNumber.from(other);
        if (o.isZero()) {
          throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
      }
      mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
      }
      mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
      }
      pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
      }
      and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
      }
      or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
      }
      xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
      }
      mask(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
      }
      shl(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
      }
      shr(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
      }
      eq(other) {
        return toBN(this).eq(toBN(other));
      }
      lt(other) {
        return toBN(this).lt(toBN(other));
      }
      lte(other) {
        return toBN(this).lte(toBN(other));
      }
      gt(other) {
        return toBN(this).gt(toBN(other));
      }
      gte(other) {
        return toBN(this).gte(toBN(other));
      }
      isNegative() {
        return this._hex[0] === "-";
      }
      isZero() {
        return toBN(this).isZero();
      }
      toNumber() {
        try {
          return toBN(this).toNumber();
        } catch (error) {
          throwFault("overflow", "toNumber", this.toString());
        }
        return null;
      }
      toBigInt() {
        try {
          return BigInt(this.toString());
        } catch (e) {
        }
        return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
          value: this.toString()
        });
      }
      toString() {
        if (arguments.length > 0) {
          if (arguments[0] === 10) {
            if (!_warnedToStringRadix) {
              _warnedToStringRadix = true;
              logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
            }
          } else if (arguments[0] === 16) {
            logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
          } else {
            logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
          }
        }
        return toBN(this).toString(10);
      }
      toHexString() {
        return this._hex;
      }
      toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
      }
      static from(value) {
        if (value instanceof _BigNumber) {
          return value;
        }
        if (typeof value === "string") {
          if (value.match(/^-?0x[0-9a-f]+$/i)) {
            return new _BigNumber(_constructorGuard, toHex(value));
          }
          if (value.match(/^-?[0-9]+$/)) {
            return new _BigNumber(_constructorGuard, toHex(new BN(value)));
          }
          return logger2.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof value === "number") {
          if (value % 1) {
            throwFault("underflow", "BigNumber.from", value);
          }
          if (value >= MAX_SAFE || value <= -MAX_SAFE) {
            throwFault("overflow", "BigNumber.from", value);
          }
          return _BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof anyValue === "bigint") {
          return _BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
          return _BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
          if (anyValue.toHexString) {
            const hex = anyValue.toHexString();
            if (typeof hex === "string") {
              return _BigNumber.from(hex);
            }
          } else {
            let hex = anyValue._hex;
            if (hex == null && anyValue.type === "BigNumber") {
              hex = anyValue.hex;
            }
            if (typeof hex === "string") {
              if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
                return _BigNumber.from(hex);
              }
            }
          }
        }
        return logger2.throwArgumentError("invalid BigNumber value", "value", value);
      }
      static isBigNumber(value) {
        return !!(value && value._isBigNumber);
      }
    };
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var import_dist835, import_dist836, import_dist837, logger3, _constructorGuard2, Zero, NegativeOne, zeros, FixedFormat, FixedNumber, ONE2, BUMP;
var init_fixednumber = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js"() {
    "use strict";
    import_dist835 = __toESM(require_dist());
    import_dist836 = __toESM(require_dist2());
    import_dist837 = __toESM(require_dist3());
    init_lib2();
    init_lib();
    init_version3();
    init_bignumber();
    logger3 = new Logger(version4);
    _constructorGuard2 = {};
    Zero = BigNumber.from(0);
    NegativeOne = BigNumber.from(-1);
    zeros = "0";
    while (zeros.length < 256) {
      zeros += zeros;
    }
    FixedFormat = class _FixedFormat {
      constructor(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
      }
      static from(value) {
        if (value instanceof _FixedFormat) {
          return value;
        }
        if (typeof value === "number") {
          value = `fixed128x${value}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof value === "string") {
          if (value === "fixed") {
          } else if (value === "ufixed") {
            signed = false;
          } else {
            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            if (!match) {
              logger3.throwArgumentError("invalid fixed format", "format", value);
            }
            signed = match[1] !== "u";
            width = parseInt(match[2]);
            decimals = parseInt(match[3]);
          }
        } else if (value) {
          const check2 = (key, type, defaultValue) => {
            if (value[key] == null) {
              return defaultValue;
            }
            if (typeof value[key] !== type) {
              logger3.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
            }
            return value[key];
          };
          signed = check2("signed", "boolean", signed);
          width = check2("width", "number", width);
          decimals = check2("decimals", "number", decimals);
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
          logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new _FixedFormat(_constructorGuard2, signed, width, decimals);
      }
    };
    FixedNumber = class _FixedNumber {
      constructor(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
      }
      _checkFormat(other) {
        if (this.format.name !== other.format.name) {
          logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
      }
      addUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
      }
      subUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
      }
      mulUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
      }
      divUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
      }
      floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result2 = _FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
          result2 = result2.subUnsafe(ONE2.toFormat(result2.format));
        }
        return result2;
      }
      ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result2 = _FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
          result2 = result2.addUnsafe(ONE2.toFormat(result2.format));
        }
        return result2;
      }
      // @TODO: Support other rounding algorithms
      round(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || decimals % 1) {
          logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
          return this;
        }
        const factor = _FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
      }
      isZero() {
        return this._value === "0.0" || this._value === "0";
      }
      isNegative() {
        return this._value[0] === "-";
      }
      toString() {
        return this._value;
      }
      toHexString(width) {
        if (width == null) {
          return this._hex;
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return hexZeroPad(hex, width / 8);
      }
      toUnsafeFloat() {
        return parseFloat(this.toString());
      }
      toFormat(format) {
        return _FixedNumber.fromString(this._value, format);
      }
      static fromValue(value, decimals, format) {
        if (format == null && decimals != null && !isBigNumberish(decimals)) {
          format = decimals;
          decimals = null;
        }
        if (decimals == null) {
          decimals = 0;
        }
        if (format == null) {
          format = "fixed";
        }
        return _FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
      }
      static fromString(value, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) {
          throwFault2("unsigned value cannot be negative", "overflow", "value", value);
        }
        let hex = null;
        if (fixedFormat.signed) {
          hex = numeric.toTwos(fixedFormat.width).toHexString();
        } else {
          hex = numeric.toHexString();
          hex = hexZeroPad(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static fromBytes(value, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if (arrayify(value).length > fixedFormat.width / 8) {
          throw new Error("overflow");
        }
        let numeric = BigNumber.from(value);
        if (fixedFormat.signed) {
          numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static from(value, format) {
        if (typeof value === "string") {
          return _FixedNumber.fromString(value, format);
        }
        if (isBytes(value)) {
          return _FixedNumber.fromBytes(value, format);
        }
        try {
          return _FixedNumber.fromValue(value, 0, format);
        } catch (error) {
          if (error.code !== Logger.errors.INVALID_ARGUMENT) {
            throw error;
          }
        }
        return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
      }
      static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
      }
    };
    ONE2 = FixedNumber.from(1);
    BUMP = FixedNumber.from("0.5");
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/index.js
var import_dist838, import_dist839, import_dist840;
var init_lib3 = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/index.js"() {
    import_dist838 = __toESM(require_dist());
    import_dist839 = __toESM(require_dist2());
    import_dist840 = __toESM(require_dist3());
    init_bignumber();
    init_fixednumber();
    init_bignumber();
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha34 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root2 = WINDOW ? window : {};
      if (root2.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root2 = global;
      } else if (WEB_WORKER) {
        root2 = self;
      }
      var COMMON_JS = !root2.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n, s) {
          return methods2["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s) {
          return methods2["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n, s) {
          if (!n && !s) {
            return methods2["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
          }
        };
        method.update = function(message, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method.update = function(key, message, outputBits, s) {
          return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods2 = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods2[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods2[newMethodName] = methods2[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index2 = 0, s = this.s, i2, code;
        while (index2 < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index2 < length && i2 < byteCount; ++index2) {
              blocks[i2 >> 2] |= message[index2] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index2 < length && i2 < byteCount; ++index2) {
              code = message.charCodeAt(index2);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes % w;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset4, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset4 = j2 << 2;
            block = s[i2];
            array[offset4] = block & 255;
            array[offset4 + 1] = block >> 8 & 255;
            array[offset4 + 2] = block >> 16 & 255;
            array[offset4 + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          offset4 = j2 << 2;
          block = s[i2];
          array[offset4] = block & 255;
          if (extraBytes > 1) {
            array[offset4 + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset4 + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS) {
        module2.exports = methods2;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root2[methodNames[i]] = methods2[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods2;
          });
        }
      }
    })();
  }
});

// node_modules/@ethersproject/keccak256/lib.esm/index.js
function keccak256(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}
var import_dist841, import_dist842, import_dist843, import_js_sha3;
var init_lib4 = __esm({
  "node_modules/@ethersproject/keccak256/lib.esm/index.js"() {
    "use strict";
    import_dist841 = __toESM(require_dist());
    import_dist842 = __toESM(require_dist2());
    import_dist843 = __toESM(require_dist3());
    import_js_sha3 = __toESM(require_sha34());
    init_lib2();
  }
});

// node_modules/@ethersproject/rlp/lib.esm/_version.js
var import_dist844, import_dist845, import_dist846, version5;
var init_version4 = __esm({
  "node_modules/@ethersproject/rlp/lib.esm/_version.js"() {
    import_dist844 = __toESM(require_dist());
    import_dist845 = __toESM(require_dist2());
    import_dist846 = __toESM(require_dist3());
    version5 = "rlp/5.7.0";
  }
});

// node_modules/@ethersproject/rlp/lib.esm/index.js
function arrayifyInteger(value) {
  const result2 = [];
  while (value) {
    result2.unshift(value & 255);
    value >>= 8;
  }
  return result2;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger4.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode2(object) {
  return hexlify(_encode(object));
}
var import_dist847, import_dist848, import_dist849, logger4;
var init_lib5 = __esm({
  "node_modules/@ethersproject/rlp/lib.esm/index.js"() {
    "use strict";
    import_dist847 = __toESM(require_dist());
    import_dist848 = __toESM(require_dist2());
    import_dist849 = __toESM(require_dist3());
    init_lib2();
    init_lib();
    init_version4();
    logger4 = new Logger(version5);
  }
});

// node_modules/@ethersproject/address/lib.esm/_version.js
var import_dist850, import_dist851, import_dist852, version6;
var init_version5 = __esm({
  "node_modules/@ethersproject/address/lib.esm/_version.js"() {
    import_dist850 = __toESM(require_dist());
    import_dist851 = __toESM(require_dist2());
    import_dist852 = __toESM(require_dist3());
    version6 = "address/5.7.0";
  }
});

// node_modules/@ethersproject/address/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  isAddress: () => isAddress
});
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger5.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result2 = null;
  if (typeof address !== "string") {
    logger5.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result2 = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result2 !== address) {
      logger5.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger5.throwArgumentError("bad icap checksum", "address", address);
    }
    result2 = _base36To16(address.substring(4));
    while (result2.length < 40) {
      result2 = "0" + result2;
    }
    result2 = getChecksumAddress("0x" + result2);
  } else {
    logger5.throwArgumentError("invalid address", "address", address);
  }
  return result2;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction2) {
  let from2 = null;
  try {
    from2 = getAddress(transaction2.from);
  } catch (error) {
    logger5.throwArgumentError("missing from address", "transaction", transaction2);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction2.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode2([from2, nonce])), 12));
}
function getCreate2Address(from2, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger5.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger5.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256(concat2(["0xff", getAddress(from2), salt, initCodeHash])), 12));
}
var import_dist853, import_dist854, import_dist855, logger5, MAX_SAFE_INTEGER, ibanLookup, safeDigits;
var init_lib6 = __esm({
  "node_modules/@ethersproject/address/lib.esm/index.js"() {
    "use strict";
    import_dist853 = __toESM(require_dist());
    import_dist854 = __toESM(require_dist2());
    import_dist855 = __toESM(require_dist3());
    init_lib2();
    init_lib3();
    init_lib4();
    init_lib5();
    init_lib();
    init_version5();
    logger5 = new Logger(version6);
    MAX_SAFE_INTEGER = 9007199254740991;
    ibanLookup = {};
    for (let i = 0; i < 10; i++) {
      ibanLookup[String(i)] = String(i);
    }
    for (let i = 0; i < 26; i++) {
      ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
    }
    safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
  }
});

// node_modules/@keplr-wallet/cosmos/build/bech32/index.js
var require_bech322 = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/bech32/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result2 = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result2, mod2, k);
      }
      __setModuleDefault(result2, mod2);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Bech32Address = void 0;
    var bech32_1 = __importStar(require_bech32());
    var buffer_1 = require_dist();
    var address_1 = (init_lib6(), __toCommonJS(lib_exports));
    var Bech32Address = class _Bech32Address {
      static shortenAddress(bech322, maxCharacters) {
        if (maxCharacters >= bech322.length) {
          return bech322;
        }
        const i = bech322.indexOf("1");
        const prefix = bech322.slice(0, i);
        const address = bech322.slice(i + 1);
        maxCharacters -= prefix.length;
        maxCharacters -= 3;
        maxCharacters -= 1;
        if (maxCharacters <= 0) {
          return "";
        }
        const mid = Math.floor(address.length / 2);
        let former = address.slice(0, mid);
        let latter = address.slice(mid);
        while (maxCharacters < former.length + latter.length) {
          if ((former.length + latter.length) % 2 === 1 && former.length > 0) {
            former = former.slice(0, former.length - 1);
          } else {
            latter = latter.slice(1);
          }
        }
        return prefix + "1" + former + "..." + latter;
      }
      static fromBech32(bech32Address, prefix, limit) {
        const decoded = bech32_1.default.decode(bech32Address, limit);
        if (prefix && decoded.prefix !== prefix) {
          throw new Error("Unmatched prefix");
        }
        return new _Bech32Address(new Uint8Array((0, bech32_1.fromWords)(decoded.words)));
      }
      static validate(bech32Address, prefix, limit) {
        const { prefix: decodedPrefix } = bech32_1.default.decode(bech32Address, limit);
        if (prefix && prefix !== decodedPrefix) {
          throw new Error(`Unexpected prefix (expected: ${prefix}, actual: ${decodedPrefix})`);
        }
      }
      static defaultBech32Config(mainPrefix, validatorPrefix = "val", consensusPrefix = "cons", publicPrefix = "pub", operatorPrefix = "oper") {
        return {
          bech32PrefixAccAddr: mainPrefix,
          bech32PrefixAccPub: mainPrefix + publicPrefix,
          bech32PrefixValAddr: mainPrefix + validatorPrefix + operatorPrefix,
          bech32PrefixValPub: mainPrefix + validatorPrefix + operatorPrefix + publicPrefix,
          bech32PrefixConsAddr: mainPrefix + validatorPrefix + consensusPrefix,
          bech32PrefixConsPub: mainPrefix + validatorPrefix + consensusPrefix + publicPrefix
        };
      }
      constructor(address) {
        this.address = address;
      }
      toBech32(prefix, limit) {
        const words = bech32_1.default.toWords(this.address);
        return bech32_1.default.encode(prefix, words, limit);
      }
      toHex(mixedCaseChecksum = true) {
        const hex = buffer_1.Buffer.from(this.address).toString("hex");
        if (hex.length === 0) {
          throw new Error("Empty address");
        }
        if (mixedCaseChecksum) {
          return (0, address_1.getAddress)("0x" + hex);
        } else {
          return "0x" + hex;
        }
      }
    };
    exports2.Bech32Address = Bech32Address;
  }
});

// node_modules/@keplr-wallet/cosmos/build/chain-id/cosmos.js
var require_cosmos = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/chain-id/cosmos.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChainIdHelper = void 0;
    var ChainIdHelper = class _ChainIdHelper {
      static parse(chainId) {
        if (chainId === "injective-777" || chainId === "injective-888") {
          return {
            identifier: chainId,
            version: 0
          };
        }
        const split2 = chainId.split(_ChainIdHelper.VersionFormatRegExp).filter(Boolean);
        if (split2.length !== 2) {
          return {
            identifier: chainId,
            version: 0
          };
        } else {
          return { identifier: split2[0], version: parseInt(split2[1]) };
        }
      }
      static hasChainVersion(chainId) {
        const version7 = _ChainIdHelper.parse(chainId);
        return version7.identifier !== chainId;
      }
    };
    ChainIdHelper.VersionFormatRegExp = /(.+)-([\d]+)/;
    exports2.ChainIdHelper = ChainIdHelper;
  }
});

// node_modules/@keplr-wallet/cosmos/build/chain-id/ethermint.js
var require_ethermint = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/chain-id/ethermint.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EthermintChainIdHelper = void 0;
    var cosmos_1 = require_cosmos();
    var EthermintChainIdHelper = class {
      static parse(chainId) {
        const cosmosChainId = cosmos_1.ChainIdHelper.parse(chainId);
        if (chainId === "carbon-1") {
          return Object.assign({ ethChainId: 9790 }, cosmosChainId);
        }
        if (chainId.startsWith("injective")) {
          const injectiveTestnetChainIds = ["injective-777", "injective-888"];
          if (injectiveTestnetChainIds.includes(chainId)) {
            return Object.assign({ ethChainId: 5 }, cosmosChainId);
          }
          return Object.assign({ ethChainId: 1 }, cosmosChainId);
        }
        const matches = chainId.match("^([a-z]{1,})_{1}([1-9][0-9]*)-{1}([1-9][0-9]*)$");
        if (!matches || matches.length !== 4 || matches[1] === "" || Number.isNaN(parseFloat(matches[2])) || !Number.isInteger(parseFloat(matches[2]))) {
          throw new Error(`Invalid chainId for ethermint: ${chainId}`);
        }
        return Object.assign(Object.assign({}, cosmosChainId), { ethChainId: parseFloat(matches[2]) });
      }
    };
    exports2.EthermintChainIdHelper = EthermintChainIdHelper;
  }
});

// node_modules/@keplr-wallet/cosmos/build/chain-id/index.js
var require_chain_id = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/chain-id/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cosmos(), exports2);
    __exportStar(require_ethermint(), exports2);
  }
});

// node_modules/@keplr-wallet/cosmos/build/tx-tracer/index.js
var require_tx_tracer = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/tx-tracer/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TendermintTxTracer = exports2.WsReadyState = void 0;
    var buffer_1 = require_dist();
    var WsReadyState;
    (function(WsReadyState2) {
      WsReadyState2[WsReadyState2["CONNECTING"] = 0] = "CONNECTING";
      WsReadyState2[WsReadyState2["OPEN"] = 1] = "OPEN";
      WsReadyState2[WsReadyState2["CLOSING"] = 2] = "CLOSING";
      WsReadyState2[WsReadyState2["CLOSED"] = 3] = "CLOSED";
      WsReadyState2[WsReadyState2["NONE"] = 4] = "NONE";
    })(WsReadyState = exports2.WsReadyState || (exports2.WsReadyState = {}));
    var TendermintTxTracer = class {
      constructor(url, wsEndpoint, options = {}) {
        this.url = url;
        this.wsEndpoint = wsEndpoint;
        this.options = options;
        this.newBlockSubscribes = [];
        this.txSubscribes = /* @__PURE__ */ new Map();
        this.pendingQueries = /* @__PURE__ */ new Map();
        this.listeners = {};
        this.onOpen = (e) => {
          var _a2;
          if (this.newBlockSubscribes.length > 0) {
            this.sendSubscribeBlockRpc();
          }
          for (const [id, tx] of this.txSubscribes) {
            this.sendSubscribeTxRpc(id, tx.params);
          }
          for (const [id, query] of this.pendingQueries) {
            this.sendQueryRpc(id, query.method, query.params);
          }
          for (const listener of (_a2 = this.listeners.open) !== null && _a2 !== void 0 ? _a2 : []) {
            listener(e);
          }
        };
        this.onMessage = (e) => {
          var _a2, _b, _c, _d, _e, _f;
          for (const listener of (_a2 = this.listeners.message) !== null && _a2 !== void 0 ? _a2 : []) {
            listener(e);
          }
          if (e.data) {
            try {
              const obj = JSON.parse(e.data);
              if (obj === null || obj === void 0 ? void 0 : obj.id) {
                if (this.pendingQueries.has(obj.id)) {
                  if (obj.error) {
                    this.pendingQueries.get(obj.id).rejector(new Error(obj.error.data || obj.error.message));
                  } else {
                    if ((_b = obj.result) === null || _b === void 0 ? void 0 : _b.tx_result) {
                      this.pendingQueries.get(obj.id).resolver(obj.result.tx_result);
                    } else {
                      this.pendingQueries.get(obj.id).resolver(obj.result);
                    }
                  }
                  this.pendingQueries.delete(obj.id);
                }
              }
              if (((_d = (_c = obj === null || obj === void 0 ? void 0 : obj.result) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.type) === "tendermint/event/NewBlock") {
                for (const handler of this.newBlockSubscribes) {
                  handler.handler(obj.result.data.value);
                }
              }
              if (((_f = (_e = obj === null || obj === void 0 ? void 0 : obj.result) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.type) === "tendermint/event/Tx") {
                if (obj === null || obj === void 0 ? void 0 : obj.id) {
                  if (this.txSubscribes.has(obj.id)) {
                    if (obj.error) {
                      this.txSubscribes.get(obj.id).rejector(new Error(obj.error.data || obj.error.message));
                    } else {
                      this.txSubscribes.get(obj.id).resolver(obj.result.data.value.TxResult.result);
                    }
                    this.txSubscribes.delete(obj.id);
                  }
                }
              }
            } catch (e2) {
              console.log(`Tendermint websocket jsonrpc response is not JSON: ${e2.message || e2.toString()}`);
            }
          }
        };
        this.onClose = (e) => {
          var _a2;
          for (const listener of (_a2 = this.listeners.close) !== null && _a2 !== void 0 ? _a2 : []) {
            listener(e);
          }
        };
        this.onError = (e) => {
          var _a2;
          for (const listener of (_a2 = this.listeners.error) !== null && _a2 !== void 0 ? _a2 : []) {
            listener(e);
          }
          this.close();
        };
        this.ws = this.options.wsObject ? new this.options.wsObject(this.getWsEndpoint()) : new WebSocket(this.getWsEndpoint());
        this.ws.onopen = this.onOpen;
        this.ws.onmessage = this.onMessage;
        this.ws.onclose = this.onClose;
        this.ws.onerror = this.onError;
      }
      getWsEndpoint() {
        let url = this.url;
        if (url.startsWith("http")) {
          url = url.replace("http", "ws");
        }
        if (!url.endsWith(this.wsEndpoint)) {
          const wsEndpoint = this.wsEndpoint.startsWith("/") ? this.wsEndpoint : "/" + this.wsEndpoint;
          url = url.endsWith("/") ? url + wsEndpoint.slice(1) : url + wsEndpoint;
        }
        return url;
      }
      close() {
        this.ws.close();
      }
      get readyState() {
        switch (this.ws.readyState) {
          case 0:
            return WsReadyState.CONNECTING;
          case 1:
            return WsReadyState.OPEN;
          case 2:
            return WsReadyState.CLOSING;
          case 3:
            return WsReadyState.CLOSED;
          default:
            return WsReadyState.NONE;
        }
      }
      addEventListener(type, listener) {
        if (!this.listeners[type]) {
          this.listeners[type] = [];
        }
        this.listeners[type].push(listener);
      }
      /**
       * SubscribeBlock receives the handler for the block.
       * The handelrs shares the subscription of block.
       * @param handler
       * @return unsubscriber
       */
      subscribeBlock(handler) {
        this.newBlockSubscribes.push({
          handler
        });
        if (this.newBlockSubscribes.length === 1) {
          this.sendSubscribeBlockRpc();
        }
        return () => {
          this.newBlockSubscribes = this.newBlockSubscribes.filter((s) => s.handler !== handler);
        };
      }
      sendSubscribeBlockRpc() {
        if (this.readyState === WsReadyState.OPEN) {
          this.ws.send(JSON.stringify({
            jsonrpc: "2.0",
            method: "subscribe",
            params: ["tm.event='NewBlock'"],
            id: 1
          }));
        }
      }
      // Query the tx and subscribe the tx.
      traceTx(query) {
        let resolved = false;
        return new Promise((resolve) => {
          this.queryTx(query).then((result2) => {
            if (query instanceof Uint8Array) {
              resolve(result2);
              return;
            }
            if ((result2 === null || result2 === void 0 ? void 0 : result2.total_count) !== "0") {
              resolve(result2);
              return;
            }
          }).catch(() => {
          });
          (() => __awaiter2(this, void 0, void 0, function* () {
            while (true) {
              if (resolved || this.readyState === WsReadyState.CLOSED || this.readyState === WsReadyState.CLOSING) {
                break;
              }
              yield new Promise((resolve2) => setTimeout(resolve2, 1e4));
              this.queryTx(query).then((result2) => {
                if (query instanceof Uint8Array) {
                  resolve(result2);
                  return;
                }
                if ((result2 === null || result2 === void 0 ? void 0 : result2.total_count) !== "0") {
                  resolve(result2);
                  return;
                }
              }).catch(() => {
              });
            }
          }))();
          this.subscribeTx(query).then(resolve);
        }).then((tx) => {
          resolved = true;
          return new Promise((resolve) => {
            setTimeout(() => resolve(tx), 100);
          });
        });
      }
      subscribeTx(query) {
        if (query instanceof Uint8Array) {
          const id = this.createRandomId();
          const params = {
            query: `tm.event='Tx' AND tx.hash='${buffer_1.Buffer.from(query).toString("hex").toUpperCase()}'`
          };
          return new Promise((resolve, reject) => {
            this.txSubscribes.set(id, {
              params,
              resolver: resolve,
              rejector: reject
            });
            this.sendSubscribeTxRpc(id, params);
          });
        } else {
          const id = this.createRandomId();
          const params = {
            query: `tm.event='Tx' AND ` + Object.keys(query).map((key) => {
              return {
                key,
                value: query[key]
              };
            }).map((obj) => {
              return `${obj.key}=${typeof obj.value === "string" ? `'${obj.value}'` : obj.value}`;
            }).join(" AND "),
            page: "1",
            per_page: "1",
            order_by: "asc"
          };
          return new Promise((resolve, reject) => {
            this.txSubscribes.set(id, {
              params,
              resolver: resolve,
              rejector: reject
            });
            this.sendSubscribeTxRpc(id, params);
          });
        }
      }
      sendSubscribeTxRpc(id, params) {
        if (this.readyState === WsReadyState.OPEN) {
          this.ws.send(JSON.stringify({
            jsonrpc: "2.0",
            method: "subscribe",
            params,
            id
          }));
        }
      }
      queryTx(query) {
        if (query instanceof Uint8Array) {
          return this.query("tx", {
            hash: buffer_1.Buffer.from(query).toString("base64"),
            prove: false
          });
        } else {
          const params = {
            query: Object.keys(query).map((key) => {
              return {
                key,
                value: query[key]
              };
            }).map((obj) => {
              return `${obj.key}=${typeof obj.value === "string" ? `'${obj.value}'` : obj.value}`;
            }).join(" AND "),
            page: "1",
            per_page: "1",
            order_by: "asc"
          };
          return this.query("tx_search", params);
        }
      }
      query(method, params) {
        const id = this.createRandomId();
        return new Promise((resolve, reject) => {
          this.pendingQueries.set(id, {
            method,
            params,
            resolver: resolve,
            rejector: reject
          });
          this.sendQueryRpc(id, method, params);
        });
      }
      sendQueryRpc(id, method, params) {
        if (this.readyState === WsReadyState.OPEN) {
          this.ws.send(JSON.stringify({
            jsonrpc: "2.0",
            method,
            params,
            id
          }));
        }
      }
      createRandomId() {
        return parseInt(Array.from({ length: 6 }).map(() => Math.floor(Math.random() * 100)).join(""));
      }
    };
    exports2.TendermintTxTracer = TendermintTxTracer;
  }
});

// node_modules/@keplr-wallet/proto-types/node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/@keplr-wallet/proto-types/node_modules/long/src/long.js"(exports2, module2) {
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    module2.exports = Long2;
    var wasm2 = null;
    try {
      wasm2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long2(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long2.prototype.__isLong__;
    Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
    function isLong2(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long2.isLong = isLong2;
    var INT_CACHE2 = {};
    var UINT_CACHE2 = {};
    function fromInt2(value, unsigned) {
      var obj, cachedObj, cache2;
      if (unsigned) {
        value >>>= 0;
        if (cache2 = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE2[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits2(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache2)
          UINT_CACHE2[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache2 = -128 <= value && value < 128) {
          cachedObj = INT_CACHE2[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits2(value, value < 0 ? -1 : 0, false);
        if (cache2)
          INT_CACHE2[value] = obj;
        return obj;
      }
    }
    Long2.fromInt = fromInt2;
    function fromNumber2(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO2 : ZERO2;
      if (unsigned) {
        if (value < 0)
          return UZERO2;
        if (value >= TWO_PWR_64_DBL2)
          return MAX_UNSIGNED_VALUE2;
      } else {
        if (value <= -TWO_PWR_63_DBL2)
          return MIN_VALUE2;
        if (value + 1 >= TWO_PWR_63_DBL2)
          return MAX_VALUE2;
      }
      if (value < 0)
        return fromNumber2(-value, unsigned).neg();
      return fromBits2(value % TWO_PWR_32_DBL4 | 0, value / TWO_PWR_32_DBL4 | 0, unsigned);
    }
    Long2.fromNumber = fromNumber2;
    function fromBits2(lowBits, highBits, unsigned) {
      return new Long2(lowBits, highBits, unsigned);
    }
    Long2.fromBits = fromBits2;
    var pow_dbl2 = Math.pow;
    function fromString2(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO2;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString2(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber2(pow_dbl2(radix, 8));
      var result2 = ZERO2;
      for (var i = 0; i < str.length; i += 8) {
        var size4 = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size4), radix);
        if (size4 < 8) {
          var power = fromNumber2(pow_dbl2(radix, size4));
          result2 = result2.mul(power).add(fromNumber2(value));
        } else {
          result2 = result2.mul(radixToPower);
          result2 = result2.add(fromNumber2(value));
        }
      }
      result2.unsigned = unsigned;
      return result2;
    }
    Long2.fromString = fromString2;
    function fromValue2(val, unsigned) {
      if (typeof val === "number")
        return fromNumber2(val, unsigned);
      if (typeof val === "string")
        return fromString2(val, unsigned);
      return fromBits2(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long2.fromValue = fromValue2;
    var TWO_PWR_16_DBL2 = 1 << 16;
    var TWO_PWR_24_DBL2 = 1 << 24;
    var TWO_PWR_32_DBL4 = TWO_PWR_16_DBL2 * TWO_PWR_16_DBL2;
    var TWO_PWR_64_DBL2 = TWO_PWR_32_DBL4 * TWO_PWR_32_DBL4;
    var TWO_PWR_63_DBL2 = TWO_PWR_64_DBL2 / 2;
    var TWO_PWR_242 = fromInt2(TWO_PWR_24_DBL2);
    var ZERO2 = fromInt2(0);
    Long2.ZERO = ZERO2;
    var UZERO2 = fromInt2(0, true);
    Long2.UZERO = UZERO2;
    var ONE3 = fromInt2(1);
    Long2.ONE = ONE3;
    var UONE2 = fromInt2(1, true);
    Long2.UONE = UONE2;
    var NEG_ONE2 = fromInt2(-1);
    Long2.NEG_ONE = NEG_ONE2;
    var MAX_VALUE2 = fromBits2(4294967295 | 0, 2147483647 | 0, false);
    Long2.MAX_VALUE = MAX_VALUE2;
    var MAX_UNSIGNED_VALUE2 = fromBits2(4294967295 | 0, 4294967295 | 0, true);
    Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE2;
    var MIN_VALUE2 = fromBits2(0, 2147483648 | 0, false);
    Long2.MIN_VALUE = MIN_VALUE2;
    var LongPrototype2 = Long2.prototype;
    LongPrototype2.toInt = function toInt2() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype2.toNumber = function toNumber2() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL4 + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL4 + (this.low >>> 0);
    };
    LongPrototype2.toString = function toString4(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE2)) {
          var radixLong = fromNumber2(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber2(pow_dbl2(radix, 6), this.unsigned), rem = this;
      var result2 = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result2;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result2 = "" + digits + result2;
        }
      }
    };
    LongPrototype2.getHighBits = function getHighBits2() {
      return this.high;
    };
    LongPrototype2.getHighBitsUnsigned = function getHighBitsUnsigned2() {
      return this.high >>> 0;
    };
    LongPrototype2.getLowBits = function getLowBits2() {
      return this.low;
    };
    LongPrototype2.getLowBitsUnsigned = function getLowBitsUnsigned2() {
      return this.low >>> 0;
    };
    LongPrototype2.getNumBitsAbs = function getNumBitsAbs2() {
      if (this.isNegative())
        return this.eq(MIN_VALUE2) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype2.isZero = function isZero2() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype2.eqz = LongPrototype2.isZero;
    LongPrototype2.isNegative = function isNegative2() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype2.isPositive = function isPositive2() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype2.isOdd = function isOdd2() {
      return (this.low & 1) === 1;
    };
    LongPrototype2.isEven = function isEven2() {
      return (this.low & 1) === 0;
    };
    LongPrototype2.equals = function equals2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype2.eq = LongPrototype2.equals;
    LongPrototype2.notEquals = function notEquals2(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype2.neq = LongPrototype2.notEquals;
    LongPrototype2.ne = LongPrototype2.notEquals;
    LongPrototype2.lessThan = function lessThan2(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype2.lt = LongPrototype2.lessThan;
    LongPrototype2.lessThanOrEqual = function lessThanOrEqual2(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype2.lte = LongPrototype2.lessThanOrEqual;
    LongPrototype2.le = LongPrototype2.lessThanOrEqual;
    LongPrototype2.greaterThan = function greaterThan2(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype2.gt = LongPrototype2.greaterThan;
    LongPrototype2.greaterThanOrEqual = function greaterThanOrEqual2(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype2.gte = LongPrototype2.greaterThanOrEqual;
    LongPrototype2.ge = LongPrototype2.greaterThanOrEqual;
    LongPrototype2.compare = function compare2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype2.comp = LongPrototype2.compare;
    LongPrototype2.negate = function negate2() {
      if (!this.unsigned && this.eq(MIN_VALUE2))
        return MIN_VALUE2;
      return this.not().add(ONE3);
    };
    LongPrototype2.neg = LongPrototype2.negate;
    LongPrototype2.add = function add2(addend) {
      if (!isLong2(addend))
        addend = fromValue2(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype2.subtract = function subtract2(subtrahend) {
      if (!isLong2(subtrahend))
        subtrahend = fromValue2(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype2.sub = LongPrototype2.subtract;
    LongPrototype2.multiply = function multiply2(multiplier) {
      if (this.isZero())
        return ZERO2;
      if (!isLong2(multiplier))
        multiplier = fromValue2(multiplier);
      if (wasm2) {
        var low = wasm2.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits2(low, wasm2.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO2;
      if (this.eq(MIN_VALUE2))
        return multiplier.isOdd() ? MIN_VALUE2 : ZERO2;
      if (multiplier.eq(MIN_VALUE2))
        return this.isOdd() ? MIN_VALUE2 : ZERO2;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_242) && multiplier.lt(TWO_PWR_242))
        return fromNumber2(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype2.mul = LongPrototype2.multiply;
    LongPrototype2.divide = function divide2(divisor) {
      if (!isLong2(divisor))
        divisor = fromValue2(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm2) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm2.div_u : wasm2.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits2(low, wasm2.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO2 : ZERO2;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE2)) {
          if (divisor.eq(ONE3) || divisor.eq(NEG_ONE2))
            return MIN_VALUE2;
          else if (divisor.eq(MIN_VALUE2))
            return ONE3;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO2)) {
              return divisor.isNegative() ? ONE3 : NEG_ONE2;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE2))
          return this.unsigned ? UZERO2 : ZERO2;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO2;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO2;
        if (divisor.gt(this.shru(1)))
          return UONE2;
        res = UZERO2;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl2(2, log2 - 48), approxRes = fromNumber2(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber2(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE3;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype2.div = LongPrototype2.divide;
    LongPrototype2.modulo = function modulo2(divisor) {
      if (!isLong2(divisor))
        divisor = fromValue2(divisor);
      if (wasm2) {
        var low = (this.unsigned ? wasm2.rem_u : wasm2.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits2(low, wasm2.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype2.mod = LongPrototype2.modulo;
    LongPrototype2.rem = LongPrototype2.modulo;
    LongPrototype2.not = function not2() {
      return fromBits2(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype2.and = function and2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      return fromBits2(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype2.or = function or2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      return fromBits2(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype2.xor = function xor2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      return fromBits2(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype2.shiftLeft = function shiftLeft2(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits2(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits2(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype2.shl = LongPrototype2.shiftLeft;
    LongPrototype2.shiftRight = function shiftRight2(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits2(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits2(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype2.shr = LongPrototype2.shiftRight;
    LongPrototype2.shiftRightUnsigned = function shiftRightUnsigned2(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits2(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits2(high, 0, this.unsigned);
        else
          return fromBits2(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype2.shru = LongPrototype2.shiftRightUnsigned;
    LongPrototype2.shr_u = LongPrototype2.shiftRightUnsigned;
    LongPrototype2.toSigned = function toSigned2() {
      if (!this.unsigned)
        return this;
      return fromBits2(this.low, this.high, false);
    };
    LongPrototype2.toUnsigned = function toUnsigned2() {
      if (this.unsigned)
        return this;
      return fromBits2(this.low, this.high, true);
    };
    LongPrototype2.toBytes = function toBytes2(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype2.toBytesLE = function toBytesLE2() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype2.toBytesBE = function toBytesBE2() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long2.fromBytes = function fromBytes2(bytes, unsigned, le) {
      return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
    };
    Long2.fromBytesLE = function fromBytesLE2(bytes, unsigned) {
      return new Long2(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long2.fromBytesBE = function fromBytesBE2(bytes, unsigned) {
      return new Long2(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// node_modules/@keplr-wallet/proto-types/agoric/swingset/msgs.js
var require_msgs = __commonJS({
  "node_modules/@keplr-wallet/proto-types/agoric/swingset/msgs.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgInstallBundleResponse = exports2.MsgInstallBundle = exports2.MsgProvisionResponse = exports2.MsgProvision = exports2.MsgWalletSpendActionResponse = exports2.MsgWalletSpendAction = exports2.MsgWalletActionResponse = exports2.MsgWalletAction = exports2.MsgDeliverInboundResponse = exports2.MsgDeliverInbound = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "agoric.swingset";
    function createBaseMsgDeliverInbound() {
      return { messages: [], nums: [], ack: "0", submitter: new Uint8Array() };
    }
    exports2.MsgDeliverInbound = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.messages) {
          writer.uint32(10).string(v);
        }
        writer.uint32(18).fork();
        for (const v of message.nums) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.ack !== "0") {
          writer.uint32(24).uint64(message.ack);
        }
        if (message.submitter.length !== 0) {
          writer.uint32(34).bytes(message.submitter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeliverInbound();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(reader.string());
              break;
            case 2:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.nums.push(longToString(reader.uint64()));
                }
              } else {
                message.nums.push(longToString(reader.uint64()));
              }
              break;
            case 3:
              message.ack = longToString(reader.uint64());
              break;
            case 4:
              message.submitter = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages) ? object.messages.map((e) => String(e)) : [],
          nums: Array.isArray(object === null || object === void 0 ? void 0 : object.nums) ? object.nums.map((e) => String(e)) : [],
          ack: isSet3(object.ack) ? String(object.ack) : "0",
          submitter: isSet3(object.submitter) ? bytesFromBase642(object.submitter) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e);
        } else {
          obj.messages = [];
        }
        if (message.nums) {
          obj.nums = message.nums.map((e) => e);
        } else {
          obj.nums = [];
        }
        message.ack !== void 0 && (obj.ack = message.ack);
        message.submitter !== void 0 && (obj.submitter = base64FromBytes2(message.submitter !== void 0 ? message.submitter : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgDeliverInbound();
        message.messages = ((_a2 = object.messages) === null || _a2 === void 0 ? void 0 : _a2.map((e) => e)) || [];
        message.nums = ((_b = object.nums) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.ack = (_c = object.ack) !== null && _c !== void 0 ? _c : "0";
        message.submitter = (_d = object.submitter) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgDeliverInboundResponse() {
      return {};
    }
    exports2.MsgDeliverInboundResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeliverInboundResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDeliverInboundResponse();
        return message;
      }
    };
    function createBaseMsgWalletAction() {
      return { owner: new Uint8Array(), action: "" };
    }
    exports2.MsgWalletAction = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.owner.length !== 0) {
          writer.uint32(10).bytes(message.owner);
        }
        if (message.action !== "") {
          writer.uint32(18).string(message.action);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWalletAction();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.bytes();
              break;
            case 2:
              message.action = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          owner: isSet3(object.owner) ? bytesFromBase642(object.owner) : new Uint8Array(),
          action: isSet3(object.action) ? String(object.action) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.owner !== void 0 && (obj.owner = base64FromBytes2(message.owner !== void 0 ? message.owner : new Uint8Array()));
        message.action !== void 0 && (obj.action = message.action);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgWalletAction();
        message.owner = (_a2 = object.owner) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.action = (_b = object.action) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgWalletActionResponse() {
      return {};
    }
    exports2.MsgWalletActionResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWalletActionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgWalletActionResponse();
        return message;
      }
    };
    function createBaseMsgWalletSpendAction() {
      return { owner: new Uint8Array(), spendAction: "" };
    }
    exports2.MsgWalletSpendAction = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.owner.length !== 0) {
          writer.uint32(10).bytes(message.owner);
        }
        if (message.spendAction !== "") {
          writer.uint32(18).string(message.spendAction);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWalletSpendAction();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.bytes();
              break;
            case 2:
              message.spendAction = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          owner: isSet3(object.owner) ? bytesFromBase642(object.owner) : new Uint8Array(),
          spendAction: isSet3(object.spendAction) ? String(object.spendAction) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.owner !== void 0 && (obj.owner = base64FromBytes2(message.owner !== void 0 ? message.owner : new Uint8Array()));
        message.spendAction !== void 0 && (obj.spendAction = message.spendAction);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgWalletSpendAction();
        message.owner = (_a2 = object.owner) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.spendAction = (_b = object.spendAction) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgWalletSpendActionResponse() {
      return {};
    }
    exports2.MsgWalletSpendActionResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWalletSpendActionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgWalletSpendActionResponse();
        return message;
      }
    };
    function createBaseMsgProvision() {
      return {
        nickname: "",
        address: new Uint8Array(),
        powerFlags: [],
        submitter: new Uint8Array()
      };
    }
    exports2.MsgProvision = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nickname !== "") {
          writer.uint32(10).string(message.nickname);
        }
        if (message.address.length !== 0) {
          writer.uint32(18).bytes(message.address);
        }
        for (const v of message.powerFlags) {
          writer.uint32(26).string(v);
        }
        if (message.submitter.length !== 0) {
          writer.uint32(34).bytes(message.submitter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgProvision();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nickname = reader.string();
              break;
            case 2:
              message.address = reader.bytes();
              break;
            case 3:
              message.powerFlags.push(reader.string());
              break;
            case 4:
              message.submitter = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          nickname: isSet3(object.nickname) ? String(object.nickname) : "",
          address: isSet3(object.address) ? bytesFromBase642(object.address) : new Uint8Array(),
          powerFlags: Array.isArray(object === null || object === void 0 ? void 0 : object.powerFlags) ? object.powerFlags.map((e) => String(e)) : [],
          submitter: isSet3(object.submitter) ? bytesFromBase642(object.submitter) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.nickname !== void 0 && (obj.nickname = message.nickname);
        message.address !== void 0 && (obj.address = base64FromBytes2(message.address !== void 0 ? message.address : new Uint8Array()));
        if (message.powerFlags) {
          obj.powerFlags = message.powerFlags.map((e) => e);
        } else {
          obj.powerFlags = [];
        }
        message.submitter !== void 0 && (obj.submitter = base64FromBytes2(message.submitter !== void 0 ? message.submitter : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgProvision();
        message.nickname = (_a2 = object.nickname) !== null && _a2 !== void 0 ? _a2 : "";
        message.address = (_b = object.address) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.powerFlags = ((_c = object.powerFlags) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.submitter = (_d = object.submitter) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgProvisionResponse() {
      return {};
    }
    exports2.MsgProvisionResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgProvisionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgProvisionResponse();
        return message;
      }
    };
    function createBaseMsgInstallBundle() {
      return {
        bundle: "",
        submitter: new Uint8Array(),
        compressedBundle: new Uint8Array(),
        uncompressedSize: "0"
      };
    }
    exports2.MsgInstallBundle = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bundle !== "") {
          writer.uint32(10).string(message.bundle);
        }
        if (message.submitter.length !== 0) {
          writer.uint32(18).bytes(message.submitter);
        }
        if (message.compressedBundle.length !== 0) {
          writer.uint32(26).bytes(message.compressedBundle);
        }
        if (message.uncompressedSize !== "0") {
          writer.uint32(32).int64(message.uncompressedSize);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstallBundle();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bundle = reader.string();
              break;
            case 2:
              message.submitter = reader.bytes();
              break;
            case 3:
              message.compressedBundle = reader.bytes();
              break;
            case 4:
              message.uncompressedSize = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          bundle: isSet3(object.bundle) ? String(object.bundle) : "",
          submitter: isSet3(object.submitter) ? bytesFromBase642(object.submitter) : new Uint8Array(),
          compressedBundle: isSet3(object.compressedBundle) ? bytesFromBase642(object.compressedBundle) : new Uint8Array(),
          uncompressedSize: isSet3(object.uncompressedSize) ? String(object.uncompressedSize) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.bundle !== void 0 && (obj.bundle = message.bundle);
        message.submitter !== void 0 && (obj.submitter = base64FromBytes2(message.submitter !== void 0 ? message.submitter : new Uint8Array()));
        message.compressedBundle !== void 0 && (obj.compressedBundle = base64FromBytes2(message.compressedBundle !== void 0 ? message.compressedBundle : new Uint8Array()));
        message.uncompressedSize !== void 0 && (obj.uncompressedSize = message.uncompressedSize);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgInstallBundle();
        message.bundle = (_a2 = object.bundle) !== null && _a2 !== void 0 ? _a2 : "";
        message.submitter = (_b = object.submitter) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.compressedBundle = (_c = object.compressedBundle) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.uncompressedSize = (_d = object.uncompressedSize) !== null && _d !== void 0 ? _d : "0";
        return message;
      }
    };
    function createBaseMsgInstallBundleResponse() {
      return {};
    }
    exports2.MsgInstallBundleResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstallBundleResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgInstallBundleResponse();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js
var require_coin2 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DecProto = exports2.IntProto = exports2.DecCoin = exports2.Coin = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "cosmos.base.v1beta1";
    function createBaseCoin2() {
      return { denom: "", amount: "" };
    }
    exports2.Coin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCoin2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          denom: isSet3(object.denom) ? String(object.denom) : "",
          amount: isSet3(object.amount) ? String(object.amount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseCoin2();
        message.denom = (_a2 = object.denom) !== null && _a2 !== void 0 ? _a2 : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseDecCoin() {
      return { denom: "", amount: "" };
    }
    exports2.DecCoin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecCoin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          denom: isSet3(object.denom) ? String(object.denom) : "",
          amount: isSet3(object.amount) ? String(object.amount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseDecCoin();
        message.denom = (_a2 = object.denom) !== null && _a2 !== void 0 ? _a2 : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseIntProto() {
      return { int: "" };
    }
    exports2.IntProto = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.int !== "") {
          writer.uint32(10).string(message.int);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIntProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.int = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          int: isSet3(object.int) ? String(object.int) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.int !== void 0 && (obj.int = message.int);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseIntProto();
        message.int = (_a2 = object.int) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseDecProto() {
      return { dec: "" };
    }
    exports2.DecProto = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.dec !== "") {
          writer.uint32(10).string(message.dec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.dec = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          dec: isSet3(object.dec) ? String(object.dec) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.dec !== void 0 && (obj.dec = message.dec);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDecProto();
        message.dec = (_a2 = object.dec) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/bank.js
var require_bank = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/bank.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = exports2.DenomUnit = exports2.Supply = exports2.Output = exports2.Input = exports2.SendEnabled = exports2.Params = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    exports2.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseParams() {
      return { sendEnabled: [], defaultSendEnabled: false };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.sendEnabled) {
          exports2.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.defaultSendEnabled === true) {
          writer.uint32(16).bool(message.defaultSendEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled.push(exports2.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 2:
              message.defaultSendEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sendEnabled: Array.isArray(object === null || object === void 0 ? void 0 : object.sendEnabled) ? object.sendEnabled.map((e) => exports2.SendEnabled.fromJSON(e)) : [],
          defaultSendEnabled: isSet3(object.defaultSendEnabled) ? Boolean(object.defaultSendEnabled) : false
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? exports2.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        message.defaultSendEnabled !== void 0 && (obj.defaultSendEnabled = message.defaultSendEnabled);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseParams();
        message.sendEnabled = ((_a2 = object.sendEnabled) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.SendEnabled.fromPartial(e))) || [];
        message.defaultSendEnabled = (_b = object.defaultSendEnabled) !== null && _b !== void 0 ? _b : false;
        return message;
      }
    };
    function createBaseSendEnabled() {
      return { denom: "", enabled: false };
    }
    exports2.SendEnabled = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.enabled === true) {
          writer.uint32(16).bool(message.enabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSendEnabled();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.enabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          denom: isSet3(object.denom) ? String(object.denom) : "",
          enabled: isSet3(object.enabled) ? Boolean(object.enabled) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.enabled !== void 0 && (obj.enabled = message.enabled);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseSendEnabled();
        message.denom = (_a2 = object.denom) !== null && _a2 !== void 0 ? _a2 : "";
        message.enabled = (_b = object.enabled) !== null && _b !== void 0 ? _b : false;
        return message;
      }
    };
    function createBaseInput() {
      return { address: "", coins: [] };
    }
    exports2.Input = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v of message.coins) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet3(object.address) ? String(object.address) : "",
          coins: Array.isArray(object === null || object === void 0 ? void 0 : object.coins) ? object.coins.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseInput();
        message.address = (_a2 = object.address) !== null && _a2 !== void 0 ? _a2 : "";
        message.coins = ((_b = object.coins) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseOutput() {
      return { address: "", coins: [] };
    }
    exports2.Output = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v of message.coins) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseOutput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet3(object.address) ? String(object.address) : "",
          coins: Array.isArray(object === null || object === void 0 ? void 0 : object.coins) ? object.coins.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseOutput();
        message.address = (_a2 = object.address) !== null && _a2 !== void 0 ? _a2 : "";
        message.coins = ((_b = object.coins) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSupply() {
      return { total: [] };
    }
    exports2.Supply = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.total) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSupply();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          total: Array.isArray(object === null || object === void 0 ? void 0 : object.total) ? object.total.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSupply();
        message.total = ((_a2 = object.total) === null || _a2 === void 0 ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDenomUnit() {
      return { denom: "", exponent: 0, aliases: [] };
    }
    exports2.DenomUnit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.exponent !== 0) {
          writer.uint32(16).uint32(message.exponent);
        }
        for (const v of message.aliases) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomUnit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.exponent = reader.uint32();
              break;
            case 3:
              message.aliases.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          denom: isSet3(object.denom) ? String(object.denom) : "",
          exponent: isSet3(object.exponent) ? Number(object.exponent) : 0,
          aliases: Array.isArray(object === null || object === void 0 ? void 0 : object.aliases) ? object.aliases.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.exponent !== void 0 && (obj.exponent = Math.round(message.exponent));
        if (message.aliases) {
          obj.aliases = message.aliases.map((e) => e);
        } else {
          obj.aliases = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseDenomUnit();
        message.denom = (_a2 = object.denom) !== null && _a2 !== void 0 ? _a2 : "";
        message.exponent = (_b = object.exponent) !== null && _b !== void 0 ? _b : 0;
        message.aliases = ((_c = object.aliases) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMetadata() {
      return {
        description: "",
        denomUnits: [],
        base: "",
        display: "",
        name: "",
        symbol: ""
      };
    }
    exports2.Metadata = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== "") {
          writer.uint32(10).string(message.description);
        }
        for (const v of message.denomUnits) {
          exports2.DenomUnit.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.base !== "") {
          writer.uint32(26).string(message.base);
        }
        if (message.display !== "") {
          writer.uint32(34).string(message.display);
        }
        if (message.name !== "") {
          writer.uint32(42).string(message.name);
        }
        if (message.symbol !== "") {
          writer.uint32(50).string(message.symbol);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = reader.string();
              break;
            case 2:
              message.denomUnits.push(exports2.DenomUnit.decode(reader, reader.uint32()));
              break;
            case 3:
              message.base = reader.string();
              break;
            case 4:
              message.display = reader.string();
              break;
            case 5:
              message.name = reader.string();
              break;
            case 6:
              message.symbol = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          description: isSet3(object.description) ? String(object.description) : "",
          denomUnits: Array.isArray(object === null || object === void 0 ? void 0 : object.denomUnits) ? object.denomUnits.map((e) => exports2.DenomUnit.fromJSON(e)) : [],
          base: isSet3(object.base) ? String(object.base) : "",
          display: isSet3(object.display) ? String(object.display) : "",
          name: isSet3(object.name) ? String(object.name) : "",
          symbol: isSet3(object.symbol) ? String(object.symbol) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description);
        if (message.denomUnits) {
          obj.denomUnits = message.denomUnits.map((e) => e ? exports2.DenomUnit.toJSON(e) : void 0);
        } else {
          obj.denomUnits = [];
        }
        message.base !== void 0 && (obj.base = message.base);
        message.display !== void 0 && (obj.display = message.display);
        message.name !== void 0 && (obj.name = message.name);
        message.symbol !== void 0 && (obj.symbol = message.symbol);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f;
        const message = createBaseMetadata();
        message.description = (_a2 = object.description) !== null && _a2 !== void 0 ? _a2 : "";
        message.denomUnits = ((_b = object.denomUnits) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.DenomUnit.fromPartial(e))) || [];
        message.base = (_c = object.base) !== null && _c !== void 0 ? _c : "";
        message.display = (_d = object.display) !== null && _d !== void 0 ? _d : "";
        message.name = (_e = object.name) !== null && _e !== void 0 ? _e : "";
        message.symbol = (_f = object.symbol) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx.js
var require_tx4 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgMultiSendResponse = exports2.MsgMultiSend = exports2.MsgSendResponse = exports2.MsgSend = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    var bank_1 = require_bank();
    exports2.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseMsgSend() {
      return { fromAddress: "", toAddress: "", amount: [] };
    }
    exports2.MsgSend = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          fromAddress: isSet3(object.fromAddress) ? String(object.fromAddress) : "",
          toAddress: isSet3(object.toAddress) ? String(object.toAddress) : "",
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgSend();
        message.fromAddress = (_a2 = object.fromAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.toAddress = (_b = object.toAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = ((_c = object.amount) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgSendResponse() {
      return {};
    }
    exports2.MsgSendResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSendResponse();
        return message;
      }
    };
    function createBaseMsgMultiSend() {
      return { inputs: [], outputs: [] };
    }
    exports2.MsgMultiSend = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.inputs) {
          bank_1.Input.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.outputs) {
          bank_1.Output.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));
              break;
            case 2:
              message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          inputs: Array.isArray(object === null || object === void 0 ? void 0 : object.inputs) ? object.inputs.map((e) => bank_1.Input.fromJSON(e)) : [],
          outputs: Array.isArray(object === null || object === void 0 ? void 0 : object.outputs) ? object.outputs.map((e) => bank_1.Output.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.inputs) {
          obj.inputs = message.inputs.map((e) => e ? bank_1.Input.toJSON(e) : void 0);
        } else {
          obj.inputs = [];
        }
        if (message.outputs) {
          obj.outputs = message.outputs.map((e) => e ? bank_1.Output.toJSON(e) : void 0);
        } else {
          obj.outputs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgMultiSend();
        message.inputs = ((_a2 = object.inputs) === null || _a2 === void 0 ? void 0 : _a2.map((e) => bank_1.Input.fromPartial(e))) || [];
        message.outputs = ((_b = object.outputs) === null || _b === void 0 ? void 0 : _b.map((e) => bank_1.Output.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgMultiSendResponse() {
      return {};
    }
    exports2.MsgMultiSendResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgMultiSendResponse();
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timestamp = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "google.protobuf";
    function createBaseTimestamp() {
      return { seconds: "0", nanos: 0 };
    }
    exports2.Timestamp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.seconds !== "0") {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = longToString(reader.int64());
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          seconds: isSet3(object.seconds) ? String(object.seconds) : "0",
          nanos: isSet3(object.nanos) ? Number(object.nanos) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = message.seconds);
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseTimestamp();
        message.seconds = (_a2 = object.seconds) !== null && _a2 !== void 0 ? _a2 : "0";
        message.nanos = (_b = object.nanos) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/tendermint/crypto/proof.js
var require_proof = __commonJS({
  "node_modules/@keplr-wallet/proto-types/tendermint/crypto/proof.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProofOps = exports2.ProofOp = exports2.DominoOp = exports2.ValueOp = exports2.Proof = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "tendermint.crypto";
    function createBaseProof() {
      return { total: "0", index: "0", leafHash: new Uint8Array(), aunts: [] };
    }
    exports2.Proof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.total !== "0") {
          writer.uint32(8).int64(message.total);
        }
        if (message.index !== "0") {
          writer.uint32(16).int64(message.index);
        }
        if (message.leafHash.length !== 0) {
          writer.uint32(26).bytes(message.leafHash);
        }
        for (const v of message.aunts) {
          writer.uint32(34).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = longToString(reader.int64());
              break;
            case 2:
              message.index = longToString(reader.int64());
              break;
            case 3:
              message.leafHash = reader.bytes();
              break;
            case 4:
              message.aunts.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          total: isSet3(object.total) ? String(object.total) : "0",
          index: isSet3(object.index) ? String(object.index) : "0",
          leafHash: isSet3(object.leafHash) ? bytesFromBase642(object.leafHash) : new Uint8Array(),
          aunts: Array.isArray(object === null || object === void 0 ? void 0 : object.aunts) ? object.aunts.map((e) => bytesFromBase642(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = message.total);
        message.index !== void 0 && (obj.index = message.index);
        message.leafHash !== void 0 && (obj.leafHash = base64FromBytes2(message.leafHash !== void 0 ? message.leafHash : new Uint8Array()));
        if (message.aunts) {
          obj.aunts = message.aunts.map((e) => base64FromBytes2(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.aunts = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseProof();
        message.total = (_a2 = object.total) !== null && _a2 !== void 0 ? _a2 : "0";
        message.index = (_b = object.index) !== null && _b !== void 0 ? _b : "0";
        message.leafHash = (_c = object.leafHash) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.aunts = ((_d = object.aunts) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseValueOp() {
      return { key: new Uint8Array(), proof: void 0 };
    }
    exports2.ValueOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.proof !== void 0) {
          exports2.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValueOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.proof = exports2.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet3(object.key) ? bytesFromBase642(object.key) : new Uint8Array(),
          proof: isSet3(object.proof) ? exports2.Proof.fromJSON(object.proof) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes2(message.key !== void 0 ? message.key : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? exports2.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValueOp();
        message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? exports2.Proof.fromPartial(object.proof) : void 0;
        return message;
      }
    };
    function createBaseDominoOp() {
      return { key: "", input: "", output: "" };
    }
    exports2.DominoOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.input !== "") {
          writer.uint32(18).string(message.input);
        }
        if (message.output !== "") {
          writer.uint32(26).string(message.output);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDominoOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.input = reader.string();
              break;
            case 3:
              message.output = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet3(object.key) ? String(object.key) : "",
          input: isSet3(object.input) ? String(object.input) : "",
          output: isSet3(object.output) ? String(object.output) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.input !== void 0 && (obj.input = message.input);
        message.output !== void 0 && (obj.output = message.output);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseDominoOp();
        message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : "";
        message.input = (_b = object.input) !== null && _b !== void 0 ? _b : "";
        message.output = (_c = object.output) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseProofOp() {
      return { type: "", key: new Uint8Array(), data: new Uint8Array() };
    }
    exports2.ProofOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.key.length !== 0) {
          writer.uint32(18).bytes(message.key);
        }
        if (message.data.length !== 0) {
          writer.uint32(26).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.key = reader.bytes();
              break;
            case 3:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          type: isSet3(object.type) ? String(object.type) : "",
          key: isSet3(object.key) ? bytesFromBase642(object.key) : new Uint8Array(),
          data: isSet3(object.data) ? bytesFromBase642(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        message.key !== void 0 && (obj.key = base64FromBytes2(message.key !== void 0 ? message.key : new Uint8Array()));
        message.data !== void 0 && (obj.data = base64FromBytes2(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseProofOp();
        message.type = (_a2 = object.type) !== null && _a2 !== void 0 ? _a2 : "";
        message.key = (_b = object.key) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    function createBaseProofOps() {
      return { ops: [] };
    }
    exports2.ProofOps = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.ops) {
          exports2.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOps();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ops.push(exports2.ProofOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          ops: Array.isArray(object === null || object === void 0 ? void 0 : object.ops) ? object.ops.map((e) => exports2.ProofOp.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.ops) {
          obj.ops = message.ops.map((e) => e ? exports2.ProofOp.toJSON(e) : void 0);
        } else {
          obj.ops = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseProofOps();
        message.ops = ((_a2 = object.ops) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.ProofOp.fromPartial(e))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/tendermint/version/types.js
var require_types2 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/tendermint/version/types.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Consensus = exports2.App = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "tendermint.version";
    function createBaseApp() {
      return { protocol: "0", software: "" };
    }
    exports2.App = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.protocol !== "0") {
          writer.uint32(8).uint64(message.protocol);
        }
        if (message.software !== "") {
          writer.uint32(18).string(message.software);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseApp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.protocol = longToString(reader.uint64());
              break;
            case 2:
              message.software = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          protocol: isSet3(object.protocol) ? String(object.protocol) : "0",
          software: isSet3(object.software) ? String(object.software) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.protocol !== void 0 && (obj.protocol = message.protocol);
        message.software !== void 0 && (obj.software = message.software);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseApp();
        message.protocol = (_a2 = object.protocol) !== null && _a2 !== void 0 ? _a2 : "0";
        message.software = (_b = object.software) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseConsensus() {
      return { block: "0", app: "0" };
    }
    exports2.Consensus = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.block !== "0") {
          writer.uint32(8).uint64(message.block);
        }
        if (message.app !== "0") {
          writer.uint32(16).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensus();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = longToString(reader.uint64());
              break;
            case 2:
              message.app = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          block: isSet3(object.block) ? String(object.block) : "0",
          app: isSet3(object.app) ? String(object.app) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = message.block);
        message.app !== void 0 && (obj.app = message.app);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseConsensus();
        message.block = (_a2 = object.block) !== null && _a2 !== void 0 ? _a2 : "0";
        message.app = (_b = object.app) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/tendermint/crypto/keys.js
var require_keys = __commonJS({
  "node_modules/@keplr-wallet/proto-types/tendermint/crypto/keys.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKey = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "tendermint.crypto";
    function createBasePublicKey() {
      return { ed25519: void 0, secp256k1: void 0 };
    }
    exports2.PublicKey = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ed25519 !== void 0) {
          writer.uint32(10).bytes(message.ed25519);
        }
        if (message.secp256k1 !== void 0) {
          writer.uint32(18).bytes(message.secp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ed25519 = reader.bytes();
              break;
            case 2:
              message.secp256k1 = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          ed25519: isSet3(object.ed25519) ? bytesFromBase642(object.ed25519) : void 0,
          secp256k1: isSet3(object.secp256k1) ? bytesFromBase642(object.secp256k1) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.ed25519 !== void 0 && (obj.ed25519 = message.ed25519 !== void 0 ? base64FromBytes2(message.ed25519) : void 0);
        message.secp256k1 !== void 0 && (obj.secp256k1 = message.secp256k1 !== void 0 ? base64FromBytes2(message.secp256k1) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBasePublicKey();
        message.ed25519 = (_a2 = object.ed25519) !== null && _a2 !== void 0 ? _a2 : void 0;
        message.secp256k1 = (_b = object.secp256k1) !== null && _b !== void 0 ? _b : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/tendermint/types/validator.js
var require_validator = __commonJS({
  "node_modules/@keplr-wallet/proto-types/tendermint/types/validator.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SimpleValidator = exports2.Validator = exports2.ValidatorSet = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var keys_1 = require_keys();
    exports2.protobufPackage = "tendermint.types";
    function createBaseValidatorSet() {
      return { validators: [], proposer: void 0, totalVotingPower: "0" };
    }
    exports2.ValidatorSet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validators) {
          exports2.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.proposer !== void 0) {
          exports2.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== "0") {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(exports2.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.proposer = exports2.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators) ? object.validators.map((e) => exports2.Validator.fromJSON(e)) : [],
          proposer: isSet3(object.proposer) ? exports2.Validator.fromJSON(object.proposer) : void 0,
          totalVotingPower: isSet3(object.totalVotingPower) ? String(object.totalVotingPower) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports2.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer ? exports2.Validator.toJSON(message.proposer) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = message.totalVotingPower);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseValidatorSet();
        message.validators = ((_a2 = object.validators) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.Validator.fromPartial(e))) || [];
        message.proposer = object.proposer !== void 0 && object.proposer !== null ? exports2.Validator.fromPartial(object.proposer) : void 0;
        message.totalVotingPower = (_b = object.totalVotingPower) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function createBaseValidator() {
      return {
        address: new Uint8Array(),
        pubKey: void 0,
        votingPower: "0",
        proposerPriority: "0"
      };
    }
    exports2.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPower !== "0") {
          writer.uint32(24).int64(message.votingPower);
        }
        if (message.proposerPriority !== "0") {
          writer.uint32(32).int64(message.proposerPriority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 2:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPower = longToString(reader.int64());
              break;
            case 4:
              message.proposerPriority = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet3(object.address) ? bytesFromBase642(object.address) : new Uint8Array(),
          pubKey: isSet3(object.pubKey) ? keys_1.PublicKey.fromJSON(object.pubKey) : void 0,
          votingPower: isSet3(object.votingPower) ? String(object.votingPower) : "0",
          proposerPriority: isSet3(object.proposerPriority) ? String(object.proposerPriority) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = base64FromBytes2(message.address !== void 0 ? message.address : new Uint8Array()));
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = message.votingPower);
        message.proposerPriority !== void 0 && (obj.proposerPriority = message.proposerPriority);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseValidator();
        message.address = (_a2 = object.address) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : void 0;
        message.votingPower = (_b = object.votingPower) !== null && _b !== void 0 ? _b : "0";
        message.proposerPriority = (_c = object.proposerPriority) !== null && _c !== void 0 ? _c : "0";
        return message;
      }
    };
    function createBaseSimpleValidator() {
      return { pubKey: void 0, votingPower: "0" };
    }
    exports2.SimpleValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.votingPower !== "0") {
          writer.uint32(16).int64(message.votingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimpleValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.votingPower = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          pubKey: isSet3(object.pubKey) ? keys_1.PublicKey.fromJSON(object.pubKey) : void 0,
          votingPower: isSet3(object.votingPower) ? String(object.votingPower) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = message.votingPower);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSimpleValidator();
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : void 0;
        message.votingPower = (_a2 = object.votingPower) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/tendermint/types/types.js
var require_types3 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/tendermint/types/types.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TxProof = exports2.BlockMeta = exports2.LightBlock = exports2.SignedHeader = exports2.Proposal = exports2.CommitSig = exports2.Commit = exports2.Vote = exports2.Data = exports2.Header = exports2.BlockID = exports2.Part = exports2.PartSetHeader = exports2.signedMsgTypeToJSON = exports2.signedMsgTypeFromJSON = exports2.SignedMsgType = exports2.blockIDFlagToJSON = exports2.blockIDFlagFromJSON = exports2.BlockIDFlag = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var proof_1 = require_proof();
    var types_1 = require_types2();
    var validator_1 = require_validator();
    exports2.protobufPackage = "tendermint.types";
    var BlockIDFlag;
    (function(BlockIDFlag2) {
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
      BlockIDFlag2[BlockIDFlag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BlockIDFlag = exports2.BlockIDFlag || (exports2.BlockIDFlag = {}));
    function blockIDFlagFromJSON(object) {
      switch (object) {
        case 0:
        case "BLOCK_ID_FLAG_UNKNOWN":
          return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
        case 1:
        case "BLOCK_ID_FLAG_ABSENT":
          return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
        case 2:
        case "BLOCK_ID_FLAG_COMMIT":
          return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
        case 3:
        case "BLOCK_ID_FLAG_NIL":
          return BlockIDFlag.BLOCK_ID_FLAG_NIL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BlockIDFlag.UNRECOGNIZED;
      }
    }
    exports2.blockIDFlagFromJSON = blockIDFlagFromJSON;
    function blockIDFlagToJSON(object) {
      switch (object) {
        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
          return "BLOCK_ID_FLAG_UNKNOWN";
        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
          return "BLOCK_ID_FLAG_ABSENT";
        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
          return "BLOCK_ID_FLAG_COMMIT";
        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
          return "BLOCK_ID_FLAG_NIL";
        default:
          return "UNKNOWN";
      }
    }
    exports2.blockIDFlagToJSON = blockIDFlagToJSON;
    var SignedMsgType;
    (function(SignedMsgType2) {
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
      SignedMsgType2[SignedMsgType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignedMsgType = exports2.SignedMsgType || (exports2.SignedMsgType = {}));
    function signedMsgTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGNED_MSG_TYPE_UNKNOWN":
          return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
        case 1:
        case "SIGNED_MSG_TYPE_PREVOTE":
          return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
        case 2:
        case "SIGNED_MSG_TYPE_PRECOMMIT":
          return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
        case 32:
        case "SIGNED_MSG_TYPE_PROPOSAL":
          return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignedMsgType.UNRECOGNIZED;
      }
    }
    exports2.signedMsgTypeFromJSON = signedMsgTypeFromJSON;
    function signedMsgTypeToJSON(object) {
      switch (object) {
        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
          return "SIGNED_MSG_TYPE_UNKNOWN";
        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
          return "SIGNED_MSG_TYPE_PREVOTE";
        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
          return "SIGNED_MSG_TYPE_PRECOMMIT";
        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
          return "SIGNED_MSG_TYPE_PROPOSAL";
        default:
          return "UNKNOWN";
      }
    }
    exports2.signedMsgTypeToJSON = signedMsgTypeToJSON;
    function createBasePartSetHeader() {
      return { total: 0, hash: new Uint8Array() };
    }
    exports2.PartSetHeader = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.total !== 0) {
          writer.uint32(8).uint32(message.total);
        }
        if (message.hash.length !== 0) {
          writer.uint32(18).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePartSetHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.uint32();
              break;
            case 2:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          total: isSet3(object.total) ? Number(object.total) : 0,
          hash: isSet3(object.hash) ? bytesFromBase642(object.hash) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = Math.round(message.total));
        message.hash !== void 0 && (obj.hash = base64FromBytes2(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBasePartSetHeader();
        message.total = (_a2 = object.total) !== null && _a2 !== void 0 ? _a2 : 0;
        message.hash = (_b = object.hash) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBasePart() {
      return { index: 0, bytes: new Uint8Array(), proof: void 0 };
    }
    exports2.Part = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.bytes.length !== 0) {
          writer.uint32(18).bytes(message.bytes);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePart();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.bytes = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          index: isSet3(object.index) ? Number(object.index) : 0,
          bytes: isSet3(object.bytes) ? bytesFromBase642(object.bytes) : new Uint8Array(),
          proof: isSet3(object.proof) ? proof_1.Proof.fromJSON(object.proof) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.bytes !== void 0 && (obj.bytes = base64FromBytes2(message.bytes !== void 0 ? message.bytes : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBasePart();
        message.index = (_a2 = object.index) !== null && _a2 !== void 0 ? _a2 : 0;
        message.bytes = (_b = object.bytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? proof_1.Proof.fromPartial(object.proof) : void 0;
        return message;
      }
    };
    function createBaseBlockID() {
      return { hash: new Uint8Array(), partSetHeader: void 0 };
    }
    exports2.BlockID = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.partSetHeader !== void 0) {
          exports2.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockID();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.partSetHeader = exports2.PartSetHeader.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          hash: isSet3(object.hash) ? bytesFromBase642(object.hash) : new Uint8Array(),
          partSetHeader: isSet3(object.partSetHeader) ? exports2.PartSetHeader.fromJSON(object.partSetHeader) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = base64FromBytes2(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.partSetHeader !== void 0 && (obj.partSetHeader = message.partSetHeader ? exports2.PartSetHeader.toJSON(message.partSetHeader) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseBlockID();
        message.hash = (_a2 = object.hash) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.partSetHeader = object.partSetHeader !== void 0 && object.partSetHeader !== null ? exports2.PartSetHeader.fromPartial(object.partSetHeader) : void 0;
        return message;
      }
    };
    function createBaseHeader() {
      return {
        version: void 0,
        chainId: "",
        height: "0",
        time: void 0,
        lastBlockId: void 0,
        lastCommitHash: new Uint8Array(),
        dataHash: new Uint8Array(),
        validatorsHash: new Uint8Array(),
        nextValidatorsHash: new Uint8Array(),
        consensusHash: new Uint8Array(),
        appHash: new Uint8Array(),
        lastResultsHash: new Uint8Array(),
        evidenceHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports2.Header = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.version !== void 0) {
          types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.height !== "0") {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.time), writer.uint32(34).fork()).ldelim();
        }
        if (message.lastBlockId !== void 0) {
          exports2.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.lastCommitHash.length !== 0) {
          writer.uint32(50).bytes(message.lastCommitHash);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(58).bytes(message.dataHash);
        }
        if (message.validatorsHash.length !== 0) {
          writer.uint32(66).bytes(message.validatorsHash);
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(74).bytes(message.nextValidatorsHash);
        }
        if (message.consensusHash.length !== 0) {
          writer.uint32(82).bytes(message.consensusHash);
        }
        if (message.appHash.length !== 0) {
          writer.uint32(90).bytes(message.appHash);
        }
        if (message.lastResultsHash.length !== 0) {
          writer.uint32(98).bytes(message.lastResultsHash);
        }
        if (message.evidenceHash.length !== 0) {
          writer.uint32(106).bytes(message.evidenceHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(114).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = types_1.Consensus.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.height = longToString(reader.int64());
              break;
            case 4:
              message.time = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 5:
              message.lastBlockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.lastCommitHash = reader.bytes();
              break;
            case 7:
              message.dataHash = reader.bytes();
              break;
            case 8:
              message.validatorsHash = reader.bytes();
              break;
            case 9:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 10:
              message.consensusHash = reader.bytes();
              break;
            case 11:
              message.appHash = reader.bytes();
              break;
            case 12:
              message.lastResultsHash = reader.bytes();
              break;
            case 13:
              message.evidenceHash = reader.bytes();
              break;
            case 14:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          version: isSet3(object.version) ? types_1.Consensus.fromJSON(object.version) : void 0,
          chainId: isSet3(object.chainId) ? String(object.chainId) : "",
          height: isSet3(object.height) ? String(object.height) : "0",
          time: isSet3(object.time) ? fromJsonTimestamp(object.time) : void 0,
          lastBlockId: isSet3(object.lastBlockId) ? exports2.BlockID.fromJSON(object.lastBlockId) : void 0,
          lastCommitHash: isSet3(object.lastCommitHash) ? bytesFromBase642(object.lastCommitHash) : new Uint8Array(),
          dataHash: isSet3(object.dataHash) ? bytesFromBase642(object.dataHash) : new Uint8Array(),
          validatorsHash: isSet3(object.validatorsHash) ? bytesFromBase642(object.validatorsHash) : new Uint8Array(),
          nextValidatorsHash: isSet3(object.nextValidatorsHash) ? bytesFromBase642(object.nextValidatorsHash) : new Uint8Array(),
          consensusHash: isSet3(object.consensusHash) ? bytesFromBase642(object.consensusHash) : new Uint8Array(),
          appHash: isSet3(object.appHash) ? bytesFromBase642(object.appHash) : new Uint8Array(),
          lastResultsHash: isSet3(object.lastResultsHash) ? bytesFromBase642(object.lastResultsHash) : new Uint8Array(),
          evidenceHash: isSet3(object.evidenceHash) ? bytesFromBase642(object.evidenceHash) : new Uint8Array(),
          proposerAddress: isSet3(object.proposerAddress) ? bytesFromBase642(object.proposerAddress) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version ? types_1.Consensus.toJSON(message.version) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.height !== void 0 && (obj.height = message.height);
        message.time !== void 0 && (obj.time = message.time.toISOString());
        message.lastBlockId !== void 0 && (obj.lastBlockId = message.lastBlockId ? exports2.BlockID.toJSON(message.lastBlockId) : void 0);
        message.lastCommitHash !== void 0 && (obj.lastCommitHash = base64FromBytes2(message.lastCommitHash !== void 0 ? message.lastCommitHash : new Uint8Array()));
        message.dataHash !== void 0 && (obj.dataHash = base64FromBytes2(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.validatorsHash !== void 0 && (obj.validatorsHash = base64FromBytes2(message.validatorsHash !== void 0 ? message.validatorsHash : new Uint8Array()));
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = base64FromBytes2(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.consensusHash !== void 0 && (obj.consensusHash = base64FromBytes2(message.consensusHash !== void 0 ? message.consensusHash : new Uint8Array()));
        message.appHash !== void 0 && (obj.appHash = base64FromBytes2(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        message.lastResultsHash !== void 0 && (obj.lastResultsHash = base64FromBytes2(message.lastResultsHash !== void 0 ? message.lastResultsHash : new Uint8Array()));
        message.evidenceHash !== void 0 && (obj.evidenceHash = base64FromBytes2(message.evidenceHash !== void 0 ? message.evidenceHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = base64FromBytes2(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const message = createBaseHeader();
        message.version = object.version !== void 0 && object.version !== null ? types_1.Consensus.fromPartial(object.version) : void 0;
        message.chainId = (_a2 = object.chainId) !== null && _a2 !== void 0 ? _a2 : "";
        message.height = (_b = object.height) !== null && _b !== void 0 ? _b : "0";
        message.time = (_c = object.time) !== null && _c !== void 0 ? _c : void 0;
        message.lastBlockId = object.lastBlockId !== void 0 && object.lastBlockId !== null ? exports2.BlockID.fromPartial(object.lastBlockId) : void 0;
        message.lastCommitHash = (_d = object.lastCommitHash) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.dataHash = (_e = object.dataHash) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.validatorsHash = (_f = object.validatorsHash) !== null && _f !== void 0 ? _f : new Uint8Array();
        message.nextValidatorsHash = (_g = object.nextValidatorsHash) !== null && _g !== void 0 ? _g : new Uint8Array();
        message.consensusHash = (_h = object.consensusHash) !== null && _h !== void 0 ? _h : new Uint8Array();
        message.appHash = (_j = object.appHash) !== null && _j !== void 0 ? _j : new Uint8Array();
        message.lastResultsHash = (_k = object.lastResultsHash) !== null && _k !== void 0 ? _k : new Uint8Array();
        message.evidenceHash = (_l = object.evidenceHash) !== null && _l !== void 0 ? _l : new Uint8Array();
        message.proposerAddress = (_m = object.proposerAddress) !== null && _m !== void 0 ? _m : new Uint8Array();
        return message;
      }
    };
    function createBaseData() {
      return { txs: [] };
    }
    exports2.Data = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          txs: Array.isArray(object === null || object === void 0 ? void 0 : object.txs) ? object.txs.map((e) => bytesFromBase642(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => base64FromBytes2(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseData();
        message.txs = ((_a2 = object.txs) === null || _a2 === void 0 ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseVote() {
      return {
        type: 0,
        height: "0",
        round: 0,
        blockId: void 0,
        timestamp: void 0,
        validatorAddress: new Uint8Array(),
        validatorIndex: 0,
        signature: new Uint8Array()
      };
    }
    exports2.Vote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== "0") {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(42).fork()).ldelim();
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(50).bytes(message.validatorAddress);
        }
        if (message.validatorIndex !== 0) {
          writer.uint32(56).int32(message.validatorIndex);
        }
        if (message.signature.length !== 0) {
          writer.uint32(66).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = longToString(reader.int64());
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 5:
              message.timestamp = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 6:
              message.validatorAddress = reader.bytes();
              break;
            case 7:
              message.validatorIndex = reader.int32();
              break;
            case 8:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          type: isSet3(object.type) ? signedMsgTypeFromJSON(object.type) : 0,
          height: isSet3(object.height) ? String(object.height) : "0",
          round: isSet3(object.round) ? Number(object.round) : 0,
          blockId: isSet3(object.blockId) ? exports2.BlockID.fromJSON(object.blockId) : void 0,
          timestamp: isSet3(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0,
          validatorAddress: isSet3(object.validatorAddress) ? bytesFromBase642(object.validatorAddress) : new Uint8Array(),
          validatorIndex: isSet3(object.validatorIndex) ? Number(object.validatorIndex) : 0,
          signature: isSet3(object.signature) ? bytesFromBase642(object.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = message.height);
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
        message.validatorAddress !== void 0 && (obj.validatorAddress = base64FromBytes2(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.validatorIndex !== void 0 && (obj.validatorIndex = Math.round(message.validatorIndex));
        message.signature !== void 0 && (obj.signature = base64FromBytes2(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g;
        const message = createBaseVote();
        message.type = (_a2 = object.type) !== null && _a2 !== void 0 ? _a2 : 0;
        message.height = (_b = object.height) !== null && _b !== void 0 ? _b : "0";
        message.round = (_c = object.round) !== null && _c !== void 0 ? _c : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports2.BlockID.fromPartial(object.blockId) : void 0;
        message.timestamp = (_d = object.timestamp) !== null && _d !== void 0 ? _d : void 0;
        message.validatorAddress = (_e = object.validatorAddress) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.validatorIndex = (_f = object.validatorIndex) !== null && _f !== void 0 ? _f : 0;
        message.signature = (_g = object.signature) !== null && _g !== void 0 ? _g : new Uint8Array();
        return message;
      }
    };
    function createBaseCommit() {
      return { height: "0", round: 0, blockId: void 0, signatures: [] };
    }
    exports2.Commit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.height !== "0") {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports2.CommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = longToString(reader.int64());
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.signatures.push(exports2.CommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          height: isSet3(object.height) ? String(object.height) : "0",
          round: isSet3(object.round) ? Number(object.round) : 0,
          blockId: isSet3(object.blockId) ? exports2.BlockID.fromJSON(object.blockId) : void 0,
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => exports2.CommitSig.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height);
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports2.CommitSig.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseCommit();
        message.height = (_a2 = object.height) !== null && _a2 !== void 0 ? _a2 : "0";
        message.round = (_b = object.round) !== null && _b !== void 0 ? _b : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports2.BlockID.fromPartial(object.blockId) : void 0;
        message.signatures = ((_c = object.signatures) === null || _c === void 0 ? void 0 : _c.map((e) => exports2.CommitSig.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommitSig() {
      return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: void 0,
        signature: new Uint8Array()
      };
    }
    exports2.CommitSig = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitSig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          blockIdFlag: isSet3(object.blockIdFlag) ? blockIDFlagFromJSON(object.blockIdFlag) : 0,
          validatorAddress: isSet3(object.validatorAddress) ? bytesFromBase642(object.validatorAddress) : new Uint8Array(),
          timestamp: isSet3(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0,
          signature: isSet3(object.signature) ? bytesFromBase642(object.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = base64FromBytes2(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
        message.signature !== void 0 && (obj.signature = base64FromBytes2(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseCommitSig();
        message.blockIdFlag = (_a2 = object.blockIdFlag) !== null && _a2 !== void 0 ? _a2 : 0;
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.timestamp = (_c = object.timestamp) !== null && _c !== void 0 ? _c : void 0;
        message.signature = (_d = object.signature) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    function createBaseProposal() {
      return {
        type: 0,
        height: "0",
        round: 0,
        polRound: 0,
        blockId: void 0,
        timestamp: void 0,
        signature: new Uint8Array()
      };
    }
    exports2.Proposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== "0") {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.polRound !== 0) {
          writer.uint32(32).int32(message.polRound);
        }
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(58).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = longToString(reader.int64());
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.polRound = reader.int32();
              break;
            case 5:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.timestamp = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 7:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          type: isSet3(object.type) ? signedMsgTypeFromJSON(object.type) : 0,
          height: isSet3(object.height) ? String(object.height) : "0",
          round: isSet3(object.round) ? Number(object.round) : 0,
          polRound: isSet3(object.polRound) ? Number(object.polRound) : 0,
          blockId: isSet3(object.blockId) ? exports2.BlockID.fromJSON(object.blockId) : void 0,
          timestamp: isSet3(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0,
          signature: isSet3(object.signature) ? bytesFromBase642(object.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = message.height);
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.polRound !== void 0 && (obj.polRound = Math.round(message.polRound));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
        message.signature !== void 0 && (obj.signature = base64FromBytes2(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f;
        const message = createBaseProposal();
        message.type = (_a2 = object.type) !== null && _a2 !== void 0 ? _a2 : 0;
        message.height = (_b = object.height) !== null && _b !== void 0 ? _b : "0";
        message.round = (_c = object.round) !== null && _c !== void 0 ? _c : 0;
        message.polRound = (_d = object.polRound) !== null && _d !== void 0 ? _d : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports2.BlockID.fromPartial(object.blockId) : void 0;
        message.timestamp = (_e = object.timestamp) !== null && _e !== void 0 ? _e : void 0;
        message.signature = (_f = object.signature) !== null && _f !== void 0 ? _f : new Uint8Array();
        return message;
      }
    };
    function createBaseSignedHeader() {
      return { header: void 0, commit: void 0 };
    }
    exports2.SignedHeader = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.header !== void 0) {
          exports2.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports2.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignedHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = exports2.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.commit = exports2.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          header: isSet3(object.header) ? exports2.Header.fromJSON(object.header) : void 0,
          commit: isSet3(object.commit) ? exports2.Commit.fromJSON(object.commit) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? exports2.Header.toJSON(message.header) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports2.Commit.toJSON(message.commit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignedHeader();
        message.header = object.header !== void 0 && object.header !== null ? exports2.Header.fromPartial(object.header) : void 0;
        message.commit = object.commit !== void 0 && object.commit !== null ? exports2.Commit.fromPartial(object.commit) : void 0;
        return message;
      }
    };
    function createBaseLightBlock() {
      return { signedHeader: void 0, validatorSet: void 0 };
    }
    exports2.LightBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signedHeader !== void 0) {
          exports2.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = exports2.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signedHeader: isSet3(object.signedHeader) ? exports2.SignedHeader.fromJSON(object.signedHeader) : void 0,
          validatorSet: isSet3(object.validatorSet) ? validator_1.ValidatorSet.fromJSON(object.validatorSet) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? exports2.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLightBlock();
        message.signedHeader = object.signedHeader !== void 0 && object.signedHeader !== null ? exports2.SignedHeader.fromPartial(object.signedHeader) : void 0;
        message.validatorSet = object.validatorSet !== void 0 && object.validatorSet !== null ? validator_1.ValidatorSet.fromPartial(object.validatorSet) : void 0;
        return message;
      }
    };
    function createBaseBlockMeta() {
      return { blockId: void 0, blockSize: "0", header: void 0, numTxs: "0" };
    }
    exports2.BlockMeta = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockSize !== "0") {
          writer.uint32(16).int64(message.blockSize);
        }
        if (message.header !== void 0) {
          exports2.Header.encode(message.header, writer.uint32(26).fork()).ldelim();
        }
        if (message.numTxs !== "0") {
          writer.uint32(32).int64(message.numTxs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockMeta();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 2:
              message.blockSize = longToString(reader.int64());
              break;
            case 3:
              message.header = exports2.Header.decode(reader, reader.uint32());
              break;
            case 4:
              message.numTxs = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          blockId: isSet3(object.blockId) ? exports2.BlockID.fromJSON(object.blockId) : void 0,
          blockSize: isSet3(object.blockSize) ? String(object.blockSize) : "0",
          header: isSet3(object.header) ? exports2.Header.fromJSON(object.header) : void 0,
          numTxs: isSet3(object.numTxs) ? String(object.numTxs) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        message.blockSize !== void 0 && (obj.blockSize = message.blockSize);
        message.header !== void 0 && (obj.header = message.header ? exports2.Header.toJSON(message.header) : void 0);
        message.numTxs !== void 0 && (obj.numTxs = message.numTxs);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseBlockMeta();
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports2.BlockID.fromPartial(object.blockId) : void 0;
        message.blockSize = (_a2 = object.blockSize) !== null && _a2 !== void 0 ? _a2 : "0";
        message.header = object.header !== void 0 && object.header !== null ? exports2.Header.fromPartial(object.header) : void 0;
        message.numTxs = (_b = object.numTxs) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function createBaseTxProof() {
      return {
        rootHash: new Uint8Array(),
        data: new Uint8Array(),
        proof: void 0
      };
    }
    exports2.TxProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rootHash.length !== 0) {
          writer.uint32(10).bytes(message.rootHash);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rootHash = reader.bytes();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          rootHash: isSet3(object.rootHash) ? bytesFromBase642(object.rootHash) : new Uint8Array(),
          data: isSet3(object.data) ? bytesFromBase642(object.data) : new Uint8Array(),
          proof: isSet3(object.proof) ? proof_1.Proof.fromJSON(object.proof) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.rootHash !== void 0 && (obj.rootHash = base64FromBytes2(message.rootHash !== void 0 ? message.rootHash : new Uint8Array()));
        message.data !== void 0 && (obj.data = base64FromBytes2(message.data !== void 0 ? message.data : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseTxProof();
        message.rootHash = (_a2 = object.rootHash) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? proof_1.Proof.fromPartial(object.proof) : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return o;
      } else if (typeof o === "string") {
        return new Date(o);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
      }
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/google/protobuf/any.js
var require_any = __commonJS({
  "node_modules/@keplr-wallet/proto-types/google/protobuf/any.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Any = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "google.protobuf";
    function createBaseAny() {
      return { typeUrl: "", value: new Uint8Array() };
    }
    exports2.Any = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.typeUrl !== "") {
          writer.uint32(10).string(message.typeUrl);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAny();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.typeUrl = reader.string();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          typeUrl: isSet3(object.typeUrl) ? String(object.typeUrl) : "",
          value: isSet3(object.value) ? bytesFromBase642(object.value) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
        message.value !== void 0 && (obj.value = base64FromBytes2(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseAny();
        message.typeUrl = (_a2 = object.typeUrl) !== null && _a2 !== void 0 ? _a2 : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/google/protobuf/duration.js
var require_duration = __commonJS({
  "node_modules/@keplr-wallet/proto-types/google/protobuf/duration.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Duration = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "google.protobuf";
    function createBaseDuration() {
      return { seconds: "0", nanos: 0 };
    }
    exports2.Duration = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.seconds !== "0") {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuration();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = longToString(reader.int64());
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          seconds: isSet3(object.seconds) ? String(object.seconds) : "0",
          nanos: isSet3(object.nanos) ? Number(object.nanos) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = message.seconds);
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseDuration();
        message.seconds = (_a2 = object.seconds) !== null && _a2 !== void 0 ? _a2 : "0";
        message.nanos = (_b = object.nanos) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/staking.js
var require_staking = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/staking.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pool = exports2.RedelegationResponse = exports2.RedelegationEntryResponse = exports2.DelegationResponse = exports2.Params = exports2.Redelegation = exports2.RedelegationEntry = exports2.UnbondingDelegationEntry = exports2.UnbondingDelegation = exports2.Delegation = exports2.DVVTriplets = exports2.DVVTriplet = exports2.DVPairs = exports2.DVPair = exports2.ValAddresses = exports2.Validator = exports2.Description = exports2.Commission = exports2.CommissionRates = exports2.HistoricalInfo = exports2.bondStatusToJSON = exports2.bondStatusFromJSON = exports2.BondStatus = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var types_1 = require_types3();
    var any_1 = require_any();
    var duration_1 = require_duration();
    var coin_1 = require_coin2();
    exports2.protobufPackage = "cosmos.staking.v1beta1";
    var BondStatus;
    (function(BondStatus2) {
      BondStatus2[BondStatus2["BOND_STATUS_UNSPECIFIED"] = 0] = "BOND_STATUS_UNSPECIFIED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDED"] = 1] = "BOND_STATUS_UNBONDED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDING"] = 2] = "BOND_STATUS_UNBONDING";
      BondStatus2[BondStatus2["BOND_STATUS_BONDED"] = 3] = "BOND_STATUS_BONDED";
      BondStatus2[BondStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BondStatus = exports2.BondStatus || (exports2.BondStatus = {}));
    function bondStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "BOND_STATUS_UNSPECIFIED":
          return BondStatus.BOND_STATUS_UNSPECIFIED;
        case 1:
        case "BOND_STATUS_UNBONDED":
          return BondStatus.BOND_STATUS_UNBONDED;
        case 2:
        case "BOND_STATUS_UNBONDING":
          return BondStatus.BOND_STATUS_UNBONDING;
        case 3:
        case "BOND_STATUS_BONDED":
          return BondStatus.BOND_STATUS_BONDED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BondStatus.UNRECOGNIZED;
      }
    }
    exports2.bondStatusFromJSON = bondStatusFromJSON;
    function bondStatusToJSON(object) {
      switch (object) {
        case BondStatus.BOND_STATUS_UNSPECIFIED:
          return "BOND_STATUS_UNSPECIFIED";
        case BondStatus.BOND_STATUS_UNBONDED:
          return "BOND_STATUS_UNBONDED";
        case BondStatus.BOND_STATUS_UNBONDING:
          return "BOND_STATUS_UNBONDING";
        case BondStatus.BOND_STATUS_BONDED:
          return "BOND_STATUS_BONDED";
        default:
          return "UNKNOWN";
      }
    }
    exports2.bondStatusToJSON = bondStatusToJSON;
    function createBaseHistoricalInfo() {
      return { header: void 0, valset: [] };
    }
    exports2.HistoricalInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.valset) {
          exports2.Validator.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHistoricalInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.valset.push(exports2.Validator.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          header: isSet3(object.header) ? types_1.Header.fromJSON(object.header) : void 0,
          valset: Array.isArray(object === null || object === void 0 ? void 0 : object.valset) ? object.valset.map((e) => exports2.Validator.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        if (message.valset) {
          obj.valset = message.valset.map((e) => e ? exports2.Validator.toJSON(e) : void 0);
        } else {
          obj.valset = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseHistoricalInfo();
        message.header = object.header !== void 0 && object.header !== null ? types_1.Header.fromPartial(object.header) : void 0;
        message.valset = ((_a2 = object.valset) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.Validator.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommissionRates() {
      return { rate: "", maxRate: "", maxChangeRate: "" };
    }
    exports2.CommissionRates = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rate !== "") {
          writer.uint32(10).string(message.rate);
        }
        if (message.maxRate !== "") {
          writer.uint32(18).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
          writer.uint32(26).string(message.maxChangeRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommissionRates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rate = reader.string();
              break;
            case 2:
              message.maxRate = reader.string();
              break;
            case 3:
              message.maxChangeRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          rate: isSet3(object.rate) ? String(object.rate) : "",
          maxRate: isSet3(object.maxRate) ? String(object.maxRate) : "",
          maxChangeRate: isSet3(object.maxChangeRate) ? String(object.maxChangeRate) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.rate !== void 0 && (obj.rate = message.rate);
        message.maxRate !== void 0 && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== void 0 && (obj.maxChangeRate = message.maxChangeRate);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseCommissionRates();
        message.rate = (_a2 = object.rate) !== null && _a2 !== void 0 ? _a2 : "";
        message.maxRate = (_b = object.maxRate) !== null && _b !== void 0 ? _b : "";
        message.maxChangeRate = (_c = object.maxChangeRate) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseCommission() {
      return { commissionRates: void 0, updateTime: void 0 };
    }
    exports2.Commission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.commissionRates !== void 0) {
          exports2.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();
        }
        if (message.updateTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commissionRates = exports2.CommissionRates.decode(reader, reader.uint32());
              break;
            case 2:
              message.updateTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          commissionRates: isSet3(object.commissionRates) ? exports2.CommissionRates.fromJSON(object.commissionRates) : void 0,
          updateTime: isSet3(object.updateTime) ? fromJsonTimestamp(object.updateTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.commissionRates !== void 0 && (obj.commissionRates = message.commissionRates ? exports2.CommissionRates.toJSON(message.commissionRates) : void 0);
        message.updateTime !== void 0 && (obj.updateTime = message.updateTime.toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseCommission();
        message.commissionRates = object.commissionRates !== void 0 && object.commissionRates !== null ? exports2.CommissionRates.fromPartial(object.commissionRates) : void 0;
        message.updateTime = (_a2 = object.updateTime) !== null && _a2 !== void 0 ? _a2 : void 0;
        return message;
      }
    };
    function createBaseDescription() {
      return {
        moniker: "",
        identity: "",
        website: "",
        securityContact: "",
        details: ""
      };
    }
    exports2.Description = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.moniker !== "") {
          writer.uint32(10).string(message.moniker);
        }
        if (message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.website !== "") {
          writer.uint32(26).string(message.website);
        }
        if (message.securityContact !== "") {
          writer.uint32(34).string(message.securityContact);
        }
        if (message.details !== "") {
          writer.uint32(42).string(message.details);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDescription();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moniker = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.website = reader.string();
              break;
            case 4:
              message.securityContact = reader.string();
              break;
            case 5:
              message.details = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          moniker: isSet3(object.moniker) ? String(object.moniker) : "",
          identity: isSet3(object.identity) ? String(object.identity) : "",
          website: isSet3(object.website) ? String(object.website) : "",
          securityContact: isSet3(object.securityContact) ? String(object.securityContact) : "",
          details: isSet3(object.details) ? String(object.details) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.moniker !== void 0 && (obj.moniker = message.moniker);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.website !== void 0 && (obj.website = message.website);
        message.securityContact !== void 0 && (obj.securityContact = message.securityContact);
        message.details !== void 0 && (obj.details = message.details);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e;
        const message = createBaseDescription();
        message.moniker = (_a2 = object.moniker) !== null && _a2 !== void 0 ? _a2 : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.website = (_c = object.website) !== null && _c !== void 0 ? _c : "";
        message.securityContact = (_d = object.securityContact) !== null && _d !== void 0 ? _d : "";
        message.details = (_e = object.details) !== null && _e !== void 0 ? _e : "";
        return message;
      }
    };
    function createBaseValidator() {
      return {
        operatorAddress: "",
        consensusPubkey: void 0,
        jailed: false,
        status: 0,
        tokens: "",
        delegatorShares: "",
        description: void 0,
        unbondingHeight: "0",
        unbondingTime: void 0,
        commission: void 0,
        minSelfDelegation: ""
      };
    }
    exports2.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== void 0) {
          any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();
        }
        if (message.jailed === true) {
          writer.uint32(24).bool(message.jailed);
        }
        if (message.status !== 0) {
          writer.uint32(32).int32(message.status);
        }
        if (message.tokens !== "") {
          writer.uint32(42).string(message.tokens);
        }
        if (message.delegatorShares !== "") {
          writer.uint32(50).string(message.delegatorShares);
        }
        if (message.description !== void 0) {
          exports2.Description.encode(message.description, writer.uint32(58).fork()).ldelim();
        }
        if (message.unbondingHeight !== "0") {
          writer.uint32(64).int64(message.unbondingHeight);
        }
        if (message.unbondingTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.unbondingTime), writer.uint32(74).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          exports2.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(90).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.jailed = reader.bool();
              break;
            case 4:
              message.status = reader.int32();
              break;
            case 5:
              message.tokens = reader.string();
              break;
            case 6:
              message.delegatorShares = reader.string();
              break;
            case 7:
              message.description = exports2.Description.decode(reader, reader.uint32());
              break;
            case 8:
              message.unbondingHeight = longToString(reader.int64());
              break;
            case 9:
              message.unbondingTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 10:
              message.commission = exports2.Commission.decode(reader, reader.uint32());
              break;
            case 11:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operatorAddress: isSet3(object.operatorAddress) ? String(object.operatorAddress) : "",
          consensusPubkey: isSet3(object.consensusPubkey) ? any_1.Any.fromJSON(object.consensusPubkey) : void 0,
          jailed: isSet3(object.jailed) ? Boolean(object.jailed) : false,
          status: isSet3(object.status) ? bondStatusFromJSON(object.status) : 0,
          tokens: isSet3(object.tokens) ? String(object.tokens) : "",
          delegatorShares: isSet3(object.delegatorShares) ? String(object.delegatorShares) : "",
          description: isSet3(object.description) ? exports2.Description.fromJSON(object.description) : void 0,
          unbondingHeight: isSet3(object.unbondingHeight) ? String(object.unbondingHeight) : "0",
          unbondingTime: isSet3(object.unbondingTime) ? fromJsonTimestamp(object.unbondingTime) : void 0,
          commission: isSet3(object.commission) ? exports2.Commission.fromJSON(object.commission) : void 0,
          minSelfDelegation: isSet3(object.minSelfDelegation) ? String(object.minSelfDelegation) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        message.consensusPubkey !== void 0 && (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : void 0);
        message.jailed !== void 0 && (obj.jailed = message.jailed);
        message.status !== void 0 && (obj.status = bondStatusToJSON(message.status));
        message.tokens !== void 0 && (obj.tokens = message.tokens);
        message.delegatorShares !== void 0 && (obj.delegatorShares = message.delegatorShares);
        message.description !== void 0 && (obj.description = message.description ? exports2.Description.toJSON(message.description) : void 0);
        message.unbondingHeight !== void 0 && (obj.unbondingHeight = message.unbondingHeight);
        message.unbondingTime !== void 0 && (obj.unbondingTime = message.unbondingTime.toISOString());
        message.commission !== void 0 && (obj.commission = message.commission ? exports2.Commission.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseValidator();
        message.operatorAddress = (_a2 = object.operatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.consensusPubkey = object.consensusPubkey !== void 0 && object.consensusPubkey !== null ? any_1.Any.fromPartial(object.consensusPubkey) : void 0;
        message.jailed = (_b = object.jailed) !== null && _b !== void 0 ? _b : false;
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : 0;
        message.tokens = (_d = object.tokens) !== null && _d !== void 0 ? _d : "";
        message.delegatorShares = (_e = object.delegatorShares) !== null && _e !== void 0 ? _e : "";
        message.description = object.description !== void 0 && object.description !== null ? exports2.Description.fromPartial(object.description) : void 0;
        message.unbondingHeight = (_f = object.unbondingHeight) !== null && _f !== void 0 ? _f : "0";
        message.unbondingTime = (_g = object.unbondingTime) !== null && _g !== void 0 ? _g : void 0;
        message.commission = object.commission !== void 0 && object.commission !== null ? exports2.Commission.fromPartial(object.commission) : void 0;
        message.minSelfDelegation = (_h = object.minSelfDelegation) !== null && _h !== void 0 ? _h : "";
        return message;
      }
    };
    function createBaseValAddresses() {
      return { addresses: [] };
    }
    exports2.ValAddresses = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.addresses) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValAddresses();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          addresses: Array.isArray(object === null || object === void 0 ? void 0 : object.addresses) ? object.addresses.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseValAddresses();
        message.addresses = ((_a2 = object.addresses) === null || _a2 === void 0 ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseDVPair() {
      return { delegatorAddress: "", validatorAddress: "" };
    }
    exports2.DVPair = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPair();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseDVPair();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseDVPairs() {
      return { pairs: [] };
    }
    exports2.DVPairs = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.pairs) {
          exports2.DVPair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPairs();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pairs.push(exports2.DVPair.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          pairs: Array.isArray(object === null || object === void 0 ? void 0 : object.pairs) ? object.pairs.map((e) => exports2.DVPair.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.pairs) {
          obj.pairs = message.pairs.map((e) => e ? exports2.DVPair.toJSON(e) : void 0);
        } else {
          obj.pairs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDVPairs();
        message.pairs = ((_a2 = object.pairs) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.DVPair.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDVVTriplet() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: ""
      };
    }
    exports2.DVVTriplet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorSrcAddress: isSet3(object.validatorSrcAddress) ? String(object.validatorSrcAddress) : "",
          validatorDstAddress: isSet3(object.validatorDstAddress) ? String(object.validatorDstAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseDVVTriplet();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseDVVTriplets() {
      return { triplets: [] };
    }
    exports2.DVVTriplets = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.triplets) {
          exports2.DVVTriplet.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplets();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.triplets.push(exports2.DVVTriplet.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          triplets: Array.isArray(object === null || object === void 0 ? void 0 : object.triplets) ? object.triplets.map((e) => exports2.DVVTriplet.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.triplets) {
          obj.triplets = message.triplets.map((e) => e ? exports2.DVVTriplet.toJSON(e) : void 0);
        } else {
          obj.triplets = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDVVTriplets();
        message.triplets = ((_a2 = object.triplets) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.DVVTriplet.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDelegation() {
      return { delegatorAddress: "", validatorAddress: "", shares: "" };
    }
    exports2.Delegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.shares !== "") {
          writer.uint32(26).string(message.shares);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.shares = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : "",
          shares: isSet3(object.shares) ? String(object.shares) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.shares !== void 0 && (obj.shares = message.shares);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseDelegation();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.shares = (_c = object.shares) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseUnbondingDelegation() {
      return { delegatorAddress: "", validatorAddress: "", entries: [] };
    }
    exports2.UnbondingDelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v of message.entries) {
          exports2.UnbondingDelegationEntry.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.entries.push(exports2.UnbondingDelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : "",
          entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map((e) => exports2.UnbondingDelegationEntry.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.UnbondingDelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseUnbondingDelegation();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.entries = ((_c = object.entries) === null || _c === void 0 ? void 0 : _c.map((e) => exports2.UnbondingDelegationEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseUnbondingDelegationEntry() {
      return {
        creationHeight: "0",
        completionTime: void 0,
        initialBalance: "",
        balance: ""
      };
    }
    exports2.UnbondingDelegationEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creationHeight !== "0") {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = longToString(reader.int64());
              break;
            case 2:
              message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creationHeight: isSet3(object.creationHeight) ? String(object.creationHeight) : "0",
          completionTime: isSet3(object.completionTime) ? fromJsonTimestamp(object.completionTime) : void 0,
          initialBalance: isSet3(object.initialBalance) ? String(object.initialBalance) : "",
          balance: isSet3(object.balance) ? String(object.balance) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = message.creationHeight);
        message.completionTime !== void 0 && (obj.completionTime = message.completionTime.toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseUnbondingDelegationEntry();
        message.creationHeight = (_a2 = object.creationHeight) !== null && _a2 !== void 0 ? _a2 : "0";
        message.completionTime = (_b = object.completionTime) !== null && _b !== void 0 ? _b : void 0;
        message.initialBalance = (_c = object.initialBalance) !== null && _c !== void 0 ? _c : "";
        message.balance = (_d = object.balance) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseRedelegationEntry() {
      return {
        creationHeight: "0",
        completionTime: void 0,
        initialBalance: "",
        sharesDst: ""
      };
    }
    exports2.RedelegationEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creationHeight !== "0") {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.sharesDst !== "") {
          writer.uint32(34).string(message.sharesDst);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = longToString(reader.int64());
              break;
            case 2:
              message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.sharesDst = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creationHeight: isSet3(object.creationHeight) ? String(object.creationHeight) : "0",
          completionTime: isSet3(object.completionTime) ? fromJsonTimestamp(object.completionTime) : void 0,
          initialBalance: isSet3(object.initialBalance) ? String(object.initialBalance) : "",
          sharesDst: isSet3(object.sharesDst) ? String(object.sharesDst) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = message.creationHeight);
        message.completionTime !== void 0 && (obj.completionTime = message.completionTime.toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.sharesDst !== void 0 && (obj.sharesDst = message.sharesDst);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseRedelegationEntry();
        message.creationHeight = (_a2 = object.creationHeight) !== null && _a2 !== void 0 ? _a2 : "0";
        message.completionTime = (_b = object.completionTime) !== null && _b !== void 0 ? _b : void 0;
        message.initialBalance = (_c = object.initialBalance) !== null && _c !== void 0 ? _c : "";
        message.sharesDst = (_d = object.sharesDst) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseRedelegation() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        entries: []
      };
    }
    exports2.Redelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        for (const v of message.entries) {
          exports2.RedelegationEntry.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.entries.push(exports2.RedelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorSrcAddress: isSet3(object.validatorSrcAddress) ? String(object.validatorSrcAddress) : "",
          validatorDstAddress: isSet3(object.validatorDstAddress) ? String(object.validatorDstAddress) : "",
          entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map((e) => exports2.RedelegationEntry.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.RedelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseRedelegation();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        message.entries = ((_d = object.entries) === null || _d === void 0 ? void 0 : _d.map((e) => exports2.RedelegationEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        unbondingTime: void 0,
        maxValidators: 0,
        maxEntries: 0,
        historicalEntries: 0,
        bondDenom: ""
      };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.unbondingTime !== void 0) {
          duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxValidators !== 0) {
          writer.uint32(16).uint32(message.maxValidators);
        }
        if (message.maxEntries !== 0) {
          writer.uint32(24).uint32(message.maxEntries);
        }
        if (message.historicalEntries !== 0) {
          writer.uint32(32).uint32(message.historicalEntries);
        }
        if (message.bondDenom !== "") {
          writer.uint32(42).string(message.bondDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.maxValidators = reader.uint32();
              break;
            case 3:
              message.maxEntries = reader.uint32();
              break;
            case 4:
              message.historicalEntries = reader.uint32();
              break;
            case 5:
              message.bondDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          unbondingTime: isSet3(object.unbondingTime) ? duration_1.Duration.fromJSON(object.unbondingTime) : void 0,
          maxValidators: isSet3(object.maxValidators) ? Number(object.maxValidators) : 0,
          maxEntries: isSet3(object.maxEntries) ? Number(object.maxEntries) : 0,
          historicalEntries: isSet3(object.historicalEntries) ? Number(object.historicalEntries) : 0,
          bondDenom: isSet3(object.bondDenom) ? String(object.bondDenom) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.unbondingTime !== void 0 && (obj.unbondingTime = message.unbondingTime ? duration_1.Duration.toJSON(message.unbondingTime) : void 0);
        message.maxValidators !== void 0 && (obj.maxValidators = Math.round(message.maxValidators));
        message.maxEntries !== void 0 && (obj.maxEntries = Math.round(message.maxEntries));
        message.historicalEntries !== void 0 && (obj.historicalEntries = Math.round(message.historicalEntries));
        message.bondDenom !== void 0 && (obj.bondDenom = message.bondDenom);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseParams();
        message.unbondingTime = object.unbondingTime !== void 0 && object.unbondingTime !== null ? duration_1.Duration.fromPartial(object.unbondingTime) : void 0;
        message.maxValidators = (_a2 = object.maxValidators) !== null && _a2 !== void 0 ? _a2 : 0;
        message.maxEntries = (_b = object.maxEntries) !== null && _b !== void 0 ? _b : 0;
        message.historicalEntries = (_c = object.historicalEntries) !== null && _c !== void 0 ? _c : 0;
        message.bondDenom = (_d = object.bondDenom) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseDelegationResponse() {
      return { delegation: void 0, balance: void 0 };
    }
    exports2.DelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegation !== void 0) {
          exports2.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegation = exports2.Delegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegation: isSet3(object.delegation) ? exports2.Delegation.fromJSON(object.delegation) : void 0,
          balance: isSet3(object.balance) ? coin_1.Coin.fromJSON(object.balance) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegation !== void 0 && (obj.delegation = message.delegation ? exports2.Delegation.toJSON(message.delegation) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegationResponse();
        message.delegation = object.delegation !== void 0 && object.delegation !== null ? exports2.Delegation.fromPartial(object.delegation) : void 0;
        message.balance = object.balance !== void 0 && object.balance !== null ? coin_1.Coin.fromPartial(object.balance) : void 0;
        return message;
      }
    };
    function createBaseRedelegationEntryResponse() {
      return { redelegationEntry: void 0, balance: "" };
    }
    exports2.RedelegationEntryResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redelegationEntry !== void 0) {
          exports2.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationEntry = exports2.RedelegationEntry.decode(reader, reader.uint32());
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          redelegationEntry: isSet3(object.redelegationEntry) ? exports2.RedelegationEntry.fromJSON(object.redelegationEntry) : void 0,
          balance: isSet3(object.balance) ? String(object.balance) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.redelegationEntry !== void 0 && (obj.redelegationEntry = message.redelegationEntry ? exports2.RedelegationEntry.toJSON(message.redelegationEntry) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseRedelegationEntryResponse();
        message.redelegationEntry = object.redelegationEntry !== void 0 && object.redelegationEntry !== null ? exports2.RedelegationEntry.fromPartial(object.redelegationEntry) : void 0;
        message.balance = (_a2 = object.balance) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseRedelegationResponse() {
      return { redelegation: void 0, entries: [] };
    }
    exports2.RedelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redelegation !== void 0) {
          exports2.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.entries) {
          exports2.RedelegationEntryResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegation = exports2.Redelegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.entries.push(exports2.RedelegationEntryResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          redelegation: isSet3(object.redelegation) ? exports2.Redelegation.fromJSON(object.redelegation) : void 0,
          entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries) ? object.entries.map((e) => exports2.RedelegationEntryResponse.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.redelegation !== void 0 && (obj.redelegation = message.redelegation ? exports2.Redelegation.toJSON(message.redelegation) : void 0);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.RedelegationEntryResponse.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseRedelegationResponse();
        message.redelegation = object.redelegation !== void 0 && object.redelegation !== null ? exports2.Redelegation.fromPartial(object.redelegation) : void 0;
        message.entries = ((_a2 = object.entries) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.RedelegationEntryResponse.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePool() {
      return { notBondedTokens: "", bondedTokens: "" };
    }
    exports2.Pool = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.notBondedTokens !== "") {
          writer.uint32(10).string(message.notBondedTokens);
        }
        if (message.bondedTokens !== "") {
          writer.uint32(18).string(message.bondedTokens);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.notBondedTokens = reader.string();
              break;
            case 2:
              message.bondedTokens = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          notBondedTokens: isSet3(object.notBondedTokens) ? String(object.notBondedTokens) : "",
          bondedTokens: isSet3(object.bondedTokens) ? String(object.bondedTokens) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.notBondedTokens !== void 0 && (obj.notBondedTokens = message.notBondedTokens);
        message.bondedTokens !== void 0 && (obj.bondedTokens = message.bondedTokens);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBasePool();
        message.notBondedTokens = (_a2 = object.notBondedTokens) !== null && _a2 !== void 0 ? _a2 : "";
        message.bondedTokens = (_b = object.bondedTokens) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return o;
      } else if (typeof o === "string") {
        return new Date(o);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
      }
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx.js
var require_tx5 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgValidatorBondResponse = exports2.MsgValidatorBond = exports2.MsgEnableTokenizeSharesResponse = exports2.MsgEnableTokenizeShares = exports2.MsgDisableTokenizeSharesResponse = exports2.MsgDisableTokenizeShares = exports2.MsgTransferTokenizeShareRecordResponse = exports2.MsgTransferTokenizeShareRecord = exports2.MsgRedeemTokensForSharesResponse = exports2.MsgRedeemTokensForShares = exports2.MsgTokenizeSharesResponse = exports2.MsgTokenizeShares = exports2.MsgCancelUnbondingDelegationResponse = exports2.MsgCancelUnbondingDelegation = exports2.MsgUnbondValidatorResponse = exports2.MsgUnbondValidator = exports2.MsgUndelegateResponse = exports2.MsgUndelegate = exports2.MsgBeginRedelegateResponse = exports2.MsgBeginRedelegate = exports2.MsgDelegateResponse = exports2.MsgDelegate = exports2.MsgEditValidatorResponse = exports2.MsgEditValidator = exports2.MsgCreateValidatorResponse = exports2.MsgCreateValidator = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var staking_1 = require_staking();
    var any_1 = require_any();
    var coin_1 = require_coin2();
    exports2.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseMsgCreateValidator() {
      return {
        description: void 0,
        commission: void 0,
        minSelfDelegation: "",
        delegatorAddress: "",
        validatorAddress: "",
        pubkey: void 0,
        value: void 0
      };
    }
    exports2.MsgCreateValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(26).string(message.minSelfDelegation);
        }
        if (message.delegatorAddress !== "") {
          writer.uint32(34).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(42).string(message.validatorAddress);
        }
        if (message.pubkey !== void 0) {
          any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();
        }
        if (message.value !== void 0) {
          coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());
              break;
            case 3:
              message.minSelfDelegation = reader.string();
              break;
            case 4:
              message.delegatorAddress = reader.string();
              break;
            case 5:
              message.validatorAddress = reader.string();
              break;
            case 6:
              message.pubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.value = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          description: isSet3(object.description) ? staking_1.Description.fromJSON(object.description) : void 0,
          commission: isSet3(object.commission) ? staking_1.CommissionRates.fromJSON(object.commission) : void 0,
          minSelfDelegation: isSet3(object.minSelfDelegation) ? String(object.minSelfDelegation) : "",
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : "",
          pubkey: isSet3(object.pubkey) ? any_1.Any.fromJSON(object.pubkey) : void 0,
          value: isSet3(object.value) ? coin_1.Coin.fromJSON(object.value) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.commission !== void 0 && (obj.commission = message.commission ? staking_1.CommissionRates.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.pubkey !== void 0 && (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : void 0);
        message.value !== void 0 && (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgCreateValidator();
        message.description = object.description !== void 0 && object.description !== null ? staking_1.Description.fromPartial(object.description) : void 0;
        message.commission = object.commission !== void 0 && object.commission !== null ? staking_1.CommissionRates.fromPartial(object.commission) : void 0;
        message.minSelfDelegation = (_a2 = object.minSelfDelegation) !== null && _a2 !== void 0 ? _a2 : "";
        message.delegatorAddress = (_b = object.delegatorAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : "";
        message.pubkey = object.pubkey !== void 0 && object.pubkey !== null ? any_1.Any.fromPartial(object.pubkey) : void 0;
        message.value = object.value !== void 0 && object.value !== null ? coin_1.Coin.fromPartial(object.value) : void 0;
        return message;
      }
    };
    function createBaseMsgCreateValidatorResponse() {
      return {};
    }
    exports2.MsgCreateValidatorResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateValidatorResponse();
        return message;
      }
    };
    function createBaseMsgEditValidator() {
      return {
        description: void 0,
        validatorAddress: "",
        commissionRate: "",
        minSelfDelegation: ""
      };
    }
    exports2.MsgEditValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.commissionRate !== "") {
          writer.uint32(26).string(message.commissionRate);
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(34).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.commissionRate = reader.string();
              break;
            case 4:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          description: isSet3(object.description) ? staking_1.Description.fromJSON(object.description) : void 0,
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : "",
          commissionRate: isSet3(object.commissionRate) ? String(object.commissionRate) : "",
          minSelfDelegation: isSet3(object.minSelfDelegation) ? String(object.minSelfDelegation) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.commissionRate !== void 0 && (obj.commissionRate = message.commissionRate);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgEditValidator();
        message.description = object.description !== void 0 && object.description !== null ? staking_1.Description.fromPartial(object.description) : void 0;
        message.validatorAddress = (_a2 = object.validatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.commissionRate = (_b = object.commissionRate) !== null && _b !== void 0 ? _b : "";
        message.minSelfDelegation = (_c = object.minSelfDelegation) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgEditValidatorResponse() {
      return {};
    }
    exports2.MsgEditValidatorResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgEditValidatorResponse();
        return message;
      }
    };
    function createBaseMsgDelegate() {
      return { delegatorAddress: "", validatorAddress: "", amount: void 0 };
    }
    exports2.MsgDelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : "",
          amount: isSet3(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgDelegate();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgDelegateResponse() {
      return {};
    }
    exports2.MsgDelegateResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDelegateResponse();
        return message;
      }
    };
    function createBaseMsgBeginRedelegate() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        amount: void 0
      };
    }
    exports2.MsgBeginRedelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorSrcAddress: isSet3(object.validatorSrcAddress) ? String(object.validatorSrcAddress) : "",
          validatorDstAddress: isSet3(object.validatorDstAddress) ? String(object.validatorDstAddress) : "",
          amount: isSet3(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgBeginRedelegate();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgBeginRedelegateResponse() {
      return { completionTime: void 0 };
    }
    exports2.MsgBeginRedelegateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          completionTime: isSet3(object.completionTime) ? fromJsonTimestamp(object.completionTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = message.completionTime.toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgBeginRedelegateResponse();
        message.completionTime = (_a2 = object.completionTime) !== null && _a2 !== void 0 ? _a2 : void 0;
        return message;
      }
    };
    function createBaseMsgUndelegate() {
      return { delegatorAddress: "", validatorAddress: "", amount: void 0 };
    }
    exports2.MsgUndelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : "",
          amount: isSet3(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgUndelegate();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgUndelegateResponse() {
      return { completionTime: void 0 };
    }
    exports2.MsgUndelegateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          completionTime: isSet3(object.completionTime) ? fromJsonTimestamp(object.completionTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = message.completionTime.toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgUndelegateResponse();
        message.completionTime = (_a2 = object.completionTime) !== null && _a2 !== void 0 ? _a2 : void 0;
        return message;
      }
    };
    function createBaseMsgUnbondValidator() {
      return { validatorAddress: "" };
    }
    exports2.MsgUnbondValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUnbondValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgUnbondValidator();
        message.validatorAddress = (_a2 = object.validatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseMsgUnbondValidatorResponse() {
      return {};
    }
    exports2.MsgUnbondValidatorResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUnbondValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUnbondValidatorResponse();
        return message;
      }
    };
    function createBaseMsgCancelUnbondingDelegation() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: void 0,
        creationHeight: "0"
      };
    }
    exports2.MsgCancelUnbondingDelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        if (message.creationHeight !== "0") {
          writer.uint32(32).int64(message.creationHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.creationHeight = longToString(reader.int64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : "",
          amount: isSet3(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0,
          creationHeight: isSet3(object.creationHeight) ? String(object.creationHeight) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        message.creationHeight !== void 0 && (obj.creationHeight = message.creationHeight);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgCancelUnbondingDelegation();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        message.creationHeight = (_c = object.creationHeight) !== null && _c !== void 0 ? _c : "0";
        return message;
      }
    };
    function createBaseMsgCancelUnbondingDelegationResponse() {
      return {};
    }
    exports2.MsgCancelUnbondingDelegationResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCancelUnbondingDelegationResponse();
        return message;
      }
    };
    function createBaseMsgTokenizeShares() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: void 0,
        tokenizedShareOwner: ""
      };
    }
    exports2.MsgTokenizeShares = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        if (message.tokenizedShareOwner !== "") {
          writer.uint32(34).string(message.tokenizedShareOwner);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTokenizeShares();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.tokenizedShareOwner = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : "",
          amount: isSet3(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0,
          tokenizedShareOwner: isSet3(object.tokenizedShareOwner) ? String(object.tokenizedShareOwner) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        message.tokenizedShareOwner !== void 0 && (obj.tokenizedShareOwner = message.tokenizedShareOwner);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgTokenizeShares();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        message.tokenizedShareOwner = (_c = object.tokenizedShareOwner) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgTokenizeSharesResponse() {
      return { amount: void 0 };
    }
    exports2.MsgTokenizeSharesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTokenizeSharesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          amount: isSet3(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTokenizeSharesResponse();
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgRedeemTokensForShares() {
      return { delegatorAddress: "", amount: void 0 };
    }
    exports2.MsgRedeemTokensForShares = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemTokensForShares();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          amount: isSet3(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgRedeemTokensForShares();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgRedeemTokensForSharesResponse() {
      return { amount: void 0 };
    }
    exports2.MsgRedeemTokensForSharesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemTokensForSharesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          amount: isSet3(object.amount) ? coin_1.Coin.fromJSON(object.amount) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRedeemTokensForSharesResponse();
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    function createBaseMsgTransferTokenizeShareRecord() {
      return { tokenizeShareRecordId: "0", sender: "", newOwner: "" };
    }
    exports2.MsgTransferTokenizeShareRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tokenizeShareRecordId !== "0") {
          writer.uint32(8).uint64(message.tokenizeShareRecordId);
        }
        if (message.sender !== "") {
          writer.uint32(18).string(message.sender);
        }
        if (message.newOwner !== "") {
          writer.uint32(26).string(message.newOwner);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferTokenizeShareRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tokenizeShareRecordId = longToString(reader.uint64());
              break;
            case 2:
              message.sender = reader.string();
              break;
            case 3:
              message.newOwner = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          tokenizeShareRecordId: isSet3(object.tokenizeShareRecordId) ? String(object.tokenizeShareRecordId) : "0",
          sender: isSet3(object.sender) ? String(object.sender) : "",
          newOwner: isSet3(object.newOwner) ? String(object.newOwner) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.tokenizeShareRecordId !== void 0 && (obj.tokenizeShareRecordId = message.tokenizeShareRecordId);
        message.sender !== void 0 && (obj.sender = message.sender);
        message.newOwner !== void 0 && (obj.newOwner = message.newOwner);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgTransferTokenizeShareRecord();
        message.tokenizeShareRecordId = (_a2 = object.tokenizeShareRecordId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.sender = (_b = object.sender) !== null && _b !== void 0 ? _b : "";
        message.newOwner = (_c = object.newOwner) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgTransferTokenizeShareRecordResponse() {
      return {};
    }
    exports2.MsgTransferTokenizeShareRecordResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferTokenizeShareRecordResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgTransferTokenizeShareRecordResponse();
        return message;
      }
    };
    function createBaseMsgDisableTokenizeShares() {
      return { delegatorAddress: "" };
    }
    exports2.MsgDisableTokenizeShares = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDisableTokenizeShares();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgDisableTokenizeShares();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseMsgDisableTokenizeSharesResponse() {
      return {};
    }
    exports2.MsgDisableTokenizeSharesResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDisableTokenizeSharesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDisableTokenizeSharesResponse();
        return message;
      }
    };
    function createBaseMsgEnableTokenizeShares() {
      return { delegatorAddress: "" };
    }
    exports2.MsgEnableTokenizeShares = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEnableTokenizeShares();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgEnableTokenizeShares();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseMsgEnableTokenizeSharesResponse() {
      return { completionTime: void 0 };
    }
    exports2.MsgEnableTokenizeSharesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEnableTokenizeSharesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          completionTime: isSet3(object.completionTime) ? fromJsonTimestamp(object.completionTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = message.completionTime.toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgEnableTokenizeSharesResponse();
        message.completionTime = (_a2 = object.completionTime) !== null && _a2 !== void 0 ? _a2 : void 0;
        return message;
      }
    };
    function createBaseMsgValidatorBond() {
      return { delegatorAddress: "", validatorAddress: "" };
    }
    exports2.MsgValidatorBond = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgValidatorBond();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgValidatorBond();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgValidatorBondResponse() {
      return {};
    }
    exports2.MsgValidatorBondResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgValidatorBondResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgValidatorBondResponse();
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return o;
      } else if (typeof o === "string") {
        return new Date(o);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
      }
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/authz.js
var require_authz = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/authz.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Grant = exports2.GenericAuthorization = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    exports2.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseGenericAuthorization() {
      return { msg: "" };
    }
    exports2.GenericAuthorization = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.msg !== "") {
          writer.uint32(10).string(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGenericAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msg = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          msg: isSet3(object.msg) ? String(object.msg) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.msg !== void 0 && (obj.msg = message.msg);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseGenericAuthorization();
        message.msg = (_a2 = object.msg) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseGrant() {
      return { authorization: void 0, expiration: void 0 };
    }
    exports2.Grant = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.expiration), writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.expiration = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          authorization: isSet3(object.authorization) ? any_1.Any.fromJSON(object.authorization) : void 0,
          expiration: isSet3(object.expiration) ? fromJsonTimestamp(object.expiration) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = message.expiration.toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseGrant();
        message.authorization = object.authorization !== void 0 && object.authorization !== null ? any_1.Any.fromPartial(object.authorization) : void 0;
        message.expiration = (_a2 = object.expiration) !== null && _a2 !== void 0 ? _a2 : void 0;
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return o;
      } else if (typeof o === "string") {
        return new Date(o);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
      }
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/tx.js
var require_tx6 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgRevokeResponse = exports2.MsgRevoke = exports2.MsgGrantResponse = exports2.MsgExec = exports2.MsgExecResponse = exports2.MsgGrant = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var authz_1 = require_authz();
    var any_1 = require_any();
    exports2.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseMsgGrant() {
      return { granter: "", grantee: "", grant: void 0 };
    }
    exports2.MsgGrant = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.grant !== void 0) {
          authz_1.Grant.encode(message.grant, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.grant = authz_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet3(object.granter) ? String(object.granter) : "",
          grantee: isSet3(object.grantee) ? String(object.grantee) : "",
          grant: isSet3(object.grant) ? authz_1.Grant.fromJSON(object.grant) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.grant !== void 0 && (obj.grant = message.grant ? authz_1.Grant.toJSON(message.grant) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgGrant();
        message.granter = (_a2 = object.granter) !== null && _a2 !== void 0 ? _a2 : "";
        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : "";
        message.grant = object.grant !== void 0 && object.grant !== null ? authz_1.Grant.fromPartial(object.grant) : void 0;
        return message;
      }
    };
    function createBaseMsgExecResponse() {
      return { results: [] };
    }
    exports2.MsgExecResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.results.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          results: Array.isArray(object === null || object === void 0 ? void 0 : object.results) ? object.results.map((e) => bytesFromBase642(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.results) {
          obj.results = message.results.map((e) => base64FromBytes2(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.results = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgExecResponse();
        message.results = ((_a2 = object.results) === null || _a2 === void 0 ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMsgExec() {
      return { grantee: "", msgs: [] };
    }
    exports2.MsgExec = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        for (const v of message.msgs) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.msgs.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          grantee: isSet3(object.grantee) ? String(object.grantee) : "",
          msgs: Array.isArray(object === null || object === void 0 ? void 0 : object.msgs) ? object.msgs.map((e) => any_1.Any.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        if (message.msgs) {
          obj.msgs = message.msgs.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgExec();
        message.grantee = (_a2 = object.grantee) !== null && _a2 !== void 0 ? _a2 : "";
        message.msgs = ((_b = object.msgs) === null || _b === void 0 ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgGrantResponse() {
      return {};
    }
    exports2.MsgGrantResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgGrantResponse();
        return message;
      }
    };
    function createBaseMsgRevoke() {
      return { granter: "", grantee: "", msgTypeUrl: "" };
    }
    exports2.MsgRevoke = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevoke();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          granter: isSet3(object.granter) ? String(object.granter) : "",
          grantee: isSet3(object.grantee) ? String(object.grantee) : "",
          msgTypeUrl: isSet3(object.msgTypeUrl) ? String(object.msgTypeUrl) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgRevoke();
        message.granter = (_a2 = object.granter) !== null && _a2 !== void 0 ? _a2 : "";
        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : "";
        message.msgTypeUrl = (_c = object.msgTypeUrl) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgRevokeResponse() {
      return {};
    }
    exports2.MsgRevokeResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRevokeResponse();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov.js
var require_gov = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TallyParams = exports2.VotingParams = exports2.DepositParams = exports2.Vote = exports2.TallyResult = exports2.Proposal = exports2.Deposit = exports2.TextProposal = exports2.WeightedVoteOption = exports2.proposalStatusToJSON = exports2.proposalStatusFromJSON = exports2.ProposalStatus = exports2.voteOptionToJSON = exports2.voteOptionFromJSON = exports2.VoteOption = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var coin_1 = require_coin2();
    var any_1 = require_any();
    var duration_1 = require_duration();
    exports2.protobufPackage = "cosmos.gov.v1beta1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption = exports2.VoteOption || (exports2.VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports2.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        default:
          return "UNKNOWN";
      }
    }
    exports2.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus = exports2.ProposalStatus || (exports2.ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports2.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        default:
          return "UNKNOWN";
      }
    }
    exports2.proposalStatusToJSON = proposalStatusToJSON;
    function createBaseWeightedVoteOption() {
      return { option: 0, weight: "" };
    }
    exports2.WeightedVoteOption = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          option: isSet3(object.option) ? voteOptionFromJSON(object.option) : 0,
          weight: isSet3(object.weight) ? String(object.weight) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseWeightedVoteOption();
        message.option = (_a2 = object.option) !== null && _a2 !== void 0 ? _a2 : 0;
        message.weight = (_b = object.weight) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseTextProposal() {
      return { title: "", description: "" };
    }
    exports2.TextProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTextProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet3(object.title) ? String(object.title) : "",
          description: isSet3(object.description) ? String(object.description) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseTextProposal();
        message.title = (_a2 = object.title) !== null && _a2 !== void 0 ? _a2 : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseDeposit() {
      return { proposalId: "0", depositor: "", amount: [] };
    }
    exports2.Deposit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet3(object.proposalId) ? String(object.proposalId) : "0",
          depositor: isSet3(object.depositor) ? String(object.depositor) : "",
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseDeposit();
        message.proposalId = (_a2 = object.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.depositor = (_b = object.depositor) !== null && _b !== void 0 ? _b : "";
        message.amount = ((_c = object.amount) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseProposal() {
      return {
        proposalId: "0",
        content: void 0,
        status: 0,
        finalTallyResult: void 0,
        submitTime: void 0,
        depositEndTime: void 0,
        totalDeposit: [],
        votingStartTime: void 0,
        votingEndTime: void 0
      };
    }
    exports2.Proposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports2.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.depositEndTime), writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.totalDeposit) {
          coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.votingStartTime), writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.votingEndTime), writer.uint32(74).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports2.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 6:
              message.depositEndTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 9:
              message.votingEndTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet3(object.proposalId) ? String(object.proposalId) : "0",
          content: isSet3(object.content) ? any_1.Any.fromJSON(object.content) : void 0,
          status: isSet3(object.status) ? proposalStatusFromJSON(object.status) : 0,
          finalTallyResult: isSet3(object.finalTallyResult) ? exports2.TallyResult.fromJSON(object.finalTallyResult) : void 0,
          submitTime: isSet3(object.submitTime) ? fromJsonTimestamp(object.submitTime) : void 0,
          depositEndTime: isSet3(object.depositEndTime) ? fromJsonTimestamp(object.depositEndTime) : void 0,
          totalDeposit: Array.isArray(object === null || object === void 0 ? void 0 : object.totalDeposit) ? object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e)) : [],
          votingStartTime: isSet3(object.votingStartTime) ? fromJsonTimestamp(object.votingStartTime) : void 0,
          votingEndTime: isSet3(object.votingEndTime) ? fromJsonTimestamp(object.votingEndTime) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports2.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = message.submitTime.toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = message.depositEndTime.toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = message.votingStartTime.toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = message.votingEndTime.toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g;
        const message = createBaseProposal();
        message.proposalId = (_a2 = object.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.content = object.content !== void 0 && object.content !== null ? any_1.Any.fromPartial(object.content) : void 0;
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : 0;
        message.finalTallyResult = object.finalTallyResult !== void 0 && object.finalTallyResult !== null ? exports2.TallyResult.fromPartial(object.finalTallyResult) : void 0;
        message.submitTime = (_c = object.submitTime) !== null && _c !== void 0 ? _c : void 0;
        message.depositEndTime = (_d = object.depositEndTime) !== null && _d !== void 0 ? _d : void 0;
        message.totalDeposit = ((_e = object.totalDeposit) === null || _e === void 0 ? void 0 : _e.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.votingStartTime = (_f = object.votingStartTime) !== null && _f !== void 0 ? _f : void 0;
        message.votingEndTime = (_g = object.votingEndTime) !== null && _g !== void 0 ? _g : void 0;
        return message;
      }
    };
    function createBaseTallyResult() {
      return { yes: "", abstain: "", no: "", noWithVeto: "" };
    }
    exports2.TallyResult = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.yes !== "") {
          writer.uint32(10).string(message.yes);
        }
        if (message.abstain !== "") {
          writer.uint32(18).string(message.abstain);
        }
        if (message.no !== "") {
          writer.uint32(26).string(message.no);
        }
        if (message.noWithVeto !== "") {
          writer.uint32(34).string(message.noWithVeto);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yes = reader.string();
              break;
            case 2:
              message.abstain = reader.string();
              break;
            case 3:
              message.no = reader.string();
              break;
            case 4:
              message.noWithVeto = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          yes: isSet3(object.yes) ? String(object.yes) : "",
          abstain: isSet3(object.abstain) ? String(object.abstain) : "",
          no: isSet3(object.no) ? String(object.no) : "",
          noWithVeto: isSet3(object.noWithVeto) ? String(object.noWithVeto) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.yes !== void 0 && (obj.yes = message.yes);
        message.abstain !== void 0 && (obj.abstain = message.abstain);
        message.no !== void 0 && (obj.no = message.no);
        message.noWithVeto !== void 0 && (obj.noWithVeto = message.noWithVeto);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseTallyResult();
        message.yes = (_a2 = object.yes) !== null && _a2 !== void 0 ? _a2 : "";
        message.abstain = (_b = object.abstain) !== null && _b !== void 0 ? _b : "";
        message.no = (_c = object.no) !== null && _c !== void 0 ? _c : "";
        message.noWithVeto = (_d = object.noWithVeto) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseVote() {
      return { proposalId: "0", voter: "", option: 0, options: [] };
    }
    exports2.Vote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        for (const v of message.options) {
          exports2.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.options.push(exports2.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet3(object.proposalId) ? String(object.proposalId) : "0",
          voter: isSet3(object.voter) ? String(object.voter) : "",
          option: isSet3(object.option) ? voteOptionFromJSON(object.option) : 0,
          options: Array.isArray(object === null || object === void 0 ? void 0 : object.options) ? object.options.map((e) => exports2.WeightedVoteOption.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports2.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseVote();
        message.proposalId = (_a2 = object.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.voter = (_b = object.voter) !== null && _b !== void 0 ? _b : "";
        message.option = (_c = object.option) !== null && _c !== void 0 ? _c : 0;
        message.options = ((_d = object.options) === null || _d === void 0 ? void 0 : _d.map((e) => exports2.WeightedVoteOption.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDepositParams() {
      return { minDeposit: [], maxDepositPeriod: void 0 };
    }
    exports2.DepositParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          minDeposit: Array.isArray(object === null || object === void 0 ? void 0 : object.minDeposit) ? object.minDeposit.map((e) => coin_1.Coin.fromJSON(e)) : [],
          maxDepositPeriod: isSet3(object.maxDepositPeriod) ? duration_1.Duration.fromJSON(object.maxDepositPeriod) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseDepositParams();
        message.minDeposit = ((_a2 = object.minDeposit) === null || _a2 === void 0 ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.maxDepositPeriod = object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null ? duration_1.Duration.fromPartial(object.maxDepositPeriod) : void 0;
        return message;
      }
    };
    function createBaseVotingParams() {
      return { votingPeriod: void 0 };
    }
    exports2.VotingParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          votingPeriod: isSet3(object.votingPeriod) ? duration_1.Duration.fromJSON(object.votingPeriod) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVotingParams();
        message.votingPeriod = object.votingPeriod !== void 0 && object.votingPeriod !== null ? duration_1.Duration.fromPartial(object.votingPeriod) : void 0;
        return message;
      }
    };
    function createBaseTallyParams() {
      return {
        quorum: new Uint8Array(),
        threshold: new Uint8Array(),
        vetoThreshold: new Uint8Array()
      };
    }
    exports2.TallyParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.quorum.length !== 0) {
          writer.uint32(10).bytes(message.quorum);
        }
        if (message.threshold.length !== 0) {
          writer.uint32(18).bytes(message.threshold);
        }
        if (message.vetoThreshold.length !== 0) {
          writer.uint32(26).bytes(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.bytes();
              break;
            case 2:
              message.threshold = reader.bytes();
              break;
            case 3:
              message.vetoThreshold = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          quorum: isSet3(object.quorum) ? bytesFromBase642(object.quorum) : new Uint8Array(),
          threshold: isSet3(object.threshold) ? bytesFromBase642(object.threshold) : new Uint8Array(),
          vetoThreshold: isSet3(object.vetoThreshold) ? bytesFromBase642(object.vetoThreshold) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = base64FromBytes2(message.quorum !== void 0 ? message.quorum : new Uint8Array()));
        message.threshold !== void 0 && (obj.threshold = base64FromBytes2(message.threshold !== void 0 ? message.threshold : new Uint8Array()));
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = base64FromBytes2(message.vetoThreshold !== void 0 ? message.vetoThreshold : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseTallyParams();
        message.quorum = (_a2 = object.quorum) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.threshold = (_b = object.threshold) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.vetoThreshold = (_c = object.vetoThreshold) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return o;
      } else if (typeof o === "string") {
        return new Date(o);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
      }
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx.js
var require_tx7 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgDepositResponse = exports2.MsgDeposit = exports2.MsgVoteWeightedResponse = exports2.MsgVoteWeighted = exports2.MsgVoteResponse = exports2.MsgVote = exports2.MsgSubmitProposalResponse = exports2.MsgSubmitProposal = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var gov_1 = require_gov();
    var any_1 = require_any();
    var coin_1 = require_coin2();
    exports2.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseMsgSubmitProposal() {
      return { content: void 0, initialDeposit: [], proposer: "" };
    }
    exports2.MsgSubmitProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.initialDeposit) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          content: isSet3(object.content) ? any_1.Any.fromJSON(object.content) : void 0,
          initialDeposit: Array.isArray(object === null || object === void 0 ? void 0 : object.initialDeposit) ? object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e)) : [],
          proposer: isSet3(object.proposer) ? String(object.proposer) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgSubmitProposal();
        message.content = object.content !== void 0 && object.content !== null ? any_1.Any.fromPartial(object.content) : void 0;
        message.initialDeposit = ((_a2 = object.initialDeposit) === null || _a2 === void 0 ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.proposer = (_b = object.proposer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return { proposalId: "0" };
    }
    exports2.MsgSubmitProposalResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet3(object.proposalId) ? String(object.proposalId) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgSubmitProposalResponse();
        message.proposalId = (_a2 = object.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    function createBaseMsgVote() {
      return { proposalId: "0", voter: "", option: 0 };
    }
    exports2.MsgVote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet3(object.proposalId) ? String(object.proposalId) : "0",
          voter: isSet3(object.voter) ? String(object.voter) : "",
          option: isSet3(object.option) ? (0, gov_1.voteOptionFromJSON)(object.option) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgVote();
        message.proposalId = (_a2 = object.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.voter = (_b = object.voter) !== null && _b !== void 0 ? _b : "";
        message.option = (_c = object.option) !== null && _c !== void 0 ? _c : 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports2.MsgVoteResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgVoteWeighted() {
      return { proposalId: "0", voter: "", options: [] };
    }
    exports2.MsgVoteWeighted = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet3(object.proposalId) ? String(object.proposalId) : "0",
          voter: isSet3(object.voter) ? String(object.voter) : "",
          options: Array.isArray(object === null || object === void 0 ? void 0 : object.options) ? object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgVoteWeighted();
        message.proposalId = (_a2 = object.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.voter = (_b = object.voter) !== null && _b !== void 0 ? _b : "";
        message.options = ((_c = object.options) === null || _c === void 0 ? void 0 : _c.map((e) => gov_1.WeightedVoteOption.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse() {
      return {};
    }
    exports2.MsgVoteWeightedResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
      }
    };
    function createBaseMsgDeposit() {
      return { proposalId: "0", depositor: "", amount: [] };
    }
    exports2.MsgDeposit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalId !== "0") {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = longToString(reader.uint64());
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          proposalId: isSet3(object.proposalId) ? String(object.proposalId) : "0",
          depositor: isSet3(object.depositor) ? String(object.depositor) : "",
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = message.proposalId);
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgDeposit();
        message.proposalId = (_a2 = object.proposalId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.depositor = (_b = object.depositor) !== null && _b !== void 0 ? _b : "";
        message.amount = ((_c = object.amount) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse() {
      return {};
    }
    exports2.MsgDepositResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDepositResponse();
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx.js
var require_tx8 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgFundCommunityPoolResponse = exports2.MsgFundCommunityPool = exports2.MsgWithdrawValidatorCommissionResponse = exports2.MsgWithdrawValidatorCommission = exports2.MsgWithdrawDelegatorRewardResponse = exports2.MsgWithdrawDelegatorReward = exports2.MsgSetWithdrawAddressResponse = exports2.MsgSetWithdrawAddress = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    exports2.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseMsgSetWithdrawAddress() {
      return { delegatorAddress: "", withdrawAddress: "" };
    }
    exports2.MsgSetWithdrawAddress = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.withdrawAddress !== "") {
          writer.uint32(18).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddress();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          withdrawAddress: isSet3(object.withdrawAddress) ? String(object.withdrawAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgSetWithdrawAddress();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.withdrawAddress = (_b = object.withdrawAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgSetWithdrawAddressResponse() {
      return {};
    }
    exports2.MsgSetWithdrawAddressResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSetWithdrawAddressResponse();
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorReward() {
      return { delegatorAddress: "", validatorAddress: "" };
    }
    exports2.MsgWithdrawDelegatorReward = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorReward();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          delegatorAddress: isSet3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgWithdrawDelegatorReward();
        message.delegatorAddress = (_a2 = object.delegatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorRewardResponse() {
      return {};
    }
    exports2.MsgWithdrawDelegatorRewardResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommission() {
      return { validatorAddress: "" };
    }
    exports2.MsgWithdrawValidatorCommission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgWithdrawValidatorCommission();
        message.validatorAddress = (_a2 = object.validatorAddress) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommissionResponse() {
      return {};
    }
    exports2.MsgWithdrawValidatorCommissionResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        return message;
      }
    };
    function createBaseMsgFundCommunityPool() {
      return { amount: [], depositor: "" };
    }
    exports2.MsgFundCommunityPool = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : [],
          depositor: isSet3(object.depositor) ? String(object.depositor) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgFundCommunityPool();
        message.amount = ((_a2 = object.amount) === null || _a2 === void 0 ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.depositor = (_b = object.depositor) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgFundCommunityPoolResponse() {
      return {};
    }
    exports2.MsgFundCommunityPoolResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgFundCommunityPoolResponse();
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/types.js
var require_types4 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/types.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Model = exports2.AbsoluteTxPosition = exports2.ContractCodeHistoryEntry = exports2.ContractInfo = exports2.CodeInfo = exports2.Params = exports2.AccessConfig = exports2.AccessTypeParam = exports2.contractCodeHistoryOperationTypeToJSON = exports2.contractCodeHistoryOperationTypeFromJSON = exports2.ContractCodeHistoryOperationType = exports2.accessTypeToJSON = exports2.accessTypeFromJSON = exports2.AccessType = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    exports2.protobufPackage = "cosmwasm.wasm.v1";
    var AccessType;
    (function(AccessType2) {
      AccessType2[AccessType2["ACCESS_TYPE_UNSPECIFIED"] = 0] = "ACCESS_TYPE_UNSPECIFIED";
      AccessType2[AccessType2["ACCESS_TYPE_NOBODY"] = 1] = "ACCESS_TYPE_NOBODY";
      AccessType2[AccessType2["ACCESS_TYPE_ONLY_ADDRESS"] = 2] = "ACCESS_TYPE_ONLY_ADDRESS";
      AccessType2[AccessType2["ACCESS_TYPE_EVERYBODY"] = 3] = "ACCESS_TYPE_EVERYBODY";
      AccessType2[AccessType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(AccessType = exports2.AccessType || (exports2.AccessType = {}));
    function accessTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "ACCESS_TYPE_UNSPECIFIED":
          return AccessType.ACCESS_TYPE_UNSPECIFIED;
        case 1:
        case "ACCESS_TYPE_NOBODY":
          return AccessType.ACCESS_TYPE_NOBODY;
        case 2:
        case "ACCESS_TYPE_ONLY_ADDRESS":
          return AccessType.ACCESS_TYPE_ONLY_ADDRESS;
        case 3:
        case "ACCESS_TYPE_EVERYBODY":
          return AccessType.ACCESS_TYPE_EVERYBODY;
        case -1:
        case "UNRECOGNIZED":
        default:
          return AccessType.UNRECOGNIZED;
      }
    }
    exports2.accessTypeFromJSON = accessTypeFromJSON;
    function accessTypeToJSON(object) {
      switch (object) {
        case AccessType.ACCESS_TYPE_UNSPECIFIED:
          return "ACCESS_TYPE_UNSPECIFIED";
        case AccessType.ACCESS_TYPE_NOBODY:
          return "ACCESS_TYPE_NOBODY";
        case AccessType.ACCESS_TYPE_ONLY_ADDRESS:
          return "ACCESS_TYPE_ONLY_ADDRESS";
        case AccessType.ACCESS_TYPE_EVERYBODY:
          return "ACCESS_TYPE_EVERYBODY";
        default:
          return "UNKNOWN";
      }
    }
    exports2.accessTypeToJSON = accessTypeToJSON;
    var ContractCodeHistoryOperationType;
    (function(ContractCodeHistoryOperationType2) {
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"] = 0] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"] = 1] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"] = 2] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS"] = 3] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ContractCodeHistoryOperationType = exports2.ContractCodeHistoryOperationType || (exports2.ContractCodeHistoryOperationType = {}));
    function contractCodeHistoryOperationTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED;
        case 1:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT;
        case 2:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE;
        case 3:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ContractCodeHistoryOperationType.UNRECOGNIZED;
      }
    }
    exports2.contractCodeHistoryOperationTypeFromJSON = contractCodeHistoryOperationTypeFromJSON;
    function contractCodeHistoryOperationTypeToJSON(object) {
      switch (object) {
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
        default:
          return "UNKNOWN";
      }
    }
    exports2.contractCodeHistoryOperationTypeToJSON = contractCodeHistoryOperationTypeToJSON;
    function createBaseAccessTypeParam() {
      return { value: 0 };
    }
    exports2.AccessTypeParam = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.value !== 0) {
          writer.uint32(8).int32(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAccessTypeParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.value = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          value: isSet3(object.value) ? accessTypeFromJSON(object.value) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.value !== void 0 && (obj.value = accessTypeToJSON(message.value));
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseAccessTypeParam();
        message.value = (_a2 = object.value) !== null && _a2 !== void 0 ? _a2 : 0;
        return message;
      }
    };
    function createBaseAccessConfig() {
      return { permission: 0, address: "" };
    }
    exports2.AccessConfig = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.permission !== 0) {
          writer.uint32(8).int32(message.permission);
        }
        if (message.address !== "") {
          writer.uint32(18).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAccessConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.permission = reader.int32();
              break;
            case 2:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          permission: isSet3(object.permission) ? accessTypeFromJSON(object.permission) : 0,
          address: isSet3(object.address) ? String(object.address) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.permission !== void 0 && (obj.permission = accessTypeToJSON(message.permission));
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseAccessConfig();
        message.permission = (_a2 = object.permission) !== null && _a2 !== void 0 ? _a2 : 0;
        message.address = (_b = object.address) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        codeUploadAccess: void 0,
        instantiateDefaultPermission: 0,
        maxWasmCodeSize: "0"
      };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeUploadAccess !== void 0) {
          exports2.AccessConfig.encode(message.codeUploadAccess, writer.uint32(10).fork()).ldelim();
        }
        if (message.instantiateDefaultPermission !== 0) {
          writer.uint32(16).int32(message.instantiateDefaultPermission);
        }
        if (message.maxWasmCodeSize !== "0") {
          writer.uint32(24).uint64(message.maxWasmCodeSize);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeUploadAccess = exports2.AccessConfig.decode(reader, reader.uint32());
              break;
            case 2:
              message.instantiateDefaultPermission = reader.int32();
              break;
            case 3:
              message.maxWasmCodeSize = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeUploadAccess: isSet3(object.codeUploadAccess) ? exports2.AccessConfig.fromJSON(object.codeUploadAccess) : void 0,
          instantiateDefaultPermission: isSet3(object.instantiateDefaultPermission) ? accessTypeFromJSON(object.instantiateDefaultPermission) : 0,
          maxWasmCodeSize: isSet3(object.maxWasmCodeSize) ? String(object.maxWasmCodeSize) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeUploadAccess !== void 0 && (obj.codeUploadAccess = message.codeUploadAccess ? exports2.AccessConfig.toJSON(message.codeUploadAccess) : void 0);
        message.instantiateDefaultPermission !== void 0 && (obj.instantiateDefaultPermission = accessTypeToJSON(message.instantiateDefaultPermission));
        message.maxWasmCodeSize !== void 0 && (obj.maxWasmCodeSize = message.maxWasmCodeSize);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseParams();
        message.codeUploadAccess = object.codeUploadAccess !== void 0 && object.codeUploadAccess !== null ? exports2.AccessConfig.fromPartial(object.codeUploadAccess) : void 0;
        message.instantiateDefaultPermission = (_a2 = object.instantiateDefaultPermission) !== null && _a2 !== void 0 ? _a2 : 0;
        message.maxWasmCodeSize = (_b = object.maxWasmCodeSize) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function createBaseCodeInfo() {
      return {
        codeHash: new Uint8Array(),
        creator: "",
        instantiateConfig: void 0
      };
    }
    exports2.CodeInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeHash.length !== 0) {
          writer.uint32(10).bytes(message.codeHash);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.instantiateConfig !== void 0) {
          exports2.AccessConfig.encode(message.instantiateConfig, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCodeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeHash = reader.bytes();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 5:
              message.instantiateConfig = exports2.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeHash: isSet3(object.codeHash) ? bytesFromBase642(object.codeHash) : new Uint8Array(),
          creator: isSet3(object.creator) ? String(object.creator) : "",
          instantiateConfig: isSet3(object.instantiateConfig) ? exports2.AccessConfig.fromJSON(object.instantiateConfig) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeHash !== void 0 && (obj.codeHash = base64FromBytes2(message.codeHash !== void 0 ? message.codeHash : new Uint8Array()));
        message.creator !== void 0 && (obj.creator = message.creator);
        message.instantiateConfig !== void 0 && (obj.instantiateConfig = message.instantiateConfig ? exports2.AccessConfig.toJSON(message.instantiateConfig) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseCodeInfo();
        message.codeHash = (_a2 = object.codeHash) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.creator = (_b = object.creator) !== null && _b !== void 0 ? _b : "";
        message.instantiateConfig = object.instantiateConfig !== void 0 && object.instantiateConfig !== null ? exports2.AccessConfig.fromPartial(object.instantiateConfig) : void 0;
        return message;
      }
    };
    function createBaseContractInfo() {
      return {
        codeId: "0",
        creator: "",
        admin: "",
        label: "",
        created: void 0,
        ibcPortId: "",
        extension: void 0
      };
    }
    exports2.ContractInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeId !== "0") {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.admin !== "") {
          writer.uint32(26).string(message.admin);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.created !== void 0) {
          exports2.AbsoluteTxPosition.encode(message.created, writer.uint32(42).fork()).ldelim();
        }
        if (message.ibcPortId !== "") {
          writer.uint32(50).string(message.ibcPortId);
        }
        if (message.extension !== void 0) {
          any_1.Any.encode(message.extension, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContractInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = longToString(reader.uint64());
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 3:
              message.admin = reader.string();
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.created = exports2.AbsoluteTxPosition.decode(reader, reader.uint32());
              break;
            case 6:
              message.ibcPortId = reader.string();
              break;
            case 7:
              message.extension = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeId: isSet3(object.codeId) ? String(object.codeId) : "0",
          creator: isSet3(object.creator) ? String(object.creator) : "",
          admin: isSet3(object.admin) ? String(object.admin) : "",
          label: isSet3(object.label) ? String(object.label) : "",
          created: isSet3(object.created) ? exports2.AbsoluteTxPosition.fromJSON(object.created) : void 0,
          ibcPortId: isSet3(object.ibcPortId) ? String(object.ibcPortId) : "",
          extension: isSet3(object.extension) ? any_1.Any.fromJSON(object.extension) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = message.codeId);
        message.creator !== void 0 && (obj.creator = message.creator);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.label !== void 0 && (obj.label = message.label);
        message.created !== void 0 && (obj.created = message.created ? exports2.AbsoluteTxPosition.toJSON(message.created) : void 0);
        message.ibcPortId !== void 0 && (obj.ibcPortId = message.ibcPortId);
        message.extension !== void 0 && (obj.extension = message.extension ? any_1.Any.toJSON(message.extension) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e;
        const message = createBaseContractInfo();
        message.codeId = (_a2 = object.codeId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.creator = (_b = object.creator) !== null && _b !== void 0 ? _b : "";
        message.admin = (_c = object.admin) !== null && _c !== void 0 ? _c : "";
        message.label = (_d = object.label) !== null && _d !== void 0 ? _d : "";
        message.created = object.created !== void 0 && object.created !== null ? exports2.AbsoluteTxPosition.fromPartial(object.created) : void 0;
        message.ibcPortId = (_e = object.ibcPortId) !== null && _e !== void 0 ? _e : "";
        message.extension = object.extension !== void 0 && object.extension !== null ? any_1.Any.fromPartial(object.extension) : void 0;
        return message;
      }
    };
    function createBaseContractCodeHistoryEntry() {
      return {
        operation: 0,
        codeId: "0",
        updated: void 0,
        msg: new Uint8Array()
      };
    }
    exports2.ContractCodeHistoryEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operation !== 0) {
          writer.uint32(8).int32(message.operation);
        }
        if (message.codeId !== "0") {
          writer.uint32(16).uint64(message.codeId);
        }
        if (message.updated !== void 0) {
          exports2.AbsoluteTxPosition.encode(message.updated, writer.uint32(26).fork()).ldelim();
        }
        if (message.msg.length !== 0) {
          writer.uint32(34).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContractCodeHistoryEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operation = reader.int32();
              break;
            case 2:
              message.codeId = longToString(reader.uint64());
              break;
            case 3:
              message.updated = exports2.AbsoluteTxPosition.decode(reader, reader.uint32());
              break;
            case 4:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operation: isSet3(object.operation) ? contractCodeHistoryOperationTypeFromJSON(object.operation) : 0,
          codeId: isSet3(object.codeId) ? String(object.codeId) : "0",
          updated: isSet3(object.updated) ? exports2.AbsoluteTxPosition.fromJSON(object.updated) : void 0,
          msg: isSet3(object.msg) ? bytesFromBase642(object.msg) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.operation !== void 0 && (obj.operation = contractCodeHistoryOperationTypeToJSON(message.operation));
        message.codeId !== void 0 && (obj.codeId = message.codeId);
        message.updated !== void 0 && (obj.updated = message.updated ? exports2.AbsoluteTxPosition.toJSON(message.updated) : void 0);
        message.msg !== void 0 && (obj.msg = base64FromBytes2(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseContractCodeHistoryEntry();
        message.operation = (_a2 = object.operation) !== null && _a2 !== void 0 ? _a2 : 0;
        message.codeId = (_b = object.codeId) !== null && _b !== void 0 ? _b : "0";
        message.updated = object.updated !== void 0 && object.updated !== null ? exports2.AbsoluteTxPosition.fromPartial(object.updated) : void 0;
        message.msg = (_c = object.msg) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    function createBaseAbsoluteTxPosition() {
      return { blockHeight: "0", txIndex: "0" };
    }
    exports2.AbsoluteTxPosition = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockHeight !== "0") {
          writer.uint32(8).uint64(message.blockHeight);
        }
        if (message.txIndex !== "0") {
          writer.uint32(16).uint64(message.txIndex);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAbsoluteTxPosition();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockHeight = longToString(reader.uint64());
              break;
            case 2:
              message.txIndex = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          blockHeight: isSet3(object.blockHeight) ? String(object.blockHeight) : "0",
          txIndex: isSet3(object.txIndex) ? String(object.txIndex) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.blockHeight !== void 0 && (obj.blockHeight = message.blockHeight);
        message.txIndex !== void 0 && (obj.txIndex = message.txIndex);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseAbsoluteTxPosition();
        message.blockHeight = (_a2 = object.blockHeight) !== null && _a2 !== void 0 ? _a2 : "0";
        message.txIndex = (_b = object.txIndex) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function createBaseModel() {
      return { key: new Uint8Array(), value: new Uint8Array() };
    }
    exports2.Model = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet3(object.key) ? bytesFromBase642(object.key) : new Uint8Array(),
          value: isSet3(object.value) ? bytesFromBase642(object.value) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes2(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes2(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseModel();
        message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx.js
var require_tx9 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClearAdminResponse = exports2.MsgClearAdmin = exports2.MsgUpdateAdminResponse = exports2.MsgUpdateAdmin = exports2.MsgMigrateContractResponse = exports2.MsgMigrateContract = exports2.MsgExecuteContractResponse = exports2.MsgExecuteContract = exports2.MsgInstantiateContractResponse = exports2.MsgInstantiateContract = exports2.MsgStoreCodeResponse = exports2.MsgStoreCode = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var types_1 = require_types4();
    var coin_1 = require_coin2();
    exports2.protobufPackage = "cosmwasm.wasm.v1";
    function createBaseMsgStoreCode() {
      return {
        sender: "",
        wasmByteCode: new Uint8Array(),
        instantiatePermission: void 0
      };
    }
    exports2.MsgStoreCode = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.wasmByteCode.length !== 0) {
          writer.uint32(18).bytes(message.wasmByteCode);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreCode();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.wasmByteCode = reader.bytes();
              break;
            case 5:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet3(object.sender) ? String(object.sender) : "",
          wasmByteCode: isSet3(object.wasmByteCode) ? bytesFromBase642(object.wasmByteCode) : new Uint8Array(),
          instantiatePermission: isSet3(object.instantiatePermission) ? types_1.AccessConfig.fromJSON(object.instantiatePermission) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.wasmByteCode !== void 0 && (obj.wasmByteCode = base64FromBytes2(message.wasmByteCode !== void 0 ? message.wasmByteCode : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgStoreCode();
        message.sender = (_a2 = object.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.wasmByteCode = (_b = object.wasmByteCode) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.instantiatePermission = object.instantiatePermission !== void 0 && object.instantiatePermission !== null ? types_1.AccessConfig.fromPartial(object.instantiatePermission) : void 0;
        return message;
      }
    };
    function createBaseMsgStoreCodeResponse() {
      return { codeId: "0" };
    }
    exports2.MsgStoreCodeResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.codeId !== "0") {
          writer.uint32(8).uint64(message.codeId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          codeId: isSet3(object.codeId) ? String(object.codeId) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = message.codeId);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgStoreCodeResponse();
        message.codeId = (_a2 = object.codeId) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    function createBaseMsgInstantiateContract() {
      return {
        sender: "",
        admin: "",
        codeId: "0",
        label: "",
        msg: new Uint8Array(),
        funds: []
      };
    }
    exports2.MsgInstantiateContract = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (message.codeId !== "0") {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.msg.length !== 0) {
          writer.uint32(42).bytes(message.msg);
        }
        for (const v of message.funds) {
          coin_1.Coin.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.codeId = longToString(reader.uint64());
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.msg = reader.bytes();
              break;
            case 6:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet3(object.sender) ? String(object.sender) : "",
          admin: isSet3(object.admin) ? String(object.admin) : "",
          codeId: isSet3(object.codeId) ? String(object.codeId) : "0",
          label: isSet3(object.label) ? String(object.label) : "",
          msg: isSet3(object.msg) ? bytesFromBase642(object.msg) : new Uint8Array(),
          funds: Array.isArray(object === null || object === void 0 ? void 0 : object.funds) ? object.funds.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.codeId !== void 0 && (obj.codeId = message.codeId);
        message.label !== void 0 && (obj.label = message.label);
        message.msg !== void 0 && (obj.msg = base64FromBytes2(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f;
        const message = createBaseMsgInstantiateContract();
        message.sender = (_a2 = object.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.admin = (_b = object.admin) !== null && _b !== void 0 ? _b : "";
        message.codeId = (_c = object.codeId) !== null && _c !== void 0 ? _c : "0";
        message.label = (_d = object.label) !== null && _d !== void 0 ? _d : "";
        message.msg = (_e = object.msg) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.funds = ((_f = object.funds) === null || _f === void 0 ? void 0 : _f.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgInstantiateContractResponse() {
      return { address: "", data: new Uint8Array() };
    }
    exports2.MsgInstantiateContractResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet3(object.address) ? String(object.address) : "",
          data: isSet3(object.data) ? bytesFromBase642(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.data !== void 0 && (obj.data = base64FromBytes2(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgInstantiateContractResponse();
        message.address = (_a2 = object.address) !== null && _a2 !== void 0 ? _a2 : "";
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgExecuteContract() {
      return { sender: "", contract: "", msg: new Uint8Array(), funds: [] };
    }
    exports2.MsgExecuteContract = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (message.msg.length !== 0) {
          writer.uint32(26).bytes(message.msg);
        }
        for (const v of message.funds) {
          coin_1.Coin.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.msg = reader.bytes();
              break;
            case 5:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet3(object.sender) ? String(object.sender) : "",
          contract: isSet3(object.contract) ? String(object.contract) : "",
          msg: isSet3(object.msg) ? bytesFromBase642(object.msg) : new Uint8Array(),
          funds: Array.isArray(object === null || object === void 0 ? void 0 : object.funds) ? object.funds.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.msg !== void 0 && (obj.msg = base64FromBytes2(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgExecuteContract();
        message.sender = (_a2 = object.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.contract = (_b = object.contract) !== null && _b !== void 0 ? _b : "";
        message.msg = (_c = object.msg) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.funds = ((_d = object.funds) === null || _d === void 0 ? void 0 : _d.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgExecuteContractResponse() {
      return { data: new Uint8Array() };
    }
    exports2.MsgExecuteContractResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          data: isSet3(object.data) ? bytesFromBase642(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes2(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgExecuteContractResponse();
        message.data = (_a2 = object.data) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgMigrateContract() {
      return { sender: "", contract: "", codeId: "0", msg: new Uint8Array() };
    }
    exports2.MsgMigrateContract = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (message.codeId !== "0") {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.msg.length !== 0) {
          writer.uint32(34).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMigrateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.codeId = longToString(reader.uint64());
              break;
            case 4:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet3(object.sender) ? String(object.sender) : "",
          contract: isSet3(object.contract) ? String(object.contract) : "",
          codeId: isSet3(object.codeId) ? String(object.codeId) : "0",
          msg: isSet3(object.msg) ? bytesFromBase642(object.msg) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.codeId !== void 0 && (obj.codeId = message.codeId);
        message.msg !== void 0 && (obj.msg = base64FromBytes2(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgMigrateContract();
        message.sender = (_a2 = object.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.contract = (_b = object.contract) !== null && _b !== void 0 ? _b : "";
        message.codeId = (_c = object.codeId) !== null && _c !== void 0 ? _c : "0";
        message.msg = (_d = object.msg) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgMigrateContractResponse() {
      return { data: new Uint8Array() };
    }
    exports2.MsgMigrateContractResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMigrateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          data: isSet3(object.data) ? bytesFromBase642(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes2(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgMigrateContractResponse();
        message.data = (_a2 = object.data) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        return message;
      }
    };
    function createBaseMsgUpdateAdmin() {
      return { sender: "", newAdmin: "", contract: "" };
    }
    exports2.MsgUpdateAdmin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.newAdmin !== "") {
          writer.uint32(18).string(message.newAdmin);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.newAdmin = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet3(object.sender) ? String(object.sender) : "",
          newAdmin: isSet3(object.newAdmin) ? String(object.newAdmin) : "",
          contract: isSet3(object.contract) ? String(object.contract) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgUpdateAdmin();
        message.sender = (_a2 = object.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.newAdmin = (_b = object.newAdmin) !== null && _b !== void 0 ? _b : "";
        message.contract = (_c = object.contract) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgUpdateAdminResponse() {
      return {};
    }
    exports2.MsgUpdateAdminResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateAdminResponse();
        return message;
      }
    };
    function createBaseMsgClearAdmin() {
      return { sender: "", contract: "" };
    }
    exports2.MsgClearAdmin = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sender: isSet3(object.sender) ? String(object.sender) : "",
          contract: isSet3(object.contract) ? String(object.contract) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgClearAdmin();
        message.sender = (_a2 = object.sender) !== null && _a2 !== void 0 ? _a2 : "";
        message.contract = (_b = object.contract) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgClearAdminResponse() {
      return {};
    }
    exports2.MsgClearAdminResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgClearAdminResponse();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/upgrade/v1beta1/upgrade.js
var require_upgrade = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/upgrade/v1beta1/upgrade.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ModuleVersion = exports2.CancelSoftwareUpgradeProposal = exports2.SoftwareUpgradeProposal = exports2.Plan = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    exports2.protobufPackage = "cosmos.upgrade.v1beta1";
    function createBasePlan() {
      return {
        name: "",
        time: void 0,
        height: "0",
        info: "",
        upgradedClientState: void 0
      };
    }
    exports2.Plan = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(toTimestamp(message.time), writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== "0") {
          writer.uint32(24).int64(message.height);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePlan();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.time = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
              break;
            case 3:
              message.height = longToString(reader.int64());
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          name: isSet3(object.name) ? String(object.name) : "",
          time: isSet3(object.time) ? fromJsonTimestamp(object.time) : void 0,
          height: isSet3(object.height) ? String(object.height) : "0",
          info: isSet3(object.info) ? String(object.info) : "",
          upgradedClientState: isSet3(object.upgradedClientState) ? any_1.Any.fromJSON(object.upgradedClientState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.time !== void 0 && (obj.time = message.time.toISOString());
        message.height !== void 0 && (obj.height = message.height);
        message.info !== void 0 && (obj.info = message.info);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBasePlan();
        message.name = (_a2 = object.name) !== null && _a2 !== void 0 ? _a2 : "";
        message.time = (_b = object.time) !== null && _b !== void 0 ? _b : void 0;
        message.height = (_c = object.height) !== null && _c !== void 0 ? _c : "0";
        message.info = (_d = object.info) !== null && _d !== void 0 ? _d : "";
        message.upgradedClientState = object.upgradedClientState !== void 0 && object.upgradedClientState !== null ? any_1.Any.fromPartial(object.upgradedClientState) : void 0;
        return message;
      }
    };
    function createBaseSoftwareUpgradeProposal() {
      return { title: "", description: "", plan: void 0 };
    }
    exports2.SoftwareUpgradeProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          exports2.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = exports2.Plan.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet3(object.title) ? String(object.title) : "",
          description: isSet3(object.description) ? String(object.description) : "",
          plan: isSet3(object.plan) ? exports2.Plan.fromJSON(object.plan) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? exports2.Plan.toJSON(message.plan) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseSoftwareUpgradeProposal();
        message.title = (_a2 = object.title) !== null && _a2 !== void 0 ? _a2 : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.plan = object.plan !== void 0 && object.plan !== null ? exports2.Plan.fromPartial(object.plan) : void 0;
        return message;
      }
    };
    function createBaseCancelSoftwareUpgradeProposal() {
      return { title: "", description: "" };
    }
    exports2.CancelSoftwareUpgradeProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCancelSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet3(object.title) ? String(object.title) : "",
          description: isSet3(object.description) ? String(object.description) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseCancelSoftwareUpgradeProposal();
        message.title = (_a2 = object.title) !== null && _a2 !== void 0 ? _a2 : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseModuleVersion() {
      return { name: "", version: "0" };
    }
    exports2.ModuleVersion = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.version !== "0") {
          writer.uint32(16).uint64(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.version = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          name: isSet3(object.name) ? String(object.name) : "",
          version: isSet3(object.version) ? String(object.version) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseModuleVersion();
        message.name = (_a2 = object.name) !== null && _a2 !== void 0 ? _a2 : "";
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = Math.trunc(date.getTime() / 1e3).toString();
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return o;
      } else if (typeof o === "string") {
        return new Date(o);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
      }
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/ibc/core/client/v1/client.js
var require_client = __commonJS({
  "node_modules/@keplr-wallet/proto-types/ibc/core/client/v1/client.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.Height = exports2.UpgradeProposal = exports2.ClientUpdateProposal = exports2.ClientConsensusStates = exports2.ConsensusStateWithHeight = exports2.IdentifiedClientState = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    var upgrade_1 = require_upgrade();
    exports2.protobufPackage = "ibc.core.client.v1";
    function createBaseIdentifiedClientState() {
      return { clientId: "", clientState: void 0 };
    }
    exports2.IdentifiedClientState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet3(object.clientId) ? String(object.clientId) : "",
          clientState: isSet3(object.clientState) ? any_1.Any.fromJSON(object.clientState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseIdentifiedClientState();
        message.clientId = (_a2 = object.clientId) !== null && _a2 !== void 0 ? _a2 : "";
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        return message;
      }
    };
    function createBaseConsensusStateWithHeight() {
      return { height: void 0, consensusState: void 0 };
    }
    exports2.ConsensusStateWithHeight = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.height !== void 0) {
          exports2.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusStateWithHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = exports2.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          height: isSet3(object.height) ? exports2.Height.fromJSON(object.height) : void 0,
          consensusState: isSet3(object.consensusState) ? any_1.Any.fromJSON(object.consensusState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? exports2.Height.toJSON(message.height) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusStateWithHeight();
        message.height = object.height !== void 0 && object.height !== null ? exports2.Height.fromPartial(object.height) : void 0;
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        return message;
      }
    };
    function createBaseClientConsensusStates() {
      return { clientId: "", consensusStates: [] };
    }
    exports2.ClientConsensusStates = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.consensusStates) {
          exports2.ConsensusStateWithHeight.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientConsensusStates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.consensusStates.push(exports2.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          clientId: isSet3(object.clientId) ? String(object.clientId) : "",
          consensusStates: Array.isArray(object === null || object === void 0 ? void 0 : object.consensusStates) ? object.consensusStates.map((e) => exports2.ConsensusStateWithHeight.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? exports2.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseClientConsensusStates();
        message.clientId = (_a2 = object.clientId) !== null && _a2 !== void 0 ? _a2 : "";
        message.consensusStates = ((_b = object.consensusStates) === null || _b === void 0 ? void 0 : _b.map((e) => exports2.ConsensusStateWithHeight.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseClientUpdateProposal() {
      return {
        title: "",
        description: "",
        subjectClientId: "",
        substituteClientId: ""
      };
    }
    exports2.ClientUpdateProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.subjectClientId !== "") {
          writer.uint32(26).string(message.subjectClientId);
        }
        if (message.substituteClientId !== "") {
          writer.uint32(34).string(message.substituteClientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientUpdateProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.subjectClientId = reader.string();
              break;
            case 4:
              message.substituteClientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet3(object.title) ? String(object.title) : "",
          description: isSet3(object.description) ? String(object.description) : "",
          subjectClientId: isSet3(object.subjectClientId) ? String(object.subjectClientId) : "",
          substituteClientId: isSet3(object.substituteClientId) ? String(object.substituteClientId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.subjectClientId !== void 0 && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== void 0 && (obj.substituteClientId = message.substituteClientId);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseClientUpdateProposal();
        message.title = (_a2 = object.title) !== null && _a2 !== void 0 ? _a2 : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.subjectClientId = (_c = object.subjectClientId) !== null && _c !== void 0 ? _c : "";
        message.substituteClientId = (_d = object.substituteClientId) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseUpgradeProposal() {
      return {
        title: "",
        description: "",
        plan: void 0,
        upgradedClientState: void 0
      };
    }
    exports2.UpgradeProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
              break;
            case 4:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet3(object.title) ? String(object.title) : "",
          description: isSet3(object.description) ? String(object.description) : "",
          plan: isSet3(object.plan) ? upgrade_1.Plan.fromJSON(object.plan) : void 0,
          upgradedClientState: isSet3(object.upgradedClientState) ? any_1.Any.fromJSON(object.upgradedClientState) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : void 0);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseUpgradeProposal();
        message.title = (_a2 = object.title) !== null && _a2 !== void 0 ? _a2 : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.plan = object.plan !== void 0 && object.plan !== null ? upgrade_1.Plan.fromPartial(object.plan) : void 0;
        message.upgradedClientState = object.upgradedClientState !== void 0 && object.upgradedClientState !== null ? any_1.Any.fromPartial(object.upgradedClientState) : void 0;
        return message;
      }
    };
    function createBaseHeight() {
      return { revisionNumber: "0", revisionHeight: "0" };
    }
    exports2.Height = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.revisionNumber !== "0") {
          writer.uint32(8).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== "0") {
          writer.uint32(16).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.revisionNumber = longToString(reader.uint64());
              break;
            case 2:
              message.revisionHeight = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          revisionNumber: isSet3(object.revisionNumber) ? String(object.revisionNumber) : "0",
          revisionHeight: isSet3(object.revisionHeight) ? String(object.revisionHeight) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.revisionNumber !== void 0 && (obj.revisionNumber = message.revisionNumber);
        message.revisionHeight !== void 0 && (obj.revisionHeight = message.revisionHeight);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseHeight();
        message.revisionNumber = (_a2 = object.revisionNumber) !== null && _a2 !== void 0 ? _a2 : "0";
        message.revisionHeight = (_b = object.revisionHeight) !== null && _b !== void 0 ? _b : "0";
        return message;
      }
    };
    function createBaseParams() {
      return { allowedClients: [] };
    }
    exports2.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.allowedClients) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowedClients.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          allowedClients: Array.isArray(object === null || object === void 0 ? void 0 : object.allowedClients) ? object.allowedClients.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.allowedClients) {
          obj.allowedClients = message.allowedClients.map((e) => e);
        } else {
          obj.allowedClients = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseParams();
        message.allowedClients = ((_a2 = object.allowedClients) === null || _a2 === void 0 ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx.js
var require_tx10 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgTransferResponse = exports2.MsgTransfer = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    var client_1 = require_client();
    exports2.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseMsgTransfer() {
      return {
        sourcePort: "",
        sourceChannel: "",
        token: void 0,
        sender: "",
        receiver: "",
        timeoutHeight: void 0,
        timeoutTimestamp: "0",
        memo: ""
      };
    }
    exports2.MsgTransfer = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sourcePort !== "") {
          writer.uint32(10).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(18).string(message.sourceChannel);
        }
        if (message.token !== void 0) {
          coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();
        }
        if (message.sender !== "") {
          writer.uint32(34).string(message.sender);
        }
        if (message.receiver !== "") {
          writer.uint32(42).string(message.receiver);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== "0") {
          writer.uint32(56).uint64(message.timeoutTimestamp);
        }
        if (message.memo !== "") {
          writer.uint32(66).string(message.memo);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransfer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sourcePort = reader.string();
              break;
            case 2:
              message.sourceChannel = reader.string();
              break;
            case 3:
              message.token = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.sender = reader.string();
              break;
            case 5:
              message.receiver = reader.string();
              break;
            case 6:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.timeoutTimestamp = longToString(reader.uint64());
              break;
            case 8:
              message.memo = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sourcePort: isSet3(object.sourcePort) ? String(object.sourcePort) : "",
          sourceChannel: isSet3(object.sourceChannel) ? String(object.sourceChannel) : "",
          token: isSet3(object.token) ? coin_1.Coin.fromJSON(object.token) : void 0,
          sender: isSet3(object.sender) ? String(object.sender) : "",
          receiver: isSet3(object.receiver) ? String(object.receiver) : "",
          timeoutHeight: isSet3(object.timeoutHeight) ? client_1.Height.fromJSON(object.timeoutHeight) : void 0,
          timeoutTimestamp: isSet3(object.timeoutTimestamp) ? String(object.timeoutTimestamp) : "0",
          memo: isSet3(object.memo) ? String(object.memo) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.token !== void 0 && (obj.token = message.token ? coin_1.Coin.toJSON(message.token) : void 0);
        message.sender !== void 0 && (obj.sender = message.sender);
        message.receiver !== void 0 && (obj.receiver = message.receiver);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = message.timeoutTimestamp);
        message.memo !== void 0 && (obj.memo = message.memo);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f;
        const message = createBaseMsgTransfer();
        message.sourcePort = (_a2 = object.sourcePort) !== null && _a2 !== void 0 ? _a2 : "";
        message.sourceChannel = (_b = object.sourceChannel) !== null && _b !== void 0 ? _b : "";
        message.token = object.token !== void 0 && object.token !== null ? coin_1.Coin.fromPartial(object.token) : void 0;
        message.sender = (_c = object.sender) !== null && _c !== void 0 ? _c : "";
        message.receiver = (_d = object.receiver) !== null && _d !== void 0 ? _d : "";
        message.timeoutHeight = object.timeoutHeight !== void 0 && object.timeoutHeight !== null ? client_1.Height.fromPartial(object.timeoutHeight) : void 0;
        message.timeoutTimestamp = (_e = object.timeoutTimestamp) !== null && _e !== void 0 ? _e : "0";
        message.memo = (_f = object.memo) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseMsgTransferResponse() {
      return {};
    }
    exports2.MsgTransferResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgTransferResponse();
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/ibc/core/channel/v1/channel.js
var require_channel = __commonJS({
  "node_modules/@keplr-wallet/proto-types/ibc/core/channel/v1/channel.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timeout = exports2.Acknowledgement = exports2.PacketId = exports2.PacketState = exports2.Packet = exports2.Counterparty = exports2.IdentifiedChannel = exports2.Channel = exports2.orderToJSON = exports2.orderFromJSON = exports2.Order = exports2.stateToJSON = exports2.stateFromJSON = exports2.State = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var client_1 = require_client();
    exports2.protobufPackage = "ibc.core.channel.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["STATE_CLOSED"] = 4] = "STATE_CLOSED";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State = exports2.State || (exports2.State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case 4:
        case "STATE_CLOSED":
          return State.STATE_CLOSED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports2.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        case State.STATE_CLOSED:
          return "STATE_CLOSED";
        default:
          return "UNKNOWN";
      }
    }
    exports2.stateToJSON = stateToJSON;
    var Order;
    (function(Order2) {
      Order2[Order2["ORDER_NONE_UNSPECIFIED"] = 0] = "ORDER_NONE_UNSPECIFIED";
      Order2[Order2["ORDER_UNORDERED"] = 1] = "ORDER_UNORDERED";
      Order2[Order2["ORDER_ORDERED"] = 2] = "ORDER_ORDERED";
      Order2[Order2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Order = exports2.Order || (exports2.Order = {}));
    function orderFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_NONE_UNSPECIFIED":
          return Order.ORDER_NONE_UNSPECIFIED;
        case 1:
        case "ORDER_UNORDERED":
          return Order.ORDER_UNORDERED;
        case 2:
        case "ORDER_ORDERED":
          return Order.ORDER_ORDERED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Order.UNRECOGNIZED;
      }
    }
    exports2.orderFromJSON = orderFromJSON;
    function orderToJSON(object) {
      switch (object) {
        case Order.ORDER_NONE_UNSPECIFIED:
          return "ORDER_NONE_UNSPECIFIED";
        case Order.ORDER_UNORDERED:
          return "ORDER_UNORDERED";
        case Order.ORDER_ORDERED:
          return "ORDER_ORDERED";
        default:
          return "UNKNOWN";
      }
    }
    exports2.orderToJSON = orderToJSON;
    function createBaseChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: void 0,
        connectionHops: [],
        version: ""
      };
    }
    exports2.Channel = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports2.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports2.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          state: isSet3(object.state) ? stateFromJSON(object.state) : 0,
          ordering: isSet3(object.ordering) ? orderFromJSON(object.ordering) : 0,
          counterparty: isSet3(object.counterparty) ? exports2.Counterparty.fromJSON(object.counterparty) : void 0,
          connectionHops: Array.isArray(object === null || object === void 0 ? void 0 : object.connectionHops) ? object.connectionHops.map((e) => String(e)) : [],
          version: isSet3(object.version) ? String(object.version) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports2.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseChannel();
        message.state = (_a2 = object.state) !== null && _a2 !== void 0 ? _a2 : 0;
        message.ordering = (_b = object.ordering) !== null && _b !== void 0 ? _b : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports2.Counterparty.fromPartial(object.counterparty) : void 0;
        message.connectionHops = ((_c = object.connectionHops) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.version = (_d = object.version) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseIdentifiedChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: void 0,
        connectionHops: [],
        version: "",
        portId: "",
        channelId: ""
      };
    }
    exports2.IdentifiedChannel = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports2.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        if (message.portId !== "") {
          writer.uint32(50).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(58).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports2.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            case 6:
              message.portId = reader.string();
              break;
            case 7:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          state: isSet3(object.state) ? stateFromJSON(object.state) : 0,
          ordering: isSet3(object.ordering) ? orderFromJSON(object.ordering) : 0,
          counterparty: isSet3(object.counterparty) ? exports2.Counterparty.fromJSON(object.counterparty) : void 0,
          connectionHops: Array.isArray(object === null || object === void 0 ? void 0 : object.connectionHops) ? object.connectionHops.map((e) => String(e)) : [],
          version: isSet3(object.version) ? String(object.version) : "",
          portId: isSet3(object.portId) ? String(object.portId) : "",
          channelId: isSet3(object.channelId) ? String(object.channelId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports2.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f;
        const message = createBaseIdentifiedChannel();
        message.state = (_a2 = object.state) !== null && _a2 !== void 0 ? _a2 : 0;
        message.ordering = (_b = object.ordering) !== null && _b !== void 0 ? _b : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports2.Counterparty.fromPartial(object.counterparty) : void 0;
        message.connectionHops = ((_c = object.connectionHops) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.version = (_d = object.version) !== null && _d !== void 0 ? _d : "";
        message.portId = (_e = object.portId) !== null && _e !== void 0 ? _e : "";
        message.channelId = (_f = object.channelId) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    function createBaseCounterparty() {
      return { portId: "", channelId: "" };
    }
    exports2.Counterparty = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet3(object.portId) ? String(object.portId) : "",
          channelId: isSet3(object.channelId) ? String(object.channelId) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseCounterparty();
        message.portId = (_a2 = object.portId) !== null && _a2 !== void 0 ? _a2 : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBasePacket() {
      return {
        sequence: "0",
        sourcePort: "",
        sourceChannel: "",
        destinationPort: "",
        destinationChannel: "",
        data: new Uint8Array(),
        timeoutHeight: void 0,
        timeoutTimestamp: "0"
      };
    }
    exports2.Packet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sequence !== "0") {
          writer.uint32(8).uint64(message.sequence);
        }
        if (message.sourcePort !== "") {
          writer.uint32(18).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(26).string(message.sourceChannel);
        }
        if (message.destinationPort !== "") {
          writer.uint32(34).string(message.destinationPort);
        }
        if (message.destinationChannel !== "") {
          writer.uint32(42).string(message.destinationChannel);
        }
        if (message.data.length !== 0) {
          writer.uint32(50).bytes(message.data);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== "0") {
          writer.uint32(64).uint64(message.timeoutTimestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = longToString(reader.uint64());
              break;
            case 2:
              message.sourcePort = reader.string();
              break;
            case 3:
              message.sourceChannel = reader.string();
              break;
            case 4:
              message.destinationPort = reader.string();
              break;
            case 5:
              message.destinationChannel = reader.string();
              break;
            case 6:
              message.data = reader.bytes();
              break;
            case 7:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.timeoutTimestamp = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          sequence: isSet3(object.sequence) ? String(object.sequence) : "0",
          sourcePort: isSet3(object.sourcePort) ? String(object.sourcePort) : "",
          sourceChannel: isSet3(object.sourceChannel) ? String(object.sourceChannel) : "",
          destinationPort: isSet3(object.destinationPort) ? String(object.destinationPort) : "",
          destinationChannel: isSet3(object.destinationChannel) ? String(object.destinationChannel) : "",
          data: isSet3(object.data) ? bytesFromBase642(object.data) : new Uint8Array(),
          timeoutHeight: isSet3(object.timeoutHeight) ? client_1.Height.fromJSON(object.timeoutHeight) : void 0,
          timeoutTimestamp: isSet3(object.timeoutTimestamp) ? String(object.timeoutTimestamp) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = message.sequence);
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.destinationPort !== void 0 && (obj.destinationPort = message.destinationPort);
        message.destinationChannel !== void 0 && (obj.destinationChannel = message.destinationChannel);
        message.data !== void 0 && (obj.data = base64FromBytes2(message.data !== void 0 ? message.data : new Uint8Array()));
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = message.timeoutTimestamp);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g;
        const message = createBasePacket();
        message.sequence = (_a2 = object.sequence) !== null && _a2 !== void 0 ? _a2 : "0";
        message.sourcePort = (_b = object.sourcePort) !== null && _b !== void 0 ? _b : "";
        message.sourceChannel = (_c = object.sourceChannel) !== null && _c !== void 0 ? _c : "";
        message.destinationPort = (_d = object.destinationPort) !== null && _d !== void 0 ? _d : "";
        message.destinationChannel = (_e = object.destinationChannel) !== null && _e !== void 0 ? _e : "";
        message.data = (_f = object.data) !== null && _f !== void 0 ? _f : new Uint8Array();
        message.timeoutHeight = object.timeoutHeight !== void 0 && object.timeoutHeight !== null ? client_1.Height.fromPartial(object.timeoutHeight) : void 0;
        message.timeoutTimestamp = (_g = object.timeoutTimestamp) !== null && _g !== void 0 ? _g : "0";
        return message;
      }
    };
    function createBasePacketState() {
      return { portId: "", channelId: "", sequence: "0", data: new Uint8Array() };
    }
    exports2.PacketState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== "0") {
          writer.uint32(24).uint64(message.sequence);
        }
        if (message.data.length !== 0) {
          writer.uint32(34).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = longToString(reader.uint64());
              break;
            case 4:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet3(object.portId) ? String(object.portId) : "",
          channelId: isSet3(object.channelId) ? String(object.channelId) : "",
          sequence: isSet3(object.sequence) ? String(object.sequence) : "0",
          data: isSet3(object.data) ? bytesFromBase642(object.data) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = message.sequence);
        message.data !== void 0 && (obj.data = base64FromBytes2(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBasePacketState();
        message.portId = (_a2 = object.portId) !== null && _a2 !== void 0 ? _a2 : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.sequence = (_c = object.sequence) !== null && _c !== void 0 ? _c : "0";
        message.data = (_d = object.data) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    function createBasePacketId() {
      return { portId: "", channelId: "", sequence: "0" };
    }
    exports2.PacketId = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== "0") {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketId();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet3(object.portId) ? String(object.portId) : "",
          channelId: isSet3(object.channelId) ? String(object.channelId) : "",
          sequence: isSet3(object.sequence) ? String(object.sequence) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = message.sequence);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBasePacketId();
        message.portId = (_a2 = object.portId) !== null && _a2 !== void 0 ? _a2 : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.sequence = (_c = object.sequence) !== null && _c !== void 0 ? _c : "0";
        return message;
      }
    };
    function createBaseAcknowledgement() {
      return { result: void 0, error: void 0 };
    }
    exports2.Acknowledgement = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== void 0) {
          writer.uint32(170).bytes(message.result);
        }
        if (message.error !== void 0) {
          writer.uint32(178).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 21:
              message.result = reader.bytes();
              break;
            case 22:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          result: isSet3(object.result) ? bytesFromBase642(object.result) : void 0,
          error: isSet3(object.error) ? String(object.error) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = message.result !== void 0 ? base64FromBytes2(message.result) : void 0);
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseAcknowledgement();
        message.result = (_a2 = object.result) !== null && _a2 !== void 0 ? _a2 : void 0;
        message.error = (_b = object.error) !== null && _b !== void 0 ? _b : void 0;
        return message;
      }
    };
    function createBaseTimeout() {
      return { height: void 0, timestamp: "0" };
    }
    exports2.Timeout = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.timestamp !== "0") {
          writer.uint32(16).uint64(message.timestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.timestamp = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          height: isSet3(object.height) ? client_1.Height.fromJSON(object.height) : void 0,
          timestamp: isSet3(object.timestamp) ? String(object.timestamp) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseTimeout();
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        message.timestamp = (_a2 = object.timestamp) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/ibc/applications/fee/v1/fee.js
var require_fee = __commonJS({
  "node_modules/@keplr-wallet/proto-types/ibc/applications/fee/v1/fee.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdentifiedPacketFees = exports2.PacketFees = exports2.PacketFee = exports2.Fee = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    var channel_1 = require_channel();
    exports2.protobufPackage = "ibc.applications.fee.v1";
    function createBaseFee() {
      return { recvFee: [], ackFee: [], timeoutFee: [] };
    }
    exports2.Fee = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.recvFee) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.ackFee) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.timeoutFee) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.recvFee.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.ackFee.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.timeoutFee.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          recvFee: Array.isArray(object === null || object === void 0 ? void 0 : object.recvFee) ? object.recvFee.map((e) => coin_1.Coin.fromJSON(e)) : [],
          ackFee: Array.isArray(object === null || object === void 0 ? void 0 : object.ackFee) ? object.ackFee.map((e) => coin_1.Coin.fromJSON(e)) : [],
          timeoutFee: Array.isArray(object === null || object === void 0 ? void 0 : object.timeoutFee) ? object.timeoutFee.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.recvFee) {
          obj.recvFee = message.recvFee.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.recvFee = [];
        }
        if (message.ackFee) {
          obj.ackFee = message.ackFee.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.ackFee = [];
        }
        if (message.timeoutFee) {
          obj.timeoutFee = message.timeoutFee.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.timeoutFee = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseFee();
        message.recvFee = ((_a2 = object.recvFee) === null || _a2 === void 0 ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.ackFee = ((_b = object.ackFee) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.timeoutFee = ((_c = object.timeoutFee) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePacketFee() {
      return { fee: void 0, refundAddress: "", relayers: [] };
    }
    exports2.PacketFee = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fee !== void 0) {
          exports2.Fee.encode(message.fee, writer.uint32(10).fork()).ldelim();
        }
        if (message.refundAddress !== "") {
          writer.uint32(18).string(message.refundAddress);
        }
        for (const v of message.relayers) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketFee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fee = exports2.Fee.decode(reader, reader.uint32());
              break;
            case 2:
              message.refundAddress = reader.string();
              break;
            case 3:
              message.relayers.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          fee: isSet3(object.fee) ? exports2.Fee.fromJSON(object.fee) : void 0,
          refundAddress: isSet3(object.refundAddress) ? String(object.refundAddress) : "",
          relayers: Array.isArray(object === null || object === void 0 ? void 0 : object.relayers) ? object.relayers.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.fee !== void 0 && (obj.fee = message.fee ? exports2.Fee.toJSON(message.fee) : void 0);
        message.refundAddress !== void 0 && (obj.refundAddress = message.refundAddress);
        if (message.relayers) {
          obj.relayers = message.relayers.map((e) => e);
        } else {
          obj.relayers = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBasePacketFee();
        message.fee = object.fee !== void 0 && object.fee !== null ? exports2.Fee.fromPartial(object.fee) : void 0;
        message.refundAddress = (_a2 = object.refundAddress) !== null && _a2 !== void 0 ? _a2 : "";
        message.relayers = ((_b = object.relayers) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBasePacketFees() {
      return { packetFees: [] };
    }
    exports2.PacketFees = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.packetFees) {
          exports2.PacketFee.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketFees();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packetFees.push(exports2.PacketFee.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          packetFees: Array.isArray(object === null || object === void 0 ? void 0 : object.packetFees) ? object.packetFees.map((e) => exports2.PacketFee.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.packetFees) {
          obj.packetFees = message.packetFees.map((e) => e ? exports2.PacketFee.toJSON(e) : void 0);
        } else {
          obj.packetFees = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBasePacketFees();
        message.packetFees = ((_a2 = object.packetFees) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.PacketFee.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseIdentifiedPacketFees() {
      return { packetId: void 0, packetFees: [] };
    }
    exports2.IdentifiedPacketFees = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.packetId !== void 0) {
          channel_1.PacketId.encode(message.packetId, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.packetFees) {
          exports2.PacketFee.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedPacketFees();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packetId = channel_1.PacketId.decode(reader, reader.uint32());
              break;
            case 2:
              message.packetFees.push(exports2.PacketFee.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          packetId: isSet3(object.packetId) ? channel_1.PacketId.fromJSON(object.packetId) : void 0,
          packetFees: Array.isArray(object === null || object === void 0 ? void 0 : object.packetFees) ? object.packetFees.map((e) => exports2.PacketFee.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.packetId !== void 0 && (obj.packetId = message.packetId ? channel_1.PacketId.toJSON(message.packetId) : void 0);
        if (message.packetFees) {
          obj.packetFees = message.packetFees.map((e) => e ? exports2.PacketFee.toJSON(e) : void 0);
        } else {
          obj.packetFees = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseIdentifiedPacketFees();
        message.packetId = object.packetId !== void 0 && object.packetId !== null ? channel_1.PacketId.fromPartial(object.packetId) : void 0;
        message.packetFees = ((_a2 = object.packetFees) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.PacketFee.fromPartial(e))) || [];
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/ibc/applications/fee/v1/tx.js
var require_tx11 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/ibc/applications/fee/v1/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgPayPacketFeeAsyncResponse = exports2.MsgPayPacketFeeAsync = exports2.MsgPayPacketFeeResponse = exports2.MsgPayPacketFee = exports2.MsgRegisterCounterpartyPayeeResponse = exports2.MsgRegisterCounterpartyPayee = exports2.MsgRegisterPayeeResponse = exports2.MsgRegisterPayee = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var fee_1 = require_fee();
    var channel_1 = require_channel();
    exports2.protobufPackage = "ibc.applications.fee.v1";
    function createBaseMsgRegisterPayee() {
      return { portId: "", channelId: "", relayer: "", payee: "" };
    }
    exports2.MsgRegisterPayee = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.relayer !== "") {
          writer.uint32(26).string(message.relayer);
        }
        if (message.payee !== "") {
          writer.uint32(34).string(message.payee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterPayee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.relayer = reader.string();
              break;
            case 4:
              message.payee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet3(object.portId) ? String(object.portId) : "",
          channelId: isSet3(object.channelId) ? String(object.channelId) : "",
          relayer: isSet3(object.relayer) ? String(object.relayer) : "",
          payee: isSet3(object.payee) ? String(object.payee) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.relayer !== void 0 && (obj.relayer = message.relayer);
        message.payee !== void 0 && (obj.payee = message.payee);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgRegisterPayee();
        message.portId = (_a2 = object.portId) !== null && _a2 !== void 0 ? _a2 : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.relayer = (_c = object.relayer) !== null && _c !== void 0 ? _c : "";
        message.payee = (_d = object.payee) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseMsgRegisterPayeeResponse() {
      return {};
    }
    exports2.MsgRegisterPayeeResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterPayeeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRegisterPayeeResponse();
        return message;
      }
    };
    function createBaseMsgRegisterCounterpartyPayee() {
      return { portId: "", channelId: "", relayer: "", counterpartyPayee: "" };
    }
    exports2.MsgRegisterCounterpartyPayee = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.relayer !== "") {
          writer.uint32(26).string(message.relayer);
        }
        if (message.counterpartyPayee !== "") {
          writer.uint32(34).string(message.counterpartyPayee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterCounterpartyPayee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.relayer = reader.string();
              break;
            case 4:
              message.counterpartyPayee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          portId: isSet3(object.portId) ? String(object.portId) : "",
          channelId: isSet3(object.channelId) ? String(object.channelId) : "",
          relayer: isSet3(object.relayer) ? String(object.relayer) : "",
          counterpartyPayee: isSet3(object.counterpartyPayee) ? String(object.counterpartyPayee) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.relayer !== void 0 && (obj.relayer = message.relayer);
        message.counterpartyPayee !== void 0 && (obj.counterpartyPayee = message.counterpartyPayee);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgRegisterCounterpartyPayee();
        message.portId = (_a2 = object.portId) !== null && _a2 !== void 0 ? _a2 : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.relayer = (_c = object.relayer) !== null && _c !== void 0 ? _c : "";
        message.counterpartyPayee = (_d = object.counterpartyPayee) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseMsgRegisterCounterpartyPayeeResponse() {
      return {};
    }
    exports2.MsgRegisterCounterpartyPayeeResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterCounterpartyPayeeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRegisterCounterpartyPayeeResponse();
        return message;
      }
    };
    function createBaseMsgPayPacketFee() {
      return {
        fee: void 0,
        sourcePortId: "",
        sourceChannelId: "",
        signer: "",
        relayers: []
      };
    }
    exports2.MsgPayPacketFee = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fee !== void 0) {
          fee_1.Fee.encode(message.fee, writer.uint32(10).fork()).ldelim();
        }
        if (message.sourcePortId !== "") {
          writer.uint32(18).string(message.sourcePortId);
        }
        if (message.sourceChannelId !== "") {
          writer.uint32(26).string(message.sourceChannelId);
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        for (const v of message.relayers) {
          writer.uint32(42).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPayPacketFee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fee = fee_1.Fee.decode(reader, reader.uint32());
              break;
            case 2:
              message.sourcePortId = reader.string();
              break;
            case 3:
              message.sourceChannelId = reader.string();
              break;
            case 4:
              message.signer = reader.string();
              break;
            case 5:
              message.relayers.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          fee: isSet3(object.fee) ? fee_1.Fee.fromJSON(object.fee) : void 0,
          sourcePortId: isSet3(object.sourcePortId) ? String(object.sourcePortId) : "",
          sourceChannelId: isSet3(object.sourceChannelId) ? String(object.sourceChannelId) : "",
          signer: isSet3(object.signer) ? String(object.signer) : "",
          relayers: Array.isArray(object === null || object === void 0 ? void 0 : object.relayers) ? object.relayers.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.fee !== void 0 && (obj.fee = message.fee ? fee_1.Fee.toJSON(message.fee) : void 0);
        message.sourcePortId !== void 0 && (obj.sourcePortId = message.sourcePortId);
        message.sourceChannelId !== void 0 && (obj.sourceChannelId = message.sourceChannelId);
        message.signer !== void 0 && (obj.signer = message.signer);
        if (message.relayers) {
          obj.relayers = message.relayers.map((e) => e);
        } else {
          obj.relayers = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgPayPacketFee();
        message.fee = object.fee !== void 0 && object.fee !== null ? fee_1.Fee.fromPartial(object.fee) : void 0;
        message.sourcePortId = (_a2 = object.sourcePortId) !== null && _a2 !== void 0 ? _a2 : "";
        message.sourceChannelId = (_b = object.sourceChannelId) !== null && _b !== void 0 ? _b : "";
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        message.relayers = ((_d = object.relayers) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMsgPayPacketFeeResponse() {
      return {};
    }
    exports2.MsgPayPacketFeeResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPayPacketFeeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgPayPacketFeeResponse();
        return message;
      }
    };
    function createBaseMsgPayPacketFeeAsync() {
      return { packetId: void 0, packetFee: void 0 };
    }
    exports2.MsgPayPacketFeeAsync = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.packetId !== void 0) {
          channel_1.PacketId.encode(message.packetId, writer.uint32(10).fork()).ldelim();
        }
        if (message.packetFee !== void 0) {
          fee_1.PacketFee.encode(message.packetFee, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPayPacketFeeAsync();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packetId = channel_1.PacketId.decode(reader, reader.uint32());
              break;
            case 2:
              message.packetFee = fee_1.PacketFee.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          packetId: isSet3(object.packetId) ? channel_1.PacketId.fromJSON(object.packetId) : void 0,
          packetFee: isSet3(object.packetFee) ? fee_1.PacketFee.fromJSON(object.packetFee) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.packetId !== void 0 && (obj.packetId = message.packetId ? channel_1.PacketId.toJSON(message.packetId) : void 0);
        message.packetFee !== void 0 && (obj.packetFee = message.packetFee ? fee_1.PacketFee.toJSON(message.packetFee) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPayPacketFeeAsync();
        message.packetId = object.packetId !== void 0 && object.packetId !== null ? channel_1.PacketId.fromPartial(object.packetId) : void 0;
        message.packetFee = object.packetFee !== void 0 && object.packetFee !== null ? fee_1.PacketFee.fromPartial(object.packetFee) : void 0;
        return message;
      }
    };
    function createBaseMsgPayPacketFeeAsyncResponse() {
      return {};
    }
    exports2.MsgPayPacketFeeAsyncResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPayPacketFeeAsyncResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgPayPacketFeeAsyncResponse();
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/cosmos/build/stargate/codec/unknown.js
var require_unknown = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/stargate/codec/unknown.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnknownMessage = void 0;
    var buffer_1 = require_dist();
    var UnknownMessage = class {
      constructor(_typeUrl, _value) {
        this._typeUrl = _typeUrl;
        this._value = _value;
      }
      get typeUrl() {
        return this._typeUrl;
      }
      get value() {
        return this._value;
      }
      toJSON() {
        return {
          typeUrl: this._typeUrl,
          value: buffer_1.Buffer.from(this._value).toString("base64")
        };
      }
    };
    exports2.UnknownMessage = UnknownMessage;
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/authz.js
var require_authz2 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/authz.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StakeAuthorization_Validators = exports2.StakeAuthorization = exports2.authorizationTypeToJSON = exports2.authorizationTypeFromJSON = exports2.AuthorizationType = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    exports2.protobufPackage = "cosmos.staking.v1beta1";
    var AuthorizationType;
    (function(AuthorizationType2) {
      AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_UNSPECIFIED"] = 0] = "AUTHORIZATION_TYPE_UNSPECIFIED";
      AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_DELEGATE"] = 1] = "AUTHORIZATION_TYPE_DELEGATE";
      AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_UNDELEGATE"] = 2] = "AUTHORIZATION_TYPE_UNDELEGATE";
      AuthorizationType2[AuthorizationType2["AUTHORIZATION_TYPE_REDELEGATE"] = 3] = "AUTHORIZATION_TYPE_REDELEGATE";
      AuthorizationType2[AuthorizationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(AuthorizationType = exports2.AuthorizationType || (exports2.AuthorizationType = {}));
    function authorizationTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "AUTHORIZATION_TYPE_UNSPECIFIED":
          return AuthorizationType.AUTHORIZATION_TYPE_UNSPECIFIED;
        case 1:
        case "AUTHORIZATION_TYPE_DELEGATE":
          return AuthorizationType.AUTHORIZATION_TYPE_DELEGATE;
        case 2:
        case "AUTHORIZATION_TYPE_UNDELEGATE":
          return AuthorizationType.AUTHORIZATION_TYPE_UNDELEGATE;
        case 3:
        case "AUTHORIZATION_TYPE_REDELEGATE":
          return AuthorizationType.AUTHORIZATION_TYPE_REDELEGATE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return AuthorizationType.UNRECOGNIZED;
      }
    }
    exports2.authorizationTypeFromJSON = authorizationTypeFromJSON;
    function authorizationTypeToJSON(object) {
      switch (object) {
        case AuthorizationType.AUTHORIZATION_TYPE_UNSPECIFIED:
          return "AUTHORIZATION_TYPE_UNSPECIFIED";
        case AuthorizationType.AUTHORIZATION_TYPE_DELEGATE:
          return "AUTHORIZATION_TYPE_DELEGATE";
        case AuthorizationType.AUTHORIZATION_TYPE_UNDELEGATE:
          return "AUTHORIZATION_TYPE_UNDELEGATE";
        case AuthorizationType.AUTHORIZATION_TYPE_REDELEGATE:
          return "AUTHORIZATION_TYPE_REDELEGATE";
        default:
          return "UNKNOWN";
      }
    }
    exports2.authorizationTypeToJSON = authorizationTypeToJSON;
    function createBaseStakeAuthorization() {
      return {
        maxTokens: void 0,
        allowList: void 0,
        denyList: void 0,
        authorizationType: 0
      };
    }
    exports2.StakeAuthorization = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.maxTokens !== void 0) {
          coin_1.Coin.encode(message.maxTokens, writer.uint32(10).fork()).ldelim();
        }
        if (message.allowList !== void 0) {
          exports2.StakeAuthorization_Validators.encode(message.allowList, writer.uint32(18).fork()).ldelim();
        }
        if (message.denyList !== void 0) {
          exports2.StakeAuthorization_Validators.encode(message.denyList, writer.uint32(26).fork()).ldelim();
        }
        if (message.authorizationType !== 0) {
          writer.uint32(32).int32(message.authorizationType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStakeAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxTokens = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.allowList = exports2.StakeAuthorization_Validators.decode(reader, reader.uint32());
              break;
            case 3:
              message.denyList = exports2.StakeAuthorization_Validators.decode(reader, reader.uint32());
              break;
            case 4:
              message.authorizationType = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          maxTokens: isSet3(object.maxTokens) ? coin_1.Coin.fromJSON(object.maxTokens) : void 0,
          allowList: isSet3(object.allowList) ? exports2.StakeAuthorization_Validators.fromJSON(object.allowList) : void 0,
          denyList: isSet3(object.denyList) ? exports2.StakeAuthorization_Validators.fromJSON(object.denyList) : void 0,
          authorizationType: isSet3(object.authorizationType) ? authorizationTypeFromJSON(object.authorizationType) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.maxTokens !== void 0 && (obj.maxTokens = message.maxTokens ? coin_1.Coin.toJSON(message.maxTokens) : void 0);
        message.allowList !== void 0 && (obj.allowList = message.allowList ? exports2.StakeAuthorization_Validators.toJSON(message.allowList) : void 0);
        message.denyList !== void 0 && (obj.denyList = message.denyList ? exports2.StakeAuthorization_Validators.toJSON(message.denyList) : void 0);
        message.authorizationType !== void 0 && (obj.authorizationType = authorizationTypeToJSON(message.authorizationType));
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseStakeAuthorization();
        message.maxTokens = object.maxTokens !== void 0 && object.maxTokens !== null ? coin_1.Coin.fromPartial(object.maxTokens) : void 0;
        message.allowList = object.allowList !== void 0 && object.allowList !== null ? exports2.StakeAuthorization_Validators.fromPartial(object.allowList) : void 0;
        message.denyList = object.denyList !== void 0 && object.denyList !== null ? exports2.StakeAuthorization_Validators.fromPartial(object.denyList) : void 0;
        message.authorizationType = (_a2 = object.authorizationType) !== null && _a2 !== void 0 ? _a2 : 0;
        return message;
      }
    };
    function createBaseStakeAuthorization_Validators() {
      return { address: [] };
    }
    exports2.StakeAuthorization_Validators = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.address) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStakeAuthorization_Validators();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: Array.isArray(object === null || object === void 0 ? void 0 : object.address) ? object.address.map((e) => String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.address) {
          obj.address = message.address.map((e) => e);
        } else {
          obj.address = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseStakeAuthorization_Validators();
        message.address = ((_a2 = object.address) === null || _a2 === void 0 ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/authz.js
var require_authz3 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/authz.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SendAuthorization = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    exports2.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseSendAuthorization() {
      return { spendLimit: [] };
    }
    exports2.SendAuthorization = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.spendLimit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSendAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.spendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          spendLimit: Array.isArray(object === null || object === void 0 ? void 0 : object.spendLimit) ? object.spendLimit.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.spendLimit) {
          obj.spendLimit = message.spendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.spendLimit = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSendAuthorization();
        message.spendLimit = ((_a2 = object.spendLimit) === null || _a2 === void 0 ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@keplr-wallet/proto-types/stride/stakeibc/ica_account.js
var require_ica_account = __commonJS({
  "node_modules/@keplr-wallet/proto-types/stride/stakeibc/ica_account.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.iCAAccountTypeToJSON = exports2.iCAAccountTypeFromJSON = exports2.ICAAccountType = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "stride.stakeibc";
    var ICAAccountType;
    (function(ICAAccountType2) {
      ICAAccountType2[ICAAccountType2["DELEGATION"] = 0] = "DELEGATION";
      ICAAccountType2[ICAAccountType2["FEE"] = 1] = "FEE";
      ICAAccountType2[ICAAccountType2["WITHDRAWAL"] = 2] = "WITHDRAWAL";
      ICAAccountType2[ICAAccountType2["REDEMPTION"] = 3] = "REDEMPTION";
      ICAAccountType2[ICAAccountType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ICAAccountType = exports2.ICAAccountType || (exports2.ICAAccountType = {}));
    function iCAAccountTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "DELEGATION":
          return ICAAccountType.DELEGATION;
        case 1:
        case "FEE":
          return ICAAccountType.FEE;
        case 2:
        case "WITHDRAWAL":
          return ICAAccountType.WITHDRAWAL;
        case 3:
        case "REDEMPTION":
          return ICAAccountType.REDEMPTION;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ICAAccountType.UNRECOGNIZED;
      }
    }
    exports2.iCAAccountTypeFromJSON = iCAAccountTypeFromJSON;
    function iCAAccountTypeToJSON(object) {
      switch (object) {
        case ICAAccountType.DELEGATION:
          return "DELEGATION";
        case ICAAccountType.FEE:
          return "FEE";
        case ICAAccountType.WITHDRAWAL:
          return "WITHDRAWAL";
        case ICAAccountType.REDEMPTION:
          return "REDEMPTION";
        default:
          return "UNKNOWN";
      }
    }
    exports2.iCAAccountTypeToJSON = iCAAccountTypeToJSON;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@keplr-wallet/proto-types/stride/stakeibc/validator.js
var require_validator2 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/stride/stakeibc/validator.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Validator = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "stride.stakeibc";
    function createBaseValidator() {
      return {
        name: "",
        address: "",
        weight: "0",
        delegation: "",
        slashQueryProgressTracker: "",
        slashQueryCheckpoint: "",
        sharesToTokensRate: "",
        delegationChangesInProgress: "0",
        slashQueryInProgress: false
      };
    }
    exports2.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.address !== "") {
          writer.uint32(18).string(message.address);
        }
        if (message.weight !== "0") {
          writer.uint32(48).uint64(message.weight);
        }
        if (message.delegation !== "") {
          writer.uint32(42).string(message.delegation);
        }
        if (message.slashQueryProgressTracker !== "") {
          writer.uint32(74).string(message.slashQueryProgressTracker);
        }
        if (message.slashQueryCheckpoint !== "") {
          writer.uint32(98).string(message.slashQueryCheckpoint);
        }
        if (message.sharesToTokensRate !== "") {
          writer.uint32(82).string(message.sharesToTokensRate);
        }
        if (message.delegationChangesInProgress !== "0") {
          writer.uint32(88).int64(message.delegationChangesInProgress);
        }
        if (message.slashQueryInProgress === true) {
          writer.uint32(104).bool(message.slashQueryInProgress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.address = reader.string();
              break;
            case 6:
              message.weight = longToString(reader.uint64());
              break;
            case 5:
              message.delegation = reader.string();
              break;
            case 9:
              message.slashQueryProgressTracker = reader.string();
              break;
            case 12:
              message.slashQueryCheckpoint = reader.string();
              break;
            case 10:
              message.sharesToTokensRate = reader.string();
              break;
            case 11:
              message.delegationChangesInProgress = longToString(reader.int64());
              break;
            case 13:
              message.slashQueryInProgress = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          name: isSet3(object.name) ? String(object.name) : "",
          address: isSet3(object.address) ? String(object.address) : "",
          weight: isSet3(object.weight) ? String(object.weight) : "0",
          delegation: isSet3(object.delegation) ? String(object.delegation) : "",
          slashQueryProgressTracker: isSet3(object.slashQueryProgressTracker) ? String(object.slashQueryProgressTracker) : "",
          slashQueryCheckpoint: isSet3(object.slashQueryCheckpoint) ? String(object.slashQueryCheckpoint) : "",
          sharesToTokensRate: isSet3(object.sharesToTokensRate) ? String(object.sharesToTokensRate) : "",
          delegationChangesInProgress: isSet3(object.delegationChangesInProgress) ? String(object.delegationChangesInProgress) : "0",
          slashQueryInProgress: isSet3(object.slashQueryInProgress) ? Boolean(object.slashQueryInProgress) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.address !== void 0 && (obj.address = message.address);
        message.weight !== void 0 && (obj.weight = message.weight);
        message.delegation !== void 0 && (obj.delegation = message.delegation);
        message.slashQueryProgressTracker !== void 0 && (obj.slashQueryProgressTracker = message.slashQueryProgressTracker);
        message.slashQueryCheckpoint !== void 0 && (obj.slashQueryCheckpoint = message.slashQueryCheckpoint);
        message.sharesToTokensRate !== void 0 && (obj.sharesToTokensRate = message.sharesToTokensRate);
        message.delegationChangesInProgress !== void 0 && (obj.delegationChangesInProgress = message.delegationChangesInProgress);
        message.slashQueryInProgress !== void 0 && (obj.slashQueryInProgress = message.slashQueryInProgress);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseValidator();
        message.name = (_a2 = object.name) !== null && _a2 !== void 0 ? _a2 : "";
        message.address = (_b = object.address) !== null && _b !== void 0 ? _b : "";
        message.weight = (_c = object.weight) !== null && _c !== void 0 ? _c : "0";
        message.delegation = (_d = object.delegation) !== null && _d !== void 0 ? _d : "";
        message.slashQueryProgressTracker = (_e = object.slashQueryProgressTracker) !== null && _e !== void 0 ? _e : "";
        message.slashQueryCheckpoint = (_f = object.slashQueryCheckpoint) !== null && _f !== void 0 ? _f : "";
        message.sharesToTokensRate = (_g = object.sharesToTokensRate) !== null && _g !== void 0 ? _g : "";
        message.delegationChangesInProgress = (_h = object.delegationChangesInProgress) !== null && _h !== void 0 ? _h : "0";
        message.slashQueryInProgress = (_j = object.slashQueryInProgress) !== null && _j !== void 0 ? _j : false;
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/stride/stakeibc/tx.js
var require_tx12 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/stride/stakeibc/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgCalibrateDelegationResponse = exports2.MsgCalibrateDelegation = exports2.MsgUndelegateHostResponse = exports2.MsgUndelegateHost = exports2.MsgUpdateValidatorSharesExchRateResponse = exports2.MsgUpdateValidatorSharesExchRate = exports2.MsgRestoreInterchainAccountResponse = exports2.MsgRestoreInterchainAccount = exports2.MsgDeleteValidatorResponse = exports2.MsgDeleteValidator = exports2.MsgChangeValidatorWeightResponse = exports2.MsgChangeValidatorWeight = exports2.MsgAddValidatorsResponse = exports2.MsgAddValidators = exports2.MsgRebalanceValidatorsResponse = exports2.MsgRebalanceValidators = exports2.MsgClaimUndelegatedTokensResponse = exports2.MsgClaimUndelegatedTokens = exports2.MsgRegisterHostZoneResponse = exports2.MsgRegisterHostZone = exports2.MsgRedeemStakeResponse = exports2.MsgRedeemStake = exports2.MsgClearBalanceResponse = exports2.MsgClearBalance = exports2.MsgLSMLiquidStakeResponse = exports2.MsgLSMLiquidStake = exports2.MsgLiquidStakeResponse = exports2.MsgLiquidStake = exports2.MsgUpdateInnerRedemptionRateBoundsResponse = exports2.MsgUpdateInnerRedemptionRateBounds = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var ica_account_1 = require_ica_account();
    var validator_1 = require_validator2();
    exports2.protobufPackage = "stride.stakeibc";
    function createBaseMsgUpdateInnerRedemptionRateBounds() {
      return {
        creator: "",
        chainId: "",
        minInnerRedemptionRate: "",
        maxInnerRedemptionRate: ""
      };
    }
    exports2.MsgUpdateInnerRedemptionRateBounds = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.minInnerRedemptionRate !== "") {
          writer.uint32(26).string(message.minInnerRedemptionRate);
        }
        if (message.maxInnerRedemptionRate !== "") {
          writer.uint32(34).string(message.maxInnerRedemptionRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.minInnerRedemptionRate = reader.string();
              break;
            case 4:
              message.maxInnerRedemptionRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          chainId: isSet3(object.chainId) ? String(object.chainId) : "",
          minInnerRedemptionRate: isSet3(object.minInnerRedemptionRate) ? String(object.minInnerRedemptionRate) : "",
          maxInnerRedemptionRate: isSet3(object.maxInnerRedemptionRate) ? String(object.maxInnerRedemptionRate) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.minInnerRedemptionRate !== void 0 && (obj.minInnerRedemptionRate = message.minInnerRedemptionRate);
        message.maxInnerRedemptionRate !== void 0 && (obj.maxInnerRedemptionRate = message.maxInnerRedemptionRate);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.minInnerRedemptionRate = (_c = object.minInnerRedemptionRate) !== null && _c !== void 0 ? _c : "";
        message.maxInnerRedemptionRate = (_d = object.maxInnerRedemptionRate) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseMsgUpdateInnerRedemptionRateBoundsResponse() {
      return {};
    }
    exports2.MsgUpdateInnerRedemptionRateBoundsResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        return message;
      }
    };
    function createBaseMsgLiquidStake() {
      return { creator: "", amount: "", hostDenom: "" };
    }
    exports2.MsgLiquidStake = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        if (message.hostDenom !== "") {
          writer.uint32(26).string(message.hostDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStake();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            case 3:
              message.hostDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          amount: isSet3(object.amount) ? String(object.amount) : "",
          hostDenom: isSet3(object.hostDenom) ? String(object.hostDenom) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.amount !== void 0 && (obj.amount = message.amount);
        message.hostDenom !== void 0 && (obj.hostDenom = message.hostDenom);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgLiquidStake();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        message.hostDenom = (_c = object.hostDenom) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgLiquidStakeResponse() {
      return {};
    }
    exports2.MsgLiquidStakeResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStakeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgLiquidStakeResponse();
        return message;
      }
    };
    function createBaseMsgLSMLiquidStake() {
      return { creator: "", amount: "", lsmTokenIbcDenom: "" };
    }
    exports2.MsgLSMLiquidStake = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        if (message.lsmTokenIbcDenom !== "") {
          writer.uint32(26).string(message.lsmTokenIbcDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLSMLiquidStake();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            case 3:
              message.lsmTokenIbcDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          amount: isSet3(object.amount) ? String(object.amount) : "",
          lsmTokenIbcDenom: isSet3(object.lsmTokenIbcDenom) ? String(object.lsmTokenIbcDenom) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.amount !== void 0 && (obj.amount = message.amount);
        message.lsmTokenIbcDenom !== void 0 && (obj.lsmTokenIbcDenom = message.lsmTokenIbcDenom);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgLSMLiquidStake();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        message.lsmTokenIbcDenom = (_c = object.lsmTokenIbcDenom) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgLSMLiquidStakeResponse() {
      return { transactionComplete: false };
    }
    exports2.MsgLSMLiquidStakeResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.transactionComplete === true) {
          writer.uint32(8).bool(message.transactionComplete);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLSMLiquidStakeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.transactionComplete = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          transactionComplete: isSet3(object.transactionComplete) ? Boolean(object.transactionComplete) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.transactionComplete !== void 0 && (obj.transactionComplete = message.transactionComplete);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgLSMLiquidStakeResponse();
        message.transactionComplete = (_a2 = object.transactionComplete) !== null && _a2 !== void 0 ? _a2 : false;
        return message;
      }
    };
    function createBaseMsgClearBalance() {
      return { creator: "", chainId: "", amount: "", channel: "" };
    }
    exports2.MsgClearBalance = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.amount !== "") {
          writer.uint32(26).string(message.amount);
        }
        if (message.channel !== "") {
          writer.uint32(34).string(message.channel);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearBalance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.amount = reader.string();
              break;
            case 4:
              message.channel = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          chainId: isSet3(object.chainId) ? String(object.chainId) : "",
          amount: isSet3(object.amount) ? String(object.amount) : "",
          channel: isSet3(object.channel) ? String(object.channel) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.amount !== void 0 && (obj.amount = message.amount);
        message.channel !== void 0 && (obj.channel = message.channel);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgClearBalance();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.amount = (_c = object.amount) !== null && _c !== void 0 ? _c : "";
        message.channel = (_d = object.channel) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseMsgClearBalanceResponse() {
      return {};
    }
    exports2.MsgClearBalanceResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearBalanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgClearBalanceResponse();
        return message;
      }
    };
    function createBaseMsgRedeemStake() {
      return { creator: "", amount: "", hostZone: "", receiver: "" };
    }
    exports2.MsgRedeemStake = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        if (message.hostZone !== "") {
          writer.uint32(26).string(message.hostZone);
        }
        if (message.receiver !== "") {
          writer.uint32(34).string(message.receiver);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStake();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            case 3:
              message.hostZone = reader.string();
              break;
            case 4:
              message.receiver = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          amount: isSet3(object.amount) ? String(object.amount) : "",
          hostZone: isSet3(object.hostZone) ? String(object.hostZone) : "",
          receiver: isSet3(object.receiver) ? String(object.receiver) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.amount !== void 0 && (obj.amount = message.amount);
        message.hostZone !== void 0 && (obj.hostZone = message.hostZone);
        message.receiver !== void 0 && (obj.receiver = message.receiver);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgRedeemStake();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        message.hostZone = (_c = object.hostZone) !== null && _c !== void 0 ? _c : "";
        message.receiver = (_d = object.receiver) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseMsgRedeemStakeResponse() {
      return {};
    }
    exports2.MsgRedeemStakeResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStakeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRedeemStakeResponse();
        return message;
      }
    };
    function createBaseMsgRegisterHostZone() {
      return {
        connectionId: "",
        bech32prefix: "",
        hostDenom: "",
        ibcDenom: "",
        creator: "",
        transferChannelId: "",
        unbondingPeriod: "0",
        minRedemptionRate: "",
        maxRedemptionRate: "",
        lsmLiquidStakeEnabled: false
      };
    }
    exports2.MsgRegisterHostZone = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(18).string(message.connectionId);
        }
        if (message.bech32prefix !== "") {
          writer.uint32(98).string(message.bech32prefix);
        }
        if (message.hostDenom !== "") {
          writer.uint32(34).string(message.hostDenom);
        }
        if (message.ibcDenom !== "") {
          writer.uint32(42).string(message.ibcDenom);
        }
        if (message.creator !== "") {
          writer.uint32(50).string(message.creator);
        }
        if (message.transferChannelId !== "") {
          writer.uint32(82).string(message.transferChannelId);
        }
        if (message.unbondingPeriod !== "0") {
          writer.uint32(88).uint64(message.unbondingPeriod);
        }
        if (message.minRedemptionRate !== "") {
          writer.uint32(106).string(message.minRedemptionRate);
        }
        if (message.maxRedemptionRate !== "") {
          writer.uint32(114).string(message.maxRedemptionRate);
        }
        if (message.lsmLiquidStakeEnabled === true) {
          writer.uint32(120).bool(message.lsmLiquidStakeEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterHostZone();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.connectionId = reader.string();
              break;
            case 12:
              message.bech32prefix = reader.string();
              break;
            case 4:
              message.hostDenom = reader.string();
              break;
            case 5:
              message.ibcDenom = reader.string();
              break;
            case 6:
              message.creator = reader.string();
              break;
            case 10:
              message.transferChannelId = reader.string();
              break;
            case 11:
              message.unbondingPeriod = longToString(reader.uint64());
              break;
            case 13:
              message.minRedemptionRate = reader.string();
              break;
            case 14:
              message.maxRedemptionRate = reader.string();
              break;
            case 15:
              message.lsmLiquidStakeEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          connectionId: isSet3(object.connectionId) ? String(object.connectionId) : "",
          bech32prefix: isSet3(object.bech32prefix) ? String(object.bech32prefix) : "",
          hostDenom: isSet3(object.hostDenom) ? String(object.hostDenom) : "",
          ibcDenom: isSet3(object.ibcDenom) ? String(object.ibcDenom) : "",
          creator: isSet3(object.creator) ? String(object.creator) : "",
          transferChannelId: isSet3(object.transferChannelId) ? String(object.transferChannelId) : "",
          unbondingPeriod: isSet3(object.unbondingPeriod) ? String(object.unbondingPeriod) : "0",
          minRedemptionRate: isSet3(object.minRedemptionRate) ? String(object.minRedemptionRate) : "",
          maxRedemptionRate: isSet3(object.maxRedemptionRate) ? String(object.maxRedemptionRate) : "",
          lsmLiquidStakeEnabled: isSet3(object.lsmLiquidStakeEnabled) ? Boolean(object.lsmLiquidStakeEnabled) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.bech32prefix !== void 0 && (obj.bech32prefix = message.bech32prefix);
        message.hostDenom !== void 0 && (obj.hostDenom = message.hostDenom);
        message.ibcDenom !== void 0 && (obj.ibcDenom = message.ibcDenom);
        message.creator !== void 0 && (obj.creator = message.creator);
        message.transferChannelId !== void 0 && (obj.transferChannelId = message.transferChannelId);
        message.unbondingPeriod !== void 0 && (obj.unbondingPeriod = message.unbondingPeriod);
        message.minRedemptionRate !== void 0 && (obj.minRedemptionRate = message.minRedemptionRate);
        message.maxRedemptionRate !== void 0 && (obj.maxRedemptionRate = message.maxRedemptionRate);
        message.lsmLiquidStakeEnabled !== void 0 && (obj.lsmLiquidStakeEnabled = message.lsmLiquidStakeEnabled);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseMsgRegisterHostZone();
        message.connectionId = (_a2 = object.connectionId) !== null && _a2 !== void 0 ? _a2 : "";
        message.bech32prefix = (_b = object.bech32prefix) !== null && _b !== void 0 ? _b : "";
        message.hostDenom = (_c = object.hostDenom) !== null && _c !== void 0 ? _c : "";
        message.ibcDenom = (_d = object.ibcDenom) !== null && _d !== void 0 ? _d : "";
        message.creator = (_e = object.creator) !== null && _e !== void 0 ? _e : "";
        message.transferChannelId = (_f = object.transferChannelId) !== null && _f !== void 0 ? _f : "";
        message.unbondingPeriod = (_g = object.unbondingPeriod) !== null && _g !== void 0 ? _g : "0";
        message.minRedemptionRate = (_h = object.minRedemptionRate) !== null && _h !== void 0 ? _h : "";
        message.maxRedemptionRate = (_j = object.maxRedemptionRate) !== null && _j !== void 0 ? _j : "";
        message.lsmLiquidStakeEnabled = (_k = object.lsmLiquidStakeEnabled) !== null && _k !== void 0 ? _k : false;
        return message;
      }
    };
    function createBaseMsgRegisterHostZoneResponse() {
      return {};
    }
    exports2.MsgRegisterHostZoneResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterHostZoneResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRegisterHostZoneResponse();
        return message;
      }
    };
    function createBaseMsgClaimUndelegatedTokens() {
      return { creator: "", hostZoneId: "", epoch: "0", sender: "" };
    }
    exports2.MsgClaimUndelegatedTokens = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.hostZoneId !== "") {
          writer.uint32(18).string(message.hostZoneId);
        }
        if (message.epoch !== "0") {
          writer.uint32(24).uint64(message.epoch);
        }
        if (message.sender !== "") {
          writer.uint32(34).string(message.sender);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClaimUndelegatedTokens();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.hostZoneId = reader.string();
              break;
            case 3:
              message.epoch = longToString(reader.uint64());
              break;
            case 4:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          hostZoneId: isSet3(object.hostZoneId) ? String(object.hostZoneId) : "",
          epoch: isSet3(object.epoch) ? String(object.epoch) : "0",
          sender: isSet3(object.sender) ? String(object.sender) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.hostZoneId !== void 0 && (obj.hostZoneId = message.hostZoneId);
        message.epoch !== void 0 && (obj.epoch = message.epoch);
        message.sender !== void 0 && (obj.sender = message.sender);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgClaimUndelegatedTokens();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.hostZoneId = (_b = object.hostZoneId) !== null && _b !== void 0 ? _b : "";
        message.epoch = (_c = object.epoch) !== null && _c !== void 0 ? _c : "0";
        message.sender = (_d = object.sender) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseMsgClaimUndelegatedTokensResponse() {
      return {};
    }
    exports2.MsgClaimUndelegatedTokensResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClaimUndelegatedTokensResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgClaimUndelegatedTokensResponse();
        return message;
      }
    };
    function createBaseMsgRebalanceValidators() {
      return { creator: "", hostZone: "", numRebalance: "0" };
    }
    exports2.MsgRebalanceValidators = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
          writer.uint32(18).string(message.hostZone);
        }
        if (message.numRebalance !== "0") {
          writer.uint32(24).uint64(message.numRebalance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRebalanceValidators();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.hostZone = reader.string();
              break;
            case 3:
              message.numRebalance = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          hostZone: isSet3(object.hostZone) ? String(object.hostZone) : "",
          numRebalance: isSet3(object.numRebalance) ? String(object.numRebalance) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.hostZone !== void 0 && (obj.hostZone = message.hostZone);
        message.numRebalance !== void 0 && (obj.numRebalance = message.numRebalance);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgRebalanceValidators();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.hostZone = (_b = object.hostZone) !== null && _b !== void 0 ? _b : "";
        message.numRebalance = (_c = object.numRebalance) !== null && _c !== void 0 ? _c : "0";
        return message;
      }
    };
    function createBaseMsgRebalanceValidatorsResponse() {
      return {};
    }
    exports2.MsgRebalanceValidatorsResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRebalanceValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRebalanceValidatorsResponse();
        return message;
      }
    };
    function createBaseMsgAddValidators() {
      return { creator: "", hostZone: "", validators: [] };
    }
    exports2.MsgAddValidators = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
          writer.uint32(18).string(message.hostZone);
        }
        for (const v of message.validators) {
          validator_1.Validator.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAddValidators();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.hostZone = reader.string();
              break;
            case 3:
              message.validators.push(validator_1.Validator.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          hostZone: isSet3(object.hostZone) ? String(object.hostZone) : "",
          validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators) ? object.validators.map((e) => validator_1.Validator.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.hostZone !== void 0 && (obj.hostZone = message.hostZone);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? validator_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgAddValidators();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.hostZone = (_b = object.hostZone) !== null && _b !== void 0 ? _b : "";
        message.validators = ((_c = object.validators) === null || _c === void 0 ? void 0 : _c.map((e) => validator_1.Validator.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgAddValidatorsResponse() {
      return {};
    }
    exports2.MsgAddValidatorsResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAddValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgAddValidatorsResponse();
        return message;
      }
    };
    function createBaseMsgChangeValidatorWeight() {
      return { creator: "", hostZone: "", valAddr: "", weight: "0" };
    }
    exports2.MsgChangeValidatorWeight = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
          writer.uint32(18).string(message.hostZone);
        }
        if (message.valAddr !== "") {
          writer.uint32(26).string(message.valAddr);
        }
        if (message.weight !== "0") {
          writer.uint32(32).uint64(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChangeValidatorWeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.hostZone = reader.string();
              break;
            case 3:
              message.valAddr = reader.string();
              break;
            case 4:
              message.weight = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          hostZone: isSet3(object.hostZone) ? String(object.hostZone) : "",
          valAddr: isSet3(object.valAddr) ? String(object.valAddr) : "",
          weight: isSet3(object.weight) ? String(object.weight) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.hostZone !== void 0 && (obj.hostZone = message.hostZone);
        message.valAddr !== void 0 && (obj.valAddr = message.valAddr);
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseMsgChangeValidatorWeight();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.hostZone = (_b = object.hostZone) !== null && _b !== void 0 ? _b : "";
        message.valAddr = (_c = object.valAddr) !== null && _c !== void 0 ? _c : "";
        message.weight = (_d = object.weight) !== null && _d !== void 0 ? _d : "0";
        return message;
      }
    };
    function createBaseMsgChangeValidatorWeightResponse() {
      return {};
    }
    exports2.MsgChangeValidatorWeightResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChangeValidatorWeightResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChangeValidatorWeightResponse();
        return message;
      }
    };
    function createBaseMsgDeleteValidator() {
      return { creator: "", hostZone: "", valAddr: "" };
    }
    exports2.MsgDeleteValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
          writer.uint32(18).string(message.hostZone);
        }
        if (message.valAddr !== "") {
          writer.uint32(26).string(message.valAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeleteValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.hostZone = reader.string();
              break;
            case 3:
              message.valAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          hostZone: isSet3(object.hostZone) ? String(object.hostZone) : "",
          valAddr: isSet3(object.valAddr) ? String(object.valAddr) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.hostZone !== void 0 && (obj.hostZone = message.hostZone);
        message.valAddr !== void 0 && (obj.valAddr = message.valAddr);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgDeleteValidator();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.hostZone = (_b = object.hostZone) !== null && _b !== void 0 ? _b : "";
        message.valAddr = (_c = object.valAddr) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgDeleteValidatorResponse() {
      return {};
    }
    exports2.MsgDeleteValidatorResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeleteValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDeleteValidatorResponse();
        return message;
      }
    };
    function createBaseMsgRestoreInterchainAccount() {
      return { creator: "", chainId: "", accountType: 0 };
    }
    exports2.MsgRestoreInterchainAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.accountType !== 0) {
          writer.uint32(24).int32(message.accountType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRestoreInterchainAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.accountType = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          chainId: isSet3(object.chainId) ? String(object.chainId) : "",
          accountType: isSet3(object.accountType) ? (0, ica_account_1.iCAAccountTypeFromJSON)(object.accountType) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountType !== void 0 && (obj.accountType = (0, ica_account_1.iCAAccountTypeToJSON)(message.accountType));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgRestoreInterchainAccount();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.accountType = (_c = object.accountType) !== null && _c !== void 0 ? _c : 0;
        return message;
      }
    };
    function createBaseMsgRestoreInterchainAccountResponse() {
      return {};
    }
    exports2.MsgRestoreInterchainAccountResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRestoreInterchainAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRestoreInterchainAccountResponse();
        return message;
      }
    };
    function createBaseMsgUpdateValidatorSharesExchRate() {
      return { creator: "", chainId: "", valoper: "" };
    }
    exports2.MsgUpdateValidatorSharesExchRate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.valoper !== "") {
          writer.uint32(26).string(message.valoper);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateValidatorSharesExchRate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.valoper = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          chainId: isSet3(object.chainId) ? String(object.chainId) : "",
          valoper: isSet3(object.valoper) ? String(object.valoper) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.valoper !== void 0 && (obj.valoper = message.valoper);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgUpdateValidatorSharesExchRate();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.valoper = (_c = object.valoper) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgUpdateValidatorSharesExchRateResponse() {
      return {};
    }
    exports2.MsgUpdateValidatorSharesExchRateResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateValidatorSharesExchRateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateValidatorSharesExchRateResponse();
        return message;
      }
    };
    function createBaseMsgUndelegateHost() {
      return { creator: "", amount: "" };
    }
    exports2.MsgUndelegateHost = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateHost();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          amount: isSet3(object.amount) ? String(object.amount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgUndelegateHost();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgUndelegateHostResponse() {
      return {};
    }
    exports2.MsgUndelegateHostResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateHostResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUndelegateHostResponse();
        return message;
      }
    };
    function createBaseMsgCalibrateDelegation() {
      return { creator: "", chainId: "", valoper: "" };
    }
    exports2.MsgCalibrateDelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.valoper !== "") {
          writer.uint32(26).string(message.valoper);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCalibrateDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.valoper = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          chainId: isSet3(object.chainId) ? String(object.chainId) : "",
          valoper: isSet3(object.valoper) ? String(object.valoper) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.valoper !== void 0 && (obj.valoper = message.valoper);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgCalibrateDelegation();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.valoper = (_c = object.valoper) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgCalibrateDelegationResponse() {
      return {};
    }
    exports2.MsgCalibrateDelegationResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCalibrateDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCalibrateDelegationResponse();
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/stride/staketia/staketia.js
var require_staketia = __commonJS({
  "node_modules/@keplr-wallet/proto-types/stride/staketia/staketia.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SlashRecord = exports2.RedemptionRecord = exports2.UnbondingRecord = exports2.DelegationRecord = exports2.HostZone = exports2.unbondingRecordStatusToJSON = exports2.unbondingRecordStatusFromJSON = exports2.UnbondingRecordStatus = exports2.delegationRecordStatusToJSON = exports2.delegationRecordStatusFromJSON = exports2.DelegationRecordStatus = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "stride.staketia";
    var DelegationRecordStatus;
    (function(DelegationRecordStatus2) {
      DelegationRecordStatus2[DelegationRecordStatus2["TRANSFER_IN_PROGRESS"] = 0] = "TRANSFER_IN_PROGRESS";
      DelegationRecordStatus2[DelegationRecordStatus2["TRANSFER_FAILED"] = 1] = "TRANSFER_FAILED";
      DelegationRecordStatus2[DelegationRecordStatus2["DELEGATION_QUEUE"] = 2] = "DELEGATION_QUEUE";
      DelegationRecordStatus2[DelegationRecordStatus2["DELEGATION_COMPLETE"] = 3] = "DELEGATION_COMPLETE";
      DelegationRecordStatus2[DelegationRecordStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(DelegationRecordStatus = exports2.DelegationRecordStatus || (exports2.DelegationRecordStatus = {}));
    function delegationRecordStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "TRANSFER_IN_PROGRESS":
          return DelegationRecordStatus.TRANSFER_IN_PROGRESS;
        case 1:
        case "TRANSFER_FAILED":
          return DelegationRecordStatus.TRANSFER_FAILED;
        case 2:
        case "DELEGATION_QUEUE":
          return DelegationRecordStatus.DELEGATION_QUEUE;
        case 3:
        case "DELEGATION_COMPLETE":
          return DelegationRecordStatus.DELEGATION_COMPLETE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return DelegationRecordStatus.UNRECOGNIZED;
      }
    }
    exports2.delegationRecordStatusFromJSON = delegationRecordStatusFromJSON;
    function delegationRecordStatusToJSON(object) {
      switch (object) {
        case DelegationRecordStatus.TRANSFER_IN_PROGRESS:
          return "TRANSFER_IN_PROGRESS";
        case DelegationRecordStatus.TRANSFER_FAILED:
          return "TRANSFER_FAILED";
        case DelegationRecordStatus.DELEGATION_QUEUE:
          return "DELEGATION_QUEUE";
        case DelegationRecordStatus.DELEGATION_COMPLETE:
          return "DELEGATION_COMPLETE";
        default:
          return "UNKNOWN";
      }
    }
    exports2.delegationRecordStatusToJSON = delegationRecordStatusToJSON;
    var UnbondingRecordStatus;
    (function(UnbondingRecordStatus2) {
      UnbondingRecordStatus2[UnbondingRecordStatus2["ACCUMULATING_REDEMPTIONS"] = 0] = "ACCUMULATING_REDEMPTIONS";
      UnbondingRecordStatus2[UnbondingRecordStatus2["UNBONDING_QUEUE"] = 1] = "UNBONDING_QUEUE";
      UnbondingRecordStatus2[UnbondingRecordStatus2["UNBONDING_IN_PROGRESS"] = 2] = "UNBONDING_IN_PROGRESS";
      UnbondingRecordStatus2[UnbondingRecordStatus2["UNBONDED"] = 3] = "UNBONDED";
      UnbondingRecordStatus2[UnbondingRecordStatus2["CLAIMABLE"] = 4] = "CLAIMABLE";
      UnbondingRecordStatus2[UnbondingRecordStatus2["CLAIMED"] = 5] = "CLAIMED";
      UnbondingRecordStatus2[UnbondingRecordStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(UnbondingRecordStatus = exports2.UnbondingRecordStatus || (exports2.UnbondingRecordStatus = {}));
    function unbondingRecordStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "ACCUMULATING_REDEMPTIONS":
          return UnbondingRecordStatus.ACCUMULATING_REDEMPTIONS;
        case 1:
        case "UNBONDING_QUEUE":
          return UnbondingRecordStatus.UNBONDING_QUEUE;
        case 2:
        case "UNBONDING_IN_PROGRESS":
          return UnbondingRecordStatus.UNBONDING_IN_PROGRESS;
        case 3:
        case "UNBONDED":
          return UnbondingRecordStatus.UNBONDED;
        case 4:
        case "CLAIMABLE":
          return UnbondingRecordStatus.CLAIMABLE;
        case 5:
        case "CLAIMED":
          return UnbondingRecordStatus.CLAIMED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return UnbondingRecordStatus.UNRECOGNIZED;
      }
    }
    exports2.unbondingRecordStatusFromJSON = unbondingRecordStatusFromJSON;
    function unbondingRecordStatusToJSON(object) {
      switch (object) {
        case UnbondingRecordStatus.ACCUMULATING_REDEMPTIONS:
          return "ACCUMULATING_REDEMPTIONS";
        case UnbondingRecordStatus.UNBONDING_QUEUE:
          return "UNBONDING_QUEUE";
        case UnbondingRecordStatus.UNBONDING_IN_PROGRESS:
          return "UNBONDING_IN_PROGRESS";
        case UnbondingRecordStatus.UNBONDED:
          return "UNBONDED";
        case UnbondingRecordStatus.CLAIMABLE:
          return "CLAIMABLE";
        case UnbondingRecordStatus.CLAIMED:
          return "CLAIMED";
        default:
          return "UNKNOWN";
      }
    }
    exports2.unbondingRecordStatusToJSON = unbondingRecordStatusToJSON;
    function createBaseHostZone() {
      return {
        chainId: "",
        nativeTokenDenom: "",
        nativeTokenIbcDenom: "",
        transferChannelId: "",
        delegationAddress: "",
        rewardAddress: "",
        depositAddress: "",
        redemptionAddress: "",
        claimAddress: "",
        operatorAddressOnStride: "",
        safeAddressOnStride: "",
        lastRedemptionRate: "",
        redemptionRate: "",
        minRedemptionRate: "",
        maxRedemptionRate: "",
        minInnerRedemptionRate: "",
        maxInnerRedemptionRate: "",
        delegatedBalance: "",
        unbondingPeriodSeconds: "0",
        halted: false
      };
    }
    exports2.HostZone = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chainId !== "") {
          writer.uint32(10).string(message.chainId);
        }
        if (message.nativeTokenDenom !== "") {
          writer.uint32(18).string(message.nativeTokenDenom);
        }
        if (message.nativeTokenIbcDenom !== "") {
          writer.uint32(26).string(message.nativeTokenIbcDenom);
        }
        if (message.transferChannelId !== "") {
          writer.uint32(34).string(message.transferChannelId);
        }
        if (message.delegationAddress !== "") {
          writer.uint32(42).string(message.delegationAddress);
        }
        if (message.rewardAddress !== "") {
          writer.uint32(50).string(message.rewardAddress);
        }
        if (message.depositAddress !== "") {
          writer.uint32(58).string(message.depositAddress);
        }
        if (message.redemptionAddress !== "") {
          writer.uint32(66).string(message.redemptionAddress);
        }
        if (message.claimAddress !== "") {
          writer.uint32(74).string(message.claimAddress);
        }
        if (message.operatorAddressOnStride !== "") {
          writer.uint32(82).string(message.operatorAddressOnStride);
        }
        if (message.safeAddressOnStride !== "") {
          writer.uint32(90).string(message.safeAddressOnStride);
        }
        if (message.lastRedemptionRate !== "") {
          writer.uint32(98).string(message.lastRedemptionRate);
        }
        if (message.redemptionRate !== "") {
          writer.uint32(106).string(message.redemptionRate);
        }
        if (message.minRedemptionRate !== "") {
          writer.uint32(114).string(message.minRedemptionRate);
        }
        if (message.maxRedemptionRate !== "") {
          writer.uint32(122).string(message.maxRedemptionRate);
        }
        if (message.minInnerRedemptionRate !== "") {
          writer.uint32(130).string(message.minInnerRedemptionRate);
        }
        if (message.maxInnerRedemptionRate !== "") {
          writer.uint32(138).string(message.maxInnerRedemptionRate);
        }
        if (message.delegatedBalance !== "") {
          writer.uint32(146).string(message.delegatedBalance);
        }
        if (message.unbondingPeriodSeconds !== "0") {
          writer.uint32(152).uint64(message.unbondingPeriodSeconds);
        }
        if (message.halted === true) {
          writer.uint32(160).bool(message.halted);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHostZone();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chainId = reader.string();
              break;
            case 2:
              message.nativeTokenDenom = reader.string();
              break;
            case 3:
              message.nativeTokenIbcDenom = reader.string();
              break;
            case 4:
              message.transferChannelId = reader.string();
              break;
            case 5:
              message.delegationAddress = reader.string();
              break;
            case 6:
              message.rewardAddress = reader.string();
              break;
            case 7:
              message.depositAddress = reader.string();
              break;
            case 8:
              message.redemptionAddress = reader.string();
              break;
            case 9:
              message.claimAddress = reader.string();
              break;
            case 10:
              message.operatorAddressOnStride = reader.string();
              break;
            case 11:
              message.safeAddressOnStride = reader.string();
              break;
            case 12:
              message.lastRedemptionRate = reader.string();
              break;
            case 13:
              message.redemptionRate = reader.string();
              break;
            case 14:
              message.minRedemptionRate = reader.string();
              break;
            case 15:
              message.maxRedemptionRate = reader.string();
              break;
            case 16:
              message.minInnerRedemptionRate = reader.string();
              break;
            case 17:
              message.maxInnerRedemptionRate = reader.string();
              break;
            case 18:
              message.delegatedBalance = reader.string();
              break;
            case 19:
              message.unbondingPeriodSeconds = longToString(reader.uint64());
              break;
            case 20:
              message.halted = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          chainId: isSet3(object.chainId) ? String(object.chainId) : "",
          nativeTokenDenom: isSet3(object.nativeTokenDenom) ? String(object.nativeTokenDenom) : "",
          nativeTokenIbcDenom: isSet3(object.nativeTokenIbcDenom) ? String(object.nativeTokenIbcDenom) : "",
          transferChannelId: isSet3(object.transferChannelId) ? String(object.transferChannelId) : "",
          delegationAddress: isSet3(object.delegationAddress) ? String(object.delegationAddress) : "",
          rewardAddress: isSet3(object.rewardAddress) ? String(object.rewardAddress) : "",
          depositAddress: isSet3(object.depositAddress) ? String(object.depositAddress) : "",
          redemptionAddress: isSet3(object.redemptionAddress) ? String(object.redemptionAddress) : "",
          claimAddress: isSet3(object.claimAddress) ? String(object.claimAddress) : "",
          operatorAddressOnStride: isSet3(object.operatorAddressOnStride) ? String(object.operatorAddressOnStride) : "",
          safeAddressOnStride: isSet3(object.safeAddressOnStride) ? String(object.safeAddressOnStride) : "",
          lastRedemptionRate: isSet3(object.lastRedemptionRate) ? String(object.lastRedemptionRate) : "",
          redemptionRate: isSet3(object.redemptionRate) ? String(object.redemptionRate) : "",
          minRedemptionRate: isSet3(object.minRedemptionRate) ? String(object.minRedemptionRate) : "",
          maxRedemptionRate: isSet3(object.maxRedemptionRate) ? String(object.maxRedemptionRate) : "",
          minInnerRedemptionRate: isSet3(object.minInnerRedemptionRate) ? String(object.minInnerRedemptionRate) : "",
          maxInnerRedemptionRate: isSet3(object.maxInnerRedemptionRate) ? String(object.maxInnerRedemptionRate) : "",
          delegatedBalance: isSet3(object.delegatedBalance) ? String(object.delegatedBalance) : "",
          unbondingPeriodSeconds: isSet3(object.unbondingPeriodSeconds) ? String(object.unbondingPeriodSeconds) : "0",
          halted: isSet3(object.halted) ? Boolean(object.halted) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.nativeTokenDenom !== void 0 && (obj.nativeTokenDenom = message.nativeTokenDenom);
        message.nativeTokenIbcDenom !== void 0 && (obj.nativeTokenIbcDenom = message.nativeTokenIbcDenom);
        message.transferChannelId !== void 0 && (obj.transferChannelId = message.transferChannelId);
        message.delegationAddress !== void 0 && (obj.delegationAddress = message.delegationAddress);
        message.rewardAddress !== void 0 && (obj.rewardAddress = message.rewardAddress);
        message.depositAddress !== void 0 && (obj.depositAddress = message.depositAddress);
        message.redemptionAddress !== void 0 && (obj.redemptionAddress = message.redemptionAddress);
        message.claimAddress !== void 0 && (obj.claimAddress = message.claimAddress);
        message.operatorAddressOnStride !== void 0 && (obj.operatorAddressOnStride = message.operatorAddressOnStride);
        message.safeAddressOnStride !== void 0 && (obj.safeAddressOnStride = message.safeAddressOnStride);
        message.lastRedemptionRate !== void 0 && (obj.lastRedemptionRate = message.lastRedemptionRate);
        message.redemptionRate !== void 0 && (obj.redemptionRate = message.redemptionRate);
        message.minRedemptionRate !== void 0 && (obj.minRedemptionRate = message.minRedemptionRate);
        message.maxRedemptionRate !== void 0 && (obj.maxRedemptionRate = message.maxRedemptionRate);
        message.minInnerRedemptionRate !== void 0 && (obj.minInnerRedemptionRate = message.minInnerRedemptionRate);
        message.maxInnerRedemptionRate !== void 0 && (obj.maxInnerRedemptionRate = message.maxInnerRedemptionRate);
        message.delegatedBalance !== void 0 && (obj.delegatedBalance = message.delegatedBalance);
        message.unbondingPeriodSeconds !== void 0 && (obj.unbondingPeriodSeconds = message.unbondingPeriodSeconds);
        message.halted !== void 0 && (obj.halted = message.halted);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        const message = createBaseHostZone();
        message.chainId = (_a2 = object.chainId) !== null && _a2 !== void 0 ? _a2 : "";
        message.nativeTokenDenom = (_b = object.nativeTokenDenom) !== null && _b !== void 0 ? _b : "";
        message.nativeTokenIbcDenom = (_c = object.nativeTokenIbcDenom) !== null && _c !== void 0 ? _c : "";
        message.transferChannelId = (_d = object.transferChannelId) !== null && _d !== void 0 ? _d : "";
        message.delegationAddress = (_e = object.delegationAddress) !== null && _e !== void 0 ? _e : "";
        message.rewardAddress = (_f = object.rewardAddress) !== null && _f !== void 0 ? _f : "";
        message.depositAddress = (_g = object.depositAddress) !== null && _g !== void 0 ? _g : "";
        message.redemptionAddress = (_h = object.redemptionAddress) !== null && _h !== void 0 ? _h : "";
        message.claimAddress = (_j = object.claimAddress) !== null && _j !== void 0 ? _j : "";
        message.operatorAddressOnStride = (_k = object.operatorAddressOnStride) !== null && _k !== void 0 ? _k : "";
        message.safeAddressOnStride = (_l = object.safeAddressOnStride) !== null && _l !== void 0 ? _l : "";
        message.lastRedemptionRate = (_m = object.lastRedemptionRate) !== null && _m !== void 0 ? _m : "";
        message.redemptionRate = (_o = object.redemptionRate) !== null && _o !== void 0 ? _o : "";
        message.minRedemptionRate = (_p = object.minRedemptionRate) !== null && _p !== void 0 ? _p : "";
        message.maxRedemptionRate = (_q = object.maxRedemptionRate) !== null && _q !== void 0 ? _q : "";
        message.minInnerRedemptionRate = (_r = object.minInnerRedemptionRate) !== null && _r !== void 0 ? _r : "";
        message.maxInnerRedemptionRate = (_s = object.maxInnerRedemptionRate) !== null && _s !== void 0 ? _s : "";
        message.delegatedBalance = (_t = object.delegatedBalance) !== null && _t !== void 0 ? _t : "";
        message.unbondingPeriodSeconds = (_u = object.unbondingPeriodSeconds) !== null && _u !== void 0 ? _u : "0";
        message.halted = (_v = object.halted) !== null && _v !== void 0 ? _v : false;
        return message;
      }
    };
    function createBaseDelegationRecord() {
      return { id: "0", nativeAmount: "", status: 0, txHash: "" };
    }
    exports2.DelegationRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "0") {
          writer.uint32(8).uint64(message.id);
        }
        if (message.nativeAmount !== "") {
          writer.uint32(18).string(message.nativeAmount);
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.txHash !== "") {
          writer.uint32(34).string(message.txHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = longToString(reader.uint64());
              break;
            case 2:
              message.nativeAmount = reader.string();
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.txHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet3(object.id) ? String(object.id) : "0",
          nativeAmount: isSet3(object.nativeAmount) ? String(object.nativeAmount) : "",
          status: isSet3(object.status) ? delegationRecordStatusFromJSON(object.status) : 0,
          txHash: isSet3(object.txHash) ? String(object.txHash) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.nativeAmount !== void 0 && (obj.nativeAmount = message.nativeAmount);
        message.status !== void 0 && (obj.status = delegationRecordStatusToJSON(message.status));
        message.txHash !== void 0 && (obj.txHash = message.txHash);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseDelegationRecord();
        message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "0";
        message.nativeAmount = (_b = object.nativeAmount) !== null && _b !== void 0 ? _b : "";
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : 0;
        message.txHash = (_d = object.txHash) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseUnbondingRecord() {
      return {
        id: "0",
        status: 0,
        stTokenAmount: "",
        nativeAmount: "",
        unbondingCompletionTimeSeconds: "0",
        undelegationTxHash: "",
        unbondedTokenSweepTxHash: ""
      };
    }
    exports2.UnbondingRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "0") {
          writer.uint32(8).uint64(message.id);
        }
        if (message.status !== 0) {
          writer.uint32(16).int32(message.status);
        }
        if (message.stTokenAmount !== "") {
          writer.uint32(26).string(message.stTokenAmount);
        }
        if (message.nativeAmount !== "") {
          writer.uint32(34).string(message.nativeAmount);
        }
        if (message.unbondingCompletionTimeSeconds !== "0") {
          writer.uint32(40).uint64(message.unbondingCompletionTimeSeconds);
        }
        if (message.undelegationTxHash !== "") {
          writer.uint32(50).string(message.undelegationTxHash);
        }
        if (message.unbondedTokenSweepTxHash !== "") {
          writer.uint32(58).string(message.unbondedTokenSweepTxHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = longToString(reader.uint64());
              break;
            case 2:
              message.status = reader.int32();
              break;
            case 3:
              message.stTokenAmount = reader.string();
              break;
            case 4:
              message.nativeAmount = reader.string();
              break;
            case 5:
              message.unbondingCompletionTimeSeconds = longToString(reader.uint64());
              break;
            case 6:
              message.undelegationTxHash = reader.string();
              break;
            case 7:
              message.unbondedTokenSweepTxHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet3(object.id) ? String(object.id) : "0",
          status: isSet3(object.status) ? unbondingRecordStatusFromJSON(object.status) : 0,
          stTokenAmount: isSet3(object.stTokenAmount) ? String(object.stTokenAmount) : "",
          nativeAmount: isSet3(object.nativeAmount) ? String(object.nativeAmount) : "",
          unbondingCompletionTimeSeconds: isSet3(object.unbondingCompletionTimeSeconds) ? String(object.unbondingCompletionTimeSeconds) : "0",
          undelegationTxHash: isSet3(object.undelegationTxHash) ? String(object.undelegationTxHash) : "",
          unbondedTokenSweepTxHash: isSet3(object.unbondedTokenSweepTxHash) ? String(object.unbondedTokenSweepTxHash) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.status !== void 0 && (obj.status = unbondingRecordStatusToJSON(message.status));
        message.stTokenAmount !== void 0 && (obj.stTokenAmount = message.stTokenAmount);
        message.nativeAmount !== void 0 && (obj.nativeAmount = message.nativeAmount);
        message.unbondingCompletionTimeSeconds !== void 0 && (obj.unbondingCompletionTimeSeconds = message.unbondingCompletionTimeSeconds);
        message.undelegationTxHash !== void 0 && (obj.undelegationTxHash = message.undelegationTxHash);
        message.unbondedTokenSweepTxHash !== void 0 && (obj.unbondedTokenSweepTxHash = message.unbondedTokenSweepTxHash);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g;
        const message = createBaseUnbondingRecord();
        message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "0";
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : 0;
        message.stTokenAmount = (_c = object.stTokenAmount) !== null && _c !== void 0 ? _c : "";
        message.nativeAmount = (_d = object.nativeAmount) !== null && _d !== void 0 ? _d : "";
        message.unbondingCompletionTimeSeconds = (_e = object.unbondingCompletionTimeSeconds) !== null && _e !== void 0 ? _e : "0";
        message.undelegationTxHash = (_f = object.undelegationTxHash) !== null && _f !== void 0 ? _f : "";
        message.unbondedTokenSweepTxHash = (_g = object.unbondedTokenSweepTxHash) !== null && _g !== void 0 ? _g : "";
        return message;
      }
    };
    function createBaseRedemptionRecord() {
      return {
        unbondingRecordId: "0",
        redeemer: "",
        stTokenAmount: "",
        nativeAmount: ""
      };
    }
    exports2.RedemptionRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.unbondingRecordId !== "0") {
          writer.uint32(8).uint64(message.unbondingRecordId);
        }
        if (message.redeemer !== "") {
          writer.uint32(18).string(message.redeemer);
        }
        if (message.stTokenAmount !== "") {
          writer.uint32(26).string(message.stTokenAmount);
        }
        if (message.nativeAmount !== "") {
          writer.uint32(34).string(message.nativeAmount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedemptionRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingRecordId = longToString(reader.uint64());
              break;
            case 2:
              message.redeemer = reader.string();
              break;
            case 3:
              message.stTokenAmount = reader.string();
              break;
            case 4:
              message.nativeAmount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          unbondingRecordId: isSet3(object.unbondingRecordId) ? String(object.unbondingRecordId) : "0",
          redeemer: isSet3(object.redeemer) ? String(object.redeemer) : "",
          stTokenAmount: isSet3(object.stTokenAmount) ? String(object.stTokenAmount) : "",
          nativeAmount: isSet3(object.nativeAmount) ? String(object.nativeAmount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.unbondingRecordId !== void 0 && (obj.unbondingRecordId = message.unbondingRecordId);
        message.redeemer !== void 0 && (obj.redeemer = message.redeemer);
        message.stTokenAmount !== void 0 && (obj.stTokenAmount = message.stTokenAmount);
        message.nativeAmount !== void 0 && (obj.nativeAmount = message.nativeAmount);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseRedemptionRecord();
        message.unbondingRecordId = (_a2 = object.unbondingRecordId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.redeemer = (_b = object.redeemer) !== null && _b !== void 0 ? _b : "";
        message.stTokenAmount = (_c = object.stTokenAmount) !== null && _c !== void 0 ? _c : "";
        message.nativeAmount = (_d = object.nativeAmount) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseSlashRecord() {
      return { id: "0", time: "0", nativeAmount: "", validatorAddress: "" };
    }
    exports2.SlashRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "0") {
          writer.uint32(8).uint64(message.id);
        }
        if (message.time !== "0") {
          writer.uint32(16).uint64(message.time);
        }
        if (message.nativeAmount !== "") {
          writer.uint32(26).string(message.nativeAmount);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(34).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSlashRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = longToString(reader.uint64());
              break;
            case 2:
              message.time = longToString(reader.uint64());
              break;
            case 3:
              message.nativeAmount = reader.string();
              break;
            case 4:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet3(object.id) ? String(object.id) : "0",
          time: isSet3(object.time) ? String(object.time) : "0",
          nativeAmount: isSet3(object.nativeAmount) ? String(object.nativeAmount) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.time !== void 0 && (obj.time = message.time);
        message.nativeAmount !== void 0 && (obj.nativeAmount = message.nativeAmount);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseSlashRecord();
        message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "0";
        message.time = (_b = object.time) !== null && _b !== void 0 ? _b : "0";
        message.nativeAmount = (_c = object.nativeAmount) !== null && _c !== void 0 ? _c : "";
        message.validatorAddress = (_d = object.validatorAddress) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/stride/staketia/tx.js
var require_tx13 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/stride/staketia/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgSetOperatorAddressResponse = exports2.MsgSetOperatorAddress = exports2.MsgOverwriteRedemptionRecordResponse = exports2.MsgOverwriteRedemptionRecord = exports2.MsgOverwriteUnbondingRecordResponse = exports2.MsgOverwriteUnbondingRecord = exports2.MsgOverwriteDelegationRecordResponse = exports2.MsgOverwriteDelegationRecord = exports2.MsgRefreshRedemptionRateResponse = exports2.MsgRefreshRedemptionRate = exports2.MsgResumeHostZoneResponse = exports2.MsgResumeHostZone = exports2.MsgUpdateInnerRedemptionRateBoundsResponse = exports2.MsgUpdateInnerRedemptionRateBounds = exports2.MsgAdjustDelegatedBalanceResponse = exports2.MsgAdjustDelegatedBalance = exports2.MsgConfirmUnbondedTokenSweepResponse = exports2.MsgConfirmUnbondedTokenSweep = exports2.MsgConfirmUndelegationResponse = exports2.MsgConfirmUndelegation = exports2.MsgConfirmDelegationResponse = exports2.MsgConfirmDelegation = exports2.MsgRedeemStakeResponse = exports2.MsgRedeemStake = exports2.MsgLiquidStakeResponse = exports2.MsgLiquidStake = exports2.overwritableRecordTypeToJSON = exports2.overwritableRecordTypeFromJSON = exports2.OverwritableRecordType = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    var staketia_1 = require_staketia();
    exports2.protobufPackage = "stride.staketia";
    var OverwritableRecordType;
    (function(OverwritableRecordType2) {
      OverwritableRecordType2[OverwritableRecordType2["RECORD_TYPE_DELEGATION"] = 0] = "RECORD_TYPE_DELEGATION";
      OverwritableRecordType2[OverwritableRecordType2["RECORD_TYPE_UNBONDING"] = 1] = "RECORD_TYPE_UNBONDING";
      OverwritableRecordType2[OverwritableRecordType2["RECORD_TYPE_REDEMPTION"] = 2] = "RECORD_TYPE_REDEMPTION";
      OverwritableRecordType2[OverwritableRecordType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(OverwritableRecordType = exports2.OverwritableRecordType || (exports2.OverwritableRecordType = {}));
    function overwritableRecordTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "RECORD_TYPE_DELEGATION":
          return OverwritableRecordType.RECORD_TYPE_DELEGATION;
        case 1:
        case "RECORD_TYPE_UNBONDING":
          return OverwritableRecordType.RECORD_TYPE_UNBONDING;
        case 2:
        case "RECORD_TYPE_REDEMPTION":
          return OverwritableRecordType.RECORD_TYPE_REDEMPTION;
        case -1:
        case "UNRECOGNIZED":
        default:
          return OverwritableRecordType.UNRECOGNIZED;
      }
    }
    exports2.overwritableRecordTypeFromJSON = overwritableRecordTypeFromJSON;
    function overwritableRecordTypeToJSON(object) {
      switch (object) {
        case OverwritableRecordType.RECORD_TYPE_DELEGATION:
          return "RECORD_TYPE_DELEGATION";
        case OverwritableRecordType.RECORD_TYPE_UNBONDING:
          return "RECORD_TYPE_UNBONDING";
        case OverwritableRecordType.RECORD_TYPE_REDEMPTION:
          return "RECORD_TYPE_REDEMPTION";
        default:
          return "UNKNOWN";
      }
    }
    exports2.overwritableRecordTypeToJSON = overwritableRecordTypeToJSON;
    function createBaseMsgLiquidStake() {
      return { staker: "", nativeAmount: "" };
    }
    exports2.MsgLiquidStake = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.staker !== "") {
          writer.uint32(10).string(message.staker);
        }
        if (message.nativeAmount !== "") {
          writer.uint32(18).string(message.nativeAmount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStake();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.staker = reader.string();
              break;
            case 2:
              message.nativeAmount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          staker: isSet3(object.staker) ? String(object.staker) : "",
          nativeAmount: isSet3(object.nativeAmount) ? String(object.nativeAmount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.staker !== void 0 && (obj.staker = message.staker);
        message.nativeAmount !== void 0 && (obj.nativeAmount = message.nativeAmount);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgLiquidStake();
        message.staker = (_a2 = object.staker) !== null && _a2 !== void 0 ? _a2 : "";
        message.nativeAmount = (_b = object.nativeAmount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgLiquidStakeResponse() {
      return { stToken: void 0 };
    }
    exports2.MsgLiquidStakeResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.stToken !== void 0) {
          coin_1.Coin.encode(message.stToken, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStakeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.stToken = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          stToken: isSet3(object.stToken) ? coin_1.Coin.fromJSON(object.stToken) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.stToken !== void 0 && (obj.stToken = message.stToken ? coin_1.Coin.toJSON(message.stToken) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgLiquidStakeResponse();
        message.stToken = object.stToken !== void 0 && object.stToken !== null ? coin_1.Coin.fromPartial(object.stToken) : void 0;
        return message;
      }
    };
    function createBaseMsgRedeemStake() {
      return { redeemer: "", stTokenAmount: "" };
    }
    exports2.MsgRedeemStake = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redeemer !== "") {
          writer.uint32(10).string(message.redeemer);
        }
        if (message.stTokenAmount !== "") {
          writer.uint32(18).string(message.stTokenAmount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStake();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redeemer = reader.string();
              break;
            case 2:
              message.stTokenAmount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          redeemer: isSet3(object.redeemer) ? String(object.redeemer) : "",
          stTokenAmount: isSet3(object.stTokenAmount) ? String(object.stTokenAmount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.redeemer !== void 0 && (obj.redeemer = message.redeemer);
        message.stTokenAmount !== void 0 && (obj.stTokenAmount = message.stTokenAmount);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgRedeemStake();
        message.redeemer = (_a2 = object.redeemer) !== null && _a2 !== void 0 ? _a2 : "";
        message.stTokenAmount = (_b = object.stTokenAmount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgRedeemStakeResponse() {
      return { nativeToken: void 0 };
    }
    exports2.MsgRedeemStakeResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nativeToken !== void 0) {
          coin_1.Coin.encode(message.nativeToken, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStakeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nativeToken = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          nativeToken: isSet3(object.nativeToken) ? coin_1.Coin.fromJSON(object.nativeToken) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.nativeToken !== void 0 && (obj.nativeToken = message.nativeToken ? coin_1.Coin.toJSON(message.nativeToken) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRedeemStakeResponse();
        message.nativeToken = object.nativeToken !== void 0 && object.nativeToken !== null ? coin_1.Coin.fromPartial(object.nativeToken) : void 0;
        return message;
      }
    };
    function createBaseMsgConfirmDelegation() {
      return { operator: "", recordId: "0", txHash: "" };
    }
    exports2.MsgConfirmDelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
          writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
          writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
          writer.uint32(26).string(message.txHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operator = reader.string();
              break;
            case 2:
              message.recordId = longToString(reader.uint64());
              break;
            case 3:
              message.txHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operator: isSet3(object.operator) ? String(object.operator) : "",
          recordId: isSet3(object.recordId) ? String(object.recordId) : "0",
          txHash: isSet3(object.txHash) ? String(object.txHash) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operator !== void 0 && (obj.operator = message.operator);
        message.recordId !== void 0 && (obj.recordId = message.recordId);
        message.txHash !== void 0 && (obj.txHash = message.txHash);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgConfirmDelegation();
        message.operator = (_a2 = object.operator) !== null && _a2 !== void 0 ? _a2 : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgConfirmDelegationResponse() {
      return {};
    }
    exports2.MsgConfirmDelegationResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConfirmDelegationResponse();
        return message;
      }
    };
    function createBaseMsgConfirmUndelegation() {
      return { operator: "", recordId: "0", txHash: "" };
    }
    exports2.MsgConfirmUndelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
          writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
          writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
          writer.uint32(26).string(message.txHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUndelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operator = reader.string();
              break;
            case 2:
              message.recordId = longToString(reader.uint64());
              break;
            case 3:
              message.txHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operator: isSet3(object.operator) ? String(object.operator) : "",
          recordId: isSet3(object.recordId) ? String(object.recordId) : "0",
          txHash: isSet3(object.txHash) ? String(object.txHash) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operator !== void 0 && (obj.operator = message.operator);
        message.recordId !== void 0 && (obj.recordId = message.recordId);
        message.txHash !== void 0 && (obj.txHash = message.txHash);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgConfirmUndelegation();
        message.operator = (_a2 = object.operator) !== null && _a2 !== void 0 ? _a2 : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgConfirmUndelegationResponse() {
      return {};
    }
    exports2.MsgConfirmUndelegationResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUndelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConfirmUndelegationResponse();
        return message;
      }
    };
    function createBaseMsgConfirmUnbondedTokenSweep() {
      return { operator: "", recordId: "0", txHash: "" };
    }
    exports2.MsgConfirmUnbondedTokenSweep = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
          writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
          writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
          writer.uint32(26).string(message.txHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUnbondedTokenSweep();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operator = reader.string();
              break;
            case 2:
              message.recordId = longToString(reader.uint64());
              break;
            case 3:
              message.txHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operator: isSet3(object.operator) ? String(object.operator) : "",
          recordId: isSet3(object.recordId) ? String(object.recordId) : "0",
          txHash: isSet3(object.txHash) ? String(object.txHash) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operator !== void 0 && (obj.operator = message.operator);
        message.recordId !== void 0 && (obj.recordId = message.recordId);
        message.txHash !== void 0 && (obj.txHash = message.txHash);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgConfirmUnbondedTokenSweep();
        message.operator = (_a2 = object.operator) !== null && _a2 !== void 0 ? _a2 : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgConfirmUnbondedTokenSweepResponse() {
      return {};
    }
    exports2.MsgConfirmUnbondedTokenSweepResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUnbondedTokenSweepResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConfirmUnbondedTokenSweepResponse();
        return message;
      }
    };
    function createBaseMsgAdjustDelegatedBalance() {
      return { operator: "", delegationOffset: "", validatorAddress: "" };
    }
    exports2.MsgAdjustDelegatedBalance = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
          writer.uint32(10).string(message.operator);
        }
        if (message.delegationOffset !== "") {
          writer.uint32(18).string(message.delegationOffset);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(26).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAdjustDelegatedBalance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operator = reader.string();
              break;
            case 2:
              message.delegationOffset = reader.string();
              break;
            case 3:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operator: isSet3(object.operator) ? String(object.operator) : "",
          delegationOffset: isSet3(object.delegationOffset) ? String(object.delegationOffset) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operator !== void 0 && (obj.operator = message.operator);
        message.delegationOffset !== void 0 && (obj.delegationOffset = message.delegationOffset);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgAdjustDelegatedBalance();
        message.operator = (_a2 = object.operator) !== null && _a2 !== void 0 ? _a2 : "";
        message.delegationOffset = (_b = object.delegationOffset) !== null && _b !== void 0 ? _b : "";
        message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgAdjustDelegatedBalanceResponse() {
      return {};
    }
    exports2.MsgAdjustDelegatedBalanceResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAdjustDelegatedBalanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgAdjustDelegatedBalanceResponse();
        return message;
      }
    };
    function createBaseMsgUpdateInnerRedemptionRateBounds() {
      return {
        creator: "",
        minInnerRedemptionRate: "",
        maxInnerRedemptionRate: ""
      };
    }
    exports2.MsgUpdateInnerRedemptionRateBounds = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.minInnerRedemptionRate !== "") {
          writer.uint32(18).string(message.minInnerRedemptionRate);
        }
        if (message.maxInnerRedemptionRate !== "") {
          writer.uint32(26).string(message.maxInnerRedemptionRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.minInnerRedemptionRate = reader.string();
              break;
            case 3:
              message.maxInnerRedemptionRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          minInnerRedemptionRate: isSet3(object.minInnerRedemptionRate) ? String(object.minInnerRedemptionRate) : "",
          maxInnerRedemptionRate: isSet3(object.maxInnerRedemptionRate) ? String(object.maxInnerRedemptionRate) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.minInnerRedemptionRate !== void 0 && (obj.minInnerRedemptionRate = message.minInnerRedemptionRate);
        message.maxInnerRedemptionRate !== void 0 && (obj.maxInnerRedemptionRate = message.maxInnerRedemptionRate);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.minInnerRedemptionRate = (_b = object.minInnerRedemptionRate) !== null && _b !== void 0 ? _b : "";
        message.maxInnerRedemptionRate = (_c = object.maxInnerRedemptionRate) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgUpdateInnerRedemptionRateBoundsResponse() {
      return {};
    }
    exports2.MsgUpdateInnerRedemptionRateBoundsResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        return message;
      }
    };
    function createBaseMsgResumeHostZone() {
      return { creator: "" };
    }
    exports2.MsgResumeHostZone = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgResumeHostZone();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgResumeHostZone();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseMsgResumeHostZoneResponse() {
      return {};
    }
    exports2.MsgResumeHostZoneResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgResumeHostZoneResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgResumeHostZoneResponse();
        return message;
      }
    };
    function createBaseMsgRefreshRedemptionRate() {
      return { creator: "" };
    }
    exports2.MsgRefreshRedemptionRate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRefreshRedemptionRate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgRefreshRedemptionRate();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseMsgRefreshRedemptionRateResponse() {
      return {};
    }
    exports2.MsgRefreshRedemptionRateResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRefreshRedemptionRateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRefreshRedemptionRateResponse();
        return message;
      }
    };
    function createBaseMsgOverwriteDelegationRecord() {
      return { creator: "", delegationRecord: void 0 };
    }
    exports2.MsgOverwriteDelegationRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.delegationRecord !== void 0) {
          staketia_1.DelegationRecord.encode(message.delegationRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteDelegationRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.delegationRecord = staketia_1.DelegationRecord.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          delegationRecord: isSet3(object.delegationRecord) ? staketia_1.DelegationRecord.fromJSON(object.delegationRecord) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.delegationRecord !== void 0 && (obj.delegationRecord = message.delegationRecord ? staketia_1.DelegationRecord.toJSON(message.delegationRecord) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgOverwriteDelegationRecord();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.delegationRecord = object.delegationRecord !== void 0 && object.delegationRecord !== null ? staketia_1.DelegationRecord.fromPartial(object.delegationRecord) : void 0;
        return message;
      }
    };
    function createBaseMsgOverwriteDelegationRecordResponse() {
      return {};
    }
    exports2.MsgOverwriteDelegationRecordResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteDelegationRecordResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgOverwriteDelegationRecordResponse();
        return message;
      }
    };
    function createBaseMsgOverwriteUnbondingRecord() {
      return { creator: "", unbondingRecord: void 0 };
    }
    exports2.MsgOverwriteUnbondingRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.unbondingRecord !== void 0) {
          staketia_1.UnbondingRecord.encode(message.unbondingRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteUnbondingRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.unbondingRecord = staketia_1.UnbondingRecord.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          unbondingRecord: isSet3(object.unbondingRecord) ? staketia_1.UnbondingRecord.fromJSON(object.unbondingRecord) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.unbondingRecord !== void 0 && (obj.unbondingRecord = message.unbondingRecord ? staketia_1.UnbondingRecord.toJSON(message.unbondingRecord) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgOverwriteUnbondingRecord();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.unbondingRecord = object.unbondingRecord !== void 0 && object.unbondingRecord !== null ? staketia_1.UnbondingRecord.fromPartial(object.unbondingRecord) : void 0;
        return message;
      }
    };
    function createBaseMsgOverwriteUnbondingRecordResponse() {
      return {};
    }
    exports2.MsgOverwriteUnbondingRecordResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteUnbondingRecordResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgOverwriteUnbondingRecordResponse();
        return message;
      }
    };
    function createBaseMsgOverwriteRedemptionRecord() {
      return { creator: "", redemptionRecord: void 0 };
    }
    exports2.MsgOverwriteRedemptionRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.redemptionRecord !== void 0) {
          staketia_1.RedemptionRecord.encode(message.redemptionRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteRedemptionRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.redemptionRecord = staketia_1.RedemptionRecord.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          redemptionRecord: isSet3(object.redemptionRecord) ? staketia_1.RedemptionRecord.fromJSON(object.redemptionRecord) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.redemptionRecord !== void 0 && (obj.redemptionRecord = message.redemptionRecord ? staketia_1.RedemptionRecord.toJSON(message.redemptionRecord) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgOverwriteRedemptionRecord();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.redemptionRecord = object.redemptionRecord !== void 0 && object.redemptionRecord !== null ? staketia_1.RedemptionRecord.fromPartial(object.redemptionRecord) : void 0;
        return message;
      }
    };
    function createBaseMsgOverwriteRedemptionRecordResponse() {
      return {};
    }
    exports2.MsgOverwriteRedemptionRecordResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteRedemptionRecordResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgOverwriteRedemptionRecordResponse();
        return message;
      }
    };
    function createBaseMsgSetOperatorAddress() {
      return { signer: "", operator: "" };
    }
    exports2.MsgSetOperatorAddress = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.operator !== "") {
          writer.uint32(18).string(message.operator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetOperatorAddress();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.operator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signer: isSet3(object.signer) ? String(object.signer) : "",
          operator: isSet3(object.operator) ? String(object.operator) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.operator !== void 0 && (obj.operator = message.operator);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgSetOperatorAddress();
        message.signer = (_a2 = object.signer) !== null && _a2 !== void 0 ? _a2 : "";
        message.operator = (_b = object.operator) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgSetOperatorAddressResponse() {
      return {};
    }
    exports2.MsgSetOperatorAddressResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetOperatorAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSetOperatorAddressResponse();
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/stride/stakedym/stakedym.js
var require_stakedym = __commonJS({
  "node_modules/@keplr-wallet/proto-types/stride/stakedym/stakedym.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SlashRecord = exports2.RedemptionRecord = exports2.UnbondingRecord = exports2.DelegationRecord = exports2.HostZone = exports2.unbondingRecordStatusToJSON = exports2.unbondingRecordStatusFromJSON = exports2.UnbondingRecordStatus = exports2.delegationRecordStatusToJSON = exports2.delegationRecordStatusFromJSON = exports2.DelegationRecordStatus = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "stride.stakedym";
    var DelegationRecordStatus;
    (function(DelegationRecordStatus2) {
      DelegationRecordStatus2[DelegationRecordStatus2["TRANSFER_IN_PROGRESS"] = 0] = "TRANSFER_IN_PROGRESS";
      DelegationRecordStatus2[DelegationRecordStatus2["TRANSFER_FAILED"] = 1] = "TRANSFER_FAILED";
      DelegationRecordStatus2[DelegationRecordStatus2["DELEGATION_QUEUE"] = 2] = "DELEGATION_QUEUE";
      DelegationRecordStatus2[DelegationRecordStatus2["DELEGATION_COMPLETE"] = 3] = "DELEGATION_COMPLETE";
      DelegationRecordStatus2[DelegationRecordStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(DelegationRecordStatus = exports2.DelegationRecordStatus || (exports2.DelegationRecordStatus = {}));
    function delegationRecordStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "TRANSFER_IN_PROGRESS":
          return DelegationRecordStatus.TRANSFER_IN_PROGRESS;
        case 1:
        case "TRANSFER_FAILED":
          return DelegationRecordStatus.TRANSFER_FAILED;
        case 2:
        case "DELEGATION_QUEUE":
          return DelegationRecordStatus.DELEGATION_QUEUE;
        case 3:
        case "DELEGATION_COMPLETE":
          return DelegationRecordStatus.DELEGATION_COMPLETE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return DelegationRecordStatus.UNRECOGNIZED;
      }
    }
    exports2.delegationRecordStatusFromJSON = delegationRecordStatusFromJSON;
    function delegationRecordStatusToJSON(object) {
      switch (object) {
        case DelegationRecordStatus.TRANSFER_IN_PROGRESS:
          return "TRANSFER_IN_PROGRESS";
        case DelegationRecordStatus.TRANSFER_FAILED:
          return "TRANSFER_FAILED";
        case DelegationRecordStatus.DELEGATION_QUEUE:
          return "DELEGATION_QUEUE";
        case DelegationRecordStatus.DELEGATION_COMPLETE:
          return "DELEGATION_COMPLETE";
        default:
          return "UNKNOWN";
      }
    }
    exports2.delegationRecordStatusToJSON = delegationRecordStatusToJSON;
    var UnbondingRecordStatus;
    (function(UnbondingRecordStatus2) {
      UnbondingRecordStatus2[UnbondingRecordStatus2["ACCUMULATING_REDEMPTIONS"] = 0] = "ACCUMULATING_REDEMPTIONS";
      UnbondingRecordStatus2[UnbondingRecordStatus2["UNBONDING_QUEUE"] = 1] = "UNBONDING_QUEUE";
      UnbondingRecordStatus2[UnbondingRecordStatus2["UNBONDING_IN_PROGRESS"] = 2] = "UNBONDING_IN_PROGRESS";
      UnbondingRecordStatus2[UnbondingRecordStatus2["UNBONDED"] = 3] = "UNBONDED";
      UnbondingRecordStatus2[UnbondingRecordStatus2["CLAIMABLE"] = 4] = "CLAIMABLE";
      UnbondingRecordStatus2[UnbondingRecordStatus2["CLAIMED"] = 5] = "CLAIMED";
      UnbondingRecordStatus2[UnbondingRecordStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(UnbondingRecordStatus = exports2.UnbondingRecordStatus || (exports2.UnbondingRecordStatus = {}));
    function unbondingRecordStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "ACCUMULATING_REDEMPTIONS":
          return UnbondingRecordStatus.ACCUMULATING_REDEMPTIONS;
        case 1:
        case "UNBONDING_QUEUE":
          return UnbondingRecordStatus.UNBONDING_QUEUE;
        case 2:
        case "UNBONDING_IN_PROGRESS":
          return UnbondingRecordStatus.UNBONDING_IN_PROGRESS;
        case 3:
        case "UNBONDED":
          return UnbondingRecordStatus.UNBONDED;
        case 4:
        case "CLAIMABLE":
          return UnbondingRecordStatus.CLAIMABLE;
        case 5:
        case "CLAIMED":
          return UnbondingRecordStatus.CLAIMED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return UnbondingRecordStatus.UNRECOGNIZED;
      }
    }
    exports2.unbondingRecordStatusFromJSON = unbondingRecordStatusFromJSON;
    function unbondingRecordStatusToJSON(object) {
      switch (object) {
        case UnbondingRecordStatus.ACCUMULATING_REDEMPTIONS:
          return "ACCUMULATING_REDEMPTIONS";
        case UnbondingRecordStatus.UNBONDING_QUEUE:
          return "UNBONDING_QUEUE";
        case UnbondingRecordStatus.UNBONDING_IN_PROGRESS:
          return "UNBONDING_IN_PROGRESS";
        case UnbondingRecordStatus.UNBONDED:
          return "UNBONDED";
        case UnbondingRecordStatus.CLAIMABLE:
          return "CLAIMABLE";
        case UnbondingRecordStatus.CLAIMED:
          return "CLAIMED";
        default:
          return "UNKNOWN";
      }
    }
    exports2.unbondingRecordStatusToJSON = unbondingRecordStatusToJSON;
    function createBaseHostZone() {
      return {
        chainId: "",
        nativeTokenDenom: "",
        nativeTokenIbcDenom: "",
        transferChannelId: "",
        delegationAddress: "",
        rewardAddress: "",
        depositAddress: "",
        redemptionAddress: "",
        claimAddress: "",
        operatorAddressOnStride: "",
        safeAddressOnStride: "",
        lastRedemptionRate: "",
        redemptionRate: "",
        minRedemptionRate: "",
        maxRedemptionRate: "",
        minInnerRedemptionRate: "",
        maxInnerRedemptionRate: "",
        delegatedBalance: "",
        unbondingPeriodSeconds: "0",
        halted: false
      };
    }
    exports2.HostZone = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chainId !== "") {
          writer.uint32(10).string(message.chainId);
        }
        if (message.nativeTokenDenom !== "") {
          writer.uint32(18).string(message.nativeTokenDenom);
        }
        if (message.nativeTokenIbcDenom !== "") {
          writer.uint32(26).string(message.nativeTokenIbcDenom);
        }
        if (message.transferChannelId !== "") {
          writer.uint32(34).string(message.transferChannelId);
        }
        if (message.delegationAddress !== "") {
          writer.uint32(42).string(message.delegationAddress);
        }
        if (message.rewardAddress !== "") {
          writer.uint32(50).string(message.rewardAddress);
        }
        if (message.depositAddress !== "") {
          writer.uint32(58).string(message.depositAddress);
        }
        if (message.redemptionAddress !== "") {
          writer.uint32(66).string(message.redemptionAddress);
        }
        if (message.claimAddress !== "") {
          writer.uint32(74).string(message.claimAddress);
        }
        if (message.operatorAddressOnStride !== "") {
          writer.uint32(82).string(message.operatorAddressOnStride);
        }
        if (message.safeAddressOnStride !== "") {
          writer.uint32(90).string(message.safeAddressOnStride);
        }
        if (message.lastRedemptionRate !== "") {
          writer.uint32(98).string(message.lastRedemptionRate);
        }
        if (message.redemptionRate !== "") {
          writer.uint32(106).string(message.redemptionRate);
        }
        if (message.minRedemptionRate !== "") {
          writer.uint32(114).string(message.minRedemptionRate);
        }
        if (message.maxRedemptionRate !== "") {
          writer.uint32(122).string(message.maxRedemptionRate);
        }
        if (message.minInnerRedemptionRate !== "") {
          writer.uint32(130).string(message.minInnerRedemptionRate);
        }
        if (message.maxInnerRedemptionRate !== "") {
          writer.uint32(138).string(message.maxInnerRedemptionRate);
        }
        if (message.delegatedBalance !== "") {
          writer.uint32(146).string(message.delegatedBalance);
        }
        if (message.unbondingPeriodSeconds !== "0") {
          writer.uint32(152).uint64(message.unbondingPeriodSeconds);
        }
        if (message.halted === true) {
          writer.uint32(160).bool(message.halted);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHostZone();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chainId = reader.string();
              break;
            case 2:
              message.nativeTokenDenom = reader.string();
              break;
            case 3:
              message.nativeTokenIbcDenom = reader.string();
              break;
            case 4:
              message.transferChannelId = reader.string();
              break;
            case 5:
              message.delegationAddress = reader.string();
              break;
            case 6:
              message.rewardAddress = reader.string();
              break;
            case 7:
              message.depositAddress = reader.string();
              break;
            case 8:
              message.redemptionAddress = reader.string();
              break;
            case 9:
              message.claimAddress = reader.string();
              break;
            case 10:
              message.operatorAddressOnStride = reader.string();
              break;
            case 11:
              message.safeAddressOnStride = reader.string();
              break;
            case 12:
              message.lastRedemptionRate = reader.string();
              break;
            case 13:
              message.redemptionRate = reader.string();
              break;
            case 14:
              message.minRedemptionRate = reader.string();
              break;
            case 15:
              message.maxRedemptionRate = reader.string();
              break;
            case 16:
              message.minInnerRedemptionRate = reader.string();
              break;
            case 17:
              message.maxInnerRedemptionRate = reader.string();
              break;
            case 18:
              message.delegatedBalance = reader.string();
              break;
            case 19:
              message.unbondingPeriodSeconds = longToString(reader.uint64());
              break;
            case 20:
              message.halted = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          chainId: isSet3(object.chainId) ? String(object.chainId) : "",
          nativeTokenDenom: isSet3(object.nativeTokenDenom) ? String(object.nativeTokenDenom) : "",
          nativeTokenIbcDenom: isSet3(object.nativeTokenIbcDenom) ? String(object.nativeTokenIbcDenom) : "",
          transferChannelId: isSet3(object.transferChannelId) ? String(object.transferChannelId) : "",
          delegationAddress: isSet3(object.delegationAddress) ? String(object.delegationAddress) : "",
          rewardAddress: isSet3(object.rewardAddress) ? String(object.rewardAddress) : "",
          depositAddress: isSet3(object.depositAddress) ? String(object.depositAddress) : "",
          redemptionAddress: isSet3(object.redemptionAddress) ? String(object.redemptionAddress) : "",
          claimAddress: isSet3(object.claimAddress) ? String(object.claimAddress) : "",
          operatorAddressOnStride: isSet3(object.operatorAddressOnStride) ? String(object.operatorAddressOnStride) : "",
          safeAddressOnStride: isSet3(object.safeAddressOnStride) ? String(object.safeAddressOnStride) : "",
          lastRedemptionRate: isSet3(object.lastRedemptionRate) ? String(object.lastRedemptionRate) : "",
          redemptionRate: isSet3(object.redemptionRate) ? String(object.redemptionRate) : "",
          minRedemptionRate: isSet3(object.minRedemptionRate) ? String(object.minRedemptionRate) : "",
          maxRedemptionRate: isSet3(object.maxRedemptionRate) ? String(object.maxRedemptionRate) : "",
          minInnerRedemptionRate: isSet3(object.minInnerRedemptionRate) ? String(object.minInnerRedemptionRate) : "",
          maxInnerRedemptionRate: isSet3(object.maxInnerRedemptionRate) ? String(object.maxInnerRedemptionRate) : "",
          delegatedBalance: isSet3(object.delegatedBalance) ? String(object.delegatedBalance) : "",
          unbondingPeriodSeconds: isSet3(object.unbondingPeriodSeconds) ? String(object.unbondingPeriodSeconds) : "0",
          halted: isSet3(object.halted) ? Boolean(object.halted) : false
        };
      },
      toJSON(message) {
        const obj = {};
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.nativeTokenDenom !== void 0 && (obj.nativeTokenDenom = message.nativeTokenDenom);
        message.nativeTokenIbcDenom !== void 0 && (obj.nativeTokenIbcDenom = message.nativeTokenIbcDenom);
        message.transferChannelId !== void 0 && (obj.transferChannelId = message.transferChannelId);
        message.delegationAddress !== void 0 && (obj.delegationAddress = message.delegationAddress);
        message.rewardAddress !== void 0 && (obj.rewardAddress = message.rewardAddress);
        message.depositAddress !== void 0 && (obj.depositAddress = message.depositAddress);
        message.redemptionAddress !== void 0 && (obj.redemptionAddress = message.redemptionAddress);
        message.claimAddress !== void 0 && (obj.claimAddress = message.claimAddress);
        message.operatorAddressOnStride !== void 0 && (obj.operatorAddressOnStride = message.operatorAddressOnStride);
        message.safeAddressOnStride !== void 0 && (obj.safeAddressOnStride = message.safeAddressOnStride);
        message.lastRedemptionRate !== void 0 && (obj.lastRedemptionRate = message.lastRedemptionRate);
        message.redemptionRate !== void 0 && (obj.redemptionRate = message.redemptionRate);
        message.minRedemptionRate !== void 0 && (obj.minRedemptionRate = message.minRedemptionRate);
        message.maxRedemptionRate !== void 0 && (obj.maxRedemptionRate = message.maxRedemptionRate);
        message.minInnerRedemptionRate !== void 0 && (obj.minInnerRedemptionRate = message.minInnerRedemptionRate);
        message.maxInnerRedemptionRate !== void 0 && (obj.maxInnerRedemptionRate = message.maxInnerRedemptionRate);
        message.delegatedBalance !== void 0 && (obj.delegatedBalance = message.delegatedBalance);
        message.unbondingPeriodSeconds !== void 0 && (obj.unbondingPeriodSeconds = message.unbondingPeriodSeconds);
        message.halted !== void 0 && (obj.halted = message.halted);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        const message = createBaseHostZone();
        message.chainId = (_a2 = object.chainId) !== null && _a2 !== void 0 ? _a2 : "";
        message.nativeTokenDenom = (_b = object.nativeTokenDenom) !== null && _b !== void 0 ? _b : "";
        message.nativeTokenIbcDenom = (_c = object.nativeTokenIbcDenom) !== null && _c !== void 0 ? _c : "";
        message.transferChannelId = (_d = object.transferChannelId) !== null && _d !== void 0 ? _d : "";
        message.delegationAddress = (_e = object.delegationAddress) !== null && _e !== void 0 ? _e : "";
        message.rewardAddress = (_f = object.rewardAddress) !== null && _f !== void 0 ? _f : "";
        message.depositAddress = (_g = object.depositAddress) !== null && _g !== void 0 ? _g : "";
        message.redemptionAddress = (_h = object.redemptionAddress) !== null && _h !== void 0 ? _h : "";
        message.claimAddress = (_j = object.claimAddress) !== null && _j !== void 0 ? _j : "";
        message.operatorAddressOnStride = (_k = object.operatorAddressOnStride) !== null && _k !== void 0 ? _k : "";
        message.safeAddressOnStride = (_l = object.safeAddressOnStride) !== null && _l !== void 0 ? _l : "";
        message.lastRedemptionRate = (_m = object.lastRedemptionRate) !== null && _m !== void 0 ? _m : "";
        message.redemptionRate = (_o = object.redemptionRate) !== null && _o !== void 0 ? _o : "";
        message.minRedemptionRate = (_p = object.minRedemptionRate) !== null && _p !== void 0 ? _p : "";
        message.maxRedemptionRate = (_q = object.maxRedemptionRate) !== null && _q !== void 0 ? _q : "";
        message.minInnerRedemptionRate = (_r = object.minInnerRedemptionRate) !== null && _r !== void 0 ? _r : "";
        message.maxInnerRedemptionRate = (_s = object.maxInnerRedemptionRate) !== null && _s !== void 0 ? _s : "";
        message.delegatedBalance = (_t = object.delegatedBalance) !== null && _t !== void 0 ? _t : "";
        message.unbondingPeriodSeconds = (_u = object.unbondingPeriodSeconds) !== null && _u !== void 0 ? _u : "0";
        message.halted = (_v = object.halted) !== null && _v !== void 0 ? _v : false;
        return message;
      }
    };
    function createBaseDelegationRecord() {
      return { id: "0", nativeAmount: "", status: 0, txHash: "" };
    }
    exports2.DelegationRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "0") {
          writer.uint32(8).uint64(message.id);
        }
        if (message.nativeAmount !== "") {
          writer.uint32(18).string(message.nativeAmount);
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.txHash !== "") {
          writer.uint32(34).string(message.txHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = longToString(reader.uint64());
              break;
            case 2:
              message.nativeAmount = reader.string();
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.txHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet3(object.id) ? String(object.id) : "0",
          nativeAmount: isSet3(object.nativeAmount) ? String(object.nativeAmount) : "",
          status: isSet3(object.status) ? delegationRecordStatusFromJSON(object.status) : 0,
          txHash: isSet3(object.txHash) ? String(object.txHash) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.nativeAmount !== void 0 && (obj.nativeAmount = message.nativeAmount);
        message.status !== void 0 && (obj.status = delegationRecordStatusToJSON(message.status));
        message.txHash !== void 0 && (obj.txHash = message.txHash);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseDelegationRecord();
        message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "0";
        message.nativeAmount = (_b = object.nativeAmount) !== null && _b !== void 0 ? _b : "";
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : 0;
        message.txHash = (_d = object.txHash) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseUnbondingRecord() {
      return {
        id: "0",
        status: 0,
        stTokenAmount: "",
        nativeAmount: "",
        unbondingCompletionTimeSeconds: "0",
        undelegationTxHash: "",
        unbondedTokenSweepTxHash: ""
      };
    }
    exports2.UnbondingRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "0") {
          writer.uint32(8).uint64(message.id);
        }
        if (message.status !== 0) {
          writer.uint32(16).int32(message.status);
        }
        if (message.stTokenAmount !== "") {
          writer.uint32(26).string(message.stTokenAmount);
        }
        if (message.nativeAmount !== "") {
          writer.uint32(34).string(message.nativeAmount);
        }
        if (message.unbondingCompletionTimeSeconds !== "0") {
          writer.uint32(40).uint64(message.unbondingCompletionTimeSeconds);
        }
        if (message.undelegationTxHash !== "") {
          writer.uint32(50).string(message.undelegationTxHash);
        }
        if (message.unbondedTokenSweepTxHash !== "") {
          writer.uint32(58).string(message.unbondedTokenSweepTxHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = longToString(reader.uint64());
              break;
            case 2:
              message.status = reader.int32();
              break;
            case 3:
              message.stTokenAmount = reader.string();
              break;
            case 4:
              message.nativeAmount = reader.string();
              break;
            case 5:
              message.unbondingCompletionTimeSeconds = longToString(reader.uint64());
              break;
            case 6:
              message.undelegationTxHash = reader.string();
              break;
            case 7:
              message.unbondedTokenSweepTxHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet3(object.id) ? String(object.id) : "0",
          status: isSet3(object.status) ? unbondingRecordStatusFromJSON(object.status) : 0,
          stTokenAmount: isSet3(object.stTokenAmount) ? String(object.stTokenAmount) : "",
          nativeAmount: isSet3(object.nativeAmount) ? String(object.nativeAmount) : "",
          unbondingCompletionTimeSeconds: isSet3(object.unbondingCompletionTimeSeconds) ? String(object.unbondingCompletionTimeSeconds) : "0",
          undelegationTxHash: isSet3(object.undelegationTxHash) ? String(object.undelegationTxHash) : "",
          unbondedTokenSweepTxHash: isSet3(object.unbondedTokenSweepTxHash) ? String(object.unbondedTokenSweepTxHash) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.status !== void 0 && (obj.status = unbondingRecordStatusToJSON(message.status));
        message.stTokenAmount !== void 0 && (obj.stTokenAmount = message.stTokenAmount);
        message.nativeAmount !== void 0 && (obj.nativeAmount = message.nativeAmount);
        message.unbondingCompletionTimeSeconds !== void 0 && (obj.unbondingCompletionTimeSeconds = message.unbondingCompletionTimeSeconds);
        message.undelegationTxHash !== void 0 && (obj.undelegationTxHash = message.undelegationTxHash);
        message.unbondedTokenSweepTxHash !== void 0 && (obj.unbondedTokenSweepTxHash = message.unbondedTokenSweepTxHash);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e, _f, _g;
        const message = createBaseUnbondingRecord();
        message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "0";
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : 0;
        message.stTokenAmount = (_c = object.stTokenAmount) !== null && _c !== void 0 ? _c : "";
        message.nativeAmount = (_d = object.nativeAmount) !== null && _d !== void 0 ? _d : "";
        message.unbondingCompletionTimeSeconds = (_e = object.unbondingCompletionTimeSeconds) !== null && _e !== void 0 ? _e : "0";
        message.undelegationTxHash = (_f = object.undelegationTxHash) !== null && _f !== void 0 ? _f : "";
        message.unbondedTokenSweepTxHash = (_g = object.unbondedTokenSweepTxHash) !== null && _g !== void 0 ? _g : "";
        return message;
      }
    };
    function createBaseRedemptionRecord() {
      return {
        unbondingRecordId: "0",
        redeemer: "",
        stTokenAmount: "",
        nativeAmount: ""
      };
    }
    exports2.RedemptionRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.unbondingRecordId !== "0") {
          writer.uint32(8).uint64(message.unbondingRecordId);
        }
        if (message.redeemer !== "") {
          writer.uint32(18).string(message.redeemer);
        }
        if (message.stTokenAmount !== "") {
          writer.uint32(26).string(message.stTokenAmount);
        }
        if (message.nativeAmount !== "") {
          writer.uint32(34).string(message.nativeAmount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedemptionRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingRecordId = longToString(reader.uint64());
              break;
            case 2:
              message.redeemer = reader.string();
              break;
            case 3:
              message.stTokenAmount = reader.string();
              break;
            case 4:
              message.nativeAmount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          unbondingRecordId: isSet3(object.unbondingRecordId) ? String(object.unbondingRecordId) : "0",
          redeemer: isSet3(object.redeemer) ? String(object.redeemer) : "",
          stTokenAmount: isSet3(object.stTokenAmount) ? String(object.stTokenAmount) : "",
          nativeAmount: isSet3(object.nativeAmount) ? String(object.nativeAmount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.unbondingRecordId !== void 0 && (obj.unbondingRecordId = message.unbondingRecordId);
        message.redeemer !== void 0 && (obj.redeemer = message.redeemer);
        message.stTokenAmount !== void 0 && (obj.stTokenAmount = message.stTokenAmount);
        message.nativeAmount !== void 0 && (obj.nativeAmount = message.nativeAmount);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseRedemptionRecord();
        message.unbondingRecordId = (_a2 = object.unbondingRecordId) !== null && _a2 !== void 0 ? _a2 : "0";
        message.redeemer = (_b = object.redeemer) !== null && _b !== void 0 ? _b : "";
        message.stTokenAmount = (_c = object.stTokenAmount) !== null && _c !== void 0 ? _c : "";
        message.nativeAmount = (_d = object.nativeAmount) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseSlashRecord() {
      return { id: "0", time: "0", nativeAmount: "", validatorAddress: "" };
    }
    exports2.SlashRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "0") {
          writer.uint32(8).uint64(message.id);
        }
        if (message.time !== "0") {
          writer.uint32(16).uint64(message.time);
        }
        if (message.nativeAmount !== "") {
          writer.uint32(26).string(message.nativeAmount);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(34).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSlashRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = longToString(reader.uint64());
              break;
            case 2:
              message.time = longToString(reader.uint64());
              break;
            case 3:
              message.nativeAmount = reader.string();
              break;
            case 4:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet3(object.id) ? String(object.id) : "0",
          time: isSet3(object.time) ? String(object.time) : "0",
          nativeAmount: isSet3(object.nativeAmount) ? String(object.nativeAmount) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.time !== void 0 && (obj.time = message.time);
        message.nativeAmount !== void 0 && (obj.nativeAmount = message.nativeAmount);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseSlashRecord();
        message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "0";
        message.time = (_b = object.time) !== null && _b !== void 0 ? _b : "0";
        message.nativeAmount = (_c = object.nativeAmount) !== null && _c !== void 0 ? _c : "";
        message.validatorAddress = (_d = object.validatorAddress) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/stride/stakedym/tx.js
var require_tx14 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/stride/stakedym/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgSetOperatorAddressResponse = exports2.MsgSetOperatorAddress = exports2.MsgOverwriteRedemptionRecordResponse = exports2.MsgOverwriteRedemptionRecord = exports2.MsgOverwriteUnbondingRecordResponse = exports2.MsgOverwriteUnbondingRecord = exports2.MsgOverwriteDelegationRecordResponse = exports2.MsgOverwriteDelegationRecord = exports2.MsgRefreshRedemptionRateResponse = exports2.MsgRefreshRedemptionRate = exports2.MsgResumeHostZoneResponse = exports2.MsgResumeHostZone = exports2.MsgUpdateInnerRedemptionRateBoundsResponse = exports2.MsgUpdateInnerRedemptionRateBounds = exports2.MsgAdjustDelegatedBalanceResponse = exports2.MsgAdjustDelegatedBalance = exports2.MsgConfirmUnbondedTokenSweepResponse = exports2.MsgConfirmUnbondedTokenSweep = exports2.MsgConfirmUndelegationResponse = exports2.MsgConfirmUndelegation = exports2.MsgConfirmDelegationResponse = exports2.MsgConfirmDelegation = exports2.MsgRedeemStakeResponse = exports2.MsgRedeemStake = exports2.MsgLiquidStakeResponse = exports2.MsgLiquidStake = exports2.overwritableRecordTypeToJSON = exports2.overwritableRecordTypeFromJSON = exports2.OverwritableRecordType = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin2();
    var stakedym_1 = require_stakedym();
    exports2.protobufPackage = "stride.stakedym";
    var OverwritableRecordType;
    (function(OverwritableRecordType2) {
      OverwritableRecordType2[OverwritableRecordType2["RECORD_TYPE_DELEGATION"] = 0] = "RECORD_TYPE_DELEGATION";
      OverwritableRecordType2[OverwritableRecordType2["RECORD_TYPE_UNBONDING"] = 1] = "RECORD_TYPE_UNBONDING";
      OverwritableRecordType2[OverwritableRecordType2["RECORD_TYPE_REDEMPTION"] = 2] = "RECORD_TYPE_REDEMPTION";
      OverwritableRecordType2[OverwritableRecordType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(OverwritableRecordType = exports2.OverwritableRecordType || (exports2.OverwritableRecordType = {}));
    function overwritableRecordTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "RECORD_TYPE_DELEGATION":
          return OverwritableRecordType.RECORD_TYPE_DELEGATION;
        case 1:
        case "RECORD_TYPE_UNBONDING":
          return OverwritableRecordType.RECORD_TYPE_UNBONDING;
        case 2:
        case "RECORD_TYPE_REDEMPTION":
          return OverwritableRecordType.RECORD_TYPE_REDEMPTION;
        case -1:
        case "UNRECOGNIZED":
        default:
          return OverwritableRecordType.UNRECOGNIZED;
      }
    }
    exports2.overwritableRecordTypeFromJSON = overwritableRecordTypeFromJSON;
    function overwritableRecordTypeToJSON(object) {
      switch (object) {
        case OverwritableRecordType.RECORD_TYPE_DELEGATION:
          return "RECORD_TYPE_DELEGATION";
        case OverwritableRecordType.RECORD_TYPE_UNBONDING:
          return "RECORD_TYPE_UNBONDING";
        case OverwritableRecordType.RECORD_TYPE_REDEMPTION:
          return "RECORD_TYPE_REDEMPTION";
        default:
          return "UNKNOWN";
      }
    }
    exports2.overwritableRecordTypeToJSON = overwritableRecordTypeToJSON;
    function createBaseMsgLiquidStake() {
      return { staker: "", nativeAmount: "" };
    }
    exports2.MsgLiquidStake = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.staker !== "") {
          writer.uint32(10).string(message.staker);
        }
        if (message.nativeAmount !== "") {
          writer.uint32(18).string(message.nativeAmount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStake();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.staker = reader.string();
              break;
            case 2:
              message.nativeAmount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          staker: isSet3(object.staker) ? String(object.staker) : "",
          nativeAmount: isSet3(object.nativeAmount) ? String(object.nativeAmount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.staker !== void 0 && (obj.staker = message.staker);
        message.nativeAmount !== void 0 && (obj.nativeAmount = message.nativeAmount);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgLiquidStake();
        message.staker = (_a2 = object.staker) !== null && _a2 !== void 0 ? _a2 : "";
        message.nativeAmount = (_b = object.nativeAmount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgLiquidStakeResponse() {
      return { stToken: void 0 };
    }
    exports2.MsgLiquidStakeResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.stToken !== void 0) {
          coin_1.Coin.encode(message.stToken, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStakeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.stToken = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          stToken: isSet3(object.stToken) ? coin_1.Coin.fromJSON(object.stToken) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.stToken !== void 0 && (obj.stToken = message.stToken ? coin_1.Coin.toJSON(message.stToken) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgLiquidStakeResponse();
        message.stToken = object.stToken !== void 0 && object.stToken !== null ? coin_1.Coin.fromPartial(object.stToken) : void 0;
        return message;
      }
    };
    function createBaseMsgRedeemStake() {
      return { redeemer: "", stTokenAmount: "" };
    }
    exports2.MsgRedeemStake = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redeemer !== "") {
          writer.uint32(10).string(message.redeemer);
        }
        if (message.stTokenAmount !== "") {
          writer.uint32(18).string(message.stTokenAmount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStake();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redeemer = reader.string();
              break;
            case 2:
              message.stTokenAmount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          redeemer: isSet3(object.redeemer) ? String(object.redeemer) : "",
          stTokenAmount: isSet3(object.stTokenAmount) ? String(object.stTokenAmount) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.redeemer !== void 0 && (obj.redeemer = message.redeemer);
        message.stTokenAmount !== void 0 && (obj.stTokenAmount = message.stTokenAmount);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgRedeemStake();
        message.redeemer = (_a2 = object.redeemer) !== null && _a2 !== void 0 ? _a2 : "";
        message.stTokenAmount = (_b = object.stTokenAmount) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgRedeemStakeResponse() {
      return { nativeToken: void 0 };
    }
    exports2.MsgRedeemStakeResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nativeToken !== void 0) {
          coin_1.Coin.encode(message.nativeToken, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStakeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nativeToken = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          nativeToken: isSet3(object.nativeToken) ? coin_1.Coin.fromJSON(object.nativeToken) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.nativeToken !== void 0 && (obj.nativeToken = message.nativeToken ? coin_1.Coin.toJSON(message.nativeToken) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRedeemStakeResponse();
        message.nativeToken = object.nativeToken !== void 0 && object.nativeToken !== null ? coin_1.Coin.fromPartial(object.nativeToken) : void 0;
        return message;
      }
    };
    function createBaseMsgConfirmDelegation() {
      return { operator: "", recordId: "0", txHash: "" };
    }
    exports2.MsgConfirmDelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
          writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
          writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
          writer.uint32(26).string(message.txHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operator = reader.string();
              break;
            case 2:
              message.recordId = longToString(reader.uint64());
              break;
            case 3:
              message.txHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operator: isSet3(object.operator) ? String(object.operator) : "",
          recordId: isSet3(object.recordId) ? String(object.recordId) : "0",
          txHash: isSet3(object.txHash) ? String(object.txHash) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operator !== void 0 && (obj.operator = message.operator);
        message.recordId !== void 0 && (obj.recordId = message.recordId);
        message.txHash !== void 0 && (obj.txHash = message.txHash);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgConfirmDelegation();
        message.operator = (_a2 = object.operator) !== null && _a2 !== void 0 ? _a2 : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgConfirmDelegationResponse() {
      return {};
    }
    exports2.MsgConfirmDelegationResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConfirmDelegationResponse();
        return message;
      }
    };
    function createBaseMsgConfirmUndelegation() {
      return { operator: "", recordId: "0", txHash: "" };
    }
    exports2.MsgConfirmUndelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
          writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
          writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
          writer.uint32(26).string(message.txHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUndelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operator = reader.string();
              break;
            case 2:
              message.recordId = longToString(reader.uint64());
              break;
            case 3:
              message.txHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operator: isSet3(object.operator) ? String(object.operator) : "",
          recordId: isSet3(object.recordId) ? String(object.recordId) : "0",
          txHash: isSet3(object.txHash) ? String(object.txHash) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operator !== void 0 && (obj.operator = message.operator);
        message.recordId !== void 0 && (obj.recordId = message.recordId);
        message.txHash !== void 0 && (obj.txHash = message.txHash);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgConfirmUndelegation();
        message.operator = (_a2 = object.operator) !== null && _a2 !== void 0 ? _a2 : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgConfirmUndelegationResponse() {
      return {};
    }
    exports2.MsgConfirmUndelegationResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUndelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConfirmUndelegationResponse();
        return message;
      }
    };
    function createBaseMsgConfirmUnbondedTokenSweep() {
      return { operator: "", recordId: "0", txHash: "" };
    }
    exports2.MsgConfirmUnbondedTokenSweep = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
          writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
          writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
          writer.uint32(26).string(message.txHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUnbondedTokenSweep();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operator = reader.string();
              break;
            case 2:
              message.recordId = longToString(reader.uint64());
              break;
            case 3:
              message.txHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operator: isSet3(object.operator) ? String(object.operator) : "",
          recordId: isSet3(object.recordId) ? String(object.recordId) : "0",
          txHash: isSet3(object.txHash) ? String(object.txHash) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operator !== void 0 && (obj.operator = message.operator);
        message.recordId !== void 0 && (obj.recordId = message.recordId);
        message.txHash !== void 0 && (obj.txHash = message.txHash);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgConfirmUnbondedTokenSweep();
        message.operator = (_a2 = object.operator) !== null && _a2 !== void 0 ? _a2 : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgConfirmUnbondedTokenSweepResponse() {
      return {};
    }
    exports2.MsgConfirmUnbondedTokenSweepResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUnbondedTokenSweepResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConfirmUnbondedTokenSweepResponse();
        return message;
      }
    };
    function createBaseMsgAdjustDelegatedBalance() {
      return { operator: "", delegationOffset: "", validatorAddress: "" };
    }
    exports2.MsgAdjustDelegatedBalance = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
          writer.uint32(10).string(message.operator);
        }
        if (message.delegationOffset !== "") {
          writer.uint32(18).string(message.delegationOffset);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(26).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAdjustDelegatedBalance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operator = reader.string();
              break;
            case 2:
              message.delegationOffset = reader.string();
              break;
            case 3:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          operator: isSet3(object.operator) ? String(object.operator) : "",
          delegationOffset: isSet3(object.delegationOffset) ? String(object.delegationOffset) : "",
          validatorAddress: isSet3(object.validatorAddress) ? String(object.validatorAddress) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.operator !== void 0 && (obj.operator = message.operator);
        message.delegationOffset !== void 0 && (obj.delegationOffset = message.delegationOffset);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgAdjustDelegatedBalance();
        message.operator = (_a2 = object.operator) !== null && _a2 !== void 0 ? _a2 : "";
        message.delegationOffset = (_b = object.delegationOffset) !== null && _b !== void 0 ? _b : "";
        message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgAdjustDelegatedBalanceResponse() {
      return {};
    }
    exports2.MsgAdjustDelegatedBalanceResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAdjustDelegatedBalanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgAdjustDelegatedBalanceResponse();
        return message;
      }
    };
    function createBaseMsgUpdateInnerRedemptionRateBounds() {
      return {
        creator: "",
        minInnerRedemptionRate: "",
        maxInnerRedemptionRate: ""
      };
    }
    exports2.MsgUpdateInnerRedemptionRateBounds = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.minInnerRedemptionRate !== "") {
          writer.uint32(18).string(message.minInnerRedemptionRate);
        }
        if (message.maxInnerRedemptionRate !== "") {
          writer.uint32(26).string(message.maxInnerRedemptionRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.minInnerRedemptionRate = reader.string();
              break;
            case 3:
              message.maxInnerRedemptionRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          minInnerRedemptionRate: isSet3(object.minInnerRedemptionRate) ? String(object.minInnerRedemptionRate) : "",
          maxInnerRedemptionRate: isSet3(object.maxInnerRedemptionRate) ? String(object.maxInnerRedemptionRate) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.minInnerRedemptionRate !== void 0 && (obj.minInnerRedemptionRate = message.minInnerRedemptionRate);
        message.maxInnerRedemptionRate !== void 0 && (obj.maxInnerRedemptionRate = message.maxInnerRedemptionRate);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.minInnerRedemptionRate = (_b = object.minInnerRedemptionRate) !== null && _b !== void 0 ? _b : "";
        message.maxInnerRedemptionRate = (_c = object.maxInnerRedemptionRate) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    function createBaseMsgUpdateInnerRedemptionRateBoundsResponse() {
      return {};
    }
    exports2.MsgUpdateInnerRedemptionRateBoundsResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        return message;
      }
    };
    function createBaseMsgResumeHostZone() {
      return { creator: "" };
    }
    exports2.MsgResumeHostZone = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgResumeHostZone();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgResumeHostZone();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseMsgResumeHostZoneResponse() {
      return {};
    }
    exports2.MsgResumeHostZoneResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgResumeHostZoneResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgResumeHostZoneResponse();
        return message;
      }
    };
    function createBaseMsgRefreshRedemptionRate() {
      return { creator: "" };
    }
    exports2.MsgRefreshRedemptionRate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRefreshRedemptionRate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgRefreshRedemptionRate();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        return message;
      }
    };
    function createBaseMsgRefreshRedemptionRateResponse() {
      return {};
    }
    exports2.MsgRefreshRedemptionRateResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRefreshRedemptionRateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRefreshRedemptionRateResponse();
        return message;
      }
    };
    function createBaseMsgOverwriteDelegationRecord() {
      return { creator: "", delegationRecord: void 0 };
    }
    exports2.MsgOverwriteDelegationRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.delegationRecord !== void 0) {
          stakedym_1.DelegationRecord.encode(message.delegationRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteDelegationRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.delegationRecord = stakedym_1.DelegationRecord.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          delegationRecord: isSet3(object.delegationRecord) ? stakedym_1.DelegationRecord.fromJSON(object.delegationRecord) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.delegationRecord !== void 0 && (obj.delegationRecord = message.delegationRecord ? stakedym_1.DelegationRecord.toJSON(message.delegationRecord) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgOverwriteDelegationRecord();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.delegationRecord = object.delegationRecord !== void 0 && object.delegationRecord !== null ? stakedym_1.DelegationRecord.fromPartial(object.delegationRecord) : void 0;
        return message;
      }
    };
    function createBaseMsgOverwriteDelegationRecordResponse() {
      return {};
    }
    exports2.MsgOverwriteDelegationRecordResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteDelegationRecordResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgOverwriteDelegationRecordResponse();
        return message;
      }
    };
    function createBaseMsgOverwriteUnbondingRecord() {
      return { creator: "", unbondingRecord: void 0 };
    }
    exports2.MsgOverwriteUnbondingRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.unbondingRecord !== void 0) {
          stakedym_1.UnbondingRecord.encode(message.unbondingRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteUnbondingRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.unbondingRecord = stakedym_1.UnbondingRecord.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          unbondingRecord: isSet3(object.unbondingRecord) ? stakedym_1.UnbondingRecord.fromJSON(object.unbondingRecord) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.unbondingRecord !== void 0 && (obj.unbondingRecord = message.unbondingRecord ? stakedym_1.UnbondingRecord.toJSON(message.unbondingRecord) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgOverwriteUnbondingRecord();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.unbondingRecord = object.unbondingRecord !== void 0 && object.unbondingRecord !== null ? stakedym_1.UnbondingRecord.fromPartial(object.unbondingRecord) : void 0;
        return message;
      }
    };
    function createBaseMsgOverwriteUnbondingRecordResponse() {
      return {};
    }
    exports2.MsgOverwriteUnbondingRecordResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteUnbondingRecordResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgOverwriteUnbondingRecordResponse();
        return message;
      }
    };
    function createBaseMsgOverwriteRedemptionRecord() {
      return { creator: "", redemptionRecord: void 0 };
    }
    exports2.MsgOverwriteRedemptionRecord = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
          writer.uint32(10).string(message.creator);
        }
        if (message.redemptionRecord !== void 0) {
          stakedym_1.RedemptionRecord.encode(message.redemptionRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteRedemptionRecord();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.redemptionRecord = stakedym_1.RedemptionRecord.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          creator: isSet3(object.creator) ? String(object.creator) : "",
          redemptionRecord: isSet3(object.redemptionRecord) ? stakedym_1.RedemptionRecord.fromJSON(object.redemptionRecord) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.creator !== void 0 && (obj.creator = message.creator);
        message.redemptionRecord !== void 0 && (obj.redemptionRecord = message.redemptionRecord ? stakedym_1.RedemptionRecord.toJSON(message.redemptionRecord) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMsgOverwriteRedemptionRecord();
        message.creator = (_a2 = object.creator) !== null && _a2 !== void 0 ? _a2 : "";
        message.redemptionRecord = object.redemptionRecord !== void 0 && object.redemptionRecord !== null ? stakedym_1.RedemptionRecord.fromPartial(object.redemptionRecord) : void 0;
        return message;
      }
    };
    function createBaseMsgOverwriteRedemptionRecordResponse() {
      return {};
    }
    exports2.MsgOverwriteRedemptionRecordResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteRedemptionRecordResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgOverwriteRedemptionRecordResponse();
        return message;
      }
    };
    function createBaseMsgSetOperatorAddress() {
      return { signer: "", operator: "" };
    }
    exports2.MsgSetOperatorAddress = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.operator !== "") {
          writer.uint32(18).string(message.operator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetOperatorAddress();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.operator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signer: isSet3(object.signer) ? String(object.signer) : "",
          operator: isSet3(object.operator) ? String(object.operator) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.operator !== void 0 && (obj.operator = message.operator);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseMsgSetOperatorAddress();
        message.signer = (_a2 = object.signer) !== null && _a2 !== void 0 ? _a2 : "";
        message.operator = (_b = object.operator) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function createBaseMsgSetOperatorAddressResponse() {
      return {};
    }
    exports2.MsgSetOperatorAddressResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetOperatorAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSetOperatorAddressResponse();
        return message;
      }
    };
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/cosmos/build/stargate/codec/index.js
var require_codec = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/stargate/codec/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultProtoCodec = exports2.ProtoCodec = void 0;
    var msgs_1 = require_msgs();
    var tx_1 = require_tx4();
    var tx_2 = require_tx5();
    var tx_3 = require_tx6();
    var tx_4 = require_tx7();
    var tx_5 = require_tx8();
    var tx_6 = require_tx9();
    var tx_7 = require_tx10();
    var tx_8 = require_tx11();
    var unknown_1 = require_unknown();
    var authz_1 = require_authz();
    var authz_2 = require_authz2();
    var authz_3 = require_authz3();
    var tx_9 = require_tx12();
    var tx_10 = require_tx13();
    var tx_11 = require_tx14();
    var buffer_1 = require_dist();
    __exportStar(require_unknown(), exports2);
    var ProtoCodec = class {
      constructor() {
        this.typeUrlMap = /* @__PURE__ */ new Map();
      }
      unpackAnyFactory(typeUrl) {
        if (!this.typeUrlMap.has(typeUrl)) {
          return void 0;
        }
        return this.typeUrlMap.get(typeUrl);
      }
      /**
       * Unpack the any to the registered message.
       * NOTE: If there is no matched message, it will not throw an error but return the `UnknownMessage` class.
       * @param any
       */
      unpackAny(any) {
        const factory = this.unpackAnyFactory(any.typeUrl);
        if (!factory) {
          return new unknown_1.UnknownMessage(any.typeUrl, any.value);
        }
        const unpacked = factory.decode(any.value);
        return Object.assign(Object.assign({}, any), { unpacked });
      }
      unpackedAnyToJSONRecursive(unpacked) {
        if (unpacked instanceof unknown_1.UnknownMessage) {
          return unpacked.toJSON();
        }
        const factory = this.unpackAnyFactory(unpacked.typeUrl);
        if (factory && "unpacked" in unpacked && unpacked.unpacked) {
          const isJSONEncodedAny = (any) => {
            const r2 = typeof any === "object" && !(any instanceof unknown_1.UnknownMessage) && "typeUrl" in any && any.typeUrl && typeof any.typeUrl === "string" && "value" in any && any.value && typeof any.value === "string";
            if (r2) {
              try {
                buffer_1.Buffer.from(any.value, "base64");
              } catch (_a2) {
                return false;
              }
            }
            return r2;
          };
          const unpackJSONEncodedAnyInner = (jsonEncodedAny) => {
            const factory2 = this.unpackAnyFactory(jsonEncodedAny.typeUrl);
            const bz = buffer_1.Buffer.from(jsonEncodedAny.value, "base64");
            if (!factory2) {
              return new unknown_1.UnknownMessage(jsonEncodedAny.typeUrl, bz).toJSON();
            }
            const unpacked2 = factory2.decode(bz);
            return {
              typeUrl: jsonEncodedAny.typeUrl,
              value: factory2.toJSON(unpacked2)
            };
          };
          const unpackedJSONEncodedAnyRecursive = (obj) => {
            if (Array.isArray(obj)) {
              for (let i = 0; i < obj.length; i++) {
                const value = obj[i];
                if (isJSONEncodedAny(value)) {
                  obj[i] = unpackJSONEncodedAnyInner(value);
                } else if (typeof value === "object") {
                  obj[i] = unpackedJSONEncodedAnyRecursive(value);
                }
              }
            } else {
              for (const key in obj) {
                const value = obj[key];
                if (isJSONEncodedAny(value)) {
                  obj[key] = unpackJSONEncodedAnyInner(value);
                } else if (typeof value === "object") {
                  obj[key] = unpackedJSONEncodedAnyRecursive(value);
                }
              }
            }
            return obj;
          };
          let mutObj = factory.toJSON(unpacked.unpacked);
          if (mutObj && typeof mutObj === "object") {
            mutObj = unpackedJSONEncodedAnyRecursive(mutObj);
            return {
              typeUrl: unpacked.typeUrl,
              value: mutObj
            };
          }
        }
        return new unknown_1.UnknownMessage(unpacked.typeUrl, unpacked.value).toJSON();
      }
      registerAny(typeUrl, message) {
        this.typeUrlMap.set(typeUrl, message);
      }
    };
    exports2.ProtoCodec = ProtoCodec;
    exports2.defaultProtoCodec = new ProtoCodec();
    exports2.defaultProtoCodec.registerAny("/agoric.swingset.MsgWalletSpendAction", msgs_1.MsgWalletSpendAction);
    exports2.defaultProtoCodec.registerAny("/agoric.swingset.MsgProvision", msgs_1.MsgProvision);
    exports2.defaultProtoCodec.registerAny("/cosmos.bank.v1beta1.MsgSend", tx_1.MsgSend);
    exports2.defaultProtoCodec.registerAny("/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgDelegate", tx_2.MsgDelegate);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgUndelegate", tx_2.MsgUndelegate);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_2.MsgBeginRedelegate);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgUnbondValidator", tx_2.MsgUnbondValidator);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation", tx_2.MsgCancelUnbondingDelegation);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgTokenizeShares", tx_2.MsgTokenizeShares);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgRedeemTokensForShares", tx_2.MsgRedeemTokensForShares);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgTransferTokenizeShareRecord", tx_2.MsgTransferTokenizeShareRecord);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgDisableTokenizeShares", tx_2.MsgDisableTokenizeShares);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgEnableTokenizeShares", tx_2.MsgEnableTokenizeShares);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.MsgValidatorBond", tx_2.MsgValidatorBond);
    exports2.defaultProtoCodec.registerAny("/cosmwasm.wasm.v1.MsgExecuteContract", tx_6.MsgExecuteContract);
    exports2.defaultProtoCodec.registerAny("/cosmwasm.wasm.v1.MsgInstantiateContract", tx_6.MsgInstantiateContract);
    exports2.defaultProtoCodec.registerAny("/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_5.MsgWithdrawDelegatorReward);
    exports2.defaultProtoCodec.registerAny("/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_5.MsgSetWithdrawAddress);
    exports2.defaultProtoCodec.registerAny("/ibc.applications.transfer.v1.MsgTransfer", tx_7.MsgTransfer);
    exports2.defaultProtoCodec.registerAny("/ibc.applications.fee.v1.MsgPayPacketFee", tx_8.MsgPayPacketFee);
    exports2.defaultProtoCodec.registerAny("/ibc.applications.fee.v1.MsgPayPacketFeeAsync", tx_8.MsgPayPacketFeeAsync);
    exports2.defaultProtoCodec.registerAny("/ibc.applications.fee.v1.MsgRegisterPayee", tx_8.MsgRegisterPayee);
    exports2.defaultProtoCodec.registerAny("/ibc.applications.fee.v1.MsgRegisterCounterpartyPayee", tx_8.MsgRegisterCounterpartyPayee);
    exports2.defaultProtoCodec.registerAny("/cosmos.gov.v1beta1.MsgVote", tx_4.MsgVote);
    exports2.defaultProtoCodec.registerAny("/cosmos.authz.v1beta1.MsgGrant", tx_3.MsgGrant);
    exports2.defaultProtoCodec.registerAny("/cosmos.authz.v1beta1.GenericAuthorization", authz_1.GenericAuthorization);
    exports2.defaultProtoCodec.registerAny("/cosmos.staking.v1beta1.StakeAuthorization", authz_2.StakeAuthorization);
    exports2.defaultProtoCodec.registerAny("/cosmos.bank.v1beta1.SendAuthorization", authz_3.SendAuthorization);
    exports2.defaultProtoCodec.registerAny("/cosmos.authz.v1beta1.MsgRevoke", tx_3.MsgRevoke);
    exports2.defaultProtoCodec.registerAny("/cosmos.authz.v1beta1.MsgExec", tx_3.MsgExec);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgLiquidStake", tx_9.MsgLiquidStake);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgLSMLiquidStake", tx_9.MsgLSMLiquidStake);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgRedeemStake", tx_9.MsgRedeemStake);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgRegisterHostZone", tx_9.MsgRegisterHostZone);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgClaimUndelegatedTokens", tx_9.MsgClaimUndelegatedTokens);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgRebalanceValidators", tx_9.MsgRebalanceValidators);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgAddValidators", tx_9.MsgAddValidators);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgChangeValidatorWeight", tx_9.MsgChangeValidatorWeight);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgDeleteValidator", tx_9.MsgDeleteValidator);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgRestoreInterchainAccount", tx_9.MsgRestoreInterchainAccount);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgUpdateValidatorSharesExchRate", tx_9.MsgUpdateValidatorSharesExchRate);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgCalibrateDelegation", tx_9.MsgCalibrateDelegation);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgClearBalance", tx_9.MsgClearBalance);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgUndelegateHost", tx_9.MsgUndelegateHost);
    exports2.defaultProtoCodec.registerAny("/stride.stakeibc.MsgUpdateInnerRedemptionRateBounds", tx_9.MsgUpdateInnerRedemptionRateBounds);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgLiquidStake", tx_10.MsgLiquidStake);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgRedeemStake", tx_10.MsgRedeemStake);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgConfirmDelegation", tx_10.MsgConfirmDelegation);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgConfirmUndelegation", tx_10.MsgConfirmUndelegation);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgConfirmUnbondedTokenSweep", tx_10.MsgConfirmUnbondedTokenSweep);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgAdjustDelegatedBalance", tx_10.MsgAdjustDelegatedBalance);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgUpdateInnerRedemptionRateBounds", tx_10.MsgUpdateInnerRedemptionRateBounds);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgResumeHostZone", tx_10.MsgResumeHostZone);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgRefreshRedemptionRate", tx_10.MsgRefreshRedemptionRate);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgOverwriteDelegationRecord", tx_10.MsgOverwriteDelegationRecord);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgOverwriteUnbondingRecord", tx_10.MsgOverwriteUnbondingRecord);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgOverwriteRedemptionRecord", tx_10.MsgOverwriteRedemptionRecord);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgOverwriteRedemptionRecord", tx_10.MsgOverwriteRedemptionRecord);
    exports2.defaultProtoCodec.registerAny("/stride.staketia.MsgSetOperatorAddress", tx_10.MsgSetOperatorAddress);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgLiquidStake", tx_11.MsgLiquidStake);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgRedeemStake", tx_11.MsgRedeemStake);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgConfirmDelegation", tx_11.MsgConfirmDelegation);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgConfirmUndelegation", tx_11.MsgConfirmUndelegation);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgConfirmUnbondedTokenSweep", tx_11.MsgConfirmUnbondedTokenSweep);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgAdjustDelegatedBalance", tx_11.MsgAdjustDelegatedBalance);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgUpdateInnerRedemptionRateBounds", tx_11.MsgUpdateInnerRedemptionRateBounds);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgResumeHostZone", tx_11.MsgResumeHostZone);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgRefreshRedemptionRate", tx_11.MsgRefreshRedemptionRate);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgOverwriteDelegationRecord", tx_11.MsgOverwriteDelegationRecord);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgOverwriteUnbondingRecord", tx_11.MsgOverwriteUnbondingRecord);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgOverwriteRedemptionRecord", tx_11.MsgOverwriteRedemptionRecord);
    exports2.defaultProtoCodec.registerAny("/stride.stakedym.MsgSetOperatorAddress", tx_11.MsgSetOperatorAddress);
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/crypto/multisig/v1beta1/multisig.js
var require_multisig = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/crypto/multisig/v1beta1/multisig.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompactBitArray = exports2.MultiSignature = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports2.protobufPackage = "cosmos.crypto.multisig.v1beta1";
    function createBaseMultiSignature() {
      return { signatures: [] };
    }
    exports2.MultiSignature = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.signatures) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiSignature();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => bytesFromBase642(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => base64FromBytes2(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseMultiSignature();
        message.signatures = ((_a2 = object.signatures) === null || _a2 === void 0 ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseCompactBitArray() {
      return { extraBitsStored: 0, elems: new Uint8Array() };
    }
    exports2.CompactBitArray = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.extraBitsStored !== 0) {
          writer.uint32(8).uint32(message.extraBitsStored);
        }
        if (message.elems.length !== 0) {
          writer.uint32(18).bytes(message.elems);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompactBitArray();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.extraBitsStored = reader.uint32();
              break;
            case 2:
              message.elems = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          extraBitsStored: isSet3(object.extraBitsStored) ? Number(object.extraBitsStored) : 0,
          elems: isSet3(object.elems) ? bytesFromBase642(object.elems) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.extraBitsStored !== void 0 && (obj.extraBitsStored = Math.round(message.extraBitsStored));
        message.elems !== void 0 && (obj.elems = base64FromBytes2(message.elems !== void 0 ? message.elems : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseCompactBitArray();
        message.extraBitsStored = (_a2 = object.extraBitsStored) !== null && _a2 !== void 0 ? _a2 : 0;
        message.elems = (_b = object.elems) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing.js
var require_signing2 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignatureDescriptor_Data_Multi = exports2.SignatureDescriptor_Data_Single = exports2.SignatureDescriptor_Data = exports2.SignatureDescriptor = exports2.SignatureDescriptors = exports2.signModeToJSON = exports2.signModeFromJSON = exports2.SignMode = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    var multisig_1 = require_multisig();
    exports2.protobufPackage = "cosmos.tx.signing.v1beta1";
    var SignMode2;
    (function(SignMode3) {
      SignMode3[SignMode3["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
      SignMode3[SignMode3["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
      SignMode3[SignMode3["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
      SignMode3[SignMode3["SIGN_MODE_DIRECT_AUX"] = 3] = "SIGN_MODE_DIRECT_AUX";
      SignMode3[SignMode3["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
      SignMode3[SignMode3["SIGN_MODE_EIP_191"] = 191] = "SIGN_MODE_EIP_191";
      SignMode3[SignMode3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignMode2 = exports2.SignMode || (exports2.SignMode = {}));
    function signModeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGN_MODE_UNSPECIFIED":
          return SignMode2.SIGN_MODE_UNSPECIFIED;
        case 1:
        case "SIGN_MODE_DIRECT":
          return SignMode2.SIGN_MODE_DIRECT;
        case 2:
        case "SIGN_MODE_TEXTUAL":
          return SignMode2.SIGN_MODE_TEXTUAL;
        case 3:
        case "SIGN_MODE_DIRECT_AUX":
          return SignMode2.SIGN_MODE_DIRECT_AUX;
        case 127:
        case "SIGN_MODE_LEGACY_AMINO_JSON":
          return SignMode2.SIGN_MODE_LEGACY_AMINO_JSON;
        case 191:
        case "SIGN_MODE_EIP_191":
          return SignMode2.SIGN_MODE_EIP_191;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignMode2.UNRECOGNIZED;
      }
    }
    exports2.signModeFromJSON = signModeFromJSON;
    function signModeToJSON(object) {
      switch (object) {
        case SignMode2.SIGN_MODE_UNSPECIFIED:
          return "SIGN_MODE_UNSPECIFIED";
        case SignMode2.SIGN_MODE_DIRECT:
          return "SIGN_MODE_DIRECT";
        case SignMode2.SIGN_MODE_TEXTUAL:
          return "SIGN_MODE_TEXTUAL";
        case SignMode2.SIGN_MODE_DIRECT_AUX:
          return "SIGN_MODE_DIRECT_AUX";
        case SignMode2.SIGN_MODE_LEGACY_AMINO_JSON:
          return "SIGN_MODE_LEGACY_AMINO_JSON";
        case SignMode2.SIGN_MODE_EIP_191:
          return "SIGN_MODE_EIP_191";
        default:
          return "UNKNOWN";
      }
    }
    exports2.signModeToJSON = signModeToJSON;
    function createBaseSignatureDescriptors() {
      return { signatures: [] };
    }
    exports2.SignatureDescriptors = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.signatures) {
          exports2.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptors();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(exports2.SignatureDescriptor.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => exports2.SignatureDescriptor.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports2.SignatureDescriptor.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSignatureDescriptors();
        message.signatures = ((_a2 = object.signatures) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.SignatureDescriptor.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSignatureDescriptor() {
      return { publicKey: void 0, data: void 0, sequence: "0" };
    }
    exports2.SignatureDescriptor = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          exports2.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== "0") {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = exports2.SignatureDescriptor_Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          publicKey: isSet3(object.publicKey) ? any_1.Any.fromJSON(object.publicKey) : void 0,
          data: isSet3(object.data) ? exports2.SignatureDescriptor_Data.fromJSON(object.data) : void 0,
          sequence: isSet3(object.sequence) ? String(object.sequence) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.data !== void 0 && (obj.data = message.data ? exports2.SignatureDescriptor_Data.toJSON(message.data) : void 0);
        message.sequence !== void 0 && (obj.sequence = message.sequence);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSignatureDescriptor();
        message.publicKey = object.publicKey !== void 0 && object.publicKey !== null ? any_1.Any.fromPartial(object.publicKey) : void 0;
        message.data = object.data !== void 0 && object.data !== null ? exports2.SignatureDescriptor_Data.fromPartial(object.data) : void 0;
        message.sequence = (_a2 = object.sequence) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data() {
      return { single: void 0, multi: void 0 };
    }
    exports2.SignatureDescriptor_Data = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.single !== void 0) {
          exports2.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports2.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports2.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports2.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          single: isSet3(object.single) ? exports2.SignatureDescriptor_Data_Single.fromJSON(object.single) : void 0,
          multi: isSet3(object.multi) ? exports2.SignatureDescriptor_Data_Multi.fromJSON(object.multi) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports2.SignatureDescriptor_Data_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports2.SignatureDescriptor_Data_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data();
        message.single = object.single !== void 0 && object.single !== null ? exports2.SignatureDescriptor_Data_Single.fromPartial(object.single) : void 0;
        message.multi = object.multi !== void 0 && object.multi !== null ? exports2.SignatureDescriptor_Data_Multi.fromPartial(object.multi) : void 0;
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Single() {
      return { mode: 0, signature: new Uint8Array() };
    }
    exports2.SignatureDescriptor_Data_Single = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        if (message.signature.length !== 0) {
          writer.uint32(18).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            case 2:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          mode: isSet3(object.mode) ? signModeFromJSON(object.mode) : 0,
          signature: isSet3(object.signature) ? bytesFromBase642(object.signature) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = signModeToJSON(message.mode));
        message.signature !== void 0 && (obj.signature = base64FromBytes2(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b;
        const message = createBaseSignatureDescriptor_Data_Single();
        message.mode = (_a2 = object.mode) !== null && _a2 !== void 0 ? _a2 : 0;
        message.signature = (_b = object.signature) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Multi() {
      return { bitarray: void 0, signatures: [] };
    }
    exports2.SignatureDescriptor_Data_Multi = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports2.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.signatures.push(exports2.SignatureDescriptor_Data.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          bitarray: isSet3(object.bitarray) ? multisig_1.CompactBitArray.fromJSON(object.bitarray) : void 0,
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => exports2.SignatureDescriptor_Data.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports2.SignatureDescriptor_Data.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSignatureDescriptor_Data_Multi();
        message.bitarray = object.bitarray !== void 0 && object.bitarray !== null ? multisig_1.CompactBitArray.fromPartial(object.bitarray) : void 0;
        message.signatures = ((_a2 = object.signatures) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.SignatureDescriptor_Data.fromPartial(e))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx.js
var require_tx15 = __commonJS({
  "node_modules/@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuxSignerData = exports2.Fee = exports2.ModeInfo_Multi = exports2.ModeInfo_Single = exports2.ModeInfo = exports2.SignerInfo = exports2.AuthInfo = exports2.TxBody = exports2.SignDocDirectAux = exports2.SignDoc = exports2.TxRaw = exports2.Tx = exports2.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var signing_1 = require_signing2();
    var any_1 = require_any();
    var multisig_1 = require_multisig();
    var coin_1 = require_coin2();
    exports2.protobufPackage = "cosmos.tx.v1beta1";
    function createBaseTx() {
      return { body: void 0, authInfo: void 0, signatures: [] };
    }
    exports2.Tx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.body !== void 0) {
          exports2.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();
        }
        if (message.authInfo !== void 0) {
          exports2.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.body = exports2.TxBody.decode(reader, reader.uint32());
              break;
            case 2:
              message.authInfo = exports2.AuthInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          body: isSet3(object.body) ? exports2.TxBody.fromJSON(object.body) : void 0,
          authInfo: isSet3(object.authInfo) ? exports2.AuthInfo.fromJSON(object.authInfo) : void 0,
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => bytesFromBase642(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.body !== void 0 && (obj.body = message.body ? exports2.TxBody.toJSON(message.body) : void 0);
        message.authInfo !== void 0 && (obj.authInfo = message.authInfo ? exports2.AuthInfo.toJSON(message.authInfo) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => base64FromBytes2(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseTx();
        message.body = object.body !== void 0 && object.body !== null ? exports2.TxBody.fromPartial(object.body) : void 0;
        message.authInfo = object.authInfo !== void 0 && object.authInfo !== null ? exports2.AuthInfo.fromPartial(object.authInfo) : void 0;
        message.signatures = ((_a2 = object.signatures) === null || _a2 === void 0 ? void 0 : _a2.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseTxRaw() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        signatures: []
      };
    }
    exports2.TxRaw = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxRaw();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          bodyBytes: isSet3(object.bodyBytes) ? bytesFromBase642(object.bodyBytes) : new Uint8Array(),
          authInfoBytes: isSet3(object.authInfoBytes) ? bytesFromBase642(object.authInfoBytes) : new Uint8Array(),
          signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e) => bytesFromBase642(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = base64FromBytes2(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = base64FromBytes2(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => base64FromBytes2(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseTxRaw();
        message.bodyBytes = (_a2 = object.bodyBytes) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.signatures = ((_c = object.signatures) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseSignDoc() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        chainId: "",
        accountNumber: "0"
      };
    }
    exports2.SignDoc = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== "0") {
          writer.uint32(32).uint64(message.accountNumber);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDoc();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          bodyBytes: isSet3(object.bodyBytes) ? bytesFromBase642(object.bodyBytes) : new Uint8Array(),
          authInfoBytes: isSet3(object.authInfoBytes) ? bytesFromBase642(object.authInfoBytes) : new Uint8Array(),
          chainId: isSet3(object.chainId) ? String(object.chainId) : "",
          accountNumber: isSet3(object.accountNumber) ? String(object.accountNumber) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = base64FromBytes2(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = base64FromBytes2(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = message.accountNumber);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseSignDoc();
        message.bodyBytes = (_a2 = object.bodyBytes) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.chainId = (_c = object.chainId) !== null && _c !== void 0 ? _c : "";
        message.accountNumber = (_d = object.accountNumber) !== null && _d !== void 0 ? _d : "0";
        return message;
      }
    };
    function createBaseSignDocDirectAux() {
      return {
        bodyBytes: new Uint8Array(),
        publicKey: void 0,
        chainId: "",
        accountNumber: "0",
        sequence: "0"
      };
    }
    exports2.SignDocDirectAux = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== "0") {
          writer.uint32(32).uint64(message.accountNumber);
        }
        if (message.sequence !== "0") {
          writer.uint32(40).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDocDirectAux();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = longToString(reader.uint64());
              break;
            case 5:
              message.sequence = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          bodyBytes: isSet3(object.bodyBytes) ? bytesFromBase642(object.bodyBytes) : new Uint8Array(),
          publicKey: isSet3(object.publicKey) ? any_1.Any.fromJSON(object.publicKey) : void 0,
          chainId: isSet3(object.chainId) ? String(object.chainId) : "",
          accountNumber: isSet3(object.accountNumber) ? String(object.accountNumber) : "0",
          sequence: isSet3(object.sequence) ? String(object.sequence) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = base64FromBytes2(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = message.accountNumber);
        message.sequence !== void 0 && (obj.sequence = message.sequence);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseSignDocDirectAux();
        message.bodyBytes = (_a2 = object.bodyBytes) !== null && _a2 !== void 0 ? _a2 : new Uint8Array();
        message.publicKey = object.publicKey !== void 0 && object.publicKey !== null ? any_1.Any.fromPartial(object.publicKey) : void 0;
        message.chainId = (_b = object.chainId) !== null && _b !== void 0 ? _b : "";
        message.accountNumber = (_c = object.accountNumber) !== null && _c !== void 0 ? _c : "0";
        message.sequence = (_d = object.sequence) !== null && _d !== void 0 ? _d : "0";
        return message;
      }
    };
    function createBaseTxBody() {
      return {
        messages: [],
        memo: "",
        timeoutHeight: "0",
        extensionOptions: [],
        nonCriticalExtensionOptions: []
      };
    }
    exports2.TxBody = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.memo !== "") {
          writer.uint32(18).string(message.memo);
        }
        if (message.timeoutHeight !== "0") {
          writer.uint32(24).uint64(message.timeoutHeight);
        }
        for (const v of message.extensionOptions) {
          any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();
        }
        for (const v of message.nonCriticalExtensionOptions) {
          any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxBody();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.memo = reader.string();
              break;
            case 3:
              message.timeoutHeight = longToString(reader.uint64());
              break;
            case 1023:
              message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2047:
              message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages) ? object.messages.map((e) => any_1.Any.fromJSON(e)) : [],
          memo: isSet3(object.memo) ? String(object.memo) : "",
          timeoutHeight: isSet3(object.timeoutHeight) ? String(object.timeoutHeight) : "0",
          extensionOptions: Array.isArray(object === null || object === void 0 ? void 0 : object.extensionOptions) ? object.extensionOptions.map((e) => any_1.Any.fromJSON(e)) : [],
          nonCriticalExtensionOptions: Array.isArray(object === null || object === void 0 ? void 0 : object.nonCriticalExtensionOptions) ? object.nonCriticalExtensionOptions.map((e) => any_1.Any.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.memo !== void 0 && (obj.memo = message.memo);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight);
        if (message.extensionOptions) {
          obj.extensionOptions = message.extensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.extensionOptions = [];
        }
        if (message.nonCriticalExtensionOptions) {
          obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.nonCriticalExtensionOptions = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d, _e;
        const message = createBaseTxBody();
        message.messages = ((_a2 = object.messages) === null || _a2 === void 0 ? void 0 : _a2.map((e) => any_1.Any.fromPartial(e))) || [];
        message.memo = (_b = object.memo) !== null && _b !== void 0 ? _b : "";
        message.timeoutHeight = (_c = object.timeoutHeight) !== null && _c !== void 0 ? _c : "0";
        message.extensionOptions = ((_d = object.extensionOptions) === null || _d === void 0 ? void 0 : _d.map((e) => any_1.Any.fromPartial(e))) || [];
        message.nonCriticalExtensionOptions = ((_e = object.nonCriticalExtensionOptions) === null || _e === void 0 ? void 0 : _e.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseAuthInfo() {
      return { signerInfos: [], fee: void 0 };
    }
    exports2.AuthInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.signerInfos) {
          exports2.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.fee !== void 0) {
          exports2.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuthInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signerInfos.push(exports2.SignerInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.fee = exports2.Fee.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          signerInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.signerInfos) ? object.signerInfos.map((e) => exports2.SignerInfo.fromJSON(e)) : [],
          fee: isSet3(object.fee) ? exports2.Fee.fromJSON(object.fee) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signerInfos) {
          obj.signerInfos = message.signerInfos.map((e) => e ? exports2.SignerInfo.toJSON(e) : void 0);
        } else {
          obj.signerInfos = [];
        }
        message.fee !== void 0 && (obj.fee = message.fee ? exports2.Fee.toJSON(message.fee) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseAuthInfo();
        message.signerInfos = ((_a2 = object.signerInfos) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.SignerInfo.fromPartial(e))) || [];
        message.fee = object.fee !== void 0 && object.fee !== null ? exports2.Fee.fromPartial(object.fee) : void 0;
        return message;
      }
    };
    function createBaseSignerInfo() {
      return { publicKey: void 0, modeInfo: void 0, sequence: "0" };
    }
    exports2.SignerInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.modeInfo !== void 0) {
          exports2.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== "0") {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignerInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfo = exports2.ModeInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = longToString(reader.uint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          publicKey: isSet3(object.publicKey) ? any_1.Any.fromJSON(object.publicKey) : void 0,
          modeInfo: isSet3(object.modeInfo) ? exports2.ModeInfo.fromJSON(object.modeInfo) : void 0,
          sequence: isSet3(object.sequence) ? String(object.sequence) : "0"
        };
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.modeInfo !== void 0 && (obj.modeInfo = message.modeInfo ? exports2.ModeInfo.toJSON(message.modeInfo) : void 0);
        message.sequence !== void 0 && (obj.sequence = message.sequence);
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseSignerInfo();
        message.publicKey = object.publicKey !== void 0 && object.publicKey !== null ? any_1.Any.fromPartial(object.publicKey) : void 0;
        message.modeInfo = object.modeInfo !== void 0 && object.modeInfo !== null ? exports2.ModeInfo.fromPartial(object.modeInfo) : void 0;
        message.sequence = (_a2 = object.sequence) !== null && _a2 !== void 0 ? _a2 : "0";
        return message;
      }
    };
    function createBaseModeInfo() {
      return { single: void 0, multi: void 0 };
    }
    exports2.ModeInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.single !== void 0) {
          exports2.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports2.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports2.ModeInfo_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports2.ModeInfo_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          single: isSet3(object.single) ? exports2.ModeInfo_Single.fromJSON(object.single) : void 0,
          multi: isSet3(object.multi) ? exports2.ModeInfo_Multi.fromJSON(object.multi) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports2.ModeInfo_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports2.ModeInfo_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo();
        message.single = object.single !== void 0 && object.single !== null ? exports2.ModeInfo_Single.fromPartial(object.single) : void 0;
        message.multi = object.multi !== void 0 && object.multi !== null ? exports2.ModeInfo_Multi.fromPartial(object.multi) : void 0;
        return message;
      }
    };
    function createBaseModeInfo_Single() {
      return { mode: 0 };
    }
    exports2.ModeInfo_Single = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          mode: isSet3(object.mode) ? (0, signing_1.signModeFromJSON)(object.mode) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseModeInfo_Single();
        message.mode = (_a2 = object.mode) !== null && _a2 !== void 0 ? _a2 : 0;
        return message;
      }
    };
    function createBaseModeInfo_Multi() {
      return { bitarray: void 0, modeInfos: [] };
    }
    exports2.ModeInfo_Multi = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.modeInfos) {
          exports2.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfos.push(exports2.ModeInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          bitarray: isSet3(object.bitarray) ? multisig_1.CompactBitArray.fromJSON(object.bitarray) : void 0,
          modeInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.modeInfos) ? object.modeInfos.map((e) => exports2.ModeInfo.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.modeInfos) {
          obj.modeInfos = message.modeInfos.map((e) => e ? exports2.ModeInfo.toJSON(e) : void 0);
        } else {
          obj.modeInfos = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a2;
        const message = createBaseModeInfo_Multi();
        message.bitarray = object.bitarray !== void 0 && object.bitarray !== null ? multisig_1.CompactBitArray.fromPartial(object.bitarray) : void 0;
        message.modeInfos = ((_a2 = object.modeInfos) === null || _a2 === void 0 ? void 0 : _a2.map((e) => exports2.ModeInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseFee() {
      return { amount: [], gasLimit: "0", payer: "", granter: "" };
    }
    exports2.Fee = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.gasLimit !== "0") {
          writer.uint32(16).uint64(message.gasLimit);
        }
        if (message.payer !== "") {
          writer.uint32(26).string(message.payer);
        }
        if (message.granter !== "") {
          writer.uint32(34).string(message.granter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.gasLimit = longToString(reader.uint64());
              break;
            case 3:
              message.payer = reader.string();
              break;
            case 4:
              message.granter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount) ? object.amount.map((e) => coin_1.Coin.fromJSON(e)) : [],
          gasLimit: isSet3(object.gasLimit) ? String(object.gasLimit) : "0",
          payer: isSet3(object.payer) ? String(object.payer) : "",
          granter: isSet3(object.granter) ? String(object.granter) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.gasLimit !== void 0 && (obj.gasLimit = message.gasLimit);
        message.payer !== void 0 && (obj.payer = message.payer);
        message.granter !== void 0 && (obj.granter = message.granter);
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c, _d;
        const message = createBaseFee();
        message.amount = ((_a2 = object.amount) === null || _a2 === void 0 ? void 0 : _a2.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.gasLimit = (_b = object.gasLimit) !== null && _b !== void 0 ? _b : "0";
        message.payer = (_c = object.payer) !== null && _c !== void 0 ? _c : "";
        message.granter = (_d = object.granter) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    function createBaseAuxSignerData() {
      return { address: "", signDoc: void 0, mode: 0, sig: new Uint8Array() };
    }
    exports2.AuxSignerData = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.signDoc !== void 0) {
          exports2.SignDocDirectAux.encode(message.signDoc, writer.uint32(18).fork()).ldelim();
        }
        if (message.mode !== 0) {
          writer.uint32(24).int32(message.mode);
        }
        if (message.sig.length !== 0) {
          writer.uint32(34).bytes(message.sig);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuxSignerData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.signDoc = exports2.SignDocDirectAux.decode(reader, reader.uint32());
              break;
            case 3:
              message.mode = reader.int32();
              break;
            case 4:
              message.sig = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        return {
          address: isSet3(object.address) ? String(object.address) : "",
          signDoc: isSet3(object.signDoc) ? exports2.SignDocDirectAux.fromJSON(object.signDoc) : void 0,
          mode: isSet3(object.mode) ? (0, signing_1.signModeFromJSON)(object.mode) : 0,
          sig: isSet3(object.sig) ? bytesFromBase642(object.sig) : new Uint8Array()
        };
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.signDoc !== void 0 && (obj.signDoc = message.signDoc ? exports2.SignDocDirectAux.toJSON(message.signDoc) : void 0);
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        message.sig !== void 0 && (obj.sig = base64FromBytes2(message.sig !== void 0 ? message.sig : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a2, _b, _c;
        const message = createBaseAuxSignerData();
        message.address = (_a2 = object.address) !== null && _a2 !== void 0 ? _a2 : "";
        message.signDoc = object.signDoc !== void 0 && object.signDoc !== null ? exports2.SignDocDirectAux.fromPartial(object.signDoc) : void 0;
        message.mode = (_b = object.mode) !== null && _b !== void 0 ? _b : 0;
        message.sig = (_c = object.sig) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase642(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes2(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa2(bin.join(""));
    }
    function longToString(long) {
      return long.toString();
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
    function isSet3(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@keplr-wallet/common/build/kv-store/interface.js
var require_interface = __commonJS({
  "node_modules/@keplr-wallet/common/build/kv-store/interface.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@keplr-wallet/common/build/kv-store/base.js
var require_base2 = __commonJS({
  "node_modules/@keplr-wallet/common/build/kv-store/base.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseKVStore = void 0;
    var BaseKVStore = class {
      constructor(provider2, _prefix) {
        this.provider = provider2;
        this._prefix = _prefix;
      }
      get(key) {
        return __awaiter2(this, void 0, void 0, function* () {
          const k = this.prefix() + "/" + key;
          const data = yield this.provider.get(k);
          return data[k];
        });
      }
      set(key, data) {
        const k = this.prefix() + "/" + key;
        return this.provider.set({ [k]: data });
      }
      prefix() {
        return this._prefix;
      }
    };
    exports2.BaseKVStore = BaseKVStore;
  }
});

// node_modules/@keplr-wallet/common/build/kv-store/extension.js
var require_extension = __commonJS({
  "node_modules/@keplr-wallet/common/build/kv-store/extension.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtensionKVStore = void 0;
    var base_1 = require_base2();
    var ExtensionKVStore = class _ExtensionKVStore extends base_1.BaseKVStore {
      constructor(prefix) {
        if (!_ExtensionKVStore.KVStoreProvider) {
          if (typeof browser === "undefined") {
            console.log("You should use ExtensionKVStore on the extension environment.");
          } else if (!browser.storage || !browser.storage.local) {
            console.log("The 'browser' exists, but it doesn't seem to be an extension environment. This can happen in Safari browser.");
          } else {
            _ExtensionKVStore.KVStoreProvider = {
              get: browser.storage.local.get,
              set: browser.storage.local.set,
              multiGet: browser.storage.local.get
            };
          }
        }
        if (!_ExtensionKVStore.KVStoreProvider) {
          throw new Error("Can't initialize kv store for browser extension");
        }
        super(_ExtensionKVStore.KVStoreProvider, prefix);
      }
      multiGet(keys) {
        var _a2;
        return __awaiter2(this, void 0, void 0, function* () {
          keys = Array.from(new Set(keys));
          const res = (_a2 = yield _ExtensionKVStore.KVStoreProvider.multiGet(keys.map((k) => this.prefix() + "/" + k))) !== null && _a2 !== void 0 ? _a2 : {};
          const prefixedKeys = Object.keys(res);
          for (const prefixedKey of prefixedKeys) {
            const key = prefixedKey.slice(this.prefix().length + 1);
            res[key] = res[prefixedKey];
            delete res[prefixedKey];
          }
          return res;
        });
      }
    };
    exports2.ExtensionKVStore = ExtensionKVStore;
  }
});

// node_modules/@keplr-wallet/common/build/kv-store/memory.js
var require_memory = __commonJS({
  "node_modules/@keplr-wallet/common/build/kv-store/memory.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MemoryKVStore = void 0;
    var base_1 = require_base2();
    var MemoryKVStoreProvider = class {
      constructor() {
        this.store = {};
      }
      get(key) {
        return Promise.resolve({
          [key]: this.store[key]
        });
      }
      set(items) {
        if (typeof process !== "undefined" && (process.env["NODE_ENV"] === "test" || process.env["NODE_ENV"] === "development")) {
          this.checkNotPrimitiveField(items);
        }
        this.store = Object.assign(Object.assign({}, this.store), items);
        return Promise.resolve();
      }
      checkNotPrimitiveField(items) {
        Object.keys(items).forEach((key) => {
          const value = items[key];
          if (value != null && typeof value === "object") {
            if (value.constructor !== Object && value.constructor !== Array) {
              throw new Error(`${key} may not be serializable: ${value.constructor.name}`);
            }
            this.checkNotPrimitiveField(value);
          }
        });
      }
    };
    var MemoryKVStore = class extends base_1.BaseKVStore {
      constructor(prefix) {
        super(new MemoryKVStoreProvider(), prefix);
      }
    };
    exports2.MemoryKVStore = MemoryKVStore;
  }
});

// node_modules/@keplr-wallet/common/build/kv-store/local.js
var require_local = __commonJS({
  "node_modules/@keplr-wallet/common/build/kv-store/local.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LocalKVStore = void 0;
    var LocalKVStore = class {
      constructor(_prefix) {
        this._prefix = _prefix;
      }
      get(key) {
        const k = this.prefix() + "/" + key;
        const data = localStorage.getItem(k);
        if (data === null) {
          return Promise.resolve(void 0);
        }
        return Promise.resolve(JSON.parse(data));
      }
      set(key, data) {
        const k = this.prefix() + "/" + key;
        if (data === null) {
          return Promise.resolve(localStorage.removeItem(k));
        }
        return Promise.resolve(localStorage.setItem(k, JSON.stringify(data)));
      }
      prefix() {
        return this._prefix;
      }
    };
    exports2.LocalKVStore = LocalKVStore;
  }
});

// node_modules/@keplr-wallet/common/build/kv-store/indexed-db.js
var require_indexed_db = __commonJS({
  "node_modules/@keplr-wallet/common/build/kv-store/indexed-db.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IndexedDBKVStore = void 0;
    var IndexedDBKVStore = class {
      constructor(_prefix) {
        this._prefix = _prefix;
      }
      get(key) {
        return __awaiter2(this, void 0, void 0, function* () {
          const tx = (yield this.getDB()).transaction([this.prefix()], "readonly");
          const store = tx.objectStore(this.prefix());
          return new Promise((resolve, reject) => {
            const request = store.get(key);
            request.onerror = (event) => {
              event.stopPropagation();
              reject(event.target);
            };
            request.onsuccess = () => {
              if (!request.result) {
                resolve(void 0);
              } else {
                resolve(request.result.data);
              }
            };
          });
        });
      }
      set(key, data) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (data === null) {
            const tx = (yield this.getDB()).transaction([this.prefix()], "readwrite");
            const store = tx.objectStore(this.prefix());
            return new Promise((resolve, reject) => {
              const request = store.delete(key);
              request.onerror = (event) => {
                event.stopPropagation();
                reject(event.target);
              };
              request.onsuccess = () => {
                resolve();
              };
            });
          } else {
            const tx = (yield this.getDB()).transaction([this.prefix()], "readwrite");
            const store = tx.objectStore(this.prefix());
            return new Promise((resolve, reject) => {
              const request = store.put({
                key,
                data
              });
              request.onerror = (event) => {
                event.stopPropagation();
                reject(event.target);
              };
              request.onsuccess = () => {
                resolve();
              };
            });
          }
        });
      }
      prefix() {
        return this._prefix;
      }
      getDB() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this.cachedDB) {
            return this.cachedDB;
          }
          return new Promise((resolve, reject) => {
            const request = window.indexedDB.open(this.prefix());
            request.onerror = (event) => {
              event.stopPropagation();
              reject(event.target);
            };
            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              db.createObjectStore(this.prefix(), { keyPath: "key" });
            };
            request.onsuccess = () => {
              this.cachedDB = request.result;
              resolve(request.result);
            };
          });
        });
      }
    };
    exports2.IndexedDBKVStore = IndexedDBKVStore;
  }
});

// node_modules/@keplr-wallet/common/build/kv-store/prefix.js
var require_prefix = __commonJS({
  "node_modules/@keplr-wallet/common/build/kv-store/prefix.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrefixKVStore = void 0;
    var PrefixKVStore = class {
      constructor(kvStore, _prefix) {
        this.kvStore = kvStore;
        this._prefix = _prefix;
      }
      prefix() {
        return this._prefix;
      }
      get(key) {
        return __awaiter2(this, void 0, void 0, function* () {
          const k = this.prefix() + "/" + key;
          return yield this.kvStore.get(k);
        });
      }
      set(key, data) {
        return __awaiter2(this, void 0, void 0, function* () {
          const k = this.prefix() + "/" + key;
          return yield this.kvStore.set(k, data);
        });
      }
    };
    exports2.PrefixKVStore = PrefixKVStore;
  }
});

// node_modules/@keplr-wallet/common/build/kv-store/multi-get.js
var require_multi_get = __commonJS({
  "node_modules/@keplr-wallet/common/build/kv-store/multi-get.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WrapMultiGetKVStore = void 0;
    var WrapMultiGetKVStore = class {
      constructor(kvStore) {
        this.kvStore = kvStore;
      }
      multiGet(keys) {
        return __awaiter2(this, void 0, void 0, function* () {
          keys = Array.from(new Set(keys));
          const res = {};
          const promises = [];
          for (const key of keys) {
            promises.push((() => __awaiter2(this, void 0, void 0, function* () {
              res[key] = yield this.kvStore.get(key);
            }))());
          }
          yield Promise.all(promises);
          return res;
        });
      }
    };
    exports2.WrapMultiGetKVStore = WrapMultiGetKVStore;
  }
});

// node_modules/@keplr-wallet/common/build/kv-store/index.js
var require_kv_store = __commonJS({
  "node_modules/@keplr-wallet/common/build/kv-store/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_interface(), exports2);
    __exportStar(require_extension(), exports2);
    __exportStar(require_base2(), exports2);
    __exportStar(require_memory(), exports2);
    __exportStar(require_local(), exports2);
    __exportStar(require_indexed_db(), exports2);
    __exportStar(require_prefix(), exports2);
    __exportStar(require_multi_get(), exports2);
  }
});

// node_modules/@keplr-wallet/common/build/denom/index.js
var require_denom = __commonJS({
  "node_modules/@keplr-wallet/common/build/denom/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DenomHelper = void 0;
    var buffer_1 = require_dist();
    var crypto_1 = require_build10();
    var DenomHelper = class {
      static ibcDenom(paths, coinMinimalDenom) {
        const prefixes = [];
        for (const path of paths) {
          prefixes.push(`${path.portId}/${path.channelId}`);
        }
        const prefix = prefixes.join("/");
        const denom = `${prefix}/${coinMinimalDenom}`;
        return "ibc/" + buffer_1.Buffer.from(crypto_1.Hash.sha256(buffer_1.Buffer.from(denom))).toString("hex").toUpperCase();
      }
      constructor(_denom) {
        this._denom = _denom;
        let split2 = this.denom.split(/^(\w+):(\w+)$/).filter(Boolean);
        if (split2.length !== 2) {
          split2 = this.denom.split(/^(\w+):(\w+):(.+)$/).filter(Boolean);
          if (split2.length !== 1 && split2.length !== 3) {
            throw new Error(`Invalid denom: ${this.denom}`);
          }
        }
        this._type = split2.length >= 2 ? split2[0] : "";
        this._contractAddress = split2.length >= 2 ? split2[1] : "";
      }
      get denom() {
        return this._denom;
      }
      get type() {
        return this._type || "native";
      }
      get contractAddress() {
        return this._contractAddress;
      }
    };
    exports2.DenomHelper = DenomHelper;
  }
});

// node_modules/@keplr-wallet/common/build/mobx/etc.js
var require_etc2 = __commonJS({
  "node_modules/@keplr-wallet/common/build/mobx/etc.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toGenerator = void 0;
    function* toGenerator(p) {
      return yield p;
    }
    exports2.toGenerator = toGenerator;
  }
});

// node_modules/@keplr-wallet/common/build/mobx/index.js
var require_mobx = __commonJS({
  "node_modules/@keplr-wallet/common/build/mobx/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_etc2(), exports2);
  }
});

// node_modules/@keplr-wallet/common/build/utils/debouncer.js
var require_debouncer = __commonJS({
  "node_modules/@keplr-wallet/common/build/utils/debouncer.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Debouncer = void 0;
    var Debouncer = class {
      static promise(fn) {
        let currentPromise;
        return (...arguments_) => __awaiter2(this, void 0, void 0, function* () {
          if (currentPromise) {
            return currentPromise;
          }
          try {
            currentPromise = fn.apply(this, arguments_);
            return yield currentPromise;
          } finally {
            currentPromise = void 0;
          }
        });
      }
    };
    exports2.Debouncer = Debouncer;
  }
});

// node_modules/@keplr-wallet/common/build/utils/index.js
var require_utils9 = __commonJS({
  "node_modules/@keplr-wallet/common/build/utils/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_debouncer(), exports2);
  }
});

// node_modules/@keplr-wallet/common/build/escape/index.js
var require_escape = __commonJS({
  "node_modules/@keplr-wallet/common/build/escape/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescapeHTML = exports2.escapeHTML = void 0;
    function escapeHTML(str) {
      return str.replace(/</g, "\\u003c").replace(/>/g, "\\u003e").replace(/&/g, "\\u0026");
    }
    exports2.escapeHTML = escapeHTML;
    function unescapeHTML(str) {
      return str.replace(/\\u003c/g, "<").replace(/\\u003e/g, ">").replace(/\\u0026/g, "&");
    }
    exports2.unescapeHTML = unescapeHTML;
  }
});

// node_modules/@keplr-wallet/common/build/json/sort.js
var require_sort = __commonJS({
  "node_modules/@keplr-wallet/common/build/json/sort.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sortedJsonByKeyStringify = exports2.sortObjectByKey = void 0;
    function sortObjectByKey(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(sortObjectByKey);
      }
      const sortedKeys = Object.keys(obj).sort();
      const result2 = {};
      sortedKeys.forEach((key) => {
        result2[key] = sortObjectByKey(obj[key]);
      });
      return result2;
    }
    exports2.sortObjectByKey = sortObjectByKey;
    function sortedJsonByKeyStringify(obj) {
      return JSON.stringify(sortObjectByKey(obj));
    }
    exports2.sortedJsonByKeyStringify = sortedJsonByKeyStringify;
  }
});

// node_modules/@keplr-wallet/common/build/json/index.js
var require_json = __commonJS({
  "node_modules/@keplr-wallet/common/build/json/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_sort(), exports2);
  }
});

// node_modules/@keplr-wallet/common/build/icns/index.js
var require_icns = __commonJS({
  "node_modules/@keplr-wallet/common/build/icns/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateICNSName = exports2.parseICNSName = void 0;
    function parseICNSName(name) {
      const split2 = name.split(".");
      if (split2.length === 2) {
        if (split2[0].length > 0 && split2[1].length > 0) {
          return [split2[0], split2[1]];
        }
      }
      return void 0;
    }
    exports2.parseICNSName = parseICNSName;
    function validateICNSName(name, bech32Prefix) {
      const parsed = parseICNSName(name);
      if (!parsed) {
        return false;
      }
      return parsed[1] === bech32Prefix;
    }
    exports2.validateICNSName = validateICNSName;
  }
});

// node_modules/@keplr-wallet/common/build/sleep/index.js
var require_sleep = __commonJS({
  "node_modules/@keplr-wallet/common/build/sleep/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sleep = void 0;
    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    exports2.sleep = sleep;
  }
});

// node_modules/@keplr-wallet/common/build/retry/index.js
var require_retry = __commonJS({
  "node_modules/@keplr-wallet/common/build/retry/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retryInfinite = exports2.retry = void 0;
    var sleep_1 = require_sleep();
    function retry(task, opts) {
      return __awaiter2(this, void 0, void 0, function* () {
        let retries = 0;
        while (true) {
          try {
            const promise = task();
            return yield promise;
          } catch (e) {
            if (retries >= opts.maxRetries) {
              throw e;
            }
            if (opts.onFailed) {
              opts.onFailed(e);
            }
            let waitMs = opts.waitMsAfterError || 0;
            if (waitMs > 0) {
              if (opts.maxWaitMsAfterError != null && opts.maxWaitMsAfterError > 0) {
                waitMs = Math.pow(2, retries) * waitMs;
                waitMs = Math.min(waitMs, opts.maxWaitMsAfterError);
              }
              yield (0, sleep_1.sleep)(waitMs);
            }
            retries++;
          }
        }
      });
    }
    exports2.retry = retry;
    function retryInfinite(task, opts) {
      return retry(task, Object.assign(Object.assign({}, opts), { maxRetries: Number.MAX_SAFE_INTEGER }));
    }
    exports2.retryInfinite = retryInfinite;
  }
});

// node_modules/@keplr-wallet/common/build/mnemonic/index.js
var require_mnemonic2 = __commonJS({
  "node_modules/@keplr-wallet/common/build/mnemonic/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMnemonicWord = void 0;
    function isMnemonicWord(word) {
      return !!wordlist[word];
    }
    exports2.isMnemonicWord = isMnemonicWord;
    var wordlist = {
      abandon: true,
      ability: true,
      able: true,
      about: true,
      above: true,
      absent: true,
      absorb: true,
      abstract: true,
      absurd: true,
      abuse: true,
      access: true,
      accident: true,
      account: true,
      accuse: true,
      achieve: true,
      acid: true,
      acoustic: true,
      acquire: true,
      across: true,
      act: true,
      action: true,
      actor: true,
      actress: true,
      actual: true,
      adapt: true,
      add: true,
      addict: true,
      address: true,
      adjust: true,
      admit: true,
      adult: true,
      advance: true,
      advice: true,
      aerobic: true,
      affair: true,
      afford: true,
      afraid: true,
      again: true,
      age: true,
      agent: true,
      agree: true,
      ahead: true,
      aim: true,
      air: true,
      airport: true,
      aisle: true,
      alarm: true,
      album: true,
      alcohol: true,
      alert: true,
      alien: true,
      all: true,
      alley: true,
      allow: true,
      almost: true,
      alone: true,
      alpha: true,
      already: true,
      also: true,
      alter: true,
      always: true,
      amateur: true,
      amazing: true,
      among: true,
      amount: true,
      amused: true,
      analyst: true,
      anchor: true,
      ancient: true,
      anger: true,
      angle: true,
      angry: true,
      animal: true,
      ankle: true,
      announce: true,
      annual: true,
      another: true,
      answer: true,
      antenna: true,
      antique: true,
      anxiety: true,
      any: true,
      apart: true,
      apology: true,
      appear: true,
      apple: true,
      approve: true,
      april: true,
      arch: true,
      arctic: true,
      area: true,
      arena: true,
      argue: true,
      arm: true,
      armed: true,
      armor: true,
      army: true,
      around: true,
      arrange: true,
      arrest: true,
      arrive: true,
      arrow: true,
      art: true,
      artefact: true,
      artist: true,
      artwork: true,
      ask: true,
      aspect: true,
      assault: true,
      asset: true,
      assist: true,
      assume: true,
      asthma: true,
      athlete: true,
      atom: true,
      attack: true,
      attend: true,
      attitude: true,
      attract: true,
      auction: true,
      audit: true,
      august: true,
      aunt: true,
      author: true,
      auto: true,
      autumn: true,
      average: true,
      avocado: true,
      avoid: true,
      awake: true,
      aware: true,
      away: true,
      awesome: true,
      awful: true,
      awkward: true,
      axis: true,
      baby: true,
      bachelor: true,
      bacon: true,
      badge: true,
      bag: true,
      balance: true,
      balcony: true,
      ball: true,
      bamboo: true,
      banana: true,
      banner: true,
      bar: true,
      barely: true,
      bargain: true,
      barrel: true,
      base: true,
      basic: true,
      basket: true,
      battle: true,
      beach: true,
      bean: true,
      beauty: true,
      because: true,
      become: true,
      beef: true,
      before: true,
      begin: true,
      behave: true,
      behind: true,
      believe: true,
      below: true,
      belt: true,
      bench: true,
      benefit: true,
      best: true,
      betray: true,
      better: true,
      between: true,
      beyond: true,
      bicycle: true,
      bid: true,
      bike: true,
      bind: true,
      biology: true,
      bird: true,
      birth: true,
      bitter: true,
      black: true,
      blade: true,
      blame: true,
      blanket: true,
      blast: true,
      bleak: true,
      bless: true,
      blind: true,
      blood: true,
      blossom: true,
      blouse: true,
      blue: true,
      blur: true,
      blush: true,
      board: true,
      boat: true,
      body: true,
      boil: true,
      bomb: true,
      bone: true,
      bonus: true,
      book: true,
      boost: true,
      border: true,
      boring: true,
      borrow: true,
      boss: true,
      bottom: true,
      bounce: true,
      box: true,
      boy: true,
      bracket: true,
      brain: true,
      brand: true,
      brass: true,
      brave: true,
      bread: true,
      breeze: true,
      brick: true,
      bridge: true,
      brief: true,
      bright: true,
      bring: true,
      brisk: true,
      broccoli: true,
      broken: true,
      bronze: true,
      broom: true,
      brother: true,
      brown: true,
      brush: true,
      bubble: true,
      buddy: true,
      budget: true,
      buffalo: true,
      build: true,
      bulb: true,
      bulk: true,
      bullet: true,
      bundle: true,
      bunker: true,
      burden: true,
      burger: true,
      burst: true,
      bus: true,
      business: true,
      busy: true,
      butter: true,
      buyer: true,
      buzz: true,
      cabbage: true,
      cabin: true,
      cable: true,
      cactus: true,
      cage: true,
      cake: true,
      call: true,
      calm: true,
      camera: true,
      camp: true,
      can: true,
      canal: true,
      cancel: true,
      candy: true,
      cannon: true,
      canoe: true,
      canvas: true,
      canyon: true,
      capable: true,
      capital: true,
      captain: true,
      car: true,
      carbon: true,
      card: true,
      cargo: true,
      carpet: true,
      carry: true,
      cart: true,
      case: true,
      cash: true,
      casino: true,
      castle: true,
      casual: true,
      cat: true,
      catalog: true,
      catch: true,
      category: true,
      cattle: true,
      caught: true,
      cause: true,
      caution: true,
      cave: true,
      ceiling: true,
      celery: true,
      cement: true,
      census: true,
      century: true,
      cereal: true,
      certain: true,
      chair: true,
      chalk: true,
      champion: true,
      change: true,
      chaos: true,
      chapter: true,
      charge: true,
      chase: true,
      chat: true,
      cheap: true,
      check: true,
      cheese: true,
      chef: true,
      cherry: true,
      chest: true,
      chicken: true,
      chief: true,
      child: true,
      chimney: true,
      choice: true,
      choose: true,
      chronic: true,
      chuckle: true,
      chunk: true,
      churn: true,
      cigar: true,
      cinnamon: true,
      circle: true,
      citizen: true,
      city: true,
      civil: true,
      claim: true,
      clap: true,
      clarify: true,
      claw: true,
      clay: true,
      clean: true,
      clerk: true,
      clever: true,
      click: true,
      client: true,
      cliff: true,
      climb: true,
      clinic: true,
      clip: true,
      clock: true,
      clog: true,
      close: true,
      cloth: true,
      cloud: true,
      clown: true,
      club: true,
      clump: true,
      cluster: true,
      clutch: true,
      coach: true,
      coast: true,
      coconut: true,
      code: true,
      coffee: true,
      coil: true,
      coin: true,
      collect: true,
      color: true,
      column: true,
      combine: true,
      come: true,
      comfort: true,
      comic: true,
      common: true,
      company: true,
      concert: true,
      conduct: true,
      confirm: true,
      congress: true,
      connect: true,
      consider: true,
      control: true,
      convince: true,
      cook: true,
      cool: true,
      copper: true,
      copy: true,
      coral: true,
      core: true,
      corn: true,
      correct: true,
      cost: true,
      cotton: true,
      couch: true,
      country: true,
      couple: true,
      course: true,
      cousin: true,
      cover: true,
      coyote: true,
      crack: true,
      cradle: true,
      craft: true,
      cram: true,
      crane: true,
      crash: true,
      crater: true,
      crawl: true,
      crazy: true,
      cream: true,
      credit: true,
      creek: true,
      crew: true,
      cricket: true,
      crime: true,
      crisp: true,
      critic: true,
      crop: true,
      cross: true,
      crouch: true,
      crowd: true,
      crucial: true,
      cruel: true,
      cruise: true,
      crumble: true,
      crunch: true,
      crush: true,
      cry: true,
      crystal: true,
      cube: true,
      culture: true,
      cup: true,
      cupboard: true,
      curious: true,
      current: true,
      curtain: true,
      curve: true,
      cushion: true,
      custom: true,
      cute: true,
      cycle: true,
      dad: true,
      damage: true,
      damp: true,
      dance: true,
      danger: true,
      daring: true,
      dash: true,
      daughter: true,
      dawn: true,
      day: true,
      deal: true,
      debate: true,
      debris: true,
      decade: true,
      december: true,
      decide: true,
      decline: true,
      decorate: true,
      decrease: true,
      deer: true,
      defense: true,
      define: true,
      defy: true,
      degree: true,
      delay: true,
      deliver: true,
      demand: true,
      demise: true,
      denial: true,
      dentist: true,
      deny: true,
      depart: true,
      depend: true,
      deposit: true,
      depth: true,
      deputy: true,
      derive: true,
      describe: true,
      desert: true,
      design: true,
      desk: true,
      despair: true,
      destroy: true,
      detail: true,
      detect: true,
      develop: true,
      device: true,
      devote: true,
      diagram: true,
      dial: true,
      diamond: true,
      diary: true,
      dice: true,
      diesel: true,
      diet: true,
      differ: true,
      digital: true,
      dignity: true,
      dilemma: true,
      dinner: true,
      dinosaur: true,
      direct: true,
      dirt: true,
      disagree: true,
      discover: true,
      disease: true,
      dish: true,
      dismiss: true,
      disorder: true,
      display: true,
      distance: true,
      divert: true,
      divide: true,
      divorce: true,
      dizzy: true,
      doctor: true,
      document: true,
      dog: true,
      doll: true,
      dolphin: true,
      domain: true,
      donate: true,
      donkey: true,
      donor: true,
      door: true,
      dose: true,
      double: true,
      dove: true,
      draft: true,
      dragon: true,
      drama: true,
      drastic: true,
      draw: true,
      dream: true,
      dress: true,
      drift: true,
      drill: true,
      drink: true,
      drip: true,
      drive: true,
      drop: true,
      drum: true,
      dry: true,
      duck: true,
      dumb: true,
      dune: true,
      during: true,
      dust: true,
      dutch: true,
      duty: true,
      dwarf: true,
      dynamic: true,
      eager: true,
      eagle: true,
      early: true,
      earn: true,
      earth: true,
      easily: true,
      east: true,
      easy: true,
      echo: true,
      ecology: true,
      economy: true,
      edge: true,
      edit: true,
      educate: true,
      effort: true,
      egg: true,
      eight: true,
      either: true,
      elbow: true,
      elder: true,
      electric: true,
      elegant: true,
      element: true,
      elephant: true,
      elevator: true,
      elite: true,
      else: true,
      embark: true,
      embody: true,
      embrace: true,
      emerge: true,
      emotion: true,
      employ: true,
      empower: true,
      empty: true,
      enable: true,
      enact: true,
      end: true,
      endless: true,
      endorse: true,
      enemy: true,
      energy: true,
      enforce: true,
      engage: true,
      engine: true,
      enhance: true,
      enjoy: true,
      enlist: true,
      enough: true,
      enrich: true,
      enroll: true,
      ensure: true,
      enter: true,
      entire: true,
      entry: true,
      envelope: true,
      episode: true,
      equal: true,
      equip: true,
      era: true,
      erase: true,
      erode: true,
      erosion: true,
      error: true,
      erupt: true,
      escape: true,
      essay: true,
      essence: true,
      estate: true,
      eternal: true,
      ethics: true,
      evidence: true,
      evil: true,
      evoke: true,
      evolve: true,
      exact: true,
      example: true,
      excess: true,
      exchange: true,
      excite: true,
      exclude: true,
      excuse: true,
      execute: true,
      exercise: true,
      exhaust: true,
      exhibit: true,
      exile: true,
      exist: true,
      exit: true,
      exotic: true,
      expand: true,
      expect: true,
      expire: true,
      explain: true,
      expose: true,
      express: true,
      extend: true,
      extra: true,
      eye: true,
      eyebrow: true,
      fabric: true,
      face: true,
      faculty: true,
      fade: true,
      faint: true,
      faith: true,
      fall: true,
      false: true,
      fame: true,
      family: true,
      famous: true,
      fan: true,
      fancy: true,
      fantasy: true,
      farm: true,
      fashion: true,
      fat: true,
      fatal: true,
      father: true,
      fatigue: true,
      fault: true,
      favorite: true,
      feature: true,
      february: true,
      federal: true,
      fee: true,
      feed: true,
      feel: true,
      female: true,
      fence: true,
      festival: true,
      fetch: true,
      fever: true,
      few: true,
      fiber: true,
      fiction: true,
      field: true,
      figure: true,
      file: true,
      film: true,
      filter: true,
      final: true,
      find: true,
      fine: true,
      finger: true,
      finish: true,
      fire: true,
      firm: true,
      first: true,
      fiscal: true,
      fish: true,
      fit: true,
      fitness: true,
      fix: true,
      flag: true,
      flame: true,
      flash: true,
      flat: true,
      flavor: true,
      flee: true,
      flight: true,
      flip: true,
      float: true,
      flock: true,
      floor: true,
      flower: true,
      fluid: true,
      flush: true,
      fly: true,
      foam: true,
      focus: true,
      fog: true,
      foil: true,
      fold: true,
      follow: true,
      food: true,
      foot: true,
      force: true,
      forest: true,
      forget: true,
      fork: true,
      fortune: true,
      forum: true,
      forward: true,
      fossil: true,
      foster: true,
      found: true,
      fox: true,
      fragile: true,
      frame: true,
      frequent: true,
      fresh: true,
      friend: true,
      fringe: true,
      frog: true,
      front: true,
      frost: true,
      frown: true,
      frozen: true,
      fruit: true,
      fuel: true,
      fun: true,
      funny: true,
      furnace: true,
      fury: true,
      future: true,
      gadget: true,
      gain: true,
      galaxy: true,
      gallery: true,
      game: true,
      gap: true,
      garage: true,
      garbage: true,
      garden: true,
      garlic: true,
      garment: true,
      gas: true,
      gasp: true,
      gate: true,
      gather: true,
      gauge: true,
      gaze: true,
      general: true,
      genius: true,
      genre: true,
      gentle: true,
      genuine: true,
      gesture: true,
      ghost: true,
      giant: true,
      gift: true,
      giggle: true,
      ginger: true,
      giraffe: true,
      girl: true,
      give: true,
      glad: true,
      glance: true,
      glare: true,
      glass: true,
      glide: true,
      glimpse: true,
      globe: true,
      gloom: true,
      glory: true,
      glove: true,
      glow: true,
      glue: true,
      goat: true,
      goddess: true,
      gold: true,
      good: true,
      goose: true,
      gorilla: true,
      gospel: true,
      gossip: true,
      govern: true,
      gown: true,
      grab: true,
      grace: true,
      grain: true,
      grant: true,
      grape: true,
      grass: true,
      gravity: true,
      great: true,
      green: true,
      grid: true,
      grief: true,
      grit: true,
      grocery: true,
      group: true,
      grow: true,
      grunt: true,
      guard: true,
      guess: true,
      guide: true,
      guilt: true,
      guitar: true,
      gun: true,
      gym: true,
      habit: true,
      hair: true,
      half: true,
      hammer: true,
      hamster: true,
      hand: true,
      happy: true,
      harbor: true,
      hard: true,
      harsh: true,
      harvest: true,
      hat: true,
      have: true,
      hawk: true,
      hazard: true,
      head: true,
      health: true,
      heart: true,
      heavy: true,
      hedgehog: true,
      height: true,
      hello: true,
      helmet: true,
      help: true,
      hen: true,
      hero: true,
      hidden: true,
      high: true,
      hill: true,
      hint: true,
      hip: true,
      hire: true,
      history: true,
      hobby: true,
      hockey: true,
      hold: true,
      hole: true,
      holiday: true,
      hollow: true,
      home: true,
      honey: true,
      hood: true,
      hope: true,
      horn: true,
      horror: true,
      horse: true,
      hospital: true,
      host: true,
      hotel: true,
      hour: true,
      hover: true,
      hub: true,
      huge: true,
      human: true,
      humble: true,
      humor: true,
      hundred: true,
      hungry: true,
      hunt: true,
      hurdle: true,
      hurry: true,
      hurt: true,
      husband: true,
      hybrid: true,
      ice: true,
      icon: true,
      idea: true,
      identify: true,
      idle: true,
      ignore: true,
      ill: true,
      illegal: true,
      illness: true,
      image: true,
      imitate: true,
      immense: true,
      immune: true,
      impact: true,
      impose: true,
      improve: true,
      impulse: true,
      inch: true,
      include: true,
      income: true,
      increase: true,
      index: true,
      indicate: true,
      indoor: true,
      industry: true,
      infant: true,
      inflict: true,
      inform: true,
      inhale: true,
      inherit: true,
      initial: true,
      inject: true,
      injury: true,
      inmate: true,
      inner: true,
      innocent: true,
      input: true,
      inquiry: true,
      insane: true,
      insect: true,
      inside: true,
      inspire: true,
      install: true,
      intact: true,
      interest: true,
      into: true,
      invest: true,
      invite: true,
      involve: true,
      iron: true,
      island: true,
      isolate: true,
      issue: true,
      item: true,
      ivory: true,
      jacket: true,
      jaguar: true,
      jar: true,
      jazz: true,
      jealous: true,
      jeans: true,
      jelly: true,
      jewel: true,
      job: true,
      join: true,
      joke: true,
      journey: true,
      joy: true,
      judge: true,
      juice: true,
      jump: true,
      jungle: true,
      junior: true,
      junk: true,
      just: true,
      kangaroo: true,
      keen: true,
      keep: true,
      ketchup: true,
      key: true,
      kick: true,
      kid: true,
      kidney: true,
      kind: true,
      kingdom: true,
      kiss: true,
      kit: true,
      kitchen: true,
      kite: true,
      kitten: true,
      kiwi: true,
      knee: true,
      knife: true,
      knock: true,
      know: true,
      lab: true,
      label: true,
      labor: true,
      ladder: true,
      lady: true,
      lake: true,
      lamp: true,
      language: true,
      laptop: true,
      large: true,
      later: true,
      latin: true,
      laugh: true,
      laundry: true,
      lava: true,
      law: true,
      lawn: true,
      lawsuit: true,
      layer: true,
      lazy: true,
      leader: true,
      leaf: true,
      learn: true,
      leave: true,
      lecture: true,
      left: true,
      leg: true,
      legal: true,
      legend: true,
      leisure: true,
      lemon: true,
      lend: true,
      length: true,
      lens: true,
      leopard: true,
      lesson: true,
      letter: true,
      level: true,
      liar: true,
      liberty: true,
      library: true,
      license: true,
      life: true,
      lift: true,
      light: true,
      like: true,
      limb: true,
      limit: true,
      link: true,
      lion: true,
      liquid: true,
      list: true,
      little: true,
      live: true,
      lizard: true,
      load: true,
      loan: true,
      lobster: true,
      local: true,
      lock: true,
      logic: true,
      lonely: true,
      long: true,
      loop: true,
      lottery: true,
      loud: true,
      lounge: true,
      love: true,
      loyal: true,
      lucky: true,
      luggage: true,
      lumber: true,
      lunar: true,
      lunch: true,
      luxury: true,
      lyrics: true,
      machine: true,
      mad: true,
      magic: true,
      magnet: true,
      maid: true,
      mail: true,
      main: true,
      major: true,
      make: true,
      mammal: true,
      man: true,
      manage: true,
      mandate: true,
      mango: true,
      mansion: true,
      manual: true,
      maple: true,
      marble: true,
      march: true,
      margin: true,
      marine: true,
      market: true,
      marriage: true,
      mask: true,
      mass: true,
      master: true,
      match: true,
      material: true,
      math: true,
      matrix: true,
      matter: true,
      maximum: true,
      maze: true,
      meadow: true,
      mean: true,
      measure: true,
      meat: true,
      mechanic: true,
      medal: true,
      media: true,
      melody: true,
      melt: true,
      member: true,
      memory: true,
      mention: true,
      menu: true,
      mercy: true,
      merge: true,
      merit: true,
      merry: true,
      mesh: true,
      message: true,
      metal: true,
      method: true,
      middle: true,
      midnight: true,
      milk: true,
      million: true,
      mimic: true,
      mind: true,
      minimum: true,
      minor: true,
      minute: true,
      miracle: true,
      mirror: true,
      misery: true,
      miss: true,
      mistake: true,
      mix: true,
      mixed: true,
      mixture: true,
      mobile: true,
      model: true,
      modify: true,
      mom: true,
      moment: true,
      monitor: true,
      monkey: true,
      monster: true,
      month: true,
      moon: true,
      moral: true,
      more: true,
      morning: true,
      mosquito: true,
      mother: true,
      motion: true,
      motor: true,
      mountain: true,
      mouse: true,
      move: true,
      movie: true,
      much: true,
      muffin: true,
      mule: true,
      multiply: true,
      muscle: true,
      museum: true,
      mushroom: true,
      music: true,
      must: true,
      mutual: true,
      myself: true,
      mystery: true,
      myth: true,
      naive: true,
      name: true,
      napkin: true,
      narrow: true,
      nasty: true,
      nation: true,
      nature: true,
      near: true,
      neck: true,
      need: true,
      negative: true,
      neglect: true,
      neither: true,
      nephew: true,
      nerve: true,
      nest: true,
      net: true,
      network: true,
      neutral: true,
      never: true,
      news: true,
      next: true,
      nice: true,
      night: true,
      noble: true,
      noise: true,
      nominee: true,
      noodle: true,
      normal: true,
      north: true,
      nose: true,
      notable: true,
      note: true,
      nothing: true,
      notice: true,
      novel: true,
      now: true,
      nuclear: true,
      number: true,
      nurse: true,
      nut: true,
      oak: true,
      obey: true,
      object: true,
      oblige: true,
      obscure: true,
      observe: true,
      obtain: true,
      obvious: true,
      occur: true,
      ocean: true,
      october: true,
      odor: true,
      off: true,
      offer: true,
      office: true,
      often: true,
      oil: true,
      okay: true,
      old: true,
      olive: true,
      olympic: true,
      omit: true,
      once: true,
      one: true,
      onion: true,
      online: true,
      only: true,
      open: true,
      opera: true,
      opinion: true,
      oppose: true,
      option: true,
      orange: true,
      orbit: true,
      orchard: true,
      order: true,
      ordinary: true,
      organ: true,
      orient: true,
      original: true,
      orphan: true,
      ostrich: true,
      other: true,
      outdoor: true,
      outer: true,
      output: true,
      outside: true,
      oval: true,
      oven: true,
      over: true,
      own: true,
      owner: true,
      oxygen: true,
      oyster: true,
      ozone: true,
      pact: true,
      paddle: true,
      page: true,
      pair: true,
      palace: true,
      palm: true,
      panda: true,
      panel: true,
      panic: true,
      panther: true,
      paper: true,
      parade: true,
      parent: true,
      park: true,
      parrot: true,
      party: true,
      pass: true,
      patch: true,
      path: true,
      patient: true,
      patrol: true,
      pattern: true,
      pause: true,
      pave: true,
      payment: true,
      peace: true,
      peanut: true,
      pear: true,
      peasant: true,
      pelican: true,
      pen: true,
      penalty: true,
      pencil: true,
      people: true,
      pepper: true,
      perfect: true,
      permit: true,
      person: true,
      pet: true,
      phone: true,
      photo: true,
      phrase: true,
      physical: true,
      piano: true,
      picnic: true,
      picture: true,
      piece: true,
      pig: true,
      pigeon: true,
      pill: true,
      pilot: true,
      pink: true,
      pioneer: true,
      pipe: true,
      pistol: true,
      pitch: true,
      pizza: true,
      place: true,
      planet: true,
      plastic: true,
      plate: true,
      play: true,
      please: true,
      pledge: true,
      pluck: true,
      plug: true,
      plunge: true,
      poem: true,
      poet: true,
      point: true,
      polar: true,
      pole: true,
      police: true,
      pond: true,
      pony: true,
      pool: true,
      popular: true,
      portion: true,
      position: true,
      possible: true,
      post: true,
      potato: true,
      pottery: true,
      poverty: true,
      powder: true,
      power: true,
      practice: true,
      praise: true,
      predict: true,
      prefer: true,
      prepare: true,
      present: true,
      pretty: true,
      prevent: true,
      price: true,
      pride: true,
      primary: true,
      print: true,
      priority: true,
      prison: true,
      private: true,
      prize: true,
      problem: true,
      process: true,
      produce: true,
      profit: true,
      program: true,
      project: true,
      promote: true,
      proof: true,
      property: true,
      prosper: true,
      protect: true,
      proud: true,
      provide: true,
      public: true,
      pudding: true,
      pull: true,
      pulp: true,
      pulse: true,
      pumpkin: true,
      punch: true,
      pupil: true,
      puppy: true,
      purchase: true,
      purity: true,
      purpose: true,
      purse: true,
      push: true,
      put: true,
      puzzle: true,
      pyramid: true,
      quality: true,
      quantum: true,
      quarter: true,
      question: true,
      quick: true,
      quit: true,
      quiz: true,
      quote: true,
      rabbit: true,
      raccoon: true,
      race: true,
      rack: true,
      radar: true,
      radio: true,
      rail: true,
      rain: true,
      raise: true,
      rally: true,
      ramp: true,
      ranch: true,
      random: true,
      range: true,
      rapid: true,
      rare: true,
      rate: true,
      rather: true,
      raven: true,
      raw: true,
      razor: true,
      ready: true,
      real: true,
      reason: true,
      rebel: true,
      rebuild: true,
      recall: true,
      receive: true,
      recipe: true,
      record: true,
      recycle: true,
      reduce: true,
      reflect: true,
      reform: true,
      refuse: true,
      region: true,
      regret: true,
      regular: true,
      reject: true,
      relax: true,
      release: true,
      relief: true,
      rely: true,
      remain: true,
      remember: true,
      remind: true,
      remove: true,
      render: true,
      renew: true,
      rent: true,
      reopen: true,
      repair: true,
      repeat: true,
      replace: true,
      report: true,
      require: true,
      rescue: true,
      resemble: true,
      resist: true,
      resource: true,
      response: true,
      result: true,
      retire: true,
      retreat: true,
      return: true,
      reunion: true,
      reveal: true,
      review: true,
      reward: true,
      rhythm: true,
      rib: true,
      ribbon: true,
      rice: true,
      rich: true,
      ride: true,
      ridge: true,
      rifle: true,
      right: true,
      rigid: true,
      ring: true,
      riot: true,
      ripple: true,
      risk: true,
      ritual: true,
      rival: true,
      river: true,
      road: true,
      roast: true,
      robot: true,
      robust: true,
      rocket: true,
      romance: true,
      roof: true,
      rookie: true,
      room: true,
      rose: true,
      rotate: true,
      rough: true,
      round: true,
      route: true,
      royal: true,
      rubber: true,
      rude: true,
      rug: true,
      rule: true,
      run: true,
      runway: true,
      rural: true,
      sad: true,
      saddle: true,
      sadness: true,
      safe: true,
      sail: true,
      salad: true,
      salmon: true,
      salon: true,
      salt: true,
      salute: true,
      same: true,
      sample: true,
      sand: true,
      satisfy: true,
      satoshi: true,
      sauce: true,
      sausage: true,
      save: true,
      say: true,
      scale: true,
      scan: true,
      scare: true,
      scatter: true,
      scene: true,
      scheme: true,
      school: true,
      science: true,
      scissors: true,
      scorpion: true,
      scout: true,
      scrap: true,
      screen: true,
      script: true,
      scrub: true,
      sea: true,
      search: true,
      season: true,
      seat: true,
      second: true,
      secret: true,
      section: true,
      security: true,
      seed: true,
      seek: true,
      segment: true,
      select: true,
      sell: true,
      seminar: true,
      senior: true,
      sense: true,
      sentence: true,
      series: true,
      service: true,
      session: true,
      settle: true,
      setup: true,
      seven: true,
      shadow: true,
      shaft: true,
      shallow: true,
      share: true,
      shed: true,
      shell: true,
      sheriff: true,
      shield: true,
      shift: true,
      shine: true,
      ship: true,
      shiver: true,
      shock: true,
      shoe: true,
      shoot: true,
      shop: true,
      short: true,
      shoulder: true,
      shove: true,
      shrimp: true,
      shrug: true,
      shuffle: true,
      shy: true,
      sibling: true,
      sick: true,
      side: true,
      siege: true,
      sight: true,
      sign: true,
      silent: true,
      silk: true,
      silly: true,
      silver: true,
      similar: true,
      simple: true,
      since: true,
      sing: true,
      siren: true,
      sister: true,
      situate: true,
      six: true,
      size: true,
      skate: true,
      sketch: true,
      ski: true,
      skill: true,
      skin: true,
      skirt: true,
      skull: true,
      slab: true,
      slam: true,
      sleep: true,
      slender: true,
      slice: true,
      slide: true,
      slight: true,
      slim: true,
      slogan: true,
      slot: true,
      slow: true,
      slush: true,
      small: true,
      smart: true,
      smile: true,
      smoke: true,
      smooth: true,
      snack: true,
      snake: true,
      snap: true,
      sniff: true,
      snow: true,
      soap: true,
      soccer: true,
      social: true,
      sock: true,
      soda: true,
      soft: true,
      solar: true,
      soldier: true,
      solid: true,
      solution: true,
      solve: true,
      someone: true,
      song: true,
      soon: true,
      sorry: true,
      sort: true,
      soul: true,
      sound: true,
      soup: true,
      source: true,
      south: true,
      space: true,
      spare: true,
      spatial: true,
      spawn: true,
      speak: true,
      special: true,
      speed: true,
      spell: true,
      spend: true,
      sphere: true,
      spice: true,
      spider: true,
      spike: true,
      spin: true,
      spirit: true,
      split: true,
      spoil: true,
      sponsor: true,
      spoon: true,
      sport: true,
      spot: true,
      spray: true,
      spread: true,
      spring: true,
      spy: true,
      square: true,
      squeeze: true,
      squirrel: true,
      stable: true,
      stadium: true,
      staff: true,
      stage: true,
      stairs: true,
      stamp: true,
      stand: true,
      start: true,
      state: true,
      stay: true,
      steak: true,
      steel: true,
      stem: true,
      step: true,
      stereo: true,
      stick: true,
      still: true,
      sting: true,
      stock: true,
      stomach: true,
      stone: true,
      stool: true,
      story: true,
      stove: true,
      strategy: true,
      street: true,
      strike: true,
      strong: true,
      struggle: true,
      student: true,
      stuff: true,
      stumble: true,
      style: true,
      subject: true,
      submit: true,
      subway: true,
      success: true,
      such: true,
      sudden: true,
      suffer: true,
      sugar: true,
      suggest: true,
      suit: true,
      summer: true,
      sun: true,
      sunny: true,
      sunset: true,
      super: true,
      supply: true,
      supreme: true,
      sure: true,
      surface: true,
      surge: true,
      surprise: true,
      surround: true,
      survey: true,
      suspect: true,
      sustain: true,
      swallow: true,
      swamp: true,
      swap: true,
      swarm: true,
      swear: true,
      sweet: true,
      swift: true,
      swim: true,
      swing: true,
      switch: true,
      sword: true,
      symbol: true,
      symptom: true,
      syrup: true,
      system: true,
      table: true,
      tackle: true,
      tag: true,
      tail: true,
      talent: true,
      talk: true,
      tank: true,
      tape: true,
      target: true,
      task: true,
      taste: true,
      tattoo: true,
      taxi: true,
      teach: true,
      team: true,
      tell: true,
      ten: true,
      tenant: true,
      tennis: true,
      tent: true,
      term: true,
      test: true,
      text: true,
      thank: true,
      that: true,
      theme: true,
      then: true,
      theory: true,
      there: true,
      they: true,
      thing: true,
      this: true,
      thought: true,
      three: true,
      thrive: true,
      throw: true,
      thumb: true,
      thunder: true,
      ticket: true,
      tide: true,
      tiger: true,
      tilt: true,
      timber: true,
      time: true,
      tiny: true,
      tip: true,
      tired: true,
      tissue: true,
      title: true,
      toast: true,
      tobacco: true,
      today: true,
      toddler: true,
      toe: true,
      together: true,
      toilet: true,
      token: true,
      tomato: true,
      tomorrow: true,
      tone: true,
      tongue: true,
      tonight: true,
      tool: true,
      tooth: true,
      top: true,
      topic: true,
      topple: true,
      torch: true,
      tornado: true,
      tortoise: true,
      toss: true,
      total: true,
      tourist: true,
      toward: true,
      tower: true,
      town: true,
      toy: true,
      track: true,
      trade: true,
      traffic: true,
      tragic: true,
      train: true,
      transfer: true,
      trap: true,
      trash: true,
      travel: true,
      tray: true,
      treat: true,
      tree: true,
      trend: true,
      trial: true,
      tribe: true,
      trick: true,
      trigger: true,
      trim: true,
      trip: true,
      trophy: true,
      trouble: true,
      truck: true,
      true: true,
      truly: true,
      trumpet: true,
      trust: true,
      truth: true,
      try: true,
      tube: true,
      tuition: true,
      tumble: true,
      tuna: true,
      tunnel: true,
      turkey: true,
      turn: true,
      turtle: true,
      twelve: true,
      twenty: true,
      twice: true,
      twin: true,
      twist: true,
      two: true,
      type: true,
      typical: true,
      ugly: true,
      umbrella: true,
      unable: true,
      unaware: true,
      uncle: true,
      uncover: true,
      under: true,
      undo: true,
      unfair: true,
      unfold: true,
      unhappy: true,
      uniform: true,
      unique: true,
      unit: true,
      universe: true,
      unknown: true,
      unlock: true,
      until: true,
      unusual: true,
      unveil: true,
      update: true,
      upgrade: true,
      uphold: true,
      upon: true,
      upper: true,
      upset: true,
      urban: true,
      urge: true,
      usage: true,
      use: true,
      used: true,
      useful: true,
      useless: true,
      usual: true,
      utility: true,
      vacant: true,
      vacuum: true,
      vague: true,
      valid: true,
      valley: true,
      valve: true,
      van: true,
      vanish: true,
      vapor: true,
      various: true,
      vast: true,
      vault: true,
      vehicle: true,
      velvet: true,
      vendor: true,
      venture: true,
      venue: true,
      verb: true,
      verify: true,
      version: true,
      very: true,
      vessel: true,
      veteran: true,
      viable: true,
      vibrant: true,
      vicious: true,
      victory: true,
      video: true,
      view: true,
      village: true,
      vintage: true,
      violin: true,
      virtual: true,
      virus: true,
      visa: true,
      visit: true,
      visual: true,
      vital: true,
      vivid: true,
      vocal: true,
      voice: true,
      void: true,
      volcano: true,
      volume: true,
      vote: true,
      voyage: true,
      wage: true,
      wagon: true,
      wait: true,
      walk: true,
      wall: true,
      walnut: true,
      want: true,
      warfare: true,
      warm: true,
      warrior: true,
      wash: true,
      wasp: true,
      waste: true,
      water: true,
      wave: true,
      way: true,
      wealth: true,
      weapon: true,
      wear: true,
      weasel: true,
      weather: true,
      web: true,
      wedding: true,
      weekend: true,
      weird: true,
      welcome: true,
      west: true,
      wet: true,
      whale: true,
      what: true,
      wheat: true,
      wheel: true,
      when: true,
      where: true,
      whip: true,
      whisper: true,
      wide: true,
      width: true,
      wife: true,
      wild: true,
      will: true,
      win: true,
      window: true,
      wine: true,
      wing: true,
      wink: true,
      winner: true,
      winter: true,
      wire: true,
      wisdom: true,
      wise: true,
      wish: true,
      witness: true,
      wolf: true,
      woman: true,
      wonder: true,
      wood: true,
      wool: true,
      word: true,
      work: true,
      world: true,
      worry: true,
      worth: true,
      wrap: true,
      wreck: true,
      wrestle: true,
      wrist: true,
      write: true,
      wrong: true,
      yard: true,
      year: true,
      yellow: true,
      you: true,
      young: true,
      youth: true,
      zebra: true,
      zero: true,
      zone: true,
      zoo: true
    };
  }
});

// node_modules/@keplr-wallet/common/build/coin/index.js
var require_coin3 = __commonJS({
  "node_modules/@keplr-wallet/common/build/coin/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseCoinStr = exports2.isValidCoinStr = void 0;
    function isValidCoinStr(str) {
      const split2 = str.split(/^([0-9]+)(\s)*([a-zA-Z][a-zA-Z0-9/-]*)$/);
      if (split2.length === 5) {
        if (split2[1].length > 0 && split2[3].length > 0 && !Number.isNaN(parseInt(split2[1]))) {
          return true;
        }
      }
      return false;
    }
    exports2.isValidCoinStr = isValidCoinStr;
    function parseCoinStr(str) {
      const split2 = str.split(/^([0-9]+)(\s)*([a-zA-Z][a-zA-Z0-9/-]*)$/);
      if (split2.length === 5) {
        const denom = split2[3];
        return {
          denom,
          amount: split2[1]
        };
      }
      throw new Error(`Invalid coin string: ${str}`);
    }
    exports2.parseCoinStr = parseCoinStr;
  }
});

// node_modules/@keplr-wallet/common/build/service-worker/index.js
var require_service_worker = __commonJS({
  "node_modules/@keplr-wallet/common/build/service-worker/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isServiceWorker = void 0;
    var isServiceWorker = () => {
      return typeof self !== "undefined" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      typeof ServiceWorkerGlobalScope !== "undefined" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      self instanceof ServiceWorkerGlobalScope;
    };
    exports2.isServiceWorker = isServiceWorker;
  }
});

// node_modules/@keplr-wallet/common/build/index.js
var require_build13 = __commonJS({
  "node_modules/@keplr-wallet/common/build/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_kv_store(), exports2);
    __exportStar(require_denom(), exports2);
    __exportStar(require_mobx(), exports2);
    __exportStar(require_utils9(), exports2);
    __exportStar(require_escape(), exports2);
    __exportStar(require_json(), exports2);
    __exportStar(require_icns(), exports2);
    __exportStar(require_retry(), exports2);
    __exportStar(require_sleep(), exports2);
    __exportStar(require_mnemonic2(), exports2);
    __exportStar(require_coin3(), exports2);
    __exportStar(require_service_worker(), exports2);
  }
});

// node_modules/@keplr-wallet/cosmos/build/stargate/decoder/index.js
var require_decoder = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/stargate/decoder/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtoSignDocDecoder = void 0;
    var tx_1 = require_tx15();
    var codec_1 = require_codec();
    var signing_1 = require_signing2();
    var common_1 = require_build13();
    var ProtoSignDocDecoder = class _ProtoSignDocDecoder {
      static decode(bytes) {
        return new _ProtoSignDocDecoder(tx_1.SignDoc.decode(bytes));
      }
      constructor(signDoc, protoCodec = codec_1.defaultProtoCodec) {
        this.signDoc = signDoc;
        this.protoCodec = protoCodec;
      }
      get txBody() {
        if (!this._txBody) {
          this._txBody = tx_1.TxBody.decode(this.signDoc.bodyBytes);
        }
        return this._txBody;
      }
      get txMsgs() {
        const msgs = [];
        for (const msg of this.txBody.messages) {
          msgs.push(this.protoCodec.unpackAny(msg));
        }
        return msgs;
      }
      get authInfo() {
        if (!this._authInfo) {
          if ("authInfoBytes" in this.signDoc) {
            this._authInfo = tx_1.AuthInfo.decode(this.signDoc.authInfoBytes);
          } else {
            const directAux = this.signDoc;
            this._authInfo = tx_1.AuthInfo.fromPartial({
              signerInfos: [
                {
                  publicKey: directAux.publicKey,
                  modeInfo: {
                    single: {
                      mode: signing_1.SignMode.SIGN_MODE_DIRECT
                    }
                  },
                  sequence: directAux.sequence
                }
              ],
              fee: {
                amount: [],
                gasLimit: "1",
                payer: "",
                granter: ""
              }
            });
          }
        }
        return this._authInfo;
      }
      get chainId() {
        return this.signDoc.chainId;
      }
      get accountNumber() {
        return this.signDoc.accountNumber.toString();
      }
      toBytes() {
        if ("authInfoBytes" in this.signDoc) {
          return tx_1.SignDoc.encode(this.signDoc).finish();
        }
        return tx_1.SignDocDirectAux.encode(this.signDoc).finish();
      }
      toJSON() {
        if ("authInfoBytes" in this.signDoc) {
          return (0, common_1.sortObjectByKey)({
            txBody: Object.assign(Object.assign({}, tx_1.TxBody.toJSON(this.txBody)), {
              messages: this.txMsgs.map((msg) => {
                return this.protoCodec.unpackedAnyToJSONRecursive(msg);
              })
            }),
            authInfo: tx_1.AuthInfo.toJSON(this.authInfo),
            chainId: this.chainId,
            accountNumber: this.accountNumber
          });
        }
        const directAuxJSON = tx_1.SignDocDirectAux.toJSON(this.signDoc);
        if (directAuxJSON.bodyBytes) {
          delete directAuxJSON.bodyBytes;
        }
        return (0, common_1.sortObjectByKey)(Object.assign(Object.assign({}, directAuxJSON), { txBody: Object.assign(Object.assign({}, tx_1.TxBody.toJSON(this.txBody)), {
          messages: this.txMsgs.map((msg) => {
            return this.protoCodec.unpackedAnyToJSONRecursive(msg);
          })
        }) }));
      }
    };
    exports2.ProtoSignDocDecoder = ProtoSignDocDecoder;
  }
});

// node_modules/@keplr-wallet/cosmos/build/signing/encode.js
var require_encode = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/signing/encode.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeSignDoc = exports2.encodeSecp256k1Signature = exports2.encodeSecp256k1Pubkey = void 0;
    var buffer_1 = require_dist();
    var common_1 = require_build13();
    function encodeSecp256k1Pubkey(pubkey) {
      if (pubkey.length !== 33 || pubkey[0] !== 2 && pubkey[0] !== 3) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
      }
      return {
        type: "tendermint/PubKeySecp256k1",
        value: buffer_1.Buffer.from(pubkey).toString("base64")
      };
    }
    exports2.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
    function encodeSecp256k1Signature2(pubkey, signature) {
      if (signature.length !== 64) {
        throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
      }
      return {
        pub_key: encodeSecp256k1Pubkey(pubkey),
        signature: buffer_1.Buffer.from(signature).toString("base64")
      };
    }
    exports2.encodeSecp256k1Signature = encodeSecp256k1Signature2;
    function serializeSignDoc2(signDoc) {
      return buffer_1.Buffer.from((0, common_1.escapeHTML)((0, common_1.sortedJsonByKeyStringify)(signDoc)));
    }
    exports2.serializeSignDoc = serializeSignDoc2;
  }
});

// node_modules/@keplr-wallet/cosmos/build/signing/index.js
var require_signing3 = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/signing/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_encode(), exports2);
  }
});

// node_modules/@keplr-wallet/cosmos/build/adr-36/amino.js
var require_amino = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/adr-36/amino.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyADR36Amino = exports2.verifyADR36AminoSignDoc = exports2.makeADR36AminoSignDoc = exports2.checkAndValidateADR36AminoSignDoc = void 0;
    var signing_1 = require_signing3();
    var bech32_1 = require_bech322();
    var buffer_1 = require_dist();
    var crypto_1 = require_build10();
    function checkAndValidateADR36AminoSignDoc(signDoc, bech32PrefixAccAddr) {
      const hasOnlyMsgSignData = (() => {
        if (signDoc && signDoc.msgs && Array.isArray(signDoc.msgs) && signDoc.msgs.length === 1) {
          const msg2 = signDoc.msgs[0];
          return msg2.type === "sign/MsgSignData";
        } else {
          return false;
        }
      })();
      if (!hasOnlyMsgSignData) {
        return false;
      }
      if (signDoc.chain_id !== "") {
        throw new Error("Chain id should be empty string for ADR-36 signing");
      }
      if (signDoc.memo !== "") {
        throw new Error("Memo should be empty string for ADR-36 signing");
      }
      if (signDoc.account_number !== "0") {
        throw new Error('Account number should be "0" for ADR-36 signing');
      }
      if (signDoc.sequence !== "0") {
        throw new Error('Sequence should be "0" for ADR-36 signing');
      }
      if (signDoc.fee.gas !== "0") {
        throw new Error('Gas should be "0" for ADR-36 signing');
      }
      if (signDoc.fee.amount.length !== 0) {
        throw new Error("Fee amount should be empty array for ADR-36 signing");
      }
      const msg = signDoc.msgs[0];
      if (msg.type !== "sign/MsgSignData") {
        throw new Error(`Invalid type of ADR-36 sign msg: ${msg.type}`);
      }
      if (!msg.value) {
        throw new Error("Empty value in the msg");
      }
      const signer = msg.value.signer;
      if (!signer) {
        throw new Error("Empty signer in the ADR-36 msg");
      }
      bech32_1.Bech32Address.validate(signer, bech32PrefixAccAddr);
      const data = msg.value.data;
      if (!data) {
        throw new Error("Empty data in the ADR-36 msg");
      }
      const rawData = buffer_1.Buffer.from(data, "base64");
      if (rawData.toString("base64") !== data) {
        throw new Error("Data is not encoded by base64");
      }
      if (rawData.length === 0) {
        throw new Error("Empty data in the ADR-36 msg");
      }
      return true;
    }
    exports2.checkAndValidateADR36AminoSignDoc = checkAndValidateADR36AminoSignDoc;
    function makeADR36AminoSignDoc2(signer, data) {
      if (typeof data === "string") {
        data = buffer_1.Buffer.from(data).toString("base64");
      } else {
        data = buffer_1.Buffer.from(data).toString("base64");
      }
      return {
        chain_id: "",
        account_number: "0",
        sequence: "0",
        fee: {
          gas: "0",
          amount: []
        },
        msgs: [
          {
            type: "sign/MsgSignData",
            value: {
              signer,
              data
            }
          }
        ],
        memo: ""
      };
    }
    exports2.makeADR36AminoSignDoc = makeADR36AminoSignDoc2;
    function verifyADR36AminoSignDoc(bech32PrefixAccAddr, signDoc, pubKey, signature, algo = "secp256k1") {
      if (!checkAndValidateADR36AminoSignDoc(signDoc, bech32PrefixAccAddr)) {
        throw new Error("Invalid sign doc for ADR-36");
      }
      const cryptoPubKey = new crypto_1.PubKeySecp256k1(pubKey);
      const expectedSigner = (() => {
        if (algo === "ethsecp256k1") {
          return new bech32_1.Bech32Address(cryptoPubKey.getEthAddress()).toBech32(bech32PrefixAccAddr);
        }
        return new bech32_1.Bech32Address(cryptoPubKey.getCosmosAddress()).toBech32(bech32PrefixAccAddr);
      })();
      const signer = signDoc.msgs[0].value.signer;
      if (expectedSigner !== signer) {
        throw new Error("Unmatched signer");
      }
      const msg = (0, signing_1.serializeSignDoc)(signDoc);
      return cryptoPubKey.verifyDigest32((() => {
        if (algo === "ethsecp256k1") {
          return crypto_1.Hash.keccak256(msg);
        }
        return crypto_1.Hash.sha256(msg);
      })(), signature);
    }
    exports2.verifyADR36AminoSignDoc = verifyADR36AminoSignDoc;
    function verifyADR36Amino(bech32PrefixAccAddr, signer, data, pubKey, signature, algo = "secp256k1") {
      const signDoc = makeADR36AminoSignDoc2(signer, data);
      return verifyADR36AminoSignDoc(bech32PrefixAccAddr, signDoc, pubKey, signature, algo);
    }
    exports2.verifyADR36Amino = verifyADR36Amino;
  }
});

// node_modules/@keplr-wallet/cosmos/build/adr-36/index.js
var require_adr_36 = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/adr-36/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_amino(), exports2);
  }
});

// node_modules/@keplr-wallet/cosmos/build/stargate/wrapper/index.js
var require_wrapper = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/stargate/wrapper/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignDocWrapper = void 0;
    var decoder_1 = require_decoder();
    var tx_1 = require_tx15();
    var adr_36_1 = require_adr_36();
    var SignDocWrapper = class _SignDocWrapper {
      constructor(signDoc) {
        this.signDoc = signDoc;
        this.isDirectAux = false;
        if ("msgs" in signDoc) {
          this.mode = "amino";
        } else {
          this.mode = "direct";
          this.isDirectAux = !("authInfoBytes" in signDoc);
        }
        if (this.mode === "amino") {
          this.isADR36SignDoc = (0, adr_36_1.checkAndValidateADR36AminoSignDoc)(this.aminoSignDoc);
        } else {
          this.isADR36SignDoc = false;
        }
      }
      static fromAminoSignDoc(signDoc) {
        return new _SignDocWrapper(signDoc);
      }
      static fromDirectSignDoc(signDoc) {
        return new _SignDocWrapper(signDoc);
      }
      static fromDirectAuxSignDoc(signDoc) {
        return new _SignDocWrapper(signDoc);
      }
      static fromDirectSignDocBytes(signDocBytes) {
        return new _SignDocWrapper(tx_1.SignDoc.decode(signDocBytes));
      }
      static fromDirectAuxSignDocBytes(signDocBytes) {
        return new _SignDocWrapper(tx_1.SignDocDirectAux.decode(signDocBytes));
      }
      clone() {
        return new _SignDocWrapper(this.signDoc);
      }
      get protoSignDoc() {
        if (this.mode === "amino") {
          throw new Error("Sign doc is encoded as Amino Json");
        }
        if ("msgs" in this.signDoc) {
          throw new Error("Unexpected error");
        }
        if (!this._protoSignDoc) {
          this._protoSignDoc = new decoder_1.ProtoSignDocDecoder(this.signDoc);
        }
        return this._protoSignDoc;
      }
      get aminoSignDoc() {
        if (this.mode === "direct") {
          throw new Error("Sign doc is encoded as Protobuf");
        }
        if (!("msgs" in this.signDoc)) {
          throw new Error("Unexpected error");
        }
        return this.signDoc;
      }
      get chainId() {
        if (this.mode === "direct") {
          return this.protoSignDoc.chainId;
        }
        return this.aminoSignDoc.chain_id;
      }
      get memo() {
        if (this.mode === "direct") {
          return this.protoSignDoc.txBody.memo;
        }
        return this.aminoSignDoc.memo;
      }
      get fees() {
        var _a2, _b;
        if (this.mode === "direct") {
          const fees = [];
          for (const coinObj of (_b = (_a2 = this.protoSignDoc.authInfo.fee) === null || _a2 === void 0 ? void 0 : _a2.amount) !== null && _b !== void 0 ? _b : []) {
            if (coinObj.denom == null || coinObj.amount == null) {
              throw new Error("Invalid fee");
            }
            fees.push({
              denom: coinObj.denom,
              amount: coinObj.amount
            });
          }
          return fees;
        }
        return this.aminoSignDoc.fee.amount;
      }
      get payer() {
        var _a2;
        if (this.mode === "direct") {
          return (_a2 = this.protoSignDoc.authInfo.fee) === null || _a2 === void 0 ? void 0 : _a2.payer;
        }
        return this.aminoSignDoc.fee.payer;
      }
      get granter() {
        var _a2;
        if (this.mode === "direct") {
          return (_a2 = this.protoSignDoc.authInfo.fee) === null || _a2 === void 0 ? void 0 : _a2.granter;
        }
        return this.aminoSignDoc.fee.granter;
      }
      get gas() {
        var _a2;
        if (this.mode === "direct") {
          if ((_a2 = this.protoSignDoc.authInfo.fee) === null || _a2 === void 0 ? void 0 : _a2.gasLimit) {
            return parseInt(this.protoSignDoc.authInfo.fee.gasLimit);
          } else {
            return 0;
          }
        }
        return parseInt(this.aminoSignDoc.fee.gas);
      }
    };
    exports2.SignDocWrapper = SignDocWrapper;
  }
});

// node_modules/@keplr-wallet/cosmos/build/stargate/index.js
var require_stargate = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/stargate/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_codec(), exports2);
    __exportStar(require_decoder(), exports2);
    __exportStar(require_wrapper(), exports2);
  }
});

// node_modules/@keplr-wallet/cosmos/build/index.js
var require_build14 = __commonJS({
  "node_modules/@keplr-wallet/cosmos/build/index.js"(exports2) {
    "use strict";
    var import_dist862 = __toESM(require_dist());
    var import_dist863 = __toESM(require_dist2());
    var import_dist864 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_account(), exports2);
    __exportStar(require_bech322(), exports2);
    __exportStar(require_chain_id(), exports2);
    __exportStar(require_tx_tracer(), exports2);
    __exportStar(require_stargate(), exports2);
    __exportStar(require_adr_36(), exports2);
    __exportStar(require_signing3(), exports2);
  }
});

// node_modules/@burnt-labs/abstraxion/dist/index.mjs
var import_dist859 = __toESM(require_dist(), 1);
var import_dist860 = __toESM(require_dist2(), 1);
var import_dist861 = __toESM(require_dist3(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/@burnt-labs/ui/dist/index.mjs
var import_dist250 = __toESM(require_dist(), 1);
var import_dist251 = __toESM(require_dist2(), 1);
var import_dist252 = __toESM(require_dist3(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-OXW4BQPJ.mjs
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var Spinner = () => {
  return (0, import_jsx_runtime.jsx)(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "1.25rem",
      height: "1.25rem",
      viewBox: "0 0 100 100",
      preserveAspectRatio: "xMidYMid",
      children: (0, import_jsx_runtime.jsx)(
        "circle",
        {
          cx: "50",
          cy: "50",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "8",
          r: "35",
          strokeDasharray: "164.93361431346415 56.97787143782138",
          children: (0, import_jsx_runtime.jsx)(
            "animateTransform",
            {
              attributeName: "transform",
              type: "rotate",
              repeatCount: "indefinite",
              dur: "1.25s",
              values: "0 50 50;360 50 50",
              keyTimes: "0;1"
            }
          )
        }
      )
    }
  );
};

// node_modules/@burnt-labs/ui/dist/chunk-QYUCWCCP.mjs
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-RFTE7DQK.mjs
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-3TCQU24P.mjs
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// node_modules/@burnt-labs/ui/dist/chunk-RFTE7DQK.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e)
    n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    else
      for (t in e)
        e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length; )
    (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var CLASS_PART_SEPARATOR = "-";
function createClassUtils(config) {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  function getClassGroupId(className) {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  var _a2;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a2 = classPartObject.validators.find(({
    validator
  }) => validator(classRest))) == null ? void 0 : _a2.classGroupId;
}
var arbitraryPropertyRegex = /^\[(.+)\]$/;
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config) {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path) {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache2 = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  function update(key, value) {
    cache2.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache2;
      cache2 = /* @__PURE__ */ new Map();
    }
  }
  return {
    get(key) {
      let value = cache2.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache2.has(key)) {
        cache2.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
}
var IMPORTANT_MODIFIER = "!";
function createSplitModifiers(config) {
  const separator = config.separator;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  return function splitModifiers(className) {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
}
function createConfigUtils(config) {
  return __spreadValues({
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config)
  }, createClassUtils(config));
}
var SPLIT_CLASSES_REGEX = /\s+/;
function mergeClassList(classList, configUtils) {
  const {
    splitModifiers,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map((originalClassName) => {
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = splitModifiers(originalClassName);
    let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter((parsed) => {
    if (!parsed.isTailwindClass) {
      return true;
    }
    const {
      modifierId,
      classGroupId,
      hasPostfixModifier
    } = parsed;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach((group) => classGroupsInConflict.add(modifierId + group));
    return true;
  }).reverse().map((parsed) => parsed.originalClassName).join(" ");
}
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix2) {
  if (typeof mix2 === "string") {
    return mix2;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix2.length; k++) {
    if (mix2[k]) {
      if (resolvedValue = toValue(mix2[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result2 = mergeClassList(classList, configUtils);
    cacheSet(classList, result2);
    return result2;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
function fromTheme(key) {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var fractionRegex = /^\d+\/\d+$/;
var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isNumber(value) {
  return Boolean(value) && !Number.isNaN(Number(value));
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isInteger(value) {
  return Boolean(value) && Number.isInteger(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
var sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, sizeLabels, isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
var imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
function isArbitraryImage(value) {
  return getIsArbitraryValue(value, imageLabels, isImage);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function isAny() {
  return true;
}
function getIsArbitraryValue(value, label, testValue) {
  const result2 = arbitraryValueRegex.exec(value);
  if (result2) {
    if (result2[1]) {
      return typeof label === "string" ? result2[1] === label : label.has(result2[1]);
    }
    return testValue(result2[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value);
}
function isNever() {
  return false;
}
function isShadow(value) {
  return shadowRegex.test(value);
}
function isImage(value) {
  return imageRegex.test(value);
}
function getDefaultConfig() {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumber = () => [isNumber, isArbitraryNumber];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": ["min", "max", "fit", isArbitraryValue, isLength]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize, isArbitraryValue]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["min", "max", "fit", isLength, isArbitraryValue]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: ["appearance-none"],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
function mergeConfigs(baseConfig, {
  cacheSize,
  prefix,
  separator,
  extend = {},
  override = {}
}) {
  overrideProperty(baseConfig, "cacheSize", cacheSize);
  overrideProperty(baseConfig, "prefix", prefix);
  overrideProperty(baseConfig, "separator", separator);
  for (const configKey in override) {
    overrideConfigProperties(baseConfig[configKey], override[configKey]);
  }
  for (const key in extend) {
    mergeConfigProperties(baseConfig[key], extend[key]);
  }
  return baseConfig;
}
function overrideProperty(baseObject, overrideKey, overrideValue) {
  if (overrideValue !== void 0) {
    baseObject[overrideKey] = overrideValue;
  }
}
function overrideConfigProperties(baseObject, overrideObject) {
  if (overrideObject) {
    for (const key in overrideObject) {
      overrideProperty(baseObject, key, overrideObject[key]);
    }
  }
}
function mergeConfigProperties(baseObject, mergeObject) {
  if (mergeObject) {
    for (const key in mergeObject) {
      const mergeValue = mergeObject[key];
      if (mergeValue !== void 0) {
        baseObject[key] = (baseObject[key] || []).concat(mergeValue);
      }
    }
  }
}
function extendTailwindMerge(configExtension, ...createConfig) {
  return typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
}
function cn(...inputs) {
  const customTwMerge = extendTailwindMerge({ prefix: "ui-" });
  return customTwMerge(clsx(inputs));
}

// node_modules/@burnt-labs/ui/dist/chunk-QYUCWCCP.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-TVNGZYGC.mjs
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var BrowserIcon = ({ className }) => {
  return (0, import_jsx_runtime3.jsxs)(
    "svg",
    {
      width: "160",
      height: "104",
      viewBox: "0 0 160 104",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: cn("ui-h-28 ui-w-40", className),
      children: [
        (0, import_jsx_runtime3.jsx)(
          "rect",
          {
            width: "159.467",
            height: "104",
            rx: "12",
            fill: "white",
            fillOpacity: "0.2"
          }
        ),
        (0, import_jsx_runtime3.jsx)(
          "rect",
          {
            x: "0.5",
            y: "0.5",
            width: "158.467",
            height: "103",
            rx: "11.5",
            stroke: "white",
            strokeOpacity: "0.4"
          }
        ),
        (0, import_jsx_runtime3.jsx)(
          "circle",
          {
            cx: "12.1334",
            cy: "6.93203",
            r: "2.6",
            fill: "white",
            fillOpacity: "0.4"
          }
        ),
        (0, import_jsx_runtime3.jsx)(
          "circle",
          {
            cx: "22.5333",
            cy: "6.93203",
            r: "2.6",
            fill: "white",
            fillOpacity: "0.4"
          }
        ),
        (0, import_jsx_runtime3.jsx)(
          "circle",
          {
            cx: "32.9333",
            cy: "6.93203",
            r: "2.6",
            fill: "white",
            fillOpacity: "0.4"
          }
        ),
        (0, import_jsx_runtime3.jsx)(
          "line",
          {
            y1: "12.5",
            x2: "159.467",
            y2: "12.5",
            stroke: "white",
            strokeOpacity: "0.4"
          }
        )
      ]
    }
  );
};

// node_modules/@burnt-labs/ui/dist/chunk-HZWJQRFF.mjs
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-QGGQGAAU.mjs
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-UGJJFASK.mjs
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-3KRXX5TC.mjs
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-KZ3C2OHV.mjs
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-BTRAYQSX.mjs
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-HDVGNCI7.mjs
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-HCWJO67P.mjs
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var Button = (_a2) => {
  var _b = _a2, {
    fullWidth = false,
    structure = "base",
    disabled = false,
    onClick,
    children,
    className
  } = _b, props = __objRest(_b, [
    "fullWidth",
    "structure",
    "disabled",
    "onClick",
    "children",
    "className"
  ]);
  const getButtonClasses = () => {
    if (disabled) {
      switch (structure) {
        case "outlined":
          return "ui-bg-transparent ui-border ui-border-neutral-600 ui-text-neutral-600 ui-pointer-events-none";
        case "naked":
          return "ui-border-none ui-bg-transparent ui-text-white/60 ui-underline ui-font-normal ui-pointer-events-none";
        case "destructive":
          return "ui-bg-red-500/60 ui-text-white hover:ui-bg-red-600 ui-pointer-events-none";
        default:
          return "ui-bg-white/60 ui-text-black ui-pointer-events-none";
      }
    }
    switch (structure) {
      case "outlined":
        return "ui-border ui-bg-transparent ui-border-neutral-300 ui-border-opacity-50 ui-text-white hover:ui-bg-white/5";
      case "naked":
        return "ui-border-none ui-bg-transparent ui-text-white ui-underline ui-font-normal";
      case "destructive":
        return "ui-bg-red-500 ui-text-white hover:ui-bg-red-400";
      case "destructive-outline":
        return "ui-border ui-border-red-500 ui-bg-transparent ui-text-red-500 hover:ui-bg-red-500/5";
      default:
        return "ui-bg-white ui-text-black hover:ui-bg-neutral-100";
    }
  };
  return (0, import_jsx_runtime11.jsx)(
    "button",
    __spreadProps(__spreadValues({
      className: `ui-flex ui-items-center ui-justify-center ui-rounded-md ui-font-akkuratLL ui-uppercase ui-px-5 ui-py-3.5 ui-text-sm ui-outline-none ui-hover:opacity-70 ${fullWidth ? "ui-w-full" : ""} ${getButtonClasses()} ${className}`,
      onClick
    }, props), {
      children
    })
  );
};

// node_modules/@burnt-labs/ui/dist/chunk-ILLY3M2B.mjs
var import_dist202 = __toESM(require_dist(), 1);
var import_dist203 = __toESM(require_dist2(), 1);
var import_dist204 = __toESM(require_dist3(), 1);
var React27 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_dist196 = __toESM(require_dist(), 1);
var import_dist197 = __toESM(require_dist2(), 1);
var import_dist198 = __toESM(require_dist3(), 1);
var React25 = __toESM(require_react(), 1);

// node_modules/@radix-ui/primitive/dist/index.mjs
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);
var React = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}

// node_modules/@radix-ui/react-context/dist/index.mjs
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
function createContext2(rootComponentName, defaultContext) {
  const Context = React2.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = React2.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime12.jsx)(Context.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React2.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React2.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      var _a2;
      const { scope, children, ...context } = props;
      const Context = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
      const value = React2.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime12.jsx)(Context.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      var _a2;
      const Context = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
      const context = React2.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React2.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React2.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React2.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// node_modules/@radix-ui/react-id/dist/index.mjs
var import_dist52 = __toESM(require_dist(), 1);
var import_dist53 = __toESM(require_dist2(), 1);
var import_dist54 = __toESM(require_dist3(), 1);
var React4 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var import_dist49 = __toESM(require_dist(), 1);
var import_dist50 = __toESM(require_dist2(), 1);
var import_dist51 = __toESM(require_dist3(), 1);
var React3 = __toESM(require_react(), 1);
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React3.useLayoutEffect : () => {
};

// node_modules/@radix-ui/react-id/dist/index.mjs
var useReactId = React4["useId".toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React4.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var import_dist58 = __toESM(require_dist(), 1);
var import_dist59 = __toESM(require_dist2(), 1);
var import_dist60 = __toESM(require_dist3(), 1);
var React6 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var import_dist55 = __toESM(require_dist(), 1);
var import_dist56 = __toESM(require_dist2(), 1);
var import_dist57 = __toESM(require_dist3(), 1);
var React5 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React5.useRef(callback);
  React5.useEffect(() => {
    callbackRef.current = callback;
  });
  return React5.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef(onChange);
  const setValue = React6.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React6.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React6.useRef(value);
  const handleChange = useCallbackRef(onChange);
  React6.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);
var React10 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);
var React8 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_dist61 = __toESM(require_dist(), 1);
var import_dist62 = __toESM(require_dist2(), 1);
var import_dist63 = __toESM(require_dist3(), 1);
var React7 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var Slot = React7.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React7.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React7.Children.count(newElement) > 1) return React7.Children.only(null);
        return React7.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return (0, import_jsx_runtime13.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React7.isValidElement(newElement) ? React7.cloneElement(newElement, void 0, newChildren) : null });
  }
  return (0, import_jsx_runtime13.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React7.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React7.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    return React7.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return React7.Children.count(children) > 1 ? React7.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return (0, import_jsx_runtime13.jsx)(import_jsx_runtime13.Fragment, { children });
};
function isSlottable(child) {
  return React7.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a2, _b;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = React8.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime14.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}

// node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var import_dist67 = __toESM(require_dist(), 1);
var import_dist68 = __toESM(require_dist2(), 1);
var import_dist69 = __toESM(require_dist3(), 1);
var React9 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React9.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React10.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React10.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React10.useContext(DismissableLayerContext);
    const [node, setNode] = React10.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React10.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React10.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React10.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React10.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime15.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React10.forwardRef((props, forwardedRef) => {
  const context = React10.useContext(DismissableLayerContext);
  const ref = React10.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React10.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime15.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React10.useRef(false);
  const handleClickRef = React10.useRef(() => {
  });
  React10.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React10.useRef(false);
  React10.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var import_dist73 = __toESM(require_dist(), 1);
var import_dist74 = __toESM(require_dist2(), 1);
var import_dist75 = __toESM(require_dist3(), 1);
var React11 = __toESM(require_react(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React11.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React11.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React11.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React11.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React11.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React11.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React11.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime16.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a2;
      stack = arrayRemove(stack, focusScope);
      (_a2 = stack[0]) == null ? void 0 : _a2.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/@radix-ui/react-portal/dist/index.mjs
var import_dist76 = __toESM(require_dist(), 1);
var import_dist77 = __toESM(require_dist2(), 1);
var import_dist78 = __toESM(require_dist3(), 1);
var React12 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React12.forwardRef((props, forwardedRef) => {
  var _a2;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React12.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body);
  return container ? import_react_dom.default.createPortal((0, import_jsx_runtime17.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// node_modules/@radix-ui/react-presence/dist/index.mjs
var import_dist79 = __toESM(require_dist(), 1);
var import_dist80 = __toESM(require_dist2(), 1);
var import_dist81 = __toESM(require_dist3(), 1);
var React22 = __toESM(require_react(), 1);
var React13 = __toESM(require_react(), 1);
function useStateMachine(initialState, machine) {
  return React13.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React22.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React22.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React22.useState();
  const stylesRef = React22.useRef({});
  const prevPresentRef = React22.useRef(present);
  const prevAnimationNameRef = React22.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React22.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React22.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef2(element) {
  var _a2, _b;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);
var React14 = __toESM(require_react(), 1);
var count2 = 0;
function useFocusGuards() {
  React14.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// node_modules/react-remove-scroll/dist/es2015/index.js
var import_dist190 = __toESM(require_dist());
var import_dist191 = __toESM(require_dist2());
var import_dist192 = __toESM(require_dist3());

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var import_dist187 = __toESM(require_dist());
var import_dist188 = __toESM(require_dist2());
var import_dist189 = __toESM(require_dist3());

// node_modules/tslib/tslib.es6.mjs
var import_dist85 = __toESM(require_dist(), 1);
var import_dist86 = __toESM(require_dist2(), 1);
var import_dist87 = __toESM(require_dist3(), 1);
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React24 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var import_dist148 = __toESM(require_dist());
var import_dist149 = __toESM(require_dist2());
var import_dist150 = __toESM(require_dist3());
var React19 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var import_dist88 = __toESM(require_dist());
var import_dist89 = __toESM(require_dist2());
var import_dist90 = __toESM(require_dist3());
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/index.js
var import_dist115 = __toESM(require_dist());
var import_dist116 = __toESM(require_dist2());
var import_dist117 = __toESM(require_dist3());

// node_modules/use-callback-ref/dist/es2015/assignRef.js
var import_dist91 = __toESM(require_dist());
var import_dist92 = __toESM(require_dist2());
var import_dist93 = __toESM(require_dist3());
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_dist94 = __toESM(require_dist());
var import_dist95 = __toESM(require_dist2());
var import_dist96 = __toESM(require_dist3());
var import_react = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/createRef.js
var import_dist97 = __toESM(require_dist());
var import_dist98 = __toESM(require_dist2());
var import_dist99 = __toESM(require_dist3());

// node_modules/use-callback-ref/dist/es2015/mergeRef.js
var import_dist100 = __toESM(require_dist());
var import_dist101 = __toESM(require_dist2());
var import_dist102 = __toESM(require_dist3());

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var import_dist103 = __toESM(require_dist());
var import_dist104 = __toESM(require_dist2());
var import_dist105 = __toESM(require_dist3());
var React15 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React15.useLayoutEffect : React15.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-callback-ref/dist/es2015/useTransformRef.js
var import_dist106 = __toESM(require_dist());
var import_dist107 = __toESM(require_dist2());
var import_dist108 = __toESM(require_dist3());

// node_modules/use-callback-ref/dist/es2015/transformRef.js
var import_dist109 = __toESM(require_dist());
var import_dist110 = __toESM(require_dist2());
var import_dist111 = __toESM(require_dist3());

// node_modules/use-callback-ref/dist/es2015/refToCallback.js
var import_dist112 = __toESM(require_dist());
var import_dist113 = __toESM(require_dist2());
var import_dist114 = __toESM(require_dist3());

// node_modules/react-remove-scroll/dist/es2015/medium.js
var import_dist145 = __toESM(require_dist());
var import_dist146 = __toESM(require_dist2());
var import_dist147 = __toESM(require_dist3());

// node_modules/use-sidecar/dist/es2015/index.js
var import_dist142 = __toESM(require_dist());
var import_dist143 = __toESM(require_dist2());
var import_dist144 = __toESM(require_dist3());

// node_modules/use-sidecar/dist/es2015/hoc.js
var import_dist127 = __toESM(require_dist());
var import_dist128 = __toESM(require_dist2());
var import_dist129 = __toESM(require_dist3());
var React16 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_dist124 = __toESM(require_dist());
var import_dist125 = __toESM(require_dist2());
var import_dist126 = __toESM(require_dist3());
var import_react2 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/env.js
var import_dist121 = __toESM(require_dist());
var import_dist122 = __toESM(require_dist2());
var import_dist123 = __toESM(require_dist3());

// node_modules/detect-node-es/esm/browser.js
var import_dist118 = __toESM(require_dist());
var import_dist119 = __toESM(require_dist2());
var import_dist120 = __toESM(require_dist3());

// node_modules/use-sidecar/dist/es2015/config.js
var import_dist130 = __toESM(require_dist());
var import_dist131 = __toESM(require_dist2());
var import_dist132 = __toESM(require_dist3());

// node_modules/use-sidecar/dist/es2015/medium.js
var import_dist133 = __toESM(require_dist());
var import_dist134 = __toESM(require_dist2());
var import_dist135 = __toESM(require_dist3());
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var import_dist136 = __toESM(require_dist());
var import_dist137 = __toESM(require_dist2());
var import_dist138 = __toESM(require_dist3());
var React17 = __toESM(require_react());
var import_react3 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var import_dist139 = __toESM(require_dist());
var import_dist140 = __toESM(require_dist2());
var import_dist141 = __toESM(require_dist3());
var React18 = __toESM(require_react());
var SideCar = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React18.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React19.forwardRef(function(props, parentRef) {
  var ref = React19.useRef(null);
  var _a2 = React19.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React19.createElement(
    React19.Fragment,
    null,
    enabled && React19.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React19.cloneElement(React19.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React19.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var import_dist184 = __toESM(require_dist());
var import_dist185 = __toESM(require_dist2());
var import_dist186 = __toESM(require_dist3());

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var import_dist181 = __toESM(require_dist());
var import_dist182 = __toESM(require_dist2());
var import_dist183 = __toESM(require_dist3());
var React23 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/index.js
var import_dist172 = __toESM(require_dist());
var import_dist173 = __toESM(require_dist2());
var import_dist174 = __toESM(require_dist3());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var import_dist169 = __toESM(require_dist());
var import_dist170 = __toESM(require_dist2());
var import_dist171 = __toESM(require_dist3());
var React21 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/index.js
var import_dist163 = __toESM(require_dist());
var import_dist164 = __toESM(require_dist2());
var import_dist165 = __toESM(require_dist3());

// node_modules/react-style-singleton/dist/es2015/component.js
var import_dist160 = __toESM(require_dist());
var import_dist161 = __toESM(require_dist2());
var import_dist162 = __toESM(require_dist3());

// node_modules/react-style-singleton/dist/es2015/hook.js
var import_dist157 = __toESM(require_dist());
var import_dist158 = __toESM(require_dist2());
var import_dist159 = __toESM(require_dist3());
var React20 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/singleton.js
var import_dist154 = __toESM(require_dist());
var import_dist155 = __toESM(require_dist2());
var import_dist156 = __toESM(require_dist3());

// node_modules/get-nonce/dist/es2015/index.js
var import_dist151 = __toESM(require_dist());
var import_dist152 = __toESM(require_dist2());
var import_dist153 = __toESM(require_dist3());
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React20.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic = _a2.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var import_dist166 = __toESM(require_dist());
var import_dist167 = __toESM(require_dist2());
var import_dist168 = __toESM(require_dist3());
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left), parse2(top), parse2(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React21.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b = _a2.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React21.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React21.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var import_dist175 = __toESM(require_dist());
var import_dist176 = __toESM(require_dist2());
var import_dist177 = __toESM(require_dist3());
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var import_dist178 = __toESM(require_dist());
var import_dist179 = __toESM(require_dist2());
var import_dist180 = __toESM(require_dist3());
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), scrollHeight = _a2[1], clientHeight = _a2[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React23.useRef([]);
  var touchStartRef = React23.useRef([0, 0]);
  var activeAxis = React23.useRef();
  var id = React23.useState(idCounter++)[0];
  var Style2 = React23.useState(styleSingleton)[0];
  var lastProps = React23.useRef(props);
  React23.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React23.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React23.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React23.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React23.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React23.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React23.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React23.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React23.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React23.createElement(
    React23.Fragment,
    null,
    inert ? React23.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React23.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React24.forwardRef(function(props, ref) {
  return React24.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/aria-hidden/dist/es2015/index.js
var import_dist193 = __toESM(require_dist());
var import_dist194 = __toESM(require_dist2());
var import_dist195 = __toESM(require_dist3());
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React25.useRef(null);
  const contentRef = React25.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return (0, import_jsx_runtime18.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React25.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME = "DialogTrigger";
var DialogTrigger = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return (0, import_jsx_runtime18.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
  return (0, import_jsx_runtime18.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React25.Children.map(children, (child) => (0, import_jsx_runtime18.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime18.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME2;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React25.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? (0, import_jsx_runtime18.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime18.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      (0, import_jsx_runtime18.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime18.jsx)(
        Primitive.div,
        {
          "data-state": getState(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME = "DialogContent";
var DialogContent = React25.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    return (0, import_jsx_runtime18.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime18.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime18.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME;
var DialogContentModal = React25.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const contentRef = React25.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React25.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime18.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a2;
          event.preventDefault();
          (_a2 = context.triggerRef.current) == null ? void 0 : _a2.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React25.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const hasInteractedOutsideRef = React25.useRef(false);
    const hasPointerDownOutsideRef = React25.useRef(false);
    return (0, import_jsx_runtime18.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a2, _b;
          (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2, _b;
          (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, __scopeDialog);
    const contentRef = React25.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [
      (0, import_jsx_runtime18.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: (0, import_jsx_runtime18.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [
        (0, import_jsx_runtime18.jsx)(TitleWarning, { titleId: context.titleId }),
        (0, import_jsx_runtime18.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return (0, import_jsx_runtime18.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return (0, import_jsx_runtime18.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return (0, import_jsx_runtime18.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React25.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React25.useEffect(() => {
    var _a2;
    const describedById = (_a2 = contentRef.current) == null ? void 0 : _a2.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root = Dialog;
var Portal2 = DialogPortal;
var Overlay = DialogOverlay;
var Content = DialogContent;
var Title = DialogTitle;
var Description = DialogDescription;

// node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var import_dist199 = __toESM(require_dist(), 1);
var import_dist200 = __toESM(require_dist2(), 1);
var import_dist201 = __toESM(require_dist3(), 1);
var React26 = __toESM(require_react(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var NAME = "VisuallyHidden";
var VisuallyHidden = React26.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime19.jsx)(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME;
var Root2 = VisuallyHidden;

// node_modules/@burnt-labs/ui/dist/chunk-ILLY3M2B.mjs
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var Dialog2 = Root;
var DialogPortal2 = Portal2;
var DialogOverlay2 = React27.forwardRef((_a2, ref) => {
  var _b = _a2, { className } = _b, props = __objRest(_b, ["className"]);
  return (0, import_jsx_runtime20.jsx)(
    Overlay,
    __spreadValues({
      className: cn(
        "ui-fixed ui-inset-0 ui-z-50 ui-backdrop-blur-lg ui-bg-black/80 ui-data-[state=open]:ui-animate-in ui-data-[state=closed]:ui-animate-out ui-data-[state=closed]:ui-fade-out-0 ui-data-[state=open]:ui-fade-in-0",
        className
      ),
      ref
    }, props)
  );
});
DialogOverlay2.displayName = Overlay.displayName;
var DialogContent2 = React27.forwardRef((_a2, ref) => {
  var _b = _a2, { className, children } = _b, props = __objRest(_b, ["className", "children"]);
  return (0, import_jsx_runtime20.jsxs)(DialogPortal2, { children: [
    (0, import_jsx_runtime20.jsx)(DialogOverlay2, {}),
    (0, import_jsx_runtime20.jsx)("div", { className: "ui-absolute ui-h-screen ui-w-screen ui-inset-0 ui-bg-modal-overlay ui-backdrop-blur-3xl ui-opacity-40 ui-bg-no-repeat ui-bg-cover ui-bg-center ui-bg-fixed ui-z-50" }),
    (0, import_jsx_runtime20.jsxs)(
      Content,
      __spreadProps(__spreadValues({
        "aria-describedby": void 0,
        className: cn(
          "ui-z-50 ui-fixed ui-grid ui-w-full ui-max-w-lg ui-gap-4 ui-p-10 ui-duration-200 sm:ui-rounded-[48px] ui-left-[50%] ui-top-[50%] sm:ui-bg-black/20 !ui-flex ui-justify-center ui-flex-col sm:ui-block sm:ui-flex-none ui-h-screen sm:ui-h-auto sm:ui-backdrop-blur-2xl ui-data-[state=open]:ui-animate-in ui-data-[state=closed]:ui-animate-out ui-data-[state=closed]:ui-fade-out-0 ui-data-[state=open]:ui-fade-in-0 ui-data-[state=closed]:ui-zoom-out-95 ui-data-[state=open]:ui-zoom-in-95 ui-data-[state=closed]:ui-slide-out-to-left-1/2 ui-data-[state=closed]:ui-slide-out-to-top-[48%] ui-data-[state=open]:ui-slide-in-from-left-1/2 ui-data-[state=open]:ui-slide-in-from-top-[48%] ui-translate-x-[-50%] ui-translate-y-[-50%]",
          className
        ),
        ref
      }, props), {
        children: [
          (0, import_jsx_runtime20.jsx)(Root2, { children: (0, import_jsx_runtime20.jsx)(Title, {}) }),
          children
        ]
      })
    )
  ] });
});
DialogContent2.displayName = Content.displayName;
function DialogHeader(_a2) {
  var _b = _a2, {
    className
  } = _b, props = __objRest(_b, [
    "className"
  ]);
  return (0, import_jsx_runtime20.jsx)(
    "div",
    __spreadValues({
      className: cn(
        "ui-flex ui-flex-col ui-space-y-1.5 ui-text-center sm:ui-text-left",
        className
      )
    }, props)
  );
}
DialogHeader.displayName = "DialogHeader";
function DialogFooter(_a2) {
  var _b = _a2, {
    className
  } = _b, props = __objRest(_b, [
    "className"
  ]);
  return (0, import_jsx_runtime20.jsx)(
    "div",
    __spreadValues({
      className: cn(
        "ui-flex ui-flex-col-reverse sm:ui-flex-row sm:ui-justify-end sm:ui-space-x-2",
        className
      )
    }, props)
  );
}
DialogFooter.displayName = "DialogFooter";
var DialogTitle2 = React27.forwardRef((_a2, ref) => {
  var _b = _a2, { className } = _b, props = __objRest(_b, ["className"]);
  return (0, import_jsx_runtime20.jsx)(
    Title,
    __spreadValues({
      className: cn(
        "ui-text-lg ui-font-semibold ui-leading-none ui-tracking-tight",
        className
      ),
      ref
    }, props)
  );
});
DialogTitle2.displayName = Title.displayName;
var DialogDescription2 = React27.forwardRef((_a2, ref) => {
  var _b = _a2, { className } = _b, props = __objRest(_b, ["className"]);
  return (0, import_jsx_runtime20.jsx)(
    Description,
    __spreadValues({
      className: cn("ui-text-neutral-500 ui-text-sm", className),
      ref
    }, props)
  );
});
DialogDescription2.displayName = Description.displayName;

// node_modules/@burnt-labs/ui/dist/chunk-UAKLV4YM.mjs
var import_dist205 = __toESM(require_dist(), 1);
var import_dist206 = __toESM(require_dist2(), 1);
var import_dist207 = __toESM(require_dist3(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-BLQX3BET.mjs
var import_dist208 = __toESM(require_dist(), 1);
var import_dist209 = __toESM(require_dist2(), 1);
var import_dist210 = __toESM(require_dist3(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var ModalAnchor = (0, import_react5.forwardRef)(
  (_a2, ref) => {
    var _b = _a2, { className, children } = _b, props = __objRest(_b, ["className", "children"]);
    return (0, import_jsx_runtime22.jsxs)(
      "div",
      __spreadProps(__spreadValues({
        className: cn(
          "ui-flex ui-p-4 ui-justify-center ui-items-center ui-fixed ui-inset-0 ui-h-screen ui-w-screen ui-z-[999]",
          className
        ),
        ref
      }, props), {
        children: [
          (0, import_jsx_runtime22.jsx)("div", { className: "ui-absolute ui-z-[999] ui-inset-0 ui-bg-modal-overlay ui-blur-md ui-bg-no-repeat ui-bg-cover ui-bg-center ui-bg-fixed ui-opacity-70" }),
          children
        ]
      })
    );
  }
);
ModalAnchor.displayName = "ModalAnchor";
function ModalSection(_a2) {
  var _b = _a2, {
    className,
    children
  } = _b, props = __objRest(_b, [
    "className",
    "children"
  ]);
  return (0, import_jsx_runtime22.jsx)(
    "div",
    __spreadProps(__spreadValues({
      className: cn(
        "ui-inline-flex ui-w-full ui-h-full ui-flex-col ui-items-start ui-justify-between ui-gap-8",
        className
      )
    }, props), {
      children
    })
  );
}

// node_modules/@burnt-labs/ui/dist/chunk-VSTH5YAB.mjs
var import_dist211 = __toESM(require_dist(), 1);
var import_dist212 = __toESM(require_dist2(), 1);
var import_dist213 = __toESM(require_dist3(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/ui/dist/chunk-ZVGFBZIM.mjs
var import_dist244 = __toESM(require_dist(), 1);
var import_dist245 = __toESM(require_dist2(), 1);
var import_dist246 = __toESM(require_dist3(), 1);
var React34 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-popover/dist/index.mjs
var import_dist241 = __toESM(require_dist(), 1);
var import_dist242 = __toESM(require_dist2(), 1);
var import_dist243 = __toESM(require_dist3(), 1);
var React33 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-popper/dist/index.mjs
var import_dist238 = __toESM(require_dist(), 1);
var import_dist239 = __toESM(require_dist2(), 1);
var import_dist240 = __toESM(require_dist3(), 1);
var React32 = __toESM(require_react(), 1);

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var import_dist226 = __toESM(require_dist(), 1);
var import_dist227 = __toESM(require_dist2(), 1);
var import_dist228 = __toESM(require_dist3(), 1);

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
var import_dist223 = __toESM(require_dist(), 1);
var import_dist224 = __toESM(require_dist2(), 1);
var import_dist225 = __toESM(require_dist3(), 1);

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
var import_dist217 = __toESM(require_dist(), 1);
var import_dist218 = __toESM(require_dist2(), 1);
var import_dist219 = __toESM(require_dist3(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var import_dist214 = __toESM(require_dist(), 1);
var import_dist215 = __toESM(require_dist2(), 1);
var import_dist216 = __toESM(require_dist3(), 1);
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
var import_dist220 = __toESM(require_dist(), 1);
var import_dist221 = __toESM(require_dist2(), 1);
var import_dist222 = __toESM(require_dist3(), 1);
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector2) => {
    try {
      return element.matches(selector2);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result2 = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result2) ? result2.host : result2;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result2 = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result2 = result2.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result2);
  return result2;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React28 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);
var index = typeof document !== "undefined" ? import_react7.useLayoutEffect : import_react7.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React28.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React28.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React28.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React28.useState(null);
  const [_floating, _setFloating] = React28.useState(null);
  const setReference = React28.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React28.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React28.useRef(null);
  const floatingRef = React28.useRef(null);
  const dataRef = React28.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React28.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM3.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React28.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React28.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React28.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React28.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React28.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// node_modules/@radix-ui/react-arrow/dist/index.mjs
var import_dist229 = __toESM(require_dist(), 1);
var import_dist230 = __toESM(require_dist2(), 1);
var import_dist231 = __toESM(require_dist3(), 1);
var React29 = __toESM(require_react(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var NAME2 = "Arrow";
var Arrow = React29.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return (0, import_jsx_runtime24.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : (0, import_jsx_runtime24.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME2;
var Root3 = Arrow;

// node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-context/dist/index.mjs
var import_dist232 = __toESM(require_dist(), 1);
var import_dist233 = __toESM(require_dist2(), 1);
var import_dist234 = __toESM(require_dist3(), 1);
var React30 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function createContextScope2(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React30.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = React30.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime25.jsx)(Context.Provider, { value, children });
    }
    function useContext22(consumerName, scope) {
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = React30.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React30.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React30.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes2(createScope, ...createContextScopeDeps)];
}
function composeContextScopes2(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React30.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// node_modules/@radix-ui/react-use-size/dist/index.mjs
var import_dist235 = __toESM(require_dist(), 1);
var import_dist236 = __toESM(require_dist2(), 1);
var import_dist237 = __toESM(require_dist3(), 1);
var React31 = __toESM(require_react(), 1);
function useSize(element) {
  const [size4, setSize] = React31.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope2(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React32.useState(null);
  return (0, import_jsx_runtime26.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React32.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React32.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React32.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : (0, import_jsx_runtime26.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME2 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME2);
var PopperContent = React32.forwardRef(
  (props, forwardedRef) => {
    var _a2, _b, _c, _d, _e, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME2, __scopePopper);
    const [content, setContent] = React32.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow4, setArrow] = React32.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a2 = middlewareData.arrow) == null ? void 0 : _a2.x;
    const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
    const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React32.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return (0, import_jsx_runtime26.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: (0, import_jsx_runtime26.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: (0, import_jsx_runtime26.jsx)(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME2;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React32.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    (0, import_jsx_runtime26.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: (0, import_jsx_runtime26.jsx)(
          Root3,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a2, _b, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a2 = middlewareData.arrow) == null ? void 0 : _a2.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root22 = Popper;
var Anchor = PopperAnchor;
var Content2 = PopperContent;
var Arrow2 = PopperArrow;

// node_modules/@radix-ui/react-popover/dist/index.mjs
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope(__scopePopover);
  const triggerRef = React33.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React33.useState(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return (0, import_jsx_runtime27.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime27.jsx)(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: React33.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: React33.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React33.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME2 = "PopoverAnchor";
var PopoverAnchor = React33.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME2, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React33.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return (0, import_jsx_runtime27.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME2;
var TRIGGER_NAME2 = "PopoverTrigger";
var PopoverTrigger = React33.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME2, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger = (0, import_jsx_runtime27.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState2(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger : (0, import_jsx_runtime27.jsx)(Anchor, { asChild: true, ...popperScope, children: trigger });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME2;
var PORTAL_NAME3 = "PopoverPortal";
var [PortalProvider2, usePortalContext2] = createPopoverContext(PORTAL_NAME3, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME3, __scopePopover);
  return (0, import_jsx_runtime27.jsx)(PortalProvider2, { scope: __scopePopover, forceMount, children: (0, import_jsx_runtime27.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime27.jsx)(Portal, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME3;
var CONTENT_NAME3 = "PopoverContent";
var PopoverContent = React33.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME3, props.__scopePopover);
    return (0, import_jsx_runtime27.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime27.jsx)(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime27.jsx)(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME3;
var PopoverContentModal = React33.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME3, props.__scopePopover);
    const contentRef = React33.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = React33.useRef(false);
    React33.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime27.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, children: (0, import_jsx_runtime27.jsx)(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a2;
          event.preventDefault();
          if (!isRightClickOutsideRef.current) (_a2 = context.triggerRef.current) == null ? void 0 : _a2.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = React33.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME3, props.__scopePopover);
    const hasInteractedOutsideRef = React33.useRef(false);
    const hasPointerDownOutsideRef = React33.useRef(false);
    return (0, import_jsx_runtime27.jsx)(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a2, _b;
          (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2, _b;
          (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = React33.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME3, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    useFocusGuards();
    return (0, import_jsx_runtime27.jsx)(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: (0, import_jsx_runtime27.jsx)(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: (0, import_jsx_runtime27.jsx)(
              Content2,
              {
                "data-state": getState2(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME2 = "PopoverClose";
var PopoverClose = React33.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME2, __scopePopover);
    return (0, import_jsx_runtime27.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME2;
var ARROW_NAME2 = "PopoverArrow";
var PopoverArrow = React33.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopePopover);
    return (0, import_jsx_runtime27.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME2;
function getState2(open) {
  return open ? "open" : "closed";
}
var Portal3 = PopoverPortal;
var Content22 = PopoverContent;
var Arrow22 = PopoverArrow;

// node_modules/@burnt-labs/ui/dist/chunk-ZVGFBZIM.mjs
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var PopoverContent2 = React34.forwardRef((_a2, forwardedRef) => {
  var _b = _a2, { className, children } = _b, props = __objRest(_b, ["className", "children"]);
  return (0, import_jsx_runtime28.jsx)(Portal3, { children: (0, import_jsx_runtime28.jsxs)(
    Content22,
    __spreadProps(__spreadValues({
      className: cn(
        "ui-rounded ui-text-white ui-z-50 ui-p-2 ui-bg-[#434040] ui-data-[state=open]:ui-data-[side=top]:ui-animate-slideDownAndFade ui-data-[state=open]:ui-data-[side=right]:ui-animate-slideLeftAndFade ui-data-[state=open]:ui-data-[side=bottom]:ui-animate-slideUpAndFade ui-data-[state=open]:ui-data-[side=left]:ui-animate-slideRightAndFade",
        className
      ),
      ref: forwardedRef
    }, props), {
      children: [
        children,
        (0, import_jsx_runtime28.jsx)(Arrow22, { className: "ui-fill-[#434040]" })
      ]
    })
  ) });
});
PopoverContent2.displayName = Content22.displayName;

// node_modules/@burnt-labs/ui/dist/chunk-ESZY3JBH.mjs
var import_dist247 = __toESM(require_dist(), 1);
var import_dist248 = __toESM(require_dist2(), 1);
var import_dist249 = __toESM(require_dist3(), 1);
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/constants/dist/index.mjs
var import_dist253 = __toESM(require_dist(), 1);
var import_dist254 = __toESM(require_dist2(), 1);
var import_dist255 = __toESM(require_dist3(), 1);
var xionCoin = {
  coinDenom: "XION",
  coinMinimalDenom: "uxion",
  coinDecimals: 6,
  gasPriceStep: {
    low: 5e-4,
    average: 1e-3,
    high: 0.01
  }
};
var xionGasValues = {
  gasPrice: "0.001uxion",
  gasAdjustment: 1.4,
  gasAdjustmentMargin: 5e3
};
var commonInfo = {
  rpc: "undefined",
  rest: "undefined",
  chainId: "base",
  chainName: "XION Testnet",
  bip44: {
    coinType: 118
  },
  bech32Config: {
    bech32PrefixAccAddr: "xion",
    bech32PrefixValAddr: "xionvaloper",
    bech32PrefixValPub: "xionvaloperpub",
    bech32PrefixAccPub: "xionpub",
    bech32PrefixConsAddr: "xionvalcons",
    bech32PrefixConsPub: "xionvalconspub"
  },
  stakeCurrency: xionCoin,
  currencies: [xionCoin],
  feeCurrencies: [xionCoin],
  features: ["cosmwasm"]
};
var mainnetChainInfo = {
  ...commonInfo,
  rpc: "https://rpc.xion-mainnet-1.burnt.com:443",
  rest: "https://api.xion-mainnet-1.burnt.com:443",
  chainId: "xion-mainnet-1",
  chainName: "XION Mainnet"
};
var testnetChainInfo = {
  ...commonInfo,
  rpc: "https://rpc.xion-testnet-1.burnt.com:443",
  rest: "https://api.xion-testnet-1.burnt.com:443",
  chainId: "xion-testnet-1",
  chainName: "XION Testnet"
};
var testChainInfo = {
  ...commonInfo,
  rpc: "http://localhost:26657",
  rest: "http://localhost:26656",
  chainId: "xion-local-testnet-1",
  chainName: "XION Testnet Local"
};
var DASHBOARD_URLS = {
  "xion-mainnet-1": "https://settings.mainnet.burnt.com",
  "xion-testnet-1": "https://settings.testnet.burnt.com"
};
var REST_URLS = {
  "xion-mainnet-1": "https://api.xion-mainnet-1.burnt.com:443",
  "xion-testnet-1": "https://api.xion-testnet-1.burnt.com:443"
};
async function fetchConfig(rpcUrl) {
  try {
    const fetchReq = await fetch(`${rpcUrl}/status`);
    if (!fetchReq.ok) {
      throw new Error("Something went wrong querying RPC");
    }
    const data = await fetchReq.json();
    const lookup = data.result.node_info.network;
    const dashboardUrl = DASHBOARD_URLS[lookup];
    const restUrl = REST_URLS[lookup];
    if (!dashboardUrl || !restUrl)
      throw new Error("Network not found.");
    return { dashboardUrl, restUrl };
  } catch (error) {
    throw error;
  }
}

// node_modules/@burnt-labs/abstraxion/dist/index.mjs
var import_stargate4 = __toESM(require_build8(), 1);
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);

// node_modules/@burnt-labs/abstraxion-core/dist/index.mjs
var import_dist856 = __toESM(require_dist(), 1);
var import_dist857 = __toESM(require_dist2(), 1);
var import_dist858 = __toESM(require_dist3(), 1);
var import_cosmwasm_stargate2 = __toESM(require_build9(), 1);
var import_stargate3 = __toESM(require_build8(), 1);
var import_tx3 = __toESM(require_tx2(), 1);
var import_tx4 = __toESM(require_tx3(), 1);
var import_tendermint_rpc2 = __toESM(require_build7(), 1);

// node_modules/@burnt-labs/signers/dist/index.mjs
var import_dist808 = __toESM(require_dist(), 1);
var import_dist809 = __toESM(require_dist2(), 1);
var import_dist810 = __toESM(require_dist3(), 1);
var import_stargate = __toESM(require_build8(), 1);
var import_stargate2 = __toESM(require_build8(), 1);
var import_bech32 = __toESM(require_dist4(), 1);
var import_tx = __toESM(require_tx2(), 1);
var import_proto_signing = __toESM(require_build6(), 1);
var import_tendermint_rpc = __toESM(require_build7(), 1);
var import_signing = __toESM(require_signing(), 1);
var import_amino = __toESM(require_build5(), 1);
var import_math = __toESM(require_build2(), 1);

// node_modules/@protobuf-ts/runtime/build/es2015/index.js
var import_dist337 = __toESM(require_dist());
var import_dist338 = __toESM(require_dist2());
var import_dist339 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js
var import_dist256 = __toESM(require_dist());
var import_dist257 = __toESM(require_dist2());
var import_dist258 = __toESM(require_dist3());
function typeofJsonValue(value) {
  let t = typeof value;
  if (t == "object") {
    if (Array.isArray(value))
      return "array";
    if (value === null)
      return "null";
  }
  return t;
}
function isJsonObject(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}

// node_modules/@protobuf-ts/runtime/build/es2015/base64.js
var import_dist259 = __toESM(require_dist());
var import_dist260 = __toESM(require_dist2());
var import_dist261 = __toESM(require_dist3());
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
function base64decode(base64Str) {
  let es = base64Str.length * 3 / 4;
  if (base64Str[base64Str.length - 2] == "=")
    es -= 2;
  else if (base64Str[base64Str.length - 1] == "=")
    es -= 1;
  let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
  for (let i = 0; i < base64Str.length; i++) {
    b = decTable[base64Str.charCodeAt(i)];
    if (b === void 0) {
      switch (base64Str[i]) {
        case "=":
          groupPos = 0;
        case "\n":
        case "\r":
        case "	":
        case " ":
          continue;
        default:
          throw Error(`invalid base64 string.`);
      }
    }
    switch (groupPos) {
      case 0:
        p = b;
        groupPos = 1;
        break;
      case 1:
        bytes[bytePos++] = p << 2 | (b & 48) >> 4;
        p = b;
        groupPos = 2;
        break;
      case 2:
        bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
        p = b;
        groupPos = 3;
        break;
      case 3:
        bytes[bytePos++] = (p & 3) << 6 | b;
        groupPos = 0;
        break;
    }
  }
  if (groupPos == 1)
    throw Error(`invalid base64 string.`);
  return bytes.subarray(0, bytePos);
}
function base64encode(bytes) {
  let base64 = "", groupPos = 0, b, p = 0;
  for (let i = 0; i < bytes.length; i++) {
    b = bytes[i];
    switch (groupPos) {
      case 0:
        base64 += encTable[b >> 2];
        p = (b & 3) << 4;
        groupPos = 1;
        break;
      case 1:
        base64 += encTable[p | b >> 4];
        p = (b & 15) << 2;
        groupPos = 2;
        break;
      case 2:
        base64 += encTable[p | b >> 6];
        base64 += encTable[b & 63];
        groupPos = 0;
        break;
    }
  }
  if (groupPos) {
    base64 += encTable[p];
    base64 += "=";
    if (groupPos == 1)
      base64 += "=";
  }
  return base64;
}

// node_modules/@protobuf-ts/runtime/build/es2015/protobufjs-utf8.js
var import_dist262 = __toESM(require_dist());
var import_dist263 = __toESM(require_dist2());
var import_dist264 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js
var import_dist265 = __toESM(require_dist());
var import_dist266 = __toESM(require_dist2());
var import_dist267 = __toESM(require_dist3());
var UnknownFieldHandler;
(function(UnknownFieldHandler2) {
  UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
  UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
    let container = is(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
    container.push({ no: fieldNo, wireType, data });
  };
  UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
    for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
      writer.tag(no, wireType).raw(data);
  };
  UnknownFieldHandler2.list = (message, fieldNo) => {
    if (is(message)) {
      let all = message[UnknownFieldHandler2.symbol];
      return fieldNo ? all.filter((uf) => uf.no == fieldNo) : all;
    }
    return [];
  };
  UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
  const is = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));

// node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js
var import_dist274 = __toESM(require_dist());
var import_dist275 = __toESM(require_dist2());
var import_dist276 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js
var import_dist271 = __toESM(require_dist());
var import_dist272 = __toESM(require_dist2());
var import_dist273 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js
var import_dist268 = __toESM(require_dist());
var import_dist269 = __toESM(require_dist2());
var import_dist270 = __toESM(require_dist3());
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift4 = 0; shift4 < 28; shift4 += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift4;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift4 = 3; shift4 <= 31; shift4 += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift4;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift4 = lo >>> i;
    const hasNext = !(shift4 >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift4 | 128 : shift4) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift4 = hi >>> i;
    const hasNext = !(shift4 >>> 7 == 0);
    const byte = (hasNext ? shift4 | 128 : shift4) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
function int64fromString(dec) {
  let minus = dec[0] == "-";
  if (minus)
    dec = dec.slice(1);
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return [minus, lowBits, highBits];
}
function int64toString(bitsLow, bitsHigh) {
  if (bitsHigh >>> 0 <= 2097151) {
    return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
  }
  let low = bitsLow & 16777215;
  let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  let high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  let base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    let partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  return decimalFrom1e7(
    digitC,
    /*needLeadingZeros=*/
    0
  ) + decimalFrom1e7(
    digitB,
    /*needLeadingZeros=*/
    digitC
  ) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  decimalFrom1e7(
    digitA,
    /*needLeadingZeros=*/
    1
  );
}
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result2 = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result2;
  }
  b = this.buf[this.pos++];
  result2 |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result2;
  }
  b = this.buf[this.pos++];
  result2 |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result2;
  }
  b = this.buf[this.pos++];
  result2 |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result2;
  }
  b = this.buf[this.pos++];
  result2 |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result2 >>> 0;
}

// node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js
var BI;
function detectBi() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = globalThis.BigInt !== void 0 && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
  BI = ok ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: dv
  } : void 0;
}
detectBi();
function assertBi(bi) {
  if (!bi)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
var RE_DECIMAL_STR = /^-?[0-9]+$/;
var TWO_PWR_32_DBL2 = 4294967296;
var HALF_2_PWR_32 = 2147483648;
var SharedPbLong = class {
  /**
   * Create a new instance with the given bits.
   */
  constructor(lo, hi) {
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Is this instance equal to 0?
   */
  isZero() {
    return this.lo == 0 && this.hi == 0;
  }
  /**
   * Convert to a native number.
   */
  toNumber() {
    let result2 = this.hi * TWO_PWR_32_DBL2 + (this.lo >>> 0);
    if (!Number.isSafeInteger(result2))
      throw new Error("cannot convert to safe number");
    return result2;
  }
};
var PbULong = class _PbULong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.UMIN)
            throw new Error("signed value for ulong");
          if (value > BI.UMAX)
            throw new Error("ulong too large");
          BI.V.setBigUint64(0, value, true);
          return new _PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi] = int64fromString(value);
          if (minus)
            throw new Error("signed value for ulong");
          return new _PbULong(lo, hi);
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          if (value < 0)
            throw new Error("signed value for ulong");
          return new _PbULong(value, value / TWO_PWR_32_DBL2);
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigUint64(0, true);
  }
};
PbULong.ZERO = new PbULong(0, 0);
var PbLong = class _PbLong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.MIN)
            throw new Error("signed long too small");
          if (value > BI.MAX)
            throw new Error("signed long too large");
          BI.V.setBigInt64(0, value, true);
          return new _PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi] = int64fromString(value);
          if (minus) {
            if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0)
              throw new Error("signed long too small");
          } else if (hi >= HALF_2_PWR_32)
            throw new Error("signed long too large");
          let pbl = new _PbLong(lo, hi);
          return minus ? pbl.negate() : pbl;
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          return value > 0 ? new _PbLong(value, value / TWO_PWR_32_DBL2) : new _PbLong(-value, -value / TWO_PWR_32_DBL2).negate();
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Do we have a minus sign?
   */
  isNegative() {
    return (this.hi & HALF_2_PWR_32) !== 0;
  }
  /**
   * Negate two's complement.
   * Invert all the bits and add one to the result.
   */
  negate() {
    let hi = ~this.hi, lo = this.lo;
    if (lo)
      lo = ~lo + 1;
    else
      hi += 1;
    return new _PbLong(lo, hi);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    if (BI)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let n = this.negate();
      return "-" + int64toString(n.lo, n.hi);
    }
    return int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigInt64(0, true);
  }
};
PbLong.ZERO = new PbLong(0, 0);

// node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js
var defaultsRead = {
  readUnknownField: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
function binaryReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
var BinaryReader = class {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
      fatal: true,
      ignoreBOM: true
    });
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(wireType) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        let t;
        while ((t = this.tag()[1]) !== WireType.EndGroup) {
          this.skip(t);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return new PbLong(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return new PbULong(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return new PbLong(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return new PbULong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return new PbLong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32();
    let start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js
var import_dist280 = __toESM(require_dist());
var import_dist281 = __toESM(require_dist2());
var import_dist282 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/assert.js
var import_dist277 = __toESM(require_dist());
var import_dist278 = __toESM(require_dist2());
var import_dist279 = __toESM(require_dist3());
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}

// node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js
var defaultsWrite = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function binaryWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
var BinaryWriter = class {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset4 = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset4);
      offset4 += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.textEncoder.encode(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8);
    let view = new DataView(chunk.buffer);
    let long = PbLong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8);
    let view = new DataView(chunk.buffer);
    let long = PbULong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let long = PbLong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let long = PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi = (long.hi << 1 | long.lo >>> 31) ^ sign;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let long = PbULong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js
var import_dist283 = __toESM(require_dist());
var import_dist284 = __toESM(require_dist2());
var import_dist285 = __toESM(require_dist3());
var defaultsWrite2 = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
var defaultsRead2 = {
  ignoreUnknownFields: false
};
function jsonReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead2), options) : defaultsRead2;
}
function jsonWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite2), options) : defaultsWrite2;
}

// node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js
var import_dist286 = __toESM(require_dist());
var import_dist287 = __toESM(require_dist2());
var import_dist288 = __toESM(require_dist3());
var MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");

// node_modules/@protobuf-ts/runtime/build/es2015/message-type.js
var import_dist328 = __toESM(require_dist());
var import_dist329 = __toESM(require_dist2());
var import_dist330 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js
var import_dist292 = __toESM(require_dist());
var import_dist293 = __toESM(require_dist2());
var import_dist294 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js
var import_dist289 = __toESM(require_dist());
var import_dist290 = __toESM(require_dist2());
var import_dist291 = __toESM(require_dist3());
function lowerCamelCase(snakeCase) {
  let capNext = false;
  const sb = [];
  for (let i = 0; i < snakeCase.length; i++) {
    let next = snakeCase.charAt(i);
    if (next == "_") {
      capNext = true;
    } else if (/\d/.test(next)) {
      sb.push(next);
      capNext = true;
    } else if (capNext) {
      sb.push(next.toUpperCase());
      capNext = false;
    } else if (i == 0) {
      sb.push(next.toLowerCase());
    } else {
      sb.push(next);
    }
  }
  return sb.join("");
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
  LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
var RepeatType;
(function(RepeatType2) {
  RepeatType2[RepeatType2["NO"] = 0] = "NO";
  RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
  RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
function normalizeFieldInfo(field) {
  var _a2, _b, _c, _d;
  field.localName = (_a2 = field.localName) !== null && _a2 !== void 0 ? _a2 : lowerCamelCase(field.name);
  field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
  field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
  field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
  return field;
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js
var import_dist298 = __toESM(require_dist());
var import_dist299 = __toESM(require_dist2());
var import_dist300 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/oneof.js
var import_dist295 = __toESM(require_dist());
var import_dist296 = __toESM(require_dist2());
var import_dist297 = __toESM(require_dist3());
function isOneofGroup(any) {
  if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
    return false;
  }
  switch (typeof any.oneofKind) {
    case "string":
      if (any[any.oneofKind] === void 0)
        return false;
      return Object.keys(any).length == 2;
    case "undefined":
      return Object.keys(any).length == 1;
    default:
      return false;
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js
var ReflectionTypeCheck = class {
  constructor(info) {
    var _a2;
    this.fields = (_a2 = info.fields) !== null && _a2 !== void 0 ? _a2 : [];
  }
  prepare() {
    if (this.data)
      return;
    const req = [], known = [], oneofs = [];
    for (let field of this.fields) {
      if (field.oneof) {
        if (!oneofs.includes(field.oneof)) {
          oneofs.push(field.oneof);
          req.push(field.oneof);
          known.push(field.oneof);
        }
      } else {
        known.push(field.localName);
        switch (field.kind) {
          case "scalar":
          case "enum":
            if (!field.opt || field.repeat)
              req.push(field.localName);
            break;
          case "message":
            if (field.repeat)
              req.push(field.localName);
            break;
          case "map":
            req.push(field.localName);
            break;
        }
      }
    }
    this.data = { req, known, oneofs: Object.values(oneofs) };
  }
  /**
   * Is the argument a valid message as specified by the
   * reflection information?
   *
   * Checks all field types recursively. The `depth`
   * specifies how deep into the structure the check will be.
   *
   * With a depth of 0, only the presence of fields
   * is checked.
   *
   * With a depth of 1 or more, the field types are checked.
   *
   * With a depth of 2 or more, the members of map, repeated
   * and message fields are checked.
   *
   * Message fields will be checked recursively with depth - 1.
   *
   * The number of map entries / repeated values being checked
   * is < depth.
   */
  is(message, depth, allowExcessProperties = false) {
    if (depth < 0)
      return true;
    if (message === null || message === void 0 || typeof message != "object")
      return false;
    this.prepare();
    let keys = Object.keys(message), data = this.data;
    if (keys.length < data.req.length || data.req.some((n) => !keys.includes(n)))
      return false;
    if (!allowExcessProperties) {
      if (keys.some((k) => !data.known.includes(k)))
        return false;
    }
    if (depth < 1) {
      return true;
    }
    for (const name of data.oneofs) {
      const group = message[name];
      if (!isOneofGroup(group))
        return false;
      if (group.oneofKind === void 0)
        continue;
      const field = this.fields.find((f) => f.localName === group.oneofKind);
      if (!field)
        return false;
      if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
        return false;
    }
    for (const field of this.fields) {
      if (field.oneof !== void 0)
        continue;
      if (!this.field(message[field.localName], field, allowExcessProperties, depth))
        return false;
    }
    return true;
  }
  field(arg, field, allowExcessProperties, depth) {
    let repeated = field.repeat;
    switch (field.kind) {
      case "scalar":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, field.T, depth, field.L);
        return this.scalar(arg, field.T, field.L);
      case "enum":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, ScalarType.INT32, depth);
        return this.scalar(arg, ScalarType.INT32);
      case "message":
        if (arg === void 0)
          return true;
        if (repeated)
          return this.messages(arg, field.T(), allowExcessProperties, depth);
        return this.message(arg, field.T(), allowExcessProperties, depth);
      case "map":
        if (typeof arg != "object" || arg === null)
          return false;
        if (depth < 2)
          return true;
        if (!this.mapKeys(arg, field.K, depth))
          return false;
        switch (field.V.kind) {
          case "scalar":
            return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
          case "enum":
            return this.scalars(Object.values(arg), ScalarType.INT32, depth);
          case "message":
            return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
        }
        break;
    }
    return true;
  }
  message(arg, type, allowExcessProperties, depth) {
    if (allowExcessProperties) {
      return type.isAssignable(arg, depth);
    }
    return type.is(arg, depth);
  }
  messages(arg, type, allowExcessProperties, depth) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (allowExcessProperties) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type.isAssignable(arg[i], depth - 1))
          return false;
    } else {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type.is(arg[i], depth - 1))
          return false;
    }
    return true;
  }
  scalar(arg, type, longType) {
    let argType = typeof arg;
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        switch (longType) {
          case LongType.BIGINT:
            return argType == "bigint";
          case LongType.NUMBER:
            return argType == "number" && !isNaN(arg);
          default:
            return argType == "string";
        }
      case ScalarType.BOOL:
        return argType == "boolean";
      case ScalarType.STRING:
        return argType == "string";
      case ScalarType.BYTES:
        return arg instanceof Uint8Array;
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return argType == "number" && !isNaN(arg);
      default:
        return argType == "number" && Number.isInteger(arg);
    }
  }
  scalars(arg, type, depth, longType) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (Array.isArray(arg)) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!this.scalar(arg[i], type, longType))
          return false;
    }
    return true;
  }
  mapKeys(map, type, depth) {
    let keys = Object.keys(map);
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        return this.scalars(keys.slice(0, depth).map((k) => parseInt(k)), type, depth);
      case ScalarType.BOOL:
        return this.scalars(keys.slice(0, depth).map((k) => k == "true" ? true : k == "false" ? false : k), type, depth);
      default:
        return this.scalars(keys, type, depth, LongType.STRING);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js
var import_dist304 = __toESM(require_dist());
var import_dist305 = __toESM(require_dist2());
var import_dist306 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js
var import_dist301 = __toESM(require_dist());
var import_dist302 = __toESM(require_dist2());
var import_dist303 = __toESM(require_dist3());
function reflectionLongConvert(long, type) {
  switch (type) {
    case LongType.BIGINT:
      return long.toBigInt();
    case LongType.NUMBER:
      return long.toNumber();
    default:
      return long.toString();
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js
var ReflectionJsonReader = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a2;
    if (this.fMap === void 0) {
      this.fMap = {};
      const fieldsInput = (_a2 = this.info.fields) !== null && _a2 !== void 0 ? _a2 : [];
      for (const field of fieldsInput) {
        this.fMap[field.name] = field;
        this.fMap[field.jsonName] = field;
        this.fMap[field.localName] = field;
      }
    }
  }
  // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
  assert(condition, fieldName, jsonValue) {
    if (!condition) {
      let what = typeofJsonValue(jsonValue);
      if (what == "number" || what == "boolean")
        what = jsonValue.toString();
      throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
    }
  }
  /**
   * Reads a message from canonical JSON format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(input, message, options) {
    this.prepare();
    const oneofsHandled = [];
    for (const [jsonKey, jsonValue] of Object.entries(input)) {
      const field = this.fMap[jsonKey];
      if (!field) {
        if (!options.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
        continue;
      }
      const localName = field.localName;
      let target;
      if (field.oneof) {
        if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
          continue;
        }
        if (oneofsHandled.includes(field.oneof))
          throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
        oneofsHandled.push(field.oneof);
        target = message[field.oneof] = {
          oneofKind: localName
        };
      } else {
        target = message;
      }
      if (field.kind == "map") {
        if (jsonValue === null) {
          continue;
        }
        this.assert(isJsonObject(jsonValue), field.name, jsonValue);
        const fieldObj = target[localName];
        for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
          this.assert(jsonObjValue !== null, field.name + " map value", null);
          let val;
          switch (field.V.kind) {
            case "message":
              val = field.V.T().internalJsonRead(jsonObjValue, options);
              break;
            case "enum":
              val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name + " map value", jsonObjValue);
          let key = jsonObjKey;
          if (field.K == ScalarType.BOOL)
            key = key == "true" ? true : key == "false" ? false : key;
          key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
          fieldObj[key] = val;
        }
      } else if (field.repeat) {
        if (jsonValue === null)
          continue;
        this.assert(Array.isArray(jsonValue), field.name, jsonValue);
        const fieldArr = target[localName];
        for (const jsonItem of jsonValue) {
          this.assert(jsonItem !== null, field.name, null);
          let val;
          switch (field.kind) {
            case "message":
              val = field.T().internalJsonRead(jsonItem, options);
              break;
            case "enum":
              val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonItem, field.T, field.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name, jsonValue);
          fieldArr.push(val);
        }
      } else {
        switch (field.kind) {
          case "message":
            if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
              this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
              continue;
            }
            target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
            break;
          case "enum":
            let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
            if (val === false)
              continue;
            target[localName] = val;
            break;
          case "scalar":
            target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
            break;
        }
      }
    }
  }
  /**
   * Returns `false` for unrecognized string representations.
   *
   * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
   */
  enum(type, json, fieldName, ignoreUnknownFields) {
    if (type[0] == "google.protobuf.NullValue")
      assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
    if (json === null)
      return 0;
    switch (typeof json) {
      case "number":
        assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
        return json;
      case "string":
        let localEnumName = json;
        if (type[2] && json.substring(0, type[2].length) === type[2])
          localEnumName = json.substring(type[2].length);
        let enumNumber = type[1][localEnumName];
        if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
          return false;
        }
        assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
        return enumNumber;
    }
    assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
  }
  scalar(json, type, longType, fieldName) {
    let e;
    try {
      switch (type) {
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
          if (json === null)
            return 0;
          if (json === "NaN")
            return Number.NaN;
          if (json === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (json === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (json === "") {
            e = "empty string";
            break;
          }
          if (typeof json == "string" && json.trim().length !== json.length) {
            e = "extra whitespace";
            break;
          }
          if (typeof json != "string" && typeof json != "number") {
            break;
          }
          let float = Number(json);
          if (Number.isNaN(float)) {
            e = "not a number";
            break;
          }
          if (!Number.isFinite(float)) {
            e = "too large or small";
            break;
          }
          if (type == ScalarType.FLOAT)
            assertFloat32(float);
          return float;
        case ScalarType.INT32:
        case ScalarType.FIXED32:
        case ScalarType.SFIXED32:
        case ScalarType.SINT32:
        case ScalarType.UINT32:
          if (json === null)
            return 0;
          let int32;
          if (typeof json == "number")
            int32 = json;
          else if (json === "")
            e = "empty string";
          else if (typeof json == "string") {
            if (json.trim().length !== json.length)
              e = "extra whitespace";
            else
              int32 = Number(json);
          }
          if (int32 === void 0)
            break;
          if (type == ScalarType.UINT32)
            assertUInt32(int32);
          else
            assertInt32(int32);
          return int32;
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
          if (json === null)
            return reflectionLongConvert(PbLong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbLong.from(json), longType);
        case ScalarType.FIXED64:
        case ScalarType.UINT64:
          if (json === null)
            return reflectionLongConvert(PbULong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbULong.from(json), longType);
        case ScalarType.BOOL:
          if (json === null)
            return false;
          if (typeof json !== "boolean")
            break;
          return json;
        case ScalarType.STRING:
          if (json === null)
            return "";
          if (typeof json !== "string") {
            e = "extra whitespace";
            break;
          }
          try {
            encodeURIComponent(json);
          } catch (e2) {
            e2 = "invalid UTF8";
            break;
          }
          return json;
        case ScalarType.BYTES:
          if (json === null || json === "")
            return new Uint8Array(0);
          if (typeof json !== "string")
            break;
          return base64decode(json);
      }
    } catch (error) {
      e = error.message;
    }
    this.assert(false, fieldName + (e ? " - " + e : ""), json);
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js
var import_dist307 = __toESM(require_dist());
var import_dist308 = __toESM(require_dist2());
var import_dist309 = __toESM(require_dist3());
var ReflectionJsonWriter = class {
  constructor(info) {
    var _a2;
    this.fields = (_a2 = info.fields) !== null && _a2 !== void 0 ? _a2 : [];
  }
  /**
   * Converts the message to a JSON object, based on the field descriptors.
   */
  write(message, options) {
    const json = {}, source = message;
    for (const field of this.fields) {
      if (!field.oneof) {
        let jsonValue2 = this.field(field, source[field.localName], options);
        if (jsonValue2 !== void 0)
          json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
        continue;
      }
      const group = source[field.oneof];
      if (group.oneofKind !== field.localName)
        continue;
      const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
      let jsonValue = this.field(field, group[field.localName], opt);
      assert(jsonValue !== void 0);
      json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
    }
    return json;
  }
  field(field, value, options) {
    let jsonValue = void 0;
    if (field.kind == "map") {
      assert(typeof value == "object" && value !== null);
      const jsonObj = {};
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.scalar(field.V.T, entryValue, field.name, false, true);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "message":
          const messageType = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.message(messageType, entryValue, field.name, options);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "enum":
          const enumInfo = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            assert(entryValue === void 0 || typeof entryValue == "number");
            const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
      }
      if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
        jsonValue = jsonObj;
    } else if (field.repeat) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i = 0; i < value.length; i++) {
            const val = this.scalar(field.T, value[i], field.name, field.opt, true);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "enum":
          const enumInfo = field.T();
          for (let i = 0; i < value.length; i++) {
            assert(value[i] === void 0 || typeof value[i] == "number");
            const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "message":
          const messageType = field.T();
          for (let i = 0; i < value.length; i++) {
            const val = this.message(messageType, value[i], field.name, options);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
      }
      if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
        jsonValue = jsonArr;
    } else {
      switch (field.kind) {
        case "scalar":
          jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
          break;
        case "enum":
          jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
          break;
        case "message":
          jsonValue = this.message(field.T(), value, field.name, options);
          break;
      }
    }
    return jsonValue;
  }
  /**
   * Returns `null` as the default for google.protobuf.NullValue.
   */
  enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
    if (type[0] == "google.protobuf.NullValue")
      return !emitDefaultValues && !optional ? void 0 : null;
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    if (value === 0 && !emitDefaultValues && !optional)
      return void 0;
    assert(typeof value == "number");
    assert(Number.isInteger(value));
    if (enumAsInteger || !type[1].hasOwnProperty(value))
      return value;
    if (type[2])
      return type[2] + type[1][value];
    return type[1][value];
  }
  message(type, value, fieldName, options) {
    if (value === void 0)
      return options.emitDefaultValues ? null : void 0;
    return type.internalJsonWrite(value, options);
  }
  scalar(type, value, fieldName, optional, emitDefaultValues) {
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    const ed = emitDefaultValues || optional;
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        if (value === 0)
          return ed ? 0 : void 0;
        assertInt32(value);
        return value;
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        if (value === 0)
          return ed ? 0 : void 0;
        assertUInt32(value);
        return value;
      case ScalarType.FLOAT:
        assertFloat32(value);
      case ScalarType.DOUBLE:
        if (value === 0)
          return ed ? 0 : void 0;
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      case ScalarType.STRING:
        if (value === "")
          return ed ? "" : void 0;
        assert(typeof value == "string");
        return value;
      case ScalarType.BOOL:
        if (value === false)
          return ed ? false : void 0;
        assert(typeof value == "boolean");
        return value;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let ulong = PbULong.from(value);
        if (ulong.isZero() && !ed)
          return void 0;
        return ulong.toString();
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let long = PbLong.from(value);
        if (long.isZero() && !ed)
          return void 0;
        return long.toString();
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        if (!value.byteLength)
          return ed ? "" : void 0;
        return base64encode(value);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js
var import_dist313 = __toESM(require_dist());
var import_dist314 = __toESM(require_dist2());
var import_dist315 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js
var import_dist310 = __toESM(require_dist());
var import_dist311 = __toESM(require_dist2());
var import_dist312 = __toESM(require_dist3());
function reflectionScalarDefault(type, longType = LongType.STRING) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return reflectionLongConvert(PbULong.ZERO, longType);
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return reflectionLongConvert(PbLong.ZERO, longType);
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js
var ReflectionBinaryReader = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a2;
    if (!this.fieldNoToField) {
      const fieldsInput = (_a2 = this.info.fields) !== null && _a2 !== void 0 ? _a2 : [];
      this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
    }
  }
  /**
   * Reads a message from binary format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(reader, message, options, length) {
    this.prepare();
    const end = length === void 0 ? reader.len : reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
      if (!field) {
        let u = options.readUnknownField;
        if (u == "throw")
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
        let d = reader.skip(wireType);
        if (u !== false)
          (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
        continue;
      }
      let target = message, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        target = target[field.oneof];
        if (target.oneofKind !== localName)
          target = message[field.oneof] = {
            oneofKind: localName
          };
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          let L = field.kind == "scalar" ? field.L : void 0;
          if (repeated) {
            let arr = target[localName];
            if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
              let e = reader.uint32() + reader.pos;
              while (reader.pos < e)
                arr.push(this.scalar(reader, T, L));
            } else
              arr.push(this.scalar(reader, T, L));
          } else
            target[localName] = this.scalar(reader, T, L);
          break;
        case "message":
          if (repeated) {
            let arr = target[localName];
            let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
            arr.push(msg);
          } else
            target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
          break;
        case "map":
          let [mapKey, mapVal] = this.mapEntry(field, reader, options);
          target[localName][mapKey] = mapVal;
          break;
      }
    }
  }
  /**
   * Read a map field, expecting key field = 1, value field = 2
   */
  mapEntry(field, reader, options) {
    let length = reader.uint32();
    let end = reader.pos + length;
    let key = void 0;
    let val = void 0;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          if (field.K == ScalarType.BOOL)
            key = reader.bool().toString();
          else
            key = this.scalar(reader, field.K, LongType.STRING);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = this.scalar(reader, field.V.T, field.V.L);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
              break;
          }
          break;
        default:
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
      }
    }
    if (key === void 0) {
      let keyRaw = reflectionScalarDefault(field.K);
      key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
    }
    if (val === void 0)
      switch (field.V.kind) {
        case "scalar":
          val = reflectionScalarDefault(field.V.T, field.V.L);
          break;
        case "enum":
          val = 0;
          break;
        case "message":
          val = field.V.T().create();
          break;
      }
    return [key, val];
  }
  scalar(reader, type, longType) {
    switch (type) {
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT64:
        return reflectionLongConvert(reader.int64(), longType);
      case ScalarType.UINT64:
        return reflectionLongConvert(reader.uint64(), longType);
      case ScalarType.FIXED64:
        return reflectionLongConvert(reader.fixed64(), longType);
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reflectionLongConvert(reader.sfixed64(), longType);
      case ScalarType.SINT32:
        return reader.sint32();
      case ScalarType.SINT64:
        return reflectionLongConvert(reader.sint64(), longType);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js
var import_dist316 = __toESM(require_dist());
var import_dist317 = __toESM(require_dist2());
var import_dist318 = __toESM(require_dist3());
var ReflectionBinaryWriter = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    if (!this.fields) {
      const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
      this.fields = fieldsInput.sort((a, b) => a.no - b.no);
    }
  }
  /**
   * Writes the message to binary format.
   */
  write(message, writer, options) {
    this.prepare();
    for (const field of this.fields) {
      let value, emitDefault, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        const group = message[field.oneof];
        if (group.oneofKind !== localName)
          continue;
        value = group[localName];
        emitDefault = true;
      } else {
        value = message[localName];
        emitDefault = false;
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          if (repeated) {
            assert(Array.isArray(value));
            if (repeated == RepeatType.PACKED)
              this.packed(writer, T, field.no, value);
            else
              for (const item of value)
                this.scalar(writer, T, field.no, item, true);
          } else if (value === void 0)
            assert(field.opt);
          else
            this.scalar(writer, T, field.no, value, emitDefault || field.opt);
          break;
        case "message":
          if (repeated) {
            assert(Array.isArray(value));
            for (const item of value)
              this.message(writer, options, field.T(), field.no, item);
          } else {
            this.message(writer, options, field.T(), field.no, value);
          }
          break;
        case "map":
          assert(typeof value == "object" && value !== null);
          for (const [key, val] of Object.entries(value))
            this.mapEntry(writer, options, field, key, val);
          break;
      }
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
  }
  mapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    this.scalar(writer, field.K, 1, keyValue, true);
    switch (field.V.kind) {
      case "scalar":
        this.scalar(writer, field.V.T, 2, value, true);
        break;
      case "enum":
        this.scalar(writer, ScalarType.INT32, 2, value, true);
        break;
      case "message":
        this.message(writer, options, field.V.T(), 2, value);
        break;
    }
    writer.join();
  }
  message(writer, options, handler, fieldNo, value) {
    if (value === void 0)
      return;
    handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
    writer.join();
  }
  /**
   * Write a single scalar value.
   */
  scalar(writer, type, fieldNo, value, emitDefault) {
    let [wireType, method, isDefault] = this.scalarInfo(type, value);
    if (!isDefault || emitDefault) {
      writer.tag(fieldNo, wireType);
      writer[method](value);
    }
  }
  /**
   * Write an array of scalar values in packed format.
   */
  packed(writer, type, fieldNo, value) {
    if (!value.length)
      return;
    assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
    writer.tag(fieldNo, WireType.LengthDelimited);
    writer.fork();
    let [, method] = this.scalarInfo(type);
    for (let i = 0; i < value.length; i++)
      writer[method](value[i]);
    writer.join();
  }
  /**
   * Get information for writing a scalar value.
   *
   * Returns tuple:
   * [0]: appropriate WireType
   * [1]: name of the appropriate method of IBinaryWriter
   * [2]: whether the given value is a default value
   *
   * If argument `value` is omitted, [2] is always false.
   */
  scalarInfo(type, value) {
    let t = WireType.Varint;
    let m;
    let i = value === void 0;
    let d = value === 0;
    switch (type) {
      case ScalarType.INT32:
        m = "int32";
        break;
      case ScalarType.STRING:
        d = i || !value.length;
        t = WireType.LengthDelimited;
        m = "string";
        break;
      case ScalarType.BOOL:
        d = value === false;
        m = "bool";
        break;
      case ScalarType.UINT32:
        m = "uint32";
        break;
      case ScalarType.DOUBLE:
        t = WireType.Bit64;
        m = "double";
        break;
      case ScalarType.FLOAT:
        t = WireType.Bit32;
        m = "float";
        break;
      case ScalarType.INT64:
        d = i || PbLong.from(value).isZero();
        m = "int64";
        break;
      case ScalarType.UINT64:
        d = i || PbULong.from(value).isZero();
        m = "uint64";
        break;
      case ScalarType.FIXED64:
        d = i || PbULong.from(value).isZero();
        t = WireType.Bit64;
        m = "fixed64";
        break;
      case ScalarType.BYTES:
        d = i || !value.byteLength;
        t = WireType.LengthDelimited;
        m = "bytes";
        break;
      case ScalarType.FIXED32:
        t = WireType.Bit32;
        m = "fixed32";
        break;
      case ScalarType.SFIXED32:
        t = WireType.Bit32;
        m = "sfixed32";
        break;
      case ScalarType.SFIXED64:
        d = i || PbLong.from(value).isZero();
        t = WireType.Bit64;
        m = "sfixed64";
        break;
      case ScalarType.SINT32:
        m = "sint32";
        break;
      case ScalarType.SINT64:
        d = i || PbLong.from(value).isZero();
        m = "sint64";
        break;
    }
    return [t, m, i || d];
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js
var import_dist319 = __toESM(require_dist());
var import_dist320 = __toESM(require_dist2());
var import_dist321 = __toESM(require_dist3());
function reflectionCreate(type) {
  const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
  for (let field of type.fields) {
    let name = field.localName;
    if (field.opt)
      continue;
    if (field.oneof)
      msg[field.oneof] = { oneofKind: void 0 };
    else if (field.repeat)
      msg[name] = [];
    else
      switch (field.kind) {
        case "scalar":
          msg[name] = reflectionScalarDefault(field.T, field.L);
          break;
        case "enum":
          msg[name] = 0;
          break;
        case "map":
          msg[name] = {};
          break;
      }
  }
  return msg;
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js
var import_dist322 = __toESM(require_dist());
var import_dist323 = __toESM(require_dist2());
var import_dist324 = __toESM(require_dist3());
function reflectionMergePartial(info, target, source) {
  let fieldValue, input = source, output;
  for (let field of info.fields) {
    let name = field.localName;
    if (field.oneof) {
      const group = input[field.oneof];
      if ((group === null || group === void 0 ? void 0 : group.oneofKind) == void 0) {
        continue;
      }
      fieldValue = group[name];
      output = target[field.oneof];
      output.oneofKind = group.oneofKind;
      if (fieldValue == void 0) {
        delete output[name];
        continue;
      }
    } else {
      fieldValue = input[name];
      output = target;
      if (fieldValue == void 0) {
        continue;
      }
    }
    if (field.repeat)
      output[name].length = fieldValue.length;
    switch (field.kind) {
      case "scalar":
      case "enum":
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name][i] = fieldValue[i];
        else
          output[name] = fieldValue;
        break;
      case "message":
        let T = field.T();
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name][i] = T.create(fieldValue[i]);
        else if (output[name] === void 0)
          output[name] = T.create(fieldValue);
        else
          T.mergePartial(output[name], fieldValue);
        break;
      case "map":
        switch (field.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(output[name], fieldValue);
            break;
          case "message":
            let T2 = field.V.T();
            for (let k of Object.keys(fieldValue))
              output[name][k] = T2.create(fieldValue[k]);
            break;
        }
        break;
    }
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js
var import_dist325 = __toESM(require_dist());
var import_dist326 = __toESM(require_dist2());
var import_dist327 = __toESM(require_dist3());
function reflectionEquals(info, a, b) {
  if (a === b)
    return true;
  if (!a || !b)
    return false;
  for (let field of info.fields) {
    let localName = field.localName;
    let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
    let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
    switch (field.kind) {
      case "enum":
      case "scalar":
        let t = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (!(field.repeat ? repeatedPrimitiveEq(t, val_a, val_b) : primitiveEq(t, val_a, val_b)))
          return false;
        break;
      case "map":
        if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
          return false;
        break;
      case "message":
        let T = field.T();
        if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b)))
          return false;
        break;
    }
  }
  return true;
}
var objectValues = Object.values;
function primitiveEq(type, a, b) {
  if (a === b)
    return true;
  if (type !== ScalarType.BYTES)
    return false;
  let ba = a;
  let bb = b;
  if (ba.length !== bb.length)
    return false;
  for (let i = 0; i < ba.length; i++)
    if (ba[i] != bb[i])
      return false;
  return true;
}
function repeatedPrimitiveEq(type, a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!primitiveEq(type, a[i], b[i]))
      return false;
  return true;
}
function repeatedMsgEq(type, a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!type.equals(a[i], b[i]))
      return false;
  return true;
}

// node_modules/@protobuf-ts/runtime/build/es2015/message-type.js
var baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
var MessageType = class {
  constructor(name, fields, options) {
    this.defaultCheckDepth = 16;
    this.typeName = name;
    this.fields = fields.map(normalizeFieldInfo);
    this.options = options !== null && options !== void 0 ? options : {};
    this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [MESSAGE_TYPE]: { value: this } }));
    this.refTypeCheck = new ReflectionTypeCheck(this);
    this.refJsonReader = new ReflectionJsonReader(this);
    this.refJsonWriter = new ReflectionJsonWriter(this);
    this.refBinReader = new ReflectionBinaryReader(this);
    this.refBinWriter = new ReflectionBinaryWriter(this);
  }
  create(value) {
    let message = reflectionCreate(this);
    if (value !== void 0) {
      reflectionMergePartial(this, message, value);
    }
    return message;
  }
  /**
   * Clone the message.
   *
   * Unknown fields are discarded.
   */
  clone(message) {
    let copy = this.create();
    reflectionMergePartial(this, copy, message);
    return copy;
  }
  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  equals(a, b) {
    return reflectionEquals(this, a, b);
  }
  /**
   * Is the given value assignable to our message type
   * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  is(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, false);
  }
  /**
   * Is the given value assignable to our message type,
   * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  isAssignable(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, true);
  }
  /**
   * Copy partial data into the target message.
   */
  mergePartial(target, source) {
    reflectionMergePartial(this, target, source);
  }
  /**
   * Create a new message from binary format.
   */
  fromBinary(data, options) {
    let opt = binaryReadOptions(options);
    return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
  }
  /**
   * Read a new message from a JSON value.
   */
  fromJson(json, options) {
    return this.internalJsonRead(json, jsonReadOptions(options));
  }
  /**
   * Read a new message from a JSON string.
   * This is equivalent to `T.fromJson(JSON.parse(json))`.
   */
  fromJsonString(json, options) {
    let value = JSON.parse(json);
    return this.fromJson(value, options);
  }
  /**
   * Write the message to canonical JSON value.
   */
  toJson(message, options) {
    return this.internalJsonWrite(message, jsonWriteOptions(options));
  }
  /**
   * Convert the message to canonical JSON string.
   * This is equivalent to `JSON.stringify(T.toJson(t))`
   */
  toJsonString(message, options) {
    var _a2;
    let value = this.toJson(message, options);
    return JSON.stringify(value, null, (_a2 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a2 !== void 0 ? _a2 : 0);
  }
  /**
   * Write the message to binary format.
   */
  toBinary(message, options) {
    let opt = binaryWriteOptions(options);
    return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
  }
  /**
   * This is an internal method. If you just want to read a message from
   * JSON, use `fromJson()` or `fromJsonString()`.
   *
   * Reads JSON value and merges the fields into the target
   * according to protobuf rules. If the target is omitted,
   * a new instance is created first.
   */
  internalJsonRead(json, options, target) {
    if (json !== null && typeof json == "object" && !Array.isArray(json)) {
      let message = target !== null && target !== void 0 ? target : this.create();
      this.refJsonReader.read(json, message, options);
      return message;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
  }
  /**
   * This is an internal method. If you just want to write a message
   * to JSON, use `toJson()` or `toJsonString().
   *
   * Writes JSON value and returns it.
   */
  internalJsonWrite(message, options) {
    return this.refJsonWriter.write(message, options);
  }
  /**
   * This is an internal method. If you just want to write a message
   * in binary format, use `toBinary()`.
   *
   * Serializes the message in binary format and appends it to the given
   * writer. Returns passed writer.
   */
  internalBinaryWrite(message, writer, options) {
    this.refBinWriter.write(message, writer, options);
    return writer;
  }
  /**
   * This is an internal method. If you just want to read a message from
   * binary data, use `fromBinary()`.
   *
   * Reads data from binary format and merges the fields into
   * the target according to protobuf rules. If the target is
   * omitted, a new instance is created first.
   */
  internalBinaryRead(reader, length, options, target) {
    let message = target !== null && target !== void 0 ? target : this.create();
    this.refBinReader.read(reader, message, options, length);
    return message;
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-contains-message-type.js
var import_dist331 = __toESM(require_dist());
var import_dist332 = __toESM(require_dist2());
var import_dist333 = __toESM(require_dist3());

// node_modules/@protobuf-ts/runtime/build/es2015/enum-object.js
var import_dist334 = __toESM(require_dist());
var import_dist335 = __toESM(require_dist2());
var import_dist336 = __toESM(require_dist3());

// node_modules/@burnt-labs/signers/dist/index.mjs
var import_utils14 = __toESM(require_build3(), 1);
var import_accounts = __toESM(require_accounts(), 1);

// node_modules/@apollo/client/index.js
var import_dist805 = __toESM(require_dist());
var import_dist806 = __toESM(require_dist2());
var import_dist807 = __toESM(require_dist3());

// node_modules/@apollo/client/core/index.js
var import_dist703 = __toESM(require_dist(), 1);
var import_dist704 = __toESM(require_dist2(), 1);
var import_dist705 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/core/ApolloClient.js
var import_dist694 = __toESM(require_dist(), 1);
var import_dist695 = __toESM(require_dist2(), 1);
var import_dist696 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/globals/index.js
var import_dist361 = __toESM(require_dist(), 1);
var import_dist362 = __toESM(require_dist2(), 1);
var import_dist363 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/globals/invariantWrappers.js
var import_dist358 = __toESM(require_dist(), 1);
var import_dist359 = __toESM(require_dist2(), 1);
var import_dist360 = __toESM(require_dist3(), 1);

// node_modules/ts-invariant/lib/invariant.js
var import_dist340 = __toESM(require_dist());
var import_dist341 = __toESM(require_dist2());
var import_dist342 = __toESM(require_dist3());
var genericMessage = "Invariant Violation";
var _a = Object.setPrototypeOf;
var setPrototypeOf = _a === void 0 ? function(obj, proto) {
  obj.__proto__ = proto;
  return obj;
} : _a;
var InvariantError = (
  /** @class */
  function(_super) {
    __extends(InvariantError2, _super);
    function InvariantError2(message) {
      if (message === void 0) {
        message = genericMessage;
      }
      var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
      _this.framesToPop = 1;
      _this.name = genericMessage;
      setPrototypeOf(_this, InvariantError2.prototype);
      return _this;
    }
    return InvariantError2;
  }(Error)
);
function invariant(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
var verbosityLevel = verbosityLevels.indexOf("log");
function wrapConsoleMethod(name) {
  return function() {
    if (verbosityLevels.indexOf(name) >= verbosityLevel) {
      var method = console[name] || console.log;
      return method.apply(console, arguments);
    }
  };
}
(function(invariant4) {
  invariant4.debug = wrapConsoleMethod("debug");
  invariant4.log = wrapConsoleMethod("log");
  invariant4.warn = wrapConsoleMethod("warn");
  invariant4.error = wrapConsoleMethod("error");
})(invariant || (invariant = {}));
function setVerbosity(level) {
  var old = verbosityLevels[verbosityLevel];
  verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
  return old;
}

// node_modules/@apollo/client/version.js
var import_dist343 = __toESM(require_dist(), 1);
var import_dist344 = __toESM(require_dist2(), 1);
var import_dist345 = __toESM(require_dist3(), 1);
var version = "3.12.2";

// node_modules/@apollo/client/utilities/globals/global.js
var import_dist349 = __toESM(require_dist(), 1);
var import_dist350 = __toESM(require_dist2(), 1);
var import_dist351 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/globals/maybe.js
var import_dist346 = __toESM(require_dist(), 1);
var import_dist347 = __toESM(require_dist2(), 1);
var import_dist348 = __toESM(require_dist3(), 1);
function maybe(thunk) {
  try {
    return thunk();
  } catch (_a2) {
  }
}

// node_modules/@apollo/client/utilities/globals/global.js
var global_default = maybe(function() {
  return globalThis;
}) || maybe(function() {
  return window;
}) || maybe(function() {
  return self;
}) || maybe(function() {
  return global;
}) || // We don't expect the Function constructor ever to be invoked at runtime, as
// long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
// improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
maybe(function() {
  return maybe.constructor("return this")();
});

// node_modules/@apollo/client/utilities/common/stringifyForDisplay.js
var import_dist355 = __toESM(require_dist(), 1);
var import_dist356 = __toESM(require_dist2(), 1);
var import_dist357 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/common/makeUniqueId.js
var import_dist352 = __toESM(require_dist(), 1);
var import_dist353 = __toESM(require_dist2(), 1);
var import_dist354 = __toESM(require_dist3(), 1);
var prefixCounts = /* @__PURE__ */ new Map();
function makeUniqueId(prefix) {
  var count3 = prefixCounts.get(prefix) || 1;
  prefixCounts.set(prefix, count3 + 1);
  return "".concat(prefix, ":").concat(count3, ":").concat(Math.random().toString(36).slice(2));
}

// node_modules/@apollo/client/utilities/common/stringifyForDisplay.js
function stringifyForDisplay(value, space) {
  if (space === void 0) {
    space = 0;
  }
  var undefId = makeUniqueId("stringifyForDisplay");
  return JSON.stringify(value, function(key, value2) {
    return value2 === void 0 ? undefId : value2;
  }, space).split(JSON.stringify(undefId)).join("<undefined>");
}

// node_modules/@apollo/client/utilities/globals/invariantWrappers.js
function wrap(fn) {
  return function(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (typeof message === "number") {
      var arg0 = message;
      message = getHandledErrorMsg(arg0);
      if (!message) {
        message = getFallbackErrorMsg(arg0, args);
        args = [];
      }
    }
    fn.apply(void 0, [message].concat(args));
  };
}
var invariant2 = Object.assign(function invariant3(condition, message) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (!condition) {
    invariant(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));
  }
}, {
  debug: wrap(invariant.debug),
  log: wrap(invariant.log),
  warn: wrap(invariant.warn),
  error: wrap(invariant.error)
});
function newInvariantError(message) {
  var optionalParams = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    optionalParams[_i - 1] = arguments[_i];
  }
  return new InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));
}
var ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version);
function stringify(arg) {
  if (typeof arg == "string") {
    return arg;
  }
  try {
    return stringifyForDisplay(arg, 2).slice(0, 1e3);
  } catch (_a2) {
    return "<non-serializable>";
  }
}
function getHandledErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return global_default[ApolloErrorMessageHandler] && global_default[ApolloErrorMessageHandler](message, messageArgs.map(stringify));
}
function getFallbackErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
    version,
    message,
    args: messageArgs.map(stringify)
  })));
}

// node_modules/@apollo/client/utilities/globals/index.js
var DEV = globalThis.__DEV__ !== false;

// node_modules/@apollo/client/link/core/index.js
var import_dist559 = __toESM(require_dist(), 1);
var import_dist560 = __toESM(require_dist2(), 1);
var import_dist561 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/core/empty.js
var import_dist541 = __toESM(require_dist(), 1);
var import_dist542 = __toESM(require_dist2(), 1);
var import_dist543 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/core/ApolloLink.js
var import_dist538 = __toESM(require_dist(), 1);
var import_dist539 = __toESM(require_dist2(), 1);
var import_dist540 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/index.js
var import_dist508 = __toESM(require_dist(), 1);
var import_dist509 = __toESM(require_dist2(), 1);
var import_dist510 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/graphql/directives.js
var import_dist364 = __toESM(require_dist(), 1);
var import_dist365 = __toESM(require_dist2(), 1);
var import_dist366 = __toESM(require_dist3(), 1);
function shouldInclude(_a2, variables) {
  var directives = _a2.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(function(_a3) {
    var directive = _a3.directive, ifArgument = _a3.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      invariant2(evaledValue !== void 0, 78, directive.name.value);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function hasDirectives(names, root2, all) {
  var nameSet = new Set(names);
  var uniqueCount = nameSet.size;
  visit(root2, {
    Directive: function(node) {
      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
        return BREAK;
      }
    }
  });
  return all ? !nameSet.size : nameSet.size < uniqueCount;
}
function hasClientExports(document2) {
  return document2 && hasDirectives(["client", "export"], document2, true);
}
function isInclusionDirective(_a2) {
  var value = _a2.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  var result2 = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      invariant2(directiveArguments && directiveArguments.length === 1, 79, directiveName);
      var ifArgument = directiveArguments[0];
      invariant2(ifArgument.name && ifArgument.name.value === "if", 80, directiveName);
      var ifValue = ifArgument.value;
      invariant2(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 81, directiveName);
      result2.push({ directive, ifArgument });
    });
  }
  return result2;
}
function getFragmentMaskMode(fragment) {
  var _a2, _b;
  var directive = (_a2 = fragment.directives) === null || _a2 === void 0 ? void 0 : _a2.find(function(_a3) {
    var name = _a3.name;
    return name.value === "unmask";
  });
  if (!directive) {
    return "mask";
  }
  var modeArg = (_b = directive.arguments) === null || _b === void 0 ? void 0 : _b.find(function(_a3) {
    var name = _a3.name;
    return name.value === "mode";
  });
  if (globalThis.__DEV__ !== false) {
    if (modeArg) {
      if (modeArg.value.kind === Kind.VARIABLE) {
        globalThis.__DEV__ !== false && invariant2.warn(82);
      } else if (modeArg.value.kind !== Kind.STRING) {
        globalThis.__DEV__ !== false && invariant2.warn(83);
      } else if (modeArg.value.value !== "migrate") {
        globalThis.__DEV__ !== false && invariant2.warn(84, modeArg.value.value);
      }
    }
  }
  if (modeArg && "value" in modeArg.value && modeArg.value.value === "migrate") {
    return "migrate";
  }
  return "unmask";
}

// node_modules/@apollo/client/utilities/graphql/DocumentTransform.js
var import_dist430 = __toESM(require_dist(), 1);
var import_dist431 = __toESM(require_dist2(), 1);
var import_dist432 = __toESM(require_dist3(), 1);

// node_modules/@wry/trie/lib/index.js
var import_dist367 = __toESM(require_dist());
var import_dist368 = __toESM(require_dist2());
var import_dist369 = __toESM(require_dist3());
var defaultMakeData = () => /* @__PURE__ */ Object.create(null);
var { forEach, slice } = Array.prototype;
var { hasOwnProperty } = Object.prototype;
var Trie = class _Trie {
  constructor(weakness = true, makeData = defaultMakeData) {
    this.weakness = weakness;
    this.makeData = makeData;
  }
  lookup() {
    return this.lookupArray(arguments);
  }
  lookupArray(array) {
    let node = this;
    forEach.call(array, (key) => node = node.getChildTrie(key));
    return hasOwnProperty.call(node, "data") ? node.data : node.data = this.makeData(slice.call(array));
  }
  peek() {
    return this.peekArray(arguments);
  }
  peekArray(array) {
    let node = this;
    for (let i = 0, len = array.length; node && i < len; ++i) {
      const map = node.mapFor(array[i], false);
      node = map && map.get(array[i]);
    }
    return node && node.data;
  }
  remove() {
    return this.removeArray(arguments);
  }
  removeArray(array) {
    let data;
    if (array.length) {
      const head = array[0];
      const map = this.mapFor(head, false);
      const child = map && map.get(head);
      if (child) {
        data = child.removeArray(slice.call(array, 1));
        if (!child.data && !child.weak && !(child.strong && child.strong.size)) {
          map.delete(head);
        }
      }
    } else {
      data = this.data;
      delete this.data;
    }
    return data;
  }
  getChildTrie(key) {
    const map = this.mapFor(key, true);
    let child = map.get(key);
    if (!child)
      map.set(key, child = new _Trie(this.weakness, this.makeData));
    return child;
  }
  mapFor(key, create) {
    return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (create ? this.strong = /* @__PURE__ */ new Map() : void 0);
  }
};
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}

// node_modules/@apollo/client/utilities/common/canUse.js
var import_dist370 = __toESM(require_dist(), 1);
var import_dist371 = __toESM(require_dist2(), 1);
var import_dist372 = __toESM(require_dist3(), 1);
var isReactNative = maybe(function() {
  return navigator.product;
}) == "ReactNative";
var canUseWeakMap = typeof WeakMap === "function" && !(isReactNative && !global.HermesInternal);
var canUseWeakSet = typeof WeakSet === "function";
var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
var canUseDOM = typeof maybe(function() {
  return window.document.createElement;
}) === "function";
var usingJSDOM = (
  // Following advice found in this comment from @domenic (maintainer of jsdom):
  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327
  //
  // Since we control the version of Jest and jsdom used when running Apollo
  // Client tests, and that version is recent enought to include " jsdom/x.y.z"
  // at the end of the user agent string, I believe this case is all we need to
  // check. Testing for "Node.js" was recommended for backwards compatibility
  // with older version of jsdom, but we don't have that problem.
  maybe(function() {
    return navigator.userAgent.indexOf("jsdom") >= 0;
  }) || false
);

// node_modules/@apollo/client/utilities/graphql/getFromAST.js
var import_dist406 = __toESM(require_dist(), 1);
var import_dist407 = __toESM(require_dist2(), 1);
var import_dist408 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/graphql/storeUtils.js
var import_dist403 = __toESM(require_dist(), 1);
var import_dist404 = __toESM(require_dist2(), 1);
var import_dist405 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/common/objects.js
var import_dist373 = __toESM(require_dist(), 1);
var import_dist374 = __toESM(require_dist2(), 1);
var import_dist375 = __toESM(require_dist3(), 1);
function isNonNullObject(obj) {
  return obj !== null && typeof obj === "object";
}

// node_modules/@apollo/client/utilities/graphql/fragments.js
var import_dist376 = __toESM(require_dist(), 1);
var import_dist377 = __toESM(require_dist2(), 1);
var import_dist378 = __toESM(require_dist3(), 1);
function getFragmentQueryDocument(document2, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document2.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      throw newInvariantError(
        85,
        definition.operation,
        definition.name ? " named '".concat(definition.name.value, "'") : ""
      );
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    invariant2(fragments.length === 1, 86, fragments.length);
    actualFragmentName = fragments[0].name.value;
  }
  var query = __assign(__assign({}, document2), { definitions: __spreadArray([
    {
      kind: "OperationDefinition",
      // OperationTypeNode is an enum
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document2.definitions, true) });
  return query;
}
function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragmentName = selection.name.value;
      if (typeof fragmentMap === "function") {
        return fragmentMap(fragmentName);
      }
      var fragment = fragmentMap && fragmentMap[fragmentName];
      invariant2(fragment, 87, fragmentName);
      return fragment || null;
    }
    default:
      return null;
  }
}
function isFullyUnmaskedOperation(document2) {
  var isUnmasked = true;
  visit(document2, {
    FragmentSpread: function(node) {
      isUnmasked = !!node.directives && node.directives.some(function(directive) {
        return directive.name.value === "unmask";
      });
      if (!isUnmasked) {
        return BREAK;
      }
    }
  });
  return isUnmasked;
}

// node_modules/@apollo/client/utilities/common/canonicalStringify.js
var import_dist400 = __toESM(require_dist(), 1);
var import_dist401 = __toESM(require_dist2(), 1);
var import_dist402 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/caching/index.js
var import_dist394 = __toESM(require_dist(), 1);
var import_dist395 = __toESM(require_dist2(), 1);
var import_dist396 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/caching/caches.js
var import_dist388 = __toESM(require_dist(), 1);
var import_dist389 = __toESM(require_dist2(), 1);
var import_dist390 = __toESM(require_dist3(), 1);

// node_modules/@wry/caches/lib/index.js
var import_dist385 = __toESM(require_dist());
var import_dist386 = __toESM(require_dist2());
var import_dist387 = __toESM(require_dist3());

// node_modules/@wry/caches/lib/strong.js
var import_dist379 = __toESM(require_dist(), 1);
var import_dist380 = __toESM(require_dist2(), 1);
var import_dist381 = __toESM(require_dist3(), 1);
function defaultDispose() {
}
var StrongCache = class {
  constructor(max2 = Infinity, dispose = defaultDispose) {
    this.max = max2;
    this.dispose = dispose;
    this.map = /* @__PURE__ */ new Map();
    this.newest = null;
    this.oldest = null;
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    const node = this.getNode(key);
    return node && node.value;
  }
  get size() {
    return this.map.size;
  }
  getNode(key) {
    const node = this.map.get(key);
    if (node && node !== this.newest) {
      const { older, newer } = node;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      node.older = this.newest;
      node.older.newer = node;
      node.newer = null;
      this.newest = node;
      if (node === this.oldest) {
        this.oldest = newer;
      }
    }
    return node;
  }
  set(key, value) {
    let node = this.getNode(key);
    if (node) {
      return node.value = value;
    }
    node = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = node;
    }
    this.newest = node;
    this.oldest = this.oldest || node;
    this.map.set(key, node);
    return node.value;
  }
  clean() {
    while (this.oldest && this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  }
  delete(key) {
    const node = this.map.get(key);
    if (node) {
      if (node === this.newest) {
        this.newest = node.older;
      }
      if (node === this.oldest) {
        this.oldest = node.newer;
      }
      if (node.newer) {
        node.newer.older = node.older;
      }
      if (node.older) {
        node.older.newer = node.newer;
      }
      this.map.delete(key);
      this.dispose(node.value, key);
      return true;
    }
    return false;
  }
};

// node_modules/@wry/caches/lib/weak.js
var import_dist382 = __toESM(require_dist(), 1);
var import_dist383 = __toESM(require_dist2(), 1);
var import_dist384 = __toESM(require_dist3(), 1);
function noop() {
}
var defaultDispose2 = noop;
var _WeakRef = typeof WeakRef !== "undefined" ? WeakRef : function(value) {
  return { deref: () => value };
};
var _WeakMap = typeof WeakMap !== "undefined" ? WeakMap : Map;
var _FinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : function() {
  return {
    register: noop,
    unregister: noop
  };
};
var finalizationBatchSize = 10024;
var WeakCache = class {
  constructor(max2 = Infinity, dispose = defaultDispose2) {
    this.max = max2;
    this.dispose = dispose;
    this.map = new _WeakMap();
    this.newest = null;
    this.oldest = null;
    this.unfinalizedNodes = /* @__PURE__ */ new Set();
    this.finalizationScheduled = false;
    this.size = 0;
    this.finalize = () => {
      const iterator = this.unfinalizedNodes.values();
      for (let i = 0; i < finalizationBatchSize; i++) {
        const node = iterator.next().value;
        if (!node)
          break;
        this.unfinalizedNodes.delete(node);
        const key = node.key;
        delete node.key;
        node.keyRef = new _WeakRef(key);
        this.registry.register(key, node, node);
      }
      if (this.unfinalizedNodes.size > 0) {
        queueMicrotask(this.finalize);
      } else {
        this.finalizationScheduled = false;
      }
    };
    this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    const node = this.getNode(key);
    return node && node.value;
  }
  getNode(key) {
    const node = this.map.get(key);
    if (node && node !== this.newest) {
      const { older, newer } = node;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      node.older = this.newest;
      node.older.newer = node;
      node.newer = null;
      this.newest = node;
      if (node === this.oldest) {
        this.oldest = newer;
      }
    }
    return node;
  }
  set(key, value) {
    let node = this.getNode(key);
    if (node) {
      return node.value = value;
    }
    node = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = node;
    }
    this.newest = node;
    this.oldest = this.oldest || node;
    this.scheduleFinalization(node);
    this.map.set(key, node);
    this.size++;
    return node.value;
  }
  clean() {
    while (this.oldest && this.size > this.max) {
      this.deleteNode(this.oldest);
    }
  }
  deleteNode(node) {
    if (node === this.newest) {
      this.newest = node.older;
    }
    if (node === this.oldest) {
      this.oldest = node.newer;
    }
    if (node.newer) {
      node.newer.older = node.older;
    }
    if (node.older) {
      node.older.newer = node.newer;
    }
    this.size--;
    const key = node.key || node.keyRef && node.keyRef.deref();
    this.dispose(node.value, key);
    if (!node.keyRef) {
      this.unfinalizedNodes.delete(node);
    } else {
      this.registry.unregister(node);
    }
    if (key)
      this.map.delete(key);
  }
  delete(key) {
    const node = this.map.get(key);
    if (node) {
      this.deleteNode(node);
      return true;
    }
    return false;
  }
  scheduleFinalization(node) {
    this.unfinalizedNodes.add(node);
    if (!this.finalizationScheduled) {
      this.finalizationScheduled = true;
      queueMicrotask(this.finalize);
    }
  }
};

// node_modules/@apollo/client/utilities/caching/caches.js
var scheduledCleanup = /* @__PURE__ */ new WeakSet();
function schedule(cache2) {
  if (cache2.size <= (cache2.max || -1)) {
    return;
  }
  if (!scheduledCleanup.has(cache2)) {
    scheduledCleanup.add(cache2);
    setTimeout(function() {
      cache2.clean();
      scheduledCleanup.delete(cache2);
    }, 100);
  }
}
var AutoCleanedWeakCache = function(max2, dispose) {
  var cache2 = new WeakCache(max2, dispose);
  cache2.set = function(key, value) {
    var ret = WeakCache.prototype.set.call(this, key, value);
    schedule(this);
    return ret;
  };
  return cache2;
};
var AutoCleanedStrongCache = function(max2, dispose) {
  var cache2 = new StrongCache(max2, dispose);
  cache2.set = function(key, value) {
    var ret = StrongCache.prototype.set.call(this, key, value);
    schedule(this);
    return ret;
  };
  return cache2;
};

// node_modules/@apollo/client/utilities/caching/sizes.js
var import_dist391 = __toESM(require_dist(), 1);
var import_dist392 = __toESM(require_dist2(), 1);
var import_dist393 = __toESM(require_dist3(), 1);
var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
var cacheSizes = __assign({}, global_default[cacheSizeSymbol]);

// node_modules/@apollo/client/utilities/caching/getMemoryInternals.js
var import_dist397 = __toESM(require_dist(), 1);
var import_dist398 = __toESM(require_dist2(), 1);
var import_dist399 = __toESM(require_dist3(), 1);
var globalCaches = {};
function registerGlobalCache(name, getSize) {
  globalCaches[name] = getSize;
}
var getApolloClientMemoryInternals = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals : void 0;
var getInMemoryCacheMemoryInternals = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals : void 0;
var getApolloCacheMemoryInternals = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals : void 0;
function getCurrentCacheSizes() {
  var defaults = {
    parser: 1e3,
    canonicalStringify: 1e3,
    print: 2e3,
    "documentTransform.cache": 2e3,
    "queryManager.getDocumentInfo": 2e3,
    "PersistedQueryLink.persistedQueryHashes": 2e3,
    "fragmentRegistry.transform": 2e3,
    "fragmentRegistry.lookup": 1e3,
    "fragmentRegistry.findFragmentSpreads": 4e3,
    "cache.fragmentQueryDocuments": 1e3,
    "removeTypenameFromVariables.getVariableDefinitions": 2e3,
    "inMemoryCache.maybeBroadcastWatch": 5e3,
    "inMemoryCache.executeSelectionSet": 5e4,
    "inMemoryCache.executeSubSelectedArray": 1e4
  };
  return Object.fromEntries(Object.entries(defaults).map(function(_a2) {
    var k = _a2[0], v = _a2[1];
    return [
      k,
      cacheSizes[k] || v
    ];
  }));
}
function _getApolloClientMemoryInternals() {
  var _a2, _b, _c, _d, _e;
  if (!(globalThis.__DEV__ !== false))
    throw new Error("only supported in development mode");
  return {
    limits: getCurrentCacheSizes(),
    sizes: __assign({ print: (_a2 = globalCaches.print) === null || _a2 === void 0 ? void 0 : _a2.call(globalCaches), parser: (_b = globalCaches.parser) === null || _b === void 0 ? void 0 : _b.call(globalCaches), canonicalStringify: (_c = globalCaches.canonicalStringify) === null || _c === void 0 ? void 0 : _c.call(globalCaches), links: linkInfo(this.link), queryManager: {
      getDocumentInfo: this["queryManager"]["transformCache"].size,
      documentTransforms: transformInfo(this["queryManager"].documentTransform)
    } }, (_e = (_d = this.cache).getMemoryInternals) === null || _e === void 0 ? void 0 : _e.call(_d))
  };
}
function _getApolloCacheMemoryInternals() {
  return {
    cache: {
      fragmentQueryDocuments: getWrapperInformation(this["getFragmentDoc"])
    }
  };
}
function _getInMemoryCacheMemoryInternals() {
  var fragments = this.config.fragments;
  return __assign(__assign({}, _getApolloCacheMemoryInternals.apply(this)), { addTypenameDocumentTransform: transformInfo(this["addTypenameTransform"]), inMemoryCache: {
    executeSelectionSet: getWrapperInformation(this["storeReader"]["executeSelectionSet"]),
    executeSubSelectedArray: getWrapperInformation(this["storeReader"]["executeSubSelectedArray"]),
    maybeBroadcastWatch: getWrapperInformation(this["maybeBroadcastWatch"])
  }, fragmentRegistry: {
    findFragmentSpreads: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
    lookup: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
    transform: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
  } });
}
function isWrapper(f) {
  return !!f && "dirtyKey" in f;
}
function getWrapperInformation(f) {
  return isWrapper(f) ? f.size : void 0;
}
function isDefined(value) {
  return value != null;
}
function transformInfo(transform) {
  return recurseTransformInfo(transform).map(function(cache2) {
    return { cache: cache2 };
  });
}
function recurseTransformInfo(transform) {
  return transform ? __spreadArray(__spreadArray([
    getWrapperInformation(transform === null || transform === void 0 ? void 0 : transform["performWork"])
  ], recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined) : [];
}
function linkInfo(link) {
  var _a2;
  return link ? __spreadArray(__spreadArray([
    (_a2 = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a2 === void 0 ? void 0 : _a2.call(link)
  ], linkInfo(link === null || link === void 0 ? void 0 : link.left), true), linkInfo(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined) : [];
}

// node_modules/@apollo/client/utilities/common/canonicalStringify.js
var canonicalStringify = Object.assign(function canonicalStringify2(value) {
  return JSON.stringify(value, stableObjectReplacer);
}, {
  reset: function() {
    sortingMap = new AutoCleanedStrongCache(
      cacheSizes.canonicalStringify || 1e3
      /* defaultCacheSizes.canonicalStringify */
    );
  }
});
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("canonicalStringify", function() {
    return sortingMap.size;
  });
}
var sortingMap;
canonicalStringify.reset();
function stableObjectReplacer(key, value) {
  if (value && typeof value === "object") {
    var proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
      var keys = Object.keys(value);
      if (keys.every(everyKeyInOrder))
        return value;
      var unsortedKey = JSON.stringify(keys);
      var sortedKeys = sortingMap.get(unsortedKey);
      if (!sortedKeys) {
        keys.sort();
        var sortedKey = JSON.stringify(keys);
        sortedKeys = sortingMap.get(sortedKey) || keys;
        sortingMap.set(unsortedKey, sortedKeys);
        sortingMap.set(sortedKey, sortedKeys);
      }
      var sortedObject_1 = Object.create(proto);
      sortedKeys.forEach(function(key2) {
        sortedObject_1[key2] = value[key2];
      });
      return sortedObject_1;
    }
  }
  return value;
}
function everyKeyInOrder(key, i, keys) {
  return i === 0 || keys[i - 1] <= key;
}

// node_modules/@apollo/client/utilities/graphql/storeUtils.js
function makeReference(id) {
  return { __ref: String(id) };
}
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isDocumentNode(value) {
  return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
}
function isStringValue(value) {
  return value.kind === "StringValue";
}
function isBooleanValue(value) {
  return value.kind === "BooleanValue";
}
function isIntValue(value) {
  return value.kind === "IntValue";
}
function isFloatValue(value) {
  return value.kind === "FloatValue";
}
function isVariable(value) {
  return value.kind === "Variable";
}
function isObjectValue(value) {
  return value.kind === "ObjectValue";
}
function isListValue(value) {
  return value.kind === "ListValue";
}
function isEnumValue(value) {
  return value.kind === "EnumValue";
}
function isNullValue(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation(argObj, name, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name.value] = null;
  } else {
    throw newInvariantError(96, name.value, value.kind);
  }
}
function storeKeyNameFromField(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a2) {
          var name = _a2.name, value = _a2.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a2) {
      var name = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj, name, value, variables);
    });
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
];
var storeKeyNameStringify = canonicalStringify;
var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      var filteredArgs_1 = {};
      filterKeys.forEach(function(key) {
        filteredArgs_1[key] = args[key];
      });
      return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify(filteredArgs_1), ")");
    } else {
      return directives["connection"]["key"];
    }
  }
  var completeFieldName = fieldName;
  if (args) {
    var stringifiedArgs = storeKeyNameStringify(args);
    completeFieldName += "(".concat(stringifiedArgs, ")");
  }
  if (directives) {
    Object.keys(directives).forEach(function(key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
        return;
      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify(directives[key]), ")");
      } else {
        completeFieldName += "@".concat(key);
      }
    });
  }
  return completeFieldName;
}, {
  setStringify: function(s) {
    var previous = storeKeyNameStringify;
    storeKeyNameStringify = s;
    return previous;
  }
});
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a2) {
      var name = _a2.name, value = _a2.value;
      return valueToObjectRepresentation(argObj_1, name, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result2, selectionSet, fragmentMap) {
  var fragments;
  for (var _i = 0, _a2 = selectionSet.selections; _i < _a2.length; _i++) {
    var selection = _a2[_i];
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result2[resultKeyNameFromField(selection)];
      }
    } else if (fragments) {
      fragments.push(selection);
    } else {
      fragments = [selection];
    }
  }
  if (typeof result2.__typename === "string") {
    return result2.__typename;
  }
  if (fragments) {
    for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {
      var selection = fragments_1[_b];
      var typename = getTypenameFromResult(result2, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField(selection) {
  return selection.kind === "Field";
}
function isInlineFragment(selection) {
  return selection.kind === "InlineFragment";
}

// node_modules/@apollo/client/utilities/graphql/getFromAST.js
function checkDocument(doc) {
  invariant2(doc && doc.kind === "Document", 88);
  var operations = doc.definitions.filter(function(d) {
    return d.kind !== "FragmentDefinition";
  }).map(function(definition) {
    if (definition.kind !== "OperationDefinition") {
      throw newInvariantError(89, definition.kind);
    }
    return definition;
  });
  invariant2(operations.length <= 1, 90, operations.length);
  return doc;
}
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition";
  })[0];
}
function getOperationName(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && !!definition.name;
  }).map(function(x) {
    return x.name.value;
  })[0] || null;
}
function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "FragmentDefinition";
  });
}
function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  invariant2(queryDef && queryDef.operation === "query", 91);
  return queryDef;
}
function getFragmentDefinition(doc) {
  invariant2(doc.kind === "Document", 92);
  invariant2(doc.definitions.length <= 1, 93);
  var fragmentDef = doc.definitions[0];
  invariant2(fragmentDef.kind === "FragmentDefinition", 94);
  return fragmentDef;
}
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;
  for (var _i = 0, _a2 = queryDoc.definitions; _i < _a2.length; _i++) {
    var definition = _a2[_i];
    if (definition.kind === "OperationDefinition") {
      var operation = definition.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition;
      }
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw newInvariantError(95);
}
function getDefaultValues(definition) {
  var defaultValues = /* @__PURE__ */ Object.create(null);
  var defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}

// node_modules/optimism/lib/index.js
var import_dist427 = __toESM(require_dist());
var import_dist428 = __toESM(require_dist2());
var import_dist429 = __toESM(require_dist3());

// node_modules/optimism/lib/entry.js
var import_dist421 = __toESM(require_dist(), 1);
var import_dist422 = __toESM(require_dist2(), 1);
var import_dist423 = __toESM(require_dist3(), 1);

// node_modules/optimism/lib/context.js
var import_dist415 = __toESM(require_dist(), 1);
var import_dist416 = __toESM(require_dist2(), 1);
var import_dist417 = __toESM(require_dist3(), 1);

// node_modules/@wry/context/lib/index.js
var import_dist412 = __toESM(require_dist());
var import_dist413 = __toESM(require_dist2());
var import_dist414 = __toESM(require_dist3());

// node_modules/@wry/context/lib/slot.js
var import_dist409 = __toESM(require_dist(), 1);
var import_dist410 = __toESM(require_dist2(), 1);
var import_dist411 = __toESM(require_dist3(), 1);
var currentContext = null;
var MISSING_VALUE = {};
var idCounter2 = 1;
var makeSlotClass = () => class Slot {
  constructor() {
    this.id = [
      "slot",
      idCounter2++,
      Date.now(),
      Math.random().toString(36).slice(2)
    ].join(":");
  }
  hasValue() {
    for (let context = currentContext; context; context = context.parent) {
      if (this.id in context.slots) {
        const value = context.slots[this.id];
        if (value === MISSING_VALUE)
          break;
        if (context !== currentContext) {
          currentContext.slots[this.id] = value;
        }
        return true;
      }
    }
    if (currentContext) {
      currentContext.slots[this.id] = MISSING_VALUE;
    }
    return false;
  }
  getValue() {
    if (this.hasValue()) {
      return currentContext.slots[this.id];
    }
  }
  withValue(value, callback, args, thisArg) {
    const slots = {
      __proto__: null,
      [this.id]: value
    };
    const parent = currentContext;
    currentContext = { parent, slots };
    try {
      return callback.apply(thisArg, args);
    } finally {
      currentContext = parent;
    }
  }
  // Capture the current context and wrap a callback function so that it
  // reestablishes the captured context when called.
  static bind(callback) {
    const context = currentContext;
    return function() {
      const saved = currentContext;
      try {
        currentContext = context;
        return callback.apply(this, arguments);
      } finally {
        currentContext = saved;
      }
    };
  }
  // Immediately run a callback function without any captured context.
  static noContext(callback, args, thisArg) {
    if (currentContext) {
      const saved = currentContext;
      try {
        currentContext = null;
        return callback.apply(thisArg, args);
      } finally {
        currentContext = saved;
      }
    } else {
      return callback.apply(thisArg, args);
    }
  }
};
function maybe2(fn) {
  try {
    return fn();
  } catch (ignored) {
  }
}
var globalKey = "@wry/context:Slot";
var host = (
  // Prefer globalThis when available.
  // https://github.com/benjamn/wryware/issues/347
  maybe2(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
  // bundlers to the appropriate identifier (window, self, ...) depending on the
  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
  maybe2(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall
  // back to using the Array constructor as a namespace, but that was flagged in
  // https://github.com/benjamn/wryware/issues/347, and can be avoided.
  /* @__PURE__ */ Object.create(null)
);
var globalHost = host;
var Slot2 = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array
// constructor, so we check there as well, to prevent Slot class duplication.
Array[globalKey] || function(Slot3) {
  try {
    Object.defineProperty(globalHost, globalKey, {
      value: Slot3,
      enumerable: false,
      writable: false,
      // When it was possible for globalHost to be the Array constructor (a
      // legacy Slot dedup strategy), it was important for the property to be
      // configurable:true so it could be deleted. That does not seem to be as
      // important when globalHost is the global object, but I don't want to
      // cause similar problems again, and configurable:true seems safest.
      // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
      configurable: true
    });
  } finally {
    return Slot3;
  }
}(makeSlotClass());

// node_modules/@wry/context/lib/index.js
var { bind, noContext } = Slot2;

// node_modules/optimism/lib/context.js
var parentEntrySlot = new Slot2();

// node_modules/optimism/lib/helpers.js
var import_dist418 = __toESM(require_dist(), 1);
var import_dist419 = __toESM(require_dist2(), 1);
var import_dist420 = __toESM(require_dist3(), 1);
var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
var arrayFromSet = Array.from || function(set) {
  const array = [];
  set.forEach((item) => array.push(item));
  return array;
};
function maybeUnsubscribe(entryOrDep) {
  const { unsubscribe } = entryOrDep;
  if (typeof unsubscribe === "function") {
    entryOrDep.unsubscribe = void 0;
    unsubscribe();
  }
}

// node_modules/optimism/lib/entry.js
var emptySetPool = [];
var POOL_TARGET_SIZE = 100;
function assert2(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a, b) {
  const len = a.length;
  return (
    // Unknown values are not equal to each other.
    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    len === b.length && // The underlying value or exception must be the same.
    a[len - 1] === b[len - 1]
  );
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
var Entry = class _Entry {
  constructor(fn) {
    this.fn = fn;
    this.parents = /* @__PURE__ */ new Set();
    this.childValues = /* @__PURE__ */ new Map();
    this.dirtyChildren = null;
    this.dirty = true;
    this.recomputing = false;
    this.value = [];
    this.deps = null;
    ++_Entry.count;
  }
  peek() {
    if (this.value.length === 1 && !mightBeDirty(this)) {
      rememberParent(this);
      return this.value[0];
    }
  }
  // This is the most important method of the Entry API, because it
  // determines whether the cached this.value can be returned immediately,
  // or must be recomputed. The overall performance of the caching system
  // depends on the truth of the following observations: (1) this.dirty is
  // usually false, (2) this.dirtyChildren is usually null/empty, and thus
  // (3) valueGet(this.value) is usually returned without recomputation.
  recompute(args) {
    assert2(!this.recomputing, "already recomputing");
    rememberParent(this);
    return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
  }
  setDirty() {
    if (this.dirty)
      return;
    this.dirty = true;
    reportDirty(this);
    maybeUnsubscribe(this);
  }
  dispose() {
    this.setDirty();
    forgetChildren(this);
    eachParent(this, (parent, child) => {
      parent.setDirty();
      forgetChild(parent, this);
    });
  }
  forget() {
    this.dispose();
  }
  dependOn(dep2) {
    dep2.add(this);
    if (!this.deps) {
      this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
    }
    this.deps.add(dep2);
  }
  forgetDeps() {
    if (this.deps) {
      arrayFromSet(this.deps).forEach((dep2) => dep2.delete(this));
      this.deps.clear();
      emptySetPool.push(this.deps);
      this.deps = null;
    }
  }
};
Entry.count = 0;
function rememberParent(child) {
  const parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry, args) {
  forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
  if (maybeSubscribe(entry, args)) {
    setClean(entry);
  }
  return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
  entry.recomputing = true;
  const { normalizeResult } = entry;
  let oldValueCopy;
  if (normalizeResult && entry.value.length === 1) {
    oldValueCopy = valueCopy(entry.value);
  }
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, args);
    if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {
      try {
        entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);
      } catch (_a2) {
      }
    }
  } catch (e) {
    entry.value[1] = e;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  eachParent(child, reportDirtyChild);
}
function reportClean(child) {
  eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
  const parentCount = child.parents.size;
  if (parentCount) {
    const parents = arrayFromSet(child.parents);
    for (let i = 0; i < parentCount; ++i) {
      callback(parents[i], child);
    }
  }
}
function reportDirtyChild(parent, child) {
  assert2(parent.childValues.has(child));
  assert2(mightBeDirty(child));
  const parentWasClean = !mightBeDirty(parent);
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  if (parentWasClean) {
    reportDirty(parent);
  }
}
function reportCleanChild(parent, child) {
  assert2(parent.childValues.has(child));
  assert2(!mightBeDirty(child));
  const childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  const dc = parent.dirtyChildren;
  if (dc) {
    dc.delete(child);
    if (dc.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }
      parent.dirtyChildren = null;
    }
  }
}
function forgetChildren(parent) {
  if (parent.childValues.size > 0) {
    parent.childValues.forEach((_value, child) => {
      forgetChild(parent, child);
    });
  }
  parent.forgetDeps();
  assert2(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, args);
    } catch (e) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}

// node_modules/optimism/lib/dep.js
var import_dist424 = __toESM(require_dist(), 1);
var import_dist425 = __toESM(require_dist2(), 1);
var import_dist426 = __toESM(require_dist3(), 1);
var EntryMethods = {
  setDirty: true,
  dispose: true,
  forget: true
  // Fully remove parent Entry from LRU cache and computation graph
};
function dep(options) {
  const depsByKey = /* @__PURE__ */ new Map();
  const subscribe = options && options.subscribe;
  function depend(key) {
    const parent = parentEntrySlot.getValue();
    if (parent) {
      let dep2 = depsByKey.get(key);
      if (!dep2) {
        depsByKey.set(key, dep2 = /* @__PURE__ */ new Set());
      }
      parent.dependOn(dep2);
      if (typeof subscribe === "function") {
        maybeUnsubscribe(dep2);
        dep2.unsubscribe = subscribe(key);
      }
    }
  }
  depend.dirty = function dirty(key, entryMethodName) {
    const dep2 = depsByKey.get(key);
    if (dep2) {
      const m = entryMethodName && hasOwnProperty2.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
      arrayFromSet(dep2).forEach((entry) => entry[m]());
      depsByKey.delete(key);
      maybeUnsubscribe(dep2);
    }
  };
  return depend;
}

// node_modules/optimism/lib/index.js
var defaultKeyTrie;
function defaultMakeCacheKey(...args) {
  const trie = defaultKeyTrie || (defaultKeyTrie = new Trie(typeof WeakMap === "function"));
  return trie.lookupArray(args);
}
var caches = /* @__PURE__ */ new Set();
function wrap2(originalFunction, { max: max2 = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = StrongCache } = /* @__PURE__ */ Object.create(null)) {
  const cache2 = typeof cacheOption === "function" ? new cacheOption(max2, (entry) => entry.dispose()) : cacheOption;
  const optimistic = function() {
    const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    let entry = cache2.get(key);
    if (!entry) {
      cache2.set(key, entry = new Entry(originalFunction));
      entry.normalizeResult = normalizeResult;
      entry.subscribe = subscribe;
      entry.forget = () => cache2.delete(key);
    }
    const value = entry.recompute(Array.prototype.slice.call(arguments));
    cache2.set(key, entry);
    caches.add(cache2);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach((cache3) => cache3.clean());
      caches.clear();
    }
    return value;
  };
  Object.defineProperty(optimistic, "size", {
    get: () => cache2.size,
    configurable: false,
    enumerable: false
  });
  Object.freeze(optimistic.options = {
    max: max2,
    keyArgs,
    makeCacheKey,
    normalizeResult,
    subscribe,
    cache: cache2
  });
  function dirtyKey(key) {
    const entry = key && cache2.get(key);
    if (entry) {
      entry.setDirty();
    }
  }
  optimistic.dirtyKey = dirtyKey;
  optimistic.dirty = function dirty() {
    dirtyKey(makeCacheKey.apply(null, arguments));
  };
  function peekKey(key) {
    const entry = key && cache2.get(key);
    if (entry) {
      return entry.peek();
    }
  }
  optimistic.peekKey = peekKey;
  optimistic.peek = function peek() {
    return peekKey(makeCacheKey.apply(null, arguments));
  };
  function forgetKey(key) {
    return key ? cache2.delete(key) : false;
  }
  optimistic.forgetKey = forgetKey;
  optimistic.forget = function forget() {
    return forgetKey(makeCacheKey.apply(null, arguments));
  };
  optimistic.makeCacheKey = makeCacheKey;
  optimistic.getKey = keyArgs ? function getKey() {
    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
  } : makeCacheKey;
  return Object.freeze(optimistic);
}

// node_modules/@apollo/client/utilities/graphql/DocumentTransform.js
function identity(document2) {
  return document2;
}
var DocumentTransform = (
  /** @class */
  function() {
    function DocumentTransform2(transform, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      this.resultCache = canUseWeakSet ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
      this.transform = transform;
      if (options.getCacheKey) {
        this.getCacheKey = options.getCacheKey;
      }
      this.cached = options.cache !== false;
      this.resetCache();
    }
    DocumentTransform2.prototype.getCacheKey = function(document2) {
      return [document2];
    };
    DocumentTransform2.identity = function() {
      return new DocumentTransform2(identity, { cache: false });
    };
    DocumentTransform2.split = function(predicate, left, right) {
      if (right === void 0) {
        right = DocumentTransform2.identity();
      }
      return Object.assign(new DocumentTransform2(
        function(document2) {
          var documentTransform = predicate(document2) ? left : right;
          return documentTransform.transformDocument(document2);
        },
        // Reasonably assume both `left` and `right` transforms handle their own caching
        { cache: false }
      ), { left, right });
    };
    DocumentTransform2.prototype.resetCache = function() {
      var _this = this;
      if (this.cached) {
        var stableCacheKeys_1 = new Trie(canUseWeakMap);
        this.performWork = wrap2(DocumentTransform2.prototype.performWork.bind(this), {
          makeCacheKey: function(document2) {
            var cacheKeys = _this.getCacheKey(document2);
            if (cacheKeys) {
              invariant2(Array.isArray(cacheKeys), 77);
              return stableCacheKeys_1.lookupArray(cacheKeys);
            }
          },
          max: cacheSizes["documentTransform.cache"],
          cache: WeakCache
        });
      }
    };
    DocumentTransform2.prototype.performWork = function(document2) {
      checkDocument(document2);
      return this.transform(document2);
    };
    DocumentTransform2.prototype.transformDocument = function(document2) {
      if (this.resultCache.has(document2)) {
        return document2;
      }
      var transformedDocument = this.performWork(document2);
      this.resultCache.add(transformedDocument);
      return transformedDocument;
    };
    DocumentTransform2.prototype.concat = function(otherTransform) {
      var _this = this;
      return Object.assign(new DocumentTransform2(
        function(document2) {
          return otherTransform.transformDocument(_this.transformDocument(document2));
        },
        // Reasonably assume both transforms handle their own caching
        { cache: false }
      ), {
        left: this,
        right: otherTransform
      });
    };
    return DocumentTransform2;
  }()
);

// node_modules/@apollo/client/utilities/graphql/print.js
var import_dist433 = __toESM(require_dist(), 1);
var import_dist434 = __toESM(require_dist2(), 1);
var import_dist435 = __toESM(require_dist3(), 1);
var printCache;
var print2 = Object.assign(function(ast) {
  var result2 = printCache.get(ast);
  if (!result2) {
    result2 = print(ast);
    printCache.set(ast, result2);
  }
  return result2;
}, {
  reset: function() {
    printCache = new AutoCleanedWeakCache(
      cacheSizes.print || 2e3
      /* defaultCacheSizes.print */
    );
  }
});
print2.reset();
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("print", function() {
    return printCache ? printCache.size : 0;
  });
}

// node_modules/@apollo/client/utilities/graphql/transform.js
var import_dist439 = __toESM(require_dist(), 1);
var import_dist440 = __toESM(require_dist2(), 1);
var import_dist441 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/common/arrays.js
var import_dist436 = __toESM(require_dist(), 1);
var import_dist437 = __toESM(require_dist2(), 1);
var import_dist438 = __toESM(require_dist3(), 1);
var isArray = Array.isArray;
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}

// node_modules/@apollo/client/utilities/graphql/transform.js
var TYPENAME_FIELD = {
  kind: Kind.FIELD,
  name: {
    kind: Kind.NAME,
    value: "__typename"
  }
};
function isEmpty(op, fragmentMap) {
  return !op || op.selectionSet.selections.every(function(selection) {
    return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
  });
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}
function getDirectiveMatcher(configs) {
  var names = /* @__PURE__ */ new Map();
  var tests = /* @__PURE__ */ new Map();
  configs.forEach(function(directive) {
    if (directive) {
      if (directive.name) {
        names.set(directive.name, directive);
      } else if (directive.test) {
        tests.set(directive.test, directive);
      }
    }
  });
  return function(directive) {
    var config = names.get(directive.name.value);
    if (!config && tests.size) {
      tests.forEach(function(testConfig, test) {
        if (test(directive)) {
          config = testConfig;
        }
      });
    }
    return config;
  };
}
function makeInUseGetterFunction(defaultKey) {
  var map = /* @__PURE__ */ new Map();
  return function inUseGetterFunction(key) {
    if (key === void 0) {
      key = defaultKey;
    }
    var inUse = map.get(key);
    if (!inUse) {
      map.set(key, inUse = {
        // Variable and fragment spread names used directly within this
        // operation or fragment definition, as identified by key. These sets
        // will be populated during the first traversal of the document in
        // removeDirectivesFromDocument below.
        variables: /* @__PURE__ */ new Set(),
        fragmentSpreads: /* @__PURE__ */ new Set()
      });
    }
    return inUse;
  };
}
function removeDirectivesFromDocument(directives, doc) {
  checkDocument(doc);
  var getInUseByOperationName = makeInUseGetterFunction("");
  var getInUseByFragmentName = makeInUseGetterFunction("");
  var getInUse = function(ancestors) {
    for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {
      if (isArray(ancestor))
        continue;
      if (ancestor.kind === Kind.OPERATION_DEFINITION) {
        return getInUseByOperationName(ancestor.name && ancestor.name.value);
      }
      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {
        return getInUseByFragmentName(ancestor.name.value);
      }
    }
    globalThis.__DEV__ !== false && invariant2.error(97);
    return null;
  };
  var operationCount = 0;
  for (var i = doc.definitions.length - 1; i >= 0; --i) {
    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {
      ++operationCount;
    }
  }
  var directiveMatcher = getDirectiveMatcher(directives);
  var shouldRemoveField = function(nodeDirectives) {
    return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
      return config && config.remove;
    });
  };
  var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
  var firstVisitMadeChanges = false;
  var fieldOrInlineFragmentVisitor = {
    enter: function(node) {
      if (shouldRemoveField(node.directives)) {
        firstVisitMadeChanges = true;
        return null;
      }
    }
  };
  var docWithoutDirectiveSubtrees = visit(doc, {
    // These two AST node types share the same implementation, defined above.
    Field: fieldOrInlineFragmentVisitor,
    InlineFragment: fieldOrInlineFragmentVisitor,
    VariableDefinition: {
      enter: function() {
        return false;
      }
    },
    Variable: {
      enter: function(node, _key, _parent, _path, ancestors) {
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.variables.add(node.name.value);
        }
      }
    },
    FragmentSpread: {
      enter: function(node, _key, _parent, _path, ancestors) {
        if (shouldRemoveField(node.directives)) {
          firstVisitMadeChanges = true;
          return null;
        }
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.fragmentSpreads.add(node.name.value);
        }
      }
    },
    FragmentDefinition: {
      enter: function(node, _key, _parent, path) {
        originalFragmentDefsByPath.set(JSON.stringify(path), node);
      },
      leave: function(node, _key, _parent, path) {
        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
        if (node === originalNode) {
          return node;
        }
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          operationCount > 0 && node.selectionSet.selections.every(function(selection) {
            return selection.kind === Kind.FIELD && selection.name.value === "__typename";
          })
        ) {
          getInUseByFragmentName(node.name.value).removed = true;
          firstVisitMadeChanges = true;
          return null;
        }
      }
    },
    Directive: {
      leave: function(node) {
        if (directiveMatcher(node)) {
          firstVisitMadeChanges = true;
          return null;
        }
      }
    }
  });
  if (!firstVisitMadeChanges) {
    return doc;
  }
  var populateTransitiveVars = function(inUse) {
    if (!inUse.transitiveVars) {
      inUse.transitiveVars = new Set(inUse.variables);
      if (!inUse.removed) {
        inUse.fragmentSpreads.forEach(function(childFragmentName) {
          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
            inUse.transitiveVars.add(varName);
          });
        });
      }
    }
    return inUse;
  };
  var allFragmentNamesUsed = /* @__PURE__ */ new Set();
  docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
    if (def.kind === Kind.OPERATION_DEFINITION) {
      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
        allFragmentNamesUsed.add(childFragmentName);
      });
    } else if (def.kind === Kind.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
      allFragmentNamesUsed.add(def.name.value);
    }
  });
  allFragmentNamesUsed.forEach(function(fragmentName) {
    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
      allFragmentNamesUsed.add(childFragmentName);
    });
  });
  var fragmentWillBeRemoved = function(fragmentName) {
    return !!// A fragment definition will be removed if there are no spreads that refer
    // to it, or the fragment was explicitly removed because it had no fields
    // other than __typename.
    (!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
  };
  var enterVisitor = {
    enter: function(node) {
      if (fragmentWillBeRemoved(node.name.value)) {
        return null;
      }
    }
  };
  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: enterVisitor,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: enterVisitor,
    OperationDefinition: {
      leave: function(node) {
        if (node.variableDefinitions) {
          var usedVariableNames_1 = populateTransitiveVars(
            // If an operation is anonymous, we use the empty string as its key.
            getInUseByOperationName(node.name && node.name.value)
          ).transitiveVars;
          if (usedVariableNames_1.size < node.variableDefinitions.length) {
            return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {
              return usedVariableNames_1.has(varDef.variable.name.value);
            }) });
          }
        }
      }
    }
  }));
}
var addTypenameToDocument = Object.assign(function(doc) {
  return visit(doc, {
    SelectionSet: {
      enter: function(node, _key, parent) {
        if (parent && parent.kind === Kind.OPERATION_DEFINITION) {
          return;
        }
        var selections = node.selections;
        if (!selections) {
          return;
        }
        var skip = selections.some(function(selection) {
          return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip) {
          return;
        }
        var field = parent;
        if (isField(field) && field.directives && field.directives.some(function(d) {
          return d.name.value === "export";
        })) {
          return;
        }
        return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
      }
    }
  });
}, {
  added: function(field) {
    return field === TYPENAME_FIELD;
  }
});
function buildQueryFromSelectionSet(document2) {
  var definition = getMainDefinition(document2);
  var definitionOperation = definition.operation;
  if (definitionOperation === "query") {
    return document2;
  }
  var modifiedDoc = visit(document2, {
    OperationDefinition: {
      enter: function(node) {
        return __assign(__assign({}, node), { operation: "query" });
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument(document2) {
  checkDocument(document2);
  var modifiedDoc = removeDirectivesFromDocument([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document2);
  return modifiedDoc;
}
function addNonReactiveToNamedFragments(document2) {
  checkDocument(document2);
  return visit(document2, {
    FragmentSpread: function(node) {
      var _a2;
      if ((_a2 = node.directives) === null || _a2 === void 0 ? void 0 : _a2.some(function(directive) {
        return directive.name.value === "unmask";
      })) {
        return;
      }
      return __assign(__assign({}, node), { directives: __spreadArray(__spreadArray([], node.directives || [], true), [
        {
          kind: Kind.DIRECTIVE,
          name: { kind: Kind.NAME, value: "nonreactive" }
        }
      ], false) });
    }
  });
}

// node_modules/@apollo/client/utilities/graphql/operations.js
var import_dist442 = __toESM(require_dist(), 1);
var import_dist443 = __toESM(require_dist2(), 1);
var import_dist444 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/policies/pagination.js
var import_dist448 = __toESM(require_dist(), 1);
var import_dist449 = __toESM(require_dist2(), 1);
var import_dist450 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/common/mergeDeep.js
var import_dist445 = __toESM(require_dist(), 1);
var import_dist446 = __toESM(require_dist2(), 1);
var import_dist447 = __toESM(require_dist3(), 1);
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
function mergeDeep() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count3 = sources.length;
  if (count3 > 1) {
    var merger = new DeepMerger();
    for (var i = 1; i < count3; ++i) {
      target = merger.merge(target, sources[i]);
    }
  }
  return target;
}
var defaultReconciler = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger = (
  /** @class */
  function() {
    function DeepMerger2(reconciler) {
      if (reconciler === void 0) {
        reconciler = defaultReconciler;
      }
      this.reconciler = reconciler;
      this.isObject = isNonNullObject;
      this.pastCopies = /* @__PURE__ */ new Set();
    }
    DeepMerger2.prototype.merge = function(target, source) {
      var _this = this;
      var context = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        context[_i - 2] = arguments[_i];
      }
      if (isNonNullObject(source) && isNonNullObject(target)) {
        Object.keys(source).forEach(function(sourceKey) {
          if (hasOwnProperty3.call(target, sourceKey)) {
            var targetValue = target[sourceKey];
            if (source[sourceKey] !== targetValue) {
              var result2 = _this.reconciler.apply(_this, __spreadArray([
                target,
                source,
                sourceKey
              ], context, false));
              if (result2 !== targetValue) {
                target = _this.shallowCopyForMerge(target);
                target[sourceKey] = result2;
              }
            }
          } else {
            target = _this.shallowCopyForMerge(target);
            target[sourceKey] = source[sourceKey];
          }
        });
        return target;
      }
      return source;
    };
    DeepMerger2.prototype.shallowCopyForMerge = function(value) {
      if (isNonNullObject(value)) {
        if (!this.pastCopies.has(value)) {
          if (Array.isArray(value)) {
            value = value.slice(0);
          } else {
            value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);
          }
          this.pastCopies.add(value);
        }
      }
      return value;
    };
    return DeepMerger2;
  }()
);

// node_modules/@apollo/client/utilities/observables/Observable.js
var import_dist460 = __toESM(require_dist(), 1);
var import_dist461 = __toESM(require_dist2(), 1);
var import_dist462 = __toESM(require_dist3(), 1);

// node_modules/zen-observable-ts/module.js
var import_dist451 = __toESM(require_dist());
var import_dist452 = __toESM(require_dist2());
var import_dist453 = __toESM(require_dist3());
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var hasSymbols = function() {
  return typeof Symbol === "function";
};
var hasSymbol = function(name) {
  return hasSymbols() && Boolean(Symbol[name]);
};
var getSymbol = function(name) {
  return hasSymbol(name) ? Symbol[name] : "@@" + name;
};
if (hasSymbols() && !hasSymbol("observable")) {
  Symbol.observable = Symbol("observable");
}
var SymbolIterator = getSymbol("iterator");
var SymbolObservable = getSymbol("observable");
var SymbolSpecies = getSymbol("species");
function getMethod(obj, key) {
  var value = obj[key];
  if (value == null) return void 0;
  if (typeof value !== "function") throw new TypeError(value + " is not a function");
  return value;
}
function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x) {
  return x instanceof Observable;
}
function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function() {
      throw e;
    });
  }
}
function enqueue(fn) {
  Promise.resolve().then(function() {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}
function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === void 0) return;
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, "unsubscribe");
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === "closed") break;
  }
}
function notifySubscription(subscription, type, value) {
  subscription._state = "running";
  var observer = subscription._observer;
  try {
    var m = getMethod(observer, type);
    switch (type) {
      case "next":
        if (m) m.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m) m.call(observer, value);
        else throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m) m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }
  if (subscription._state === "closed") cleanupSubscription(subscription);
  else if (subscription._state === "running") subscription._state = "ready";
}
function onNotify(subscription, type, value) {
  if (subscription._state === "closed") return;
  if (subscription._state === "buffering") {
    subscription._queue.push({
      type,
      value
    });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{
      type,
      value
    }];
    enqueue(function() {
      return flushSubscription(subscription);
    });
    return;
  }
  notifySubscription(subscription, type, value);
}
var Subscription = function() {
  function Subscription2(observer, subscriber) {
    this._cleanup = void 0;
    this._observer = observer;
    this._queue = void 0;
    this._state = "initializing";
    var subscriptionObserver = new SubscriptionObserver(this);
    try {
      this._cleanup = subscriber.call(void 0, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }
    if (this._state === "initializing") this._state = "ready";
  }
  var _proto = Subscription2.prototype;
  _proto.unsubscribe = function unsubscribe() {
    if (this._state !== "closed") {
      closeSubscription(this);
      cleanupSubscription(this);
    }
  };
  _createClass(Subscription2, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]);
  return Subscription2;
}();
var SubscriptionObserver = function() {
  function SubscriptionObserver2(subscription) {
    this._subscription = subscription;
  }
  var _proto2 = SubscriptionObserver2.prototype;
  _proto2.next = function next(value) {
    onNotify(this._subscription, "next", value);
  };
  _proto2.error = function error(value) {
    onNotify(this._subscription, "error", value);
  };
  _proto2.complete = function complete() {
    onNotify(this._subscription, "complete");
  };
  _createClass(SubscriptionObserver2, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]);
  return SubscriptionObserver2;
}();
var Observable = function() {
  function Observable2(subscriber) {
    if (!(this instanceof Observable2)) throw new TypeError("Observable cannot be called as a function");
    if (typeof subscriber !== "function") throw new TypeError("Observable initializer must be a function");
    this._subscriber = subscriber;
  }
  var _proto3 = Observable2.prototype;
  _proto3.subscribe = function subscribe(observer) {
    if (typeof observer !== "object" || observer === null) {
      observer = {
        next: observer,
        error: arguments[1],
        complete: arguments[2]
      };
    }
    return new Subscription(observer, this._subscriber);
  };
  _proto3.forEach = function forEach2(fn) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      if (typeof fn !== "function") {
        reject(new TypeError(fn + " is not a function"));
        return;
      }
      function done() {
        subscription.unsubscribe();
        resolve();
      }
      var subscription = _this.subscribe({
        next: function(value) {
          try {
            fn(value, done);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  };
  _proto3.map = function map(fn) {
    var _this2 = this;
    if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
    var C = getSpecies(this);
    return new C(function(observer) {
      return _this2.subscribe({
        next: function(value) {
          try {
            value = fn(value);
          } catch (e) {
            return observer.error(e);
          }
          observer.next(value);
        },
        error: function(e) {
          observer.error(e);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.filter = function filter(fn) {
    var _this3 = this;
    if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
    var C = getSpecies(this);
    return new C(function(observer) {
      return _this3.subscribe({
        next: function(value) {
          try {
            if (!fn(value)) return;
          } catch (e) {
            return observer.error(e);
          }
          observer.next(value);
        },
        error: function(e) {
          observer.error(e);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.reduce = function reduce(fn) {
    var _this4 = this;
    if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
    var C = getSpecies(this);
    var hasSeed = arguments.length > 1;
    var hasValue = false;
    var seed = arguments[1];
    var acc = seed;
    return new C(function(observer) {
      return _this4.subscribe({
        next: function(value) {
          var first = !hasValue;
          hasValue = true;
          if (!first || hasSeed) {
            try {
              acc = fn(acc, value);
            } catch (e) {
              return observer.error(e);
            }
          } else {
            acc = value;
          }
        },
        error: function(e) {
          observer.error(e);
        },
        complete: function() {
          if (!hasValue && !hasSeed) return observer.error(new TypeError("Cannot reduce an empty sequence"));
          observer.next(acc);
          observer.complete();
        }
      });
    });
  };
  _proto3.concat = function concat3() {
    var _this5 = this;
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var C = getSpecies(this);
    return new C(function(observer) {
      var subscription;
      var index2 = 0;
      function startNext(next) {
        subscription = next.subscribe({
          next: function(v) {
            observer.next(v);
          },
          error: function(e) {
            observer.error(e);
          },
          complete: function() {
            if (index2 === sources.length) {
              subscription = void 0;
              observer.complete();
            } else {
              startNext(C.from(sources[index2++]));
            }
          }
        });
      }
      startNext(_this5);
      return function() {
        if (subscription) {
          subscription.unsubscribe();
          subscription = void 0;
        }
      };
    });
  };
  _proto3.flatMap = function flatMap(fn) {
    var _this6 = this;
    if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
    var C = getSpecies(this);
    return new C(function(observer) {
      var subscriptions = [];
      var outer = _this6.subscribe({
        next: function(value) {
          if (fn) {
            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }
          }
          var inner = C.from(value).subscribe({
            next: function(value2) {
              observer.next(value2);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              var i = subscriptions.indexOf(inner);
              if (i >= 0) subscriptions.splice(i, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner);
        },
        error: function(e) {
          observer.error(e);
        },
        complete: function() {
          completeIfDone();
        }
      });
      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0) observer.complete();
      }
      return function() {
        subscriptions.forEach(function(s) {
          return s.unsubscribe();
        });
        outer.unsubscribe();
      };
    });
  };
  _proto3[SymbolObservable] = function() {
    return this;
  };
  Observable2.from = function from2(x) {
    var C = typeof this === "function" ? this : Observable2;
    if (x == null) throw new TypeError(x + " is not an object");
    var method = getMethod(x, SymbolObservable);
    if (method) {
      var observable = method.call(x);
      if (Object(observable) !== observable) throw new TypeError(observable + " is not an object");
      if (isObservable(observable) && observable.constructor === C) return observable;
      return new C(function(observer) {
        return observable.subscribe(observer);
      });
    }
    if (hasSymbol("iterator")) {
      method = getMethod(x, SymbolIterator);
      if (method) {
        return new C(function(observer) {
          enqueue(function() {
            if (observer.closed) return;
            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done; ) {
              var item = _step.value;
              observer.next(item);
              if (observer.closed) return;
            }
            observer.complete();
          });
        });
      }
    }
    if (Array.isArray(x)) {
      return new C(function(observer) {
        enqueue(function() {
          if (observer.closed) return;
          for (var i = 0; i < x.length; ++i) {
            observer.next(x[i]);
            if (observer.closed) return;
          }
          observer.complete();
        });
      });
    }
    throw new TypeError(x + " is not observable");
  };
  Observable2.of = function of() {
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    var C = typeof this === "function" ? this : Observable2;
    return new C(function(observer) {
      enqueue(function() {
        if (observer.closed) return;
        for (var i = 0; i < items.length; ++i) {
          observer.next(items[i]);
          if (observer.closed) return;
        }
        observer.complete();
      });
    });
  };
  _createClass(Observable2, null, [{
    key: SymbolSpecies,
    get: function() {
      return this;
    }
  }]);
  return Observable2;
}();
if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol("extensions"), {
    value: {
      symbol: SymbolObservable,
      hostReportError
    },
    configurable: true
  });
}

// node_modules/@apollo/client/node_modules/symbol-observable/es/index.js
var import_dist457 = __toESM(require_dist());
var import_dist458 = __toESM(require_dist2());
var import_dist459 = __toESM(require_dist3());

// node_modules/@apollo/client/node_modules/symbol-observable/es/ponyfill.js
var import_dist454 = __toESM(require_dist());
var import_dist455 = __toESM(require_dist2());
var import_dist456 = __toESM(require_dist3());
function symbolObservablePonyfill(root2) {
  var result2;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result2 = Symbol2.observable;
    } else {
      if (typeof Symbol2.for === "function") {
        result2 = Symbol2.for("https://github.com/benlesh/symbol-observable");
      } else {
        result2 = Symbol2("https://github.com/benlesh/symbol-observable");
      }
      try {
        Symbol2.observable = result2;
      } catch (err) {
      }
    }
  } else {
    result2 = "@@observable";
  }
  return result2;
}

// node_modules/@apollo/client/node_modules/symbol-observable/es/index.js
var root;
if (typeof self !== "undefined") {
  root = self;
} else if (typeof window !== "undefined") {
  root = window;
} else if (typeof global !== "undefined") {
  root = global;
} else if (typeof module !== "undefined") {
  root = module;
} else {
  root = Function("return this")();
}
var result = symbolObservablePonyfill(root);

// node_modules/@apollo/client/utilities/observables/Observable.js
var prototype = Observable.prototype;
var fakeObsSymbol = "@@observable";
if (!prototype[fakeObsSymbol]) {
  prototype[fakeObsSymbol] = function() {
    return this;
  };
}

// node_modules/@apollo/client/utilities/promises/decoration.js
var import_dist463 = __toESM(require_dist(), 1);
var import_dist464 = __toESM(require_dist2(), 1);
var import_dist465 = __toESM(require_dist3(), 1);
function createFulfilledPromise(value) {
  var promise = Promise.resolve(value);
  promise.status = "fulfilled";
  promise.value = value;
  return promise;
}
function createRejectedPromise(reason) {
  var promise = Promise.reject(reason);
  promise.catch(function() {
  });
  promise.status = "rejected";
  promise.reason = reason;
  return promise;
}
function isStatefulPromise(promise) {
  return "status" in promise;
}
function wrapPromiseWithState(promise) {
  if (isStatefulPromise(promise)) {
    return promise;
  }
  var pendingPromise = promise;
  pendingPromise.status = "pending";
  pendingPromise.then(function(value) {
    if (pendingPromise.status === "pending") {
      var fulfilledPromise = pendingPromise;
      fulfilledPromise.status = "fulfilled";
      fulfilledPromise.value = value;
    }
  }, function(reason) {
    if (pendingPromise.status === "pending") {
      var rejectedPromise = pendingPromise;
      rejectedPromise.status = "rejected";
      rejectedPromise.reason = reason;
    }
  });
  return promise;
}

// node_modules/@apollo/client/utilities/promises/preventUnhandledRejection.js
var import_dist466 = __toESM(require_dist(), 1);
var import_dist467 = __toESM(require_dist2(), 1);
var import_dist468 = __toESM(require_dist3(), 1);
function preventUnhandledRejection(promise) {
  promise.catch(function() {
  });
  return promise;
}

// node_modules/@apollo/client/utilities/common/cloneDeep.js
var import_dist469 = __toESM(require_dist(), 1);
var import_dist470 = __toESM(require_dist2(), 1);
var import_dist471 = __toESM(require_dist3(), 1);
var toString = Object.prototype.toString;
function cloneDeep(value) {
  return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen) {
  switch (toString.call(val)) {
    case "[object Array]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_1 = val.slice(0);
      seen.set(val, copy_1);
      copy_1.forEach(function(child, i) {
        copy_1[i] = cloneDeepHelper(child, seen);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen.set(val, copy_2);
      Object.keys(val).forEach(function(key) {
        copy_2[key] = cloneDeepHelper(val[key], seen);
      });
      return copy_2;
    }
    default:
      return val;
  }
}

// node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js
var import_dist472 = __toESM(require_dist(), 1);
var import_dist473 = __toESM(require_dist2(), 1);
var import_dist474 = __toESM(require_dist3(), 1);
function deepFreeze(value) {
  var workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach(function(obj) {
    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        if (isNonNullObject(obj[name]))
          workSet.add(obj[name]);
      });
    }
  });
  return value;
}
function shallowFreeze(obj) {
  if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e) {
      if (e instanceof TypeError)
        return null;
      throw e;
    }
  }
  return obj;
}
function maybeDeepFreeze(obj) {
  if (globalThis.__DEV__ !== false) {
    deepFreeze(obj);
  }
  return obj;
}

// node_modules/@apollo/client/utilities/observables/iteration.js
var import_dist475 = __toESM(require_dist(), 1);
var import_dist476 = __toESM(require_dist2(), 1);
var import_dist477 = __toESM(require_dist3(), 1);
function iterateObserversSafely(observers, method, argument) {
  var observersWithMethod = [];
  observers.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}

// node_modules/@apollo/client/utilities/observables/asyncMap.js
var import_dist478 = __toESM(require_dist(), 1);
var import_dist479 = __toESM(require_dist2(), 1);
var import_dist480 = __toESM(require_dist3(), 1);
function asyncMap(observable, mapFn, catchFn) {
  return new Observable(function(observer) {
    var promiseQueue = {
      // Normally we would initialize promiseQueue to Promise.resolve(), but
      // in this case, for backwards compatibility, we need to be careful to
      // invoke the first callback synchronously.
      then: function(callback) {
        return new Promise(function(resolve) {
          return resolve(callback());
        });
      }
    };
    function makeCallback(examiner, key) {
      return function(arg) {
        if (examiner) {
          var both = function() {
            return observer.closed ? (
              /* will be swallowed */
              0
            ) : examiner(arg);
          };
          promiseQueue = promiseQueue.then(both, both).then(function(result2) {
            return observer.next(result2);
          }, function(error) {
            return observer.error(error);
          });
        } else {
          observer[key](arg);
        }
      };
    }
    var handler = {
      next: makeCallback(mapFn, "next"),
      error: makeCallback(catchFn, "error"),
      complete: function() {
        promiseQueue.then(function() {
          return observer.complete();
        });
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}

// node_modules/@apollo/client/utilities/observables/Concast.js
var import_dist484 = __toESM(require_dist(), 1);
var import_dist485 = __toESM(require_dist2(), 1);
var import_dist486 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/observables/subclassing.js
var import_dist481 = __toESM(require_dist(), 1);
var import_dist482 = __toESM(require_dist2(), 1);
var import_dist483 = __toESM(require_dist3(), 1);
function fixObservableSubclass(subclass) {
  function set(key) {
    Object.defineProperty(subclass, key, { value: Observable });
  }
  if (canUseSymbol && Symbol.species) {
    set(Symbol.species);
  }
  set("@@species");
  return subclass;
}

// node_modules/@apollo/client/utilities/observables/Concast.js
function isPromiseLike(value) {
  return value && typeof value.then === "function";
}
var Concast = (
  /** @class */
  function(_super) {
    __extends(Concast2, _super);
    function Concast2(sources) {
      var _this = _super.call(this, function(observer) {
        _this.addObserver(observer);
        return function() {
          return _this.removeObserver(observer);
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      _this.handlers = {
        next: function(result2) {
          if (_this.sub !== null) {
            _this.latest = ["next", result2];
            _this.notify("next", result2);
            iterateObserversSafely(_this.observers, "next", result2);
          }
        },
        error: function(error) {
          var sub = _this.sub;
          if (sub !== null) {
            if (sub)
              setTimeout(function() {
                return sub.unsubscribe();
              });
            _this.sub = null;
            _this.latest = ["error", error];
            _this.reject(error);
            _this.notify("error", error);
            iterateObserversSafely(_this.observers, "error", error);
          }
        },
        complete: function() {
          var _a2 = _this, sub = _a2.sub, _b = _a2.sources, sources2 = _b === void 0 ? [] : _b;
          if (sub !== null) {
            var value = sources2.shift();
            if (!value) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              if (_this.latest && _this.latest[0] === "next") {
                _this.resolve(_this.latest[1]);
              } else {
                _this.resolve();
              }
              _this.notify("complete");
              iterateObserversSafely(_this.observers, "complete");
            } else if (isPromiseLike(value)) {
              value.then(function(obs) {
                return _this.sub = obs.subscribe(_this.handlers);
              }, _this.handlers.error);
            } else {
              _this.sub = value.subscribe(_this.handlers);
            }
          }
        }
      };
      _this.nextResultListeners = /* @__PURE__ */ new Set();
      _this.cancel = function(reason) {
        _this.reject(reason);
        _this.sources = [];
        _this.handlers.error(reason);
      };
      _this.promise.catch(function(_) {
      });
      if (typeof sources === "function") {
        sources = [new Observable(sources)];
      }
      if (isPromiseLike(sources)) {
        sources.then(function(iterable) {
          return _this.start(iterable);
        }, _this.handlers.error);
      } else {
        _this.start(sources);
      }
      return _this;
    }
    Concast2.prototype.start = function(sources) {
      if (this.sub !== void 0)
        return;
      this.sources = Array.from(sources);
      this.handlers.complete();
    };
    Concast2.prototype.deliverLastMessage = function(observer) {
      if (this.latest) {
        var nextOrError = this.latest[0];
        var method = observer[nextOrError];
        if (method) {
          method.call(observer, this.latest[1]);
        }
        if (this.sub === null && nextOrError === "next" && observer.complete) {
          observer.complete();
        }
      }
    };
    Concast2.prototype.addObserver = function(observer) {
      if (!this.observers.has(observer)) {
        this.deliverLastMessage(observer);
        this.observers.add(observer);
      }
    };
    Concast2.prototype.removeObserver = function(observer) {
      if (this.observers.delete(observer) && this.observers.size < 1) {
        this.handlers.complete();
      }
    };
    Concast2.prototype.notify = function(method, arg) {
      var nextResultListeners = this.nextResultListeners;
      if (nextResultListeners.size) {
        this.nextResultListeners = /* @__PURE__ */ new Set();
        nextResultListeners.forEach(function(listener) {
          return listener(method, arg);
        });
      }
    };
    Concast2.prototype.beforeNext = function(callback) {
      var called = false;
      this.nextResultListeners.add(function(method, arg) {
        if (!called) {
          called = true;
          callback(method, arg);
        }
      });
    };
    return Concast2;
  }(Observable)
);
fixObservableSubclass(Concast);

// node_modules/@apollo/client/utilities/common/errorHandling.js
var import_dist490 = __toESM(require_dist(), 1);
var import_dist491 = __toESM(require_dist2(), 1);
var import_dist492 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/common/incrementalResult.js
var import_dist487 = __toESM(require_dist(), 1);
var import_dist488 = __toESM(require_dist2(), 1);
var import_dist489 = __toESM(require_dist3(), 1);
function isExecutionPatchIncrementalResult(value) {
  return "incremental" in value;
}
function isExecutionPatchInitialResult(value) {
  return "hasNext" in value && "data" in value;
}
function isExecutionPatchResult(value) {
  return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);
}
function isApolloPayloadResult(value) {
  return isNonNullObject(value) && "payload" in value;
}
function mergeIncrementalData(prevResult, result2) {
  var mergedData = prevResult;
  var merger = new DeepMerger();
  if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
    result2.incremental.forEach(function(_a2) {
      var data = _a2.data, path = _a2.path;
      for (var i = path.length - 1; i >= 0; --i) {
        var key = path[i];
        var isNumericKey = !isNaN(+key);
        var parent_1 = isNumericKey ? [] : {};
        parent_1[key] = data;
        data = parent_1;
      }
      mergedData = merger.merge(mergedData, data);
    });
  }
  return mergedData;
}

// node_modules/@apollo/client/utilities/common/errorHandling.js
function graphQLResultHasError(result2) {
  var errors = getGraphQLErrorsFromResult(result2);
  return isNonEmptyArray(errors);
}
function getGraphQLErrorsFromResult(result2) {
  var graphQLErrors = isNonEmptyArray(result2.errors) ? result2.errors.slice(0) : [];
  if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
    result2.incremental.forEach(function(incrementalResult) {
      if (incrementalResult.errors) {
        graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
      }
    });
  }
  return graphQLErrors;
}

// node_modules/@apollo/client/utilities/common/compact.js
var import_dist493 = __toESM(require_dist(), 1);
var import_dist494 = __toESM(require_dist2(), 1);
var import_dist495 = __toESM(require_dist3(), 1);
function compact() {
  var objects = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    objects[_i] = arguments[_i];
  }
  var result2 = /* @__PURE__ */ Object.create(null);
  objects.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key) {
      var value = obj[key];
      if (value !== void 0) {
        result2[key] = value;
      }
    });
  });
  return result2;
}

// node_modules/@apollo/client/utilities/common/mergeOptions.js
var import_dist496 = __toESM(require_dist(), 1);
var import_dist497 = __toESM(require_dist2(), 1);
var import_dist498 = __toESM(require_dist3(), 1);
function mergeOptions(defaults, options) {
  return compact(defaults, options, options.variables && {
    variables: compact(__assign(__assign({}, defaults && defaults.variables), options.variables))
  });
}

// node_modules/@apollo/client/utilities/common/omitDeep.js
var import_dist499 = __toESM(require_dist(), 1);
var import_dist500 = __toESM(require_dist2(), 1);
var import_dist501 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/common/stripTypename.js
var import_dist502 = __toESM(require_dist(), 1);
var import_dist503 = __toESM(require_dist2(), 1);
var import_dist504 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/utilities/types/IsStrictlyAny.js
var import_dist505 = __toESM(require_dist(), 1);
var import_dist506 = __toESM(require_dist2(), 1);
var import_dist507 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/utils/index.js
var import_dist535 = __toESM(require_dist(), 1);
var import_dist536 = __toESM(require_dist2(), 1);
var import_dist537 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/utils/fromError.js
var import_dist511 = __toESM(require_dist(), 1);
var import_dist512 = __toESM(require_dist2(), 1);
var import_dist513 = __toESM(require_dist3(), 1);
function fromError(errorValue) {
  return new Observable(function(observer) {
    observer.error(errorValue);
  });
}

// node_modules/@apollo/client/link/utils/toPromise.js
var import_dist514 = __toESM(require_dist(), 1);
var import_dist515 = __toESM(require_dist2(), 1);
var import_dist516 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/utils/fromPromise.js
var import_dist517 = __toESM(require_dist(), 1);
var import_dist518 = __toESM(require_dist2(), 1);
var import_dist519 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/utils/throwServerError.js
var import_dist520 = __toESM(require_dist(), 1);
var import_dist521 = __toESM(require_dist2(), 1);
var import_dist522 = __toESM(require_dist3(), 1);
var throwServerError = function(response, result2, message) {
  var error = new Error(message);
  error.name = "ServerError";
  error.response = response;
  error.statusCode = response.status;
  error.result = result2;
  throw error;
};

// node_modules/@apollo/client/link/utils/validateOperation.js
var import_dist523 = __toESM(require_dist(), 1);
var import_dist524 = __toESM(require_dist2(), 1);
var import_dist525 = __toESM(require_dist3(), 1);
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i = 0, _a2 = Object.keys(operation); _i < _a2.length; _i++) {
    var key = _a2[_i];
    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw newInvariantError(46, key);
    }
  }
  return operation;
}

// node_modules/@apollo/client/link/utils/createOperation.js
var import_dist526 = __toESM(require_dist(), 1);
var import_dist527 = __toESM(require_dist2(), 1);
var import_dist528 = __toESM(require_dist3(), 1);
function createOperation(starting, operation) {
  var context = __assign({}, starting);
  var setContext = function(next) {
    if (typeof next === "function") {
      context = __assign(__assign({}, context), next(context));
    } else {
      context = __assign(__assign({}, context), next);
    }
  };
  var getContext = function() {
    return __assign({}, context);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  return operation;
}

// node_modules/@apollo/client/link/utils/transformOperation.js
var import_dist529 = __toESM(require_dist(), 1);
var import_dist530 = __toESM(require_dist2(), 1);
var import_dist531 = __toESM(require_dist3(), 1);
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
  }
  return transformedOperation;
}

// node_modules/@apollo/client/link/utils/filterOperationVariables.js
var import_dist532 = __toESM(require_dist(), 1);
var import_dist533 = __toESM(require_dist2(), 1);
var import_dist534 = __toESM(require_dist3(), 1);
function filterOperationVariables(variables, query) {
  var result2 = __assign({}, variables);
  var unusedNames = new Set(Object.keys(variables));
  visit(query, {
    Variable: function(node, _key, parent) {
      if (parent && parent.kind !== "VariableDefinition") {
        unusedNames.delete(node.name.value);
      }
    }
  });
  unusedNames.forEach(function(name) {
    delete result2[name];
  });
  return result2;
}

// node_modules/@apollo/client/link/core/ApolloLink.js
function passthrough(op, forward) {
  return forward ? forward(op) : Observable.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
  return link.request.length <= 1;
}
var ApolloLink = (
  /** @class */
  function() {
    function ApolloLink2(request) {
      if (request)
        this.request = request;
    }
    ApolloLink2.empty = function() {
      return new ApolloLink2(function() {
        return Observable.of();
      });
    };
    ApolloLink2.from = function(links) {
      if (links.length === 0)
        return ApolloLink2.empty();
      return links.map(toLink).reduce(function(x, y) {
        return x.concat(y);
      });
    };
    ApolloLink2.split = function(test, left, right) {
      var leftLink = toLink(left);
      var rightLink = toLink(right || new ApolloLink2(passthrough));
      var ret;
      if (isTerminating(leftLink) && isTerminating(rightLink)) {
        ret = new ApolloLink2(function(operation) {
          return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
        });
      } else {
        ret = new ApolloLink2(function(operation, forward) {
          return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
        });
      }
      return Object.assign(ret, { left: leftLink, right: rightLink });
    };
    ApolloLink2.execute = function(link, operation) {
      return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
    };
    ApolloLink2.concat = function(first, second) {
      var firstLink = toLink(first);
      if (isTerminating(firstLink)) {
        globalThis.__DEV__ !== false && invariant2.warn(38, firstLink);
        return firstLink;
      }
      var nextLink = toLink(second);
      var ret;
      if (isTerminating(nextLink)) {
        ret = new ApolloLink2(function(operation) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op) || Observable.of();
          }) || Observable.of();
        });
      } else {
        ret = new ApolloLink2(function(operation, forward) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op, forward) || Observable.of();
          }) || Observable.of();
        });
      }
      return Object.assign(ret, { left: firstLink, right: nextLink });
    };
    ApolloLink2.prototype.split = function(test, left, right) {
      return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
    };
    ApolloLink2.prototype.concat = function(next) {
      return ApolloLink2.concat(this, next);
    };
    ApolloLink2.prototype.request = function(operation, forward) {
      throw newInvariantError(39);
    };
    ApolloLink2.prototype.onError = function(error, observer) {
      if (observer && observer.error) {
        observer.error(error);
        return false;
      }
      throw error;
    };
    ApolloLink2.prototype.setOnError = function(fn) {
      this.onError = fn;
      return this;
    };
    return ApolloLink2;
  }()
);

// node_modules/@apollo/client/link/core/empty.js
var empty = ApolloLink.empty;

// node_modules/@apollo/client/link/core/from.js
var import_dist544 = __toESM(require_dist(), 1);
var import_dist545 = __toESM(require_dist2(), 1);
var import_dist546 = __toESM(require_dist3(), 1);
var from = ApolloLink.from;

// node_modules/@apollo/client/link/core/split.js
var import_dist547 = __toESM(require_dist(), 1);
var import_dist548 = __toESM(require_dist2(), 1);
var import_dist549 = __toESM(require_dist3(), 1);
var split = ApolloLink.split;

// node_modules/@apollo/client/link/core/concat.js
var import_dist550 = __toESM(require_dist(), 1);
var import_dist551 = __toESM(require_dist2(), 1);
var import_dist552 = __toESM(require_dist3(), 1);
var concat = ApolloLink.concat;

// node_modules/@apollo/client/link/core/execute.js
var import_dist553 = __toESM(require_dist(), 1);
var import_dist554 = __toESM(require_dist2(), 1);
var import_dist555 = __toESM(require_dist3(), 1);
var execute = ApolloLink.execute;

// node_modules/@apollo/client/link/core/types.js
var import_dist556 = __toESM(require_dist(), 1);
var import_dist557 = __toESM(require_dist2(), 1);
var import_dist558 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/http/index.js
var import_dist607 = __toESM(require_dist(), 1);
var import_dist608 = __toESM(require_dist2(), 1);
var import_dist609 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js
var import_dist580 = __toESM(require_dist(), 1);
var import_dist581 = __toESM(require_dist2(), 1);
var import_dist582 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/http/responseIterator.js
var import_dist574 = __toESM(require_dist(), 1);
var import_dist575 = __toESM(require_dist2(), 1);
var import_dist576 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/http/iterators/async.js
var import_dist562 = __toESM(require_dist(), 1);
var import_dist563 = __toESM(require_dist2(), 1);
var import_dist564 = __toESM(require_dist3(), 1);
function asyncIterator(source) {
  var _a2;
  var iterator = source[Symbol.asyncIterator]();
  return _a2 = {
    next: function() {
      return iterator.next();
    }
  }, _a2[Symbol.asyncIterator] = function() {
    return this;
  }, _a2;
}

// node_modules/@apollo/client/link/http/iterators/nodeStream.js
var import_dist565 = __toESM(require_dist(), 1);
var import_dist566 = __toESM(require_dist2(), 1);
var import_dist567 = __toESM(require_dist3(), 1);
function nodeStreamIterator(stream) {
  var cleanup = null;
  var error = null;
  var done = false;
  var data = [];
  var waiting = [];
  function onData(chunk) {
    if (error)
      return;
    if (waiting.length) {
      var shiftedArr = waiting.shift();
      if (Array.isArray(shiftedArr) && shiftedArr[0]) {
        return shiftedArr[0]({ value: chunk, done: false });
      }
    }
    data.push(chunk);
  }
  function onError(err) {
    error = err;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[1](err);
    });
    !cleanup || cleanup();
  }
  function onEnd() {
    done = true;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[0]({ value: void 0, done: true });
    });
    !cleanup || cleanup();
  }
  cleanup = function() {
    cleanup = null;
    stream.removeListener("data", onData);
    stream.removeListener("error", onError);
    stream.removeListener("end", onEnd);
    stream.removeListener("finish", onEnd);
    stream.removeListener("close", onEnd);
  };
  stream.on("data", onData);
  stream.on("error", onError);
  stream.on("end", onEnd);
  stream.on("finish", onEnd);
  stream.on("close", onEnd);
  function getNext() {
    return new Promise(function(resolve, reject) {
      if (error)
        return reject(error);
      if (data.length)
        return resolve({ value: data.shift(), done: false });
      if (done)
        return resolve({ value: void 0, done: true });
      waiting.push([resolve, reject]);
    });
  }
  var iterator = {
    next: function() {
      return getNext();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}

// node_modules/@apollo/client/link/http/iterators/promise.js
var import_dist568 = __toESM(require_dist(), 1);
var import_dist569 = __toESM(require_dist2(), 1);
var import_dist570 = __toESM(require_dist3(), 1);
function promiseIterator(promise) {
  var resolved = false;
  var iterator = {
    next: function() {
      if (resolved)
        return Promise.resolve({
          value: void 0,
          done: true
        });
      resolved = true;
      return new Promise(function(resolve, reject) {
        promise.then(function(value) {
          resolve({ value, done: false });
        }).catch(reject);
      });
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}

// node_modules/@apollo/client/link/http/iterators/reader.js
var import_dist571 = __toESM(require_dist(), 1);
var import_dist572 = __toESM(require_dist2(), 1);
var import_dist573 = __toESM(require_dist3(), 1);
function readerIterator(reader) {
  var iterator = {
    next: function() {
      return reader.read();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}

// node_modules/@apollo/client/link/http/responseIterator.js
function isNodeResponse(value) {
  return !!value.body;
}
function isReadableStream(value) {
  return !!value.getReader;
}
function isAsyncIterableIterator(value) {
  return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
}
function isStreamableBlob(value) {
  return !!value.stream;
}
function isBlob(value) {
  return !!value.arrayBuffer;
}
function isNodeReadableStream(value) {
  return !!value.pipe;
}
function responseIterator(response) {
  var body = response;
  if (isNodeResponse(response))
    body = response.body;
  if (isAsyncIterableIterator(body))
    return asyncIterator(body);
  if (isReadableStream(body))
    return readerIterator(body.getReader());
  if (isStreamableBlob(body)) {
    return readerIterator(body.stream().getReader());
  }
  if (isBlob(body))
    return promiseIterator(body.arrayBuffer());
  if (isNodeReadableStream(body))
    return nodeStreamIterator(body);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}

// node_modules/@apollo/client/errors/index.js
var import_dist577 = __toESM(require_dist(), 1);
var import_dist578 = __toESM(require_dist2(), 1);
var import_dist579 = __toESM(require_dist3(), 1);
var PROTOCOL_ERRORS_SYMBOL = Symbol();
function graphQLResultHasProtocolErrors(result2) {
  if (result2.extensions) {
    return Array.isArray(result2.extensions[PROTOCOL_ERRORS_SYMBOL]);
  }
  return false;
}
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var generateErrorMessage = function(err) {
  var errors = __spreadArray(__spreadArray(__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
  if (err.networkError)
    errors.push(err.networkError);
  return errors.map(function(err2) {
    return isNonNullObject(err2) && err2.message || "Error message not found.";
  }).join("\n");
};
var ApolloError = (
  /** @class */
  function(_super) {
    __extends(ApolloError2, _super);
    function ApolloError2(_a2) {
      var graphQLErrors = _a2.graphQLErrors, protocolErrors = _a2.protocolErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
      var _this = _super.call(this, errorMessage) || this;
      _this.name = "ApolloError";
      _this.graphQLErrors = graphQLErrors || [];
      _this.protocolErrors = protocolErrors || [];
      _this.clientErrors = clientErrors || [];
      _this.networkError = networkError || null;
      _this.message = errorMessage || generateErrorMessage(_this);
      _this.extraInfo = extraInfo;
      _this.cause = __spreadArray(__spreadArray(__spreadArray([
        networkError
      ], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function(e) {
        return !!e;
      }) || null;
      _this.__proto__ = ApolloError2.prototype;
      return _this;
    }
    return ApolloError2;
  }(Error)
);

// node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js
var hasOwnProperty4 = Object.prototype.hasOwnProperty;
function readMultipartBody(response, nextValue) {
  return __awaiter(this, void 0, void 0, function() {
    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a2, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result2, next;
    var _b, _c;
    var _d;
    return __generator(this, function(_e) {
      switch (_e.label) {
        case 0:
          if (TextDecoder === void 0) {
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          }
          decoder = new TextDecoder("utf-8");
          contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
          delimiter = "boundary=";
          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
          boundary = "\r\n--".concat(boundaryVal);
          buffer = "";
          iterator = responseIterator(response);
          running = true;
          _e.label = 1;
        case 1:
          if (!running) return [3, 3];
          return [4, iterator.next()];
        case 2:
          _a2 = _e.sent(), value = _a2.value, done = _a2.done;
          chunk = typeof value === "string" ? value : decoder.decode(value);
          searchFrom = buffer.length - boundary.length + 1;
          running = !done;
          buffer += chunk;
          bi = buffer.indexOf(boundary, searchFrom);
          while (bi > -1) {
            message = void 0;
            _b = [
              buffer.slice(0, bi),
              buffer.slice(bi + boundary.length)
            ], message = _b[0], buffer = _b[1];
            i = message.indexOf("\r\n\r\n");
            headers = parseHeaders(message.slice(0, i));
            contentType_1 = headers["content-type"];
            if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
              throw new Error("Unsupported patch content type: application/json is required.");
            }
            body = message.slice(i);
            if (body) {
              result2 = parseJsonBody(response, body);
              if (Object.keys(result2).length > 1 || "data" in result2 || "incremental" in result2 || "errors" in result2 || "payload" in result2) {
                if (isApolloPayloadResult(result2)) {
                  next = {};
                  if ("payload" in result2) {
                    if (Object.keys(result2).length === 1 && result2.payload === null) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    next = __assign({}, result2.payload);
                  }
                  if ("errors" in result2) {
                    next = __assign(__assign({}, next), { extensions: __assign(__assign({}, "extensions" in next ? next.extensions : null), (_c = {}, _c[PROTOCOL_ERRORS_SYMBOL] = result2.errors, _c)) });
                  }
                  nextValue(next);
                } else {
                  nextValue(result2);
                }
              } else if (
                // If the chunk contains only a "hasNext: false", we can call
                // observer.complete() immediately.
                Object.keys(result2).length === 1 && "hasNext" in result2 && !result2.hasNext
              ) {
                return [
                  2
                  /*return*/
                ];
              }
            }
            bi = buffer.indexOf(boundary);
          }
          return [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function parseHeaders(headerText) {
  var headersInit = {};
  headerText.split("\n").forEach(function(line) {
    var i = line.indexOf(":");
    if (i > -1) {
      var name_1 = line.slice(0, i).trim().toLowerCase();
      var value = line.slice(i + 1).trim();
      headersInit[name_1] = value;
    }
  });
  return headersInit;
}
function parseJsonBody(response, bodyText) {
  if (response.status >= 300) {
    var getResult = function() {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        return bodyText;
      }
    };
    throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
  }
  try {
    return JSON.parse(bodyText);
  } catch (err) {
    var parseError = err;
    parseError.name = "ServerParseError";
    parseError.response = response;
    parseError.statusCode = response.status;
    parseError.bodyText = bodyText;
    throw parseError;
  }
}
function handleError(err, observer) {
  if (err.result && err.result.errors && err.result.data) {
    observer.next(err.result);
  }
  observer.error(err);
}
function parseAndCheckHttpResponse(operations) {
  return function(response) {
    return response.text().then(function(bodyText) {
      return parseJsonBody(response, bodyText);
    }).then(function(result2) {
      if (!Array.isArray(result2) && !hasOwnProperty4.call(result2, "data") && !hasOwnProperty4.call(result2, "errors")) {
        throwServerError(response, result2, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
          return op.operationName;
        }) : operations.operationName, "'."));
      }
      return result2;
    });
  };
}

// node_modules/@apollo/client/link/http/serializeFetchParameter.js
var import_dist583 = __toESM(require_dist(), 1);
var import_dist584 = __toESM(require_dist2(), 1);
var import_dist585 = __toESM(require_dist3(), 1);
var serializeFetchParameter = function(p, label) {
  var serialized;
  try {
    serialized = JSON.stringify(p);
  } catch (e) {
    var parseError = newInvariantError(42, label, e.message);
    parseError.parseError = e;
    throw parseError;
  }
  return serialized;
};

// node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js
var import_dist586 = __toESM(require_dist(), 1);
var import_dist587 = __toESM(require_dist2(), 1);
var import_dist588 = __toESM(require_dist3(), 1);
var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: false,
  preserveHeaderCase: false
};
var defaultHeaders = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: "*/*",
  // The content-type header describes the type of the body of the request, and
  // so it typically only is sent with requests that actually have bodies. One
  // could imagine that Apollo Client would remove this header when constructing
  // a GET request (which has no body), but we historically have not done that.
  // This means that browsers will preflight all Apollo Client requests (even
  // GET requests). Apollo Server's CSRF prevention feature (introduced in
  // AS3.7) takes advantage of this fact and does not block requests with this
  // header. If you want to drop this header from GET requests, then you should
  // probably replace it with a `apollo-require-preflight` header, or servers
  // with CSRF prevention enabled might block your GET request. See
  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
  // for more details.
  "content-type": "application/json"
};
var defaultOptions = {
  method: "POST"
};
var fallbackHttpConfig = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions
};
var defaultPrinter = function(ast, printer) {
  return printer(ast);
};
function selectHttpOptionsAndBodyInternal(operation, printer) {
  var configs = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    configs[_i - 2] = arguments[_i];
  }
  var options = {};
  var http = {};
  configs.forEach(function(config) {
    options = __assign(__assign(__assign({}, options), config.options), { headers: __assign(__assign({}, options.headers), config.headers) });
    if (config.credentials) {
      options.credentials = config.credentials;
    }
    http = __assign(__assign({}, http), config.http);
  });
  if (options.headers) {
    options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);
  }
  var operationName2 = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
  var body = { operationName: operationName2, variables };
  if (http.includeExtensions)
    body.extensions = extensions;
  if (http.includeQuery)
    body.query = printer(query, print2);
  return {
    options,
    body
  };
}
function removeDuplicateHeaders(headers, preserveHeaderCase) {
  if (!preserveHeaderCase) {
    var normalizedHeaders_1 = {};
    Object.keys(Object(headers)).forEach(function(name) {
      normalizedHeaders_1[name.toLowerCase()] = headers[name];
    });
    return normalizedHeaders_1;
  }
  var headerData = {};
  Object.keys(Object(headers)).forEach(function(name) {
    headerData[name.toLowerCase()] = {
      originalName: name,
      value: headers[name]
    };
  });
  var normalizedHeaders = {};
  Object.keys(headerData).forEach(function(name) {
    normalizedHeaders[headerData[name].originalName] = headerData[name].value;
  });
  return normalizedHeaders;
}

// node_modules/@apollo/client/link/http/checkFetcher.js
var import_dist589 = __toESM(require_dist(), 1);
var import_dist590 = __toESM(require_dist2(), 1);
var import_dist591 = __toESM(require_dist3(), 1);
var checkFetcher = function(fetcher) {
  if (!fetcher && typeof fetch === "undefined") {
    throw newInvariantError(40);
  }
};

// node_modules/@apollo/client/link/http/createSignalIfSupported.js
var import_dist592 = __toESM(require_dist(), 1);
var import_dist593 = __toESM(require_dist2(), 1);
var import_dist594 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/http/selectURI.js
var import_dist595 = __toESM(require_dist(), 1);
var import_dist596 = __toESM(require_dist2(), 1);
var import_dist597 = __toESM(require_dist3(), 1);
var selectURI = function(operation, fallbackURI) {
  var context = operation.getContext();
  var contextURI = context.uri;
  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === "function") {
    return fallbackURI(operation);
  } else {
    return fallbackURI || "/graphql";
  }
};

// node_modules/@apollo/client/link/http/createHttpLink.js
var import_dist601 = __toESM(require_dist(), 1);
var import_dist602 = __toESM(require_dist2(), 1);
var import_dist603 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/link/http/rewriteURIForGET.js
var import_dist598 = __toESM(require_dist(), 1);
var import_dist599 = __toESM(require_dist2(), 1);
var import_dist600 = __toESM(require_dist3(), 1);
function rewriteURIForGET(chosenURI, body) {
  var queryParams = [];
  var addQueryParam = function(key, value) {
    queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter(body.variables, "Variables map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}

// node_modules/@apollo/client/link/http/createHttpLink.js
var backupFetch = maybe(function() {
  return fetch;
});
var createHttpLink = function(linkOptions) {
  if (linkOptions === void 0) {
    linkOptions = {};
  }
  var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print3 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  if (globalThis.__DEV__ !== false) {
    checkFetcher(preferredFetch || backupFetch);
  }
  var linkConfig = {
    http: { includeExtensions, preserveHeaderCase },
    options: requestOptions.fetchOptions,
    credentials: requestOptions.credentials,
    headers: requestOptions.headers
  };
  return new ApolloLink(function(operation) {
    var chosenURI = selectURI(operation, uri);
    var context = operation.getContext();
    var clientAwarenessHeaders = {};
    if (context.clientAwareness) {
      var _a3 = context.clientAwareness, name_1 = _a3.name, version7 = _a3.version;
      if (name_1) {
        clientAwarenessHeaders["apollographql-client-name"] = name_1;
      }
      if (version7) {
        clientAwarenessHeaders["apollographql-client-version"] = version7;
      }
    }
    var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);
    var contextConfig = {
      http: context.http,
      options: context.fetchOptions,
      credentials: context.credentials,
      headers: contextHeaders
    };
    if (hasDirectives(["client"], operation.query)) {
      var transformedQuery = removeClientSetsFromDocument(operation.query);
      if (!transformedQuery) {
        return fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
      }
      operation.query = transformedQuery;
    }
    var _b2 = selectHttpOptionsAndBodyInternal(operation, print3, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
    if (body.variables && !includeUnusedVariables) {
      body.variables = filterOperationVariables(body.variables, operation.query);
    }
    var controller;
    if (!options.signal && typeof AbortController !== "undefined") {
      controller = new AbortController();
      options.signal = controller.signal;
    }
    var definitionIsMutation = function(d) {
      return d.kind === "OperationDefinition" && d.operation === "mutation";
    };
    var definitionIsSubscription = function(d) {
      return d.kind === "OperationDefinition" && d.operation === "subscription";
    };
    var isSubscription = definitionIsSubscription(getMainDefinition(operation.query));
    var hasDefer = hasDirectives(["defer"], operation.query);
    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
      options.method = "GET";
    }
    if (hasDefer || isSubscription) {
      options.headers = options.headers || {};
      var acceptHeader = "multipart/mixed;";
      if (isSubscription && hasDefer) {
        globalThis.__DEV__ !== false && invariant2.warn(41);
      }
      if (isSubscription) {
        acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
      } else if (hasDefer) {
        acceptHeader += "deferSpec=20220824,application/json";
      }
      options.headers.accept = acceptHeader;
    }
    if (options.method === "GET") {
      var _c2 = rewriteURIForGET(chosenURI, body), newURI = _c2.newURI, parseError = _c2.parseError;
      if (parseError) {
        return fromError(parseError);
      }
      chosenURI = newURI;
    } else {
      try {
        options.body = serializeFetchParameter(body, "Payload");
      } catch (parseError2) {
        return fromError(parseError2);
      }
    }
    return new Observable(function(observer) {
      var currentFetch = preferredFetch || maybe(function() {
        return fetch;
      }) || backupFetch;
      var observerNext = observer.next.bind(observer);
      currentFetch(chosenURI, options).then(function(response) {
        var _a4;
        operation.setContext({ response });
        var ctype = (_a4 = response.headers) === null || _a4 === void 0 ? void 0 : _a4.get("content-type");
        if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
          return readMultipartBody(response, observerNext);
        } else {
          return parseAndCheckHttpResponse(operation)(response).then(observerNext);
        }
      }).then(function() {
        controller = void 0;
        observer.complete();
      }).catch(function(err) {
        controller = void 0;
        handleError(err, observer);
      });
      return function() {
        if (controller)
          controller.abort();
      };
    });
  });
};

// node_modules/@apollo/client/link/http/HttpLink.js
var import_dist604 = __toESM(require_dist(), 1);
var import_dist605 = __toESM(require_dist2(), 1);
var import_dist606 = __toESM(require_dist3(), 1);
var HttpLink = (
  /** @class */
  function(_super) {
    __extends(HttpLink2, _super);
    function HttpLink2(options) {
      if (options === void 0) {
        options = {};
      }
      var _this = _super.call(this, createHttpLink(options).request) || this;
      _this.options = options;
      return _this;
    }
    return HttpLink2;
  }(ApolloLink)
);

// node_modules/@apollo/client/core/QueryManager.js
var import_dist688 = __toESM(require_dist(), 1);
var import_dist689 = __toESM(require_dist2(), 1);
var import_dist690 = __toESM(require_dist3(), 1);

// node_modules/@wry/equality/lib/index.js
var import_dist610 = __toESM(require_dist());
var import_dist611 = __toESM(require_dist2());
var import_dist612 = __toESM(require_dist3());
var { toString: toString2, hasOwnProperty: hasOwnProperty5 } = Object.prototype;
var fnToStr = Function.prototype.toString;
var previousComparisons = /* @__PURE__ */ new Map();
function equal(a, b) {
  try {
    return check(a, b);
  } finally {
    previousComparisons.clear();
  }
}
var lib_default = equal;
function check(a, b) {
  if (a === b) {
    return true;
  }
  const aTag = toString2.call(a);
  const bTag = toString2.call(b);
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case "[object Array]":
      if (a.length !== b.length)
        return false;
    case "[object Object]": {
      if (previouslyCompared(a, b))
        return true;
      const aKeys = definedKeys(a);
      const bKeys = definedKeys(b);
      const keyCount = aKeys.length;
      if (keyCount !== bKeys.length)
        return false;
      for (let k = 0; k < keyCount; ++k) {
        if (!hasOwnProperty5.call(b, aKeys[k])) {
          return false;
        }
      }
      for (let k = 0; k < keyCount; ++k) {
        const key = aKeys[k];
        if (!check(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    case "[object Error]":
      return a.name === b.name && a.message === b.message;
    case "[object Number]":
      if (a !== a)
        return b !== b;
    case "[object Boolean]":
    case "[object Date]":
      return +a === +b;
    case "[object RegExp]":
    case "[object String]":
      return a == `${b}`;
    case "[object Map]":
    case "[object Set]": {
      if (a.size !== b.size)
        return false;
      if (previouslyCompared(a, b))
        return true;
      const aIterator = a.entries();
      const isMap = aTag === "[object Map]";
      while (true) {
        const info = aIterator.next();
        if (info.done)
          break;
        const [aKey, aValue] = info.value;
        if (!b.has(aKey)) {
          return false;
        }
        if (isMap && !check(aValue, b.get(aKey))) {
          return false;
        }
      }
      return true;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case "[object DataView]": {
      let len = a.byteLength;
      if (len === b.byteLength) {
        while (len-- && a[len] === b[len]) {
        }
      }
      return len === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      const aCode = fnToStr.call(a);
      if (aCode !== fnToStr.call(b)) {
        return false;
      }
      return !endsWith(aCode, nativeCodeSuffix);
    }
  }
  return false;
}
function definedKeys(obj) {
  return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
  return this[key] !== void 0;
}
var nativeCodeSuffix = "{ [native code] }";
function endsWith(full, suffix) {
  const fromIndex = full.length - suffix.length;
  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a, b) {
  let bSet = previousComparisons.get(a);
  if (bSet) {
    if (bSet.has(b))
      return true;
  } else {
    previousComparisons.set(a, bSet = /* @__PURE__ */ new Set());
  }
  bSet.add(b);
  return false;
}

// node_modules/@apollo/client/cache/index.js
var import_dist676 = __toESM(require_dist(), 1);
var import_dist677 = __toESM(require_dist2(), 1);
var import_dist678 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/cache/core/cache.js
var import_dist631 = __toESM(require_dist(), 1);
var import_dist632 = __toESM(require_dist2(), 1);
var import_dist633 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/core/equalByQuery.js
var import_dist613 = __toESM(require_dist(), 1);
var import_dist614 = __toESM(require_dist2(), 1);
var import_dist615 = __toESM(require_dist3(), 1);
function equalByQuery(query, _a2, _b, variables) {
  var aData = _a2.data, aRest = __rest(_a2, ["data"]);
  var bData = _b.data, bRest = __rest(_b, ["data"]);
  return lib_default(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {
    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
    variables
  });
}
function equalBySelectionSet(selectionSet, aResult, bResult, context) {
  if (aResult === bResult) {
    return true;
  }
  var seenSelections = /* @__PURE__ */ new Set();
  return selectionSet.selections.every(function(selection) {
    if (seenSelections.has(selection))
      return true;
    seenSelections.add(selection);
    if (!shouldInclude(selection, context.variables))
      return true;
    if (selectionHasNonreactiveDirective(selection))
      return true;
    if (isField(selection)) {
      var resultKey = resultKeyNameFromField(selection);
      var aResultChild = aResult && aResult[resultKey];
      var bResultChild = bResult && bResult[resultKey];
      var childSelectionSet = selection.selectionSet;
      if (!childSelectionSet) {
        return lib_default(aResultChild, bResultChild);
      }
      var aChildIsArray = Array.isArray(aResultChild);
      var bChildIsArray = Array.isArray(bResultChild);
      if (aChildIsArray !== bChildIsArray)
        return false;
      if (aChildIsArray && bChildIsArray) {
        var length_1 = aResultChild.length;
        if (bResultChild.length !== length_1) {
          return false;
        }
        for (var i = 0; i < length_1; ++i) {
          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
            return false;
          }
        }
        return true;
      }
      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);
    } else {
      var fragment = getFragmentFromSelection(selection, context.fragmentMap);
      if (fragment) {
        if (selectionHasNonreactiveDirective(fragment))
          return true;
        return equalBySelectionSet(
          fragment.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          aResult,
          bResult,
          context
        );
      }
    }
  });
}
function selectionHasNonreactiveDirective(selection) {
  return !!selection.directives && selection.directives.some(directiveIsNonreactive);
}
function directiveIsNonreactive(dir) {
  return dir.name.value === "nonreactive";
}

// node_modules/@apollo/client/masking/index.js
var import_dist628 = __toESM(require_dist(), 1);
var import_dist629 = __toESM(require_dist2(), 1);
var import_dist630 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/masking/utils.js
var import_dist616 = __toESM(require_dist(), 1);
var import_dist617 = __toESM(require_dist2(), 1);
var import_dist618 = __toESM(require_dist3(), 1);
var MapImpl = canUseWeakMap ? WeakMap : Map;
var SetImpl = canUseWeakSet ? WeakSet : Set;
var disableWarningsSlot = new Slot2();
var issuedWarning = false;
function warnOnImproperCacheImplementation() {
  if (!issuedWarning) {
    issuedWarning = true;
    globalThis.__DEV__ !== false && invariant2.warn(52);
  }
}

// node_modules/@apollo/client/masking/maskFragment.js
var import_dist622 = __toESM(require_dist(), 1);
var import_dist623 = __toESM(require_dist2(), 1);
var import_dist624 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/masking/maskDefinition.js
var import_dist619 = __toESM(require_dist(), 1);
var import_dist620 = __toESM(require_dist2(), 1);
var import_dist621 = __toESM(require_dist3(), 1);
function maskDefinition(data, selectionSet, context) {
  return disableWarningsSlot.withValue(true, function() {
    var masked = maskSelectionSet(data, selectionSet, context, false);
    if (Object.isFrozen(data)) {
      maybeDeepFreeze(masked);
    }
    return masked;
  });
}
function getMutableTarget(data, mutableTargets) {
  if (mutableTargets.has(data)) {
    return mutableTargets.get(data);
  }
  var mutableTarget = Array.isArray(data) ? [] : /* @__PURE__ */ Object.create(null);
  mutableTargets.set(data, mutableTarget);
  return mutableTarget;
}
function maskSelectionSet(data, selectionSet, context, migration, path) {
  var _a2;
  var knownChanged = context.knownChanged;
  var memo2 = getMutableTarget(data, context.mutableTargets);
  if (Array.isArray(data)) {
    for (var _i = 0, _b = Array.from(data.entries()); _i < _b.length; _i++) {
      var _c = _b[_i], index2 = _c[0], item = _c[1];
      if (item === null) {
        memo2[index2] = null;
        continue;
      }
      var masked = maskSelectionSet(item, selectionSet, context, migration, globalThis.__DEV__ !== false ? "".concat(path || "", "[").concat(index2, "]") : void 0);
      if (knownChanged.has(masked)) {
        knownChanged.add(memo2);
      }
      memo2[index2] = masked;
    }
    return knownChanged.has(memo2) ? memo2 : data;
  }
  for (var _d = 0, _e = selectionSet.selections; _d < _e.length; _d++) {
    var selection = _e[_d];
    var value = void 0;
    if (migration) {
      knownChanged.add(memo2);
    }
    if (selection.kind === Kind.FIELD) {
      var keyName = resultKeyNameFromField(selection);
      var childSelectionSet = selection.selectionSet;
      value = memo2[keyName] || data[keyName];
      if (value === void 0) {
        continue;
      }
      if (childSelectionSet && value !== null) {
        var masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, globalThis.__DEV__ !== false ? "".concat(path || "", ".").concat(keyName) : void 0);
        if (knownChanged.has(masked)) {
          value = masked;
        }
      }
      if (!(globalThis.__DEV__ !== false)) {
        memo2[keyName] = value;
      }
      if (globalThis.__DEV__ !== false) {
        if (migration && keyName !== "__typename" && // either the field is not present in the memo object
        // or it has a `get` descriptor, not a `value` descriptor
        // => it is a warning accessor and we can overwrite it
        // with another accessor
        !((_a2 = Object.getOwnPropertyDescriptor(memo2, keyName)) === null || _a2 === void 0 ? void 0 : _a2.value)) {
          Object.defineProperty(memo2, keyName, getAccessorWarningDescriptor(keyName, value, path || "", context.operationName, context.operationType));
        } else {
          delete memo2[keyName];
          memo2[keyName] = value;
        }
      }
    }
    if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {
      value = maskSelectionSet(data, selection.selectionSet, context, migration, path);
    }
    if (selection.kind === Kind.FRAGMENT_SPREAD) {
      var fragmentName = selection.name.value;
      var fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));
      invariant2(fragment, 47, fragmentName);
      var mode = getFragmentMaskMode(selection);
      if (mode !== "mask") {
        value = maskSelectionSet(data, fragment.selectionSet, context, mode === "migrate", path);
      }
    }
    if (knownChanged.has(value)) {
      knownChanged.add(memo2);
    }
  }
  if ("__typename" in data && !("__typename" in memo2)) {
    memo2.__typename = data.__typename;
  }
  if (Object.keys(memo2).length !== Object.keys(data).length) {
    knownChanged.add(memo2);
  }
  return knownChanged.has(memo2) ? memo2 : data;
}
function getAccessorWarningDescriptor(fieldName, value, path, operationName2, operationType) {
  var getValue = function() {
    if (disableWarningsSlot.getValue()) {
      return value;
    }
    globalThis.__DEV__ !== false && invariant2.warn(48, operationName2 ? "".concat(operationType, " '").concat(operationName2, "'") : "anonymous ".concat(operationType), "".concat(path, ".").concat(fieldName).replace(/^\./, ""));
    getValue = function() {
      return value;
    };
    return value;
  };
  return {
    get: function() {
      return getValue();
    },
    set: function(newValue) {
      getValue = function() {
        return newValue;
      };
    },
    enumerable: true,
    configurable: true
  };
}

// node_modules/@apollo/client/masking/maskFragment.js
function maskFragment(data, document2, cache2, fragmentName) {
  if (!cache2.fragmentMatches) {
    if (globalThis.__DEV__ !== false) {
      warnOnImproperCacheImplementation();
    }
    return data;
  }
  var fragments = document2.definitions.filter(function(node) {
    return node.kind === Kind.FRAGMENT_DEFINITION;
  });
  if (typeof fragmentName === "undefined") {
    invariant2(fragments.length === 1, 49, fragments.length);
    fragmentName = fragments[0].name.value;
  }
  var fragment = fragments.find(function(fragment2) {
    return fragment2.name.value === fragmentName;
  });
  invariant2(!!fragment, 50, fragmentName);
  if (data == null) {
    return data;
  }
  if (lib_default(data, {})) {
    return data;
  }
  return maskDefinition(data, fragment.selectionSet, {
    operationType: "fragment",
    operationName: fragment.name.value,
    fragmentMap: createFragmentMap(getFragmentDefinitions(document2)),
    cache: cache2,
    mutableTargets: new MapImpl(),
    knownChanged: new SetImpl()
  });
}

// node_modules/@apollo/client/masking/maskOperation.js
var import_dist625 = __toESM(require_dist(), 1);
var import_dist626 = __toESM(require_dist2(), 1);
var import_dist627 = __toESM(require_dist3(), 1);
function maskOperation(data, document2, cache2) {
  var _a2;
  if (!cache2.fragmentMatches) {
    if (globalThis.__DEV__ !== false) {
      warnOnImproperCacheImplementation();
    }
    return data;
  }
  var definition = getOperationDefinition(document2);
  invariant2(definition, 51);
  if (data == null) {
    return data;
  }
  return maskDefinition(data, definition.selectionSet, {
    operationType: definition.operation,
    operationName: (_a2 = definition.name) === null || _a2 === void 0 ? void 0 : _a2.value,
    fragmentMap: createFragmentMap(getFragmentDefinitions(document2)),
    cache: cache2,
    mutableTargets: new MapImpl(),
    knownChanged: new SetImpl()
  });
}

// node_modules/@apollo/client/cache/core/cache.js
var ApolloCache = (
  /** @class */
  function() {
    function ApolloCache2() {
      this.assumeImmutableResults = false;
      this.getFragmentDoc = wrap2(getFragmentQueryDocument, {
        max: cacheSizes["cache.fragmentQueryDocuments"] || 1e3,
        cache: WeakCache
      });
    }
    ApolloCache2.prototype.lookupFragment = function(fragmentName) {
      return null;
    };
    ApolloCache2.prototype.batch = function(options) {
      var _this = this;
      var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
      var updateResult;
      this.performTransaction(function() {
        return updateResult = options.update(_this);
      }, optimisticId);
      return updateResult;
    };
    ApolloCache2.prototype.recordOptimisticTransaction = function(transaction2, optimisticId) {
      this.performTransaction(transaction2, optimisticId);
    };
    ApolloCache2.prototype.transformDocument = function(document2) {
      return document2;
    };
    ApolloCache2.prototype.transformForLink = function(document2) {
      return document2;
    };
    ApolloCache2.prototype.identify = function(object) {
      return;
    };
    ApolloCache2.prototype.gc = function() {
      return [];
    };
    ApolloCache2.prototype.modify = function(options) {
      return false;
    };
    ApolloCache2.prototype.readQuery = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options.optimistic;
      }
      return this.read(__assign(__assign({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
    };
    ApolloCache2.prototype.watchFragment = function(options) {
      var _this = this;
      var fragment = options.fragment, fragmentName = options.fragmentName, from2 = options.from, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, otherOptions = __rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
      var query = this.getFragmentDoc(fragment, fragmentName);
      var id = typeof from2 === "undefined" || typeof from2 === "string" ? from2 : this.identify(from2);
      var dataMasking = !!options[Symbol.for("apollo.dataMasking")];
      if (globalThis.__DEV__ !== false) {
        var actualFragmentName = fragmentName || getFragmentDefinition(fragment).name.value;
        if (!id) {
          globalThis.__DEV__ !== false && invariant2.warn(1, actualFragmentName);
        }
      }
      var diffOptions = __assign(__assign({}, otherOptions), { returnPartialData: true, id, query, optimistic });
      var latestDiff;
      return new Observable(function(observer) {
        return _this.watch(__assign(__assign({}, diffOptions), { immediate: true, callback: function(diff) {
          var data = dataMasking ? maskFragment(diff.result, fragment, _this, fragmentName) : diff.result;
          if (
            // Always ensure we deliver the first result
            latestDiff && equalByQuery(query, { data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result }, { data })
          ) {
            return;
          }
          var result2 = {
            data,
            complete: !!diff.complete
          };
          if (diff.missing) {
            result2.missing = mergeDeepArray(diff.missing.map(function(error) {
              return error.missing;
            }));
          }
          latestDiff = __assign(__assign({}, diff), { result: data });
          observer.next(result2);
        } }));
      });
    };
    ApolloCache2.prototype.readFragment = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options.optimistic;
      }
      return this.read(__assign(__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
    };
    ApolloCache2.prototype.writeQuery = function(_a2) {
      var id = _a2.id, data = _a2.data, options = __rest(_a2, ["id", "data"]);
      return this.write(Object.assign(options, {
        dataId: id || "ROOT_QUERY",
        result: data
      }));
    };
    ApolloCache2.prototype.writeFragment = function(_a2) {
      var id = _a2.id, data = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options = __rest(_a2, ["id", "data", "fragment", "fragmentName"]);
      return this.write(Object.assign(options, {
        query: this.getFragmentDoc(fragment, fragmentName),
        dataId: id,
        result: data
      }));
    };
    ApolloCache2.prototype.updateQuery = function(options, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readQuery(options);
          var data = update(value);
          if (data === void 0 || data === null)
            return value;
          cache2.writeQuery(__assign(__assign({}, options), { data }));
          return data;
        }
      });
    };
    ApolloCache2.prototype.updateFragment = function(options, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readFragment(options);
          var data = update(value);
          if (data === void 0 || data === null)
            return value;
          cache2.writeFragment(__assign(__assign({}, options), { data }));
          return data;
        }
      });
    };
    return ApolloCache2;
  }()
);
if (globalThis.__DEV__ !== false) {
  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;
}

// node_modules/@apollo/client/cache/core/types/Cache.js
var import_dist634 = __toESM(require_dist(), 1);
var import_dist635 = __toESM(require_dist2(), 1);
var import_dist636 = __toESM(require_dist3(), 1);
var Cache;
/* @__PURE__ */ (function(Cache2) {
})(Cache || (Cache = {}));

// node_modules/@apollo/client/cache/core/types/common.js
var import_dist637 = __toESM(require_dist(), 1);
var import_dist638 = __toESM(require_dist2(), 1);
var import_dist639 = __toESM(require_dist3(), 1);
var MissingFieldError = (
  /** @class */
  function(_super) {
    __extends(MissingFieldError2, _super);
    function MissingFieldError2(message, path, query, variables) {
      var _a2;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.path = path;
      _this.query = query;
      _this.variables = variables;
      if (Array.isArray(_this.path)) {
        _this.missing = _this.message;
        for (var i = _this.path.length - 1; i >= 0; --i) {
          _this.missing = (_a2 = {}, _a2[_this.path[i]] = _this.missing, _a2);
        }
      } else {
        _this.missing = _this.path;
      }
      _this.__proto__ = MissingFieldError2.prototype;
      return _this;
    }
    return MissingFieldError2;
  }(Error)
);

// node_modules/@apollo/client/cache/inmemory/entityStore.js
var import_dist643 = __toESM(require_dist(), 1);
var import_dist644 = __toESM(require_dist2(), 1);
var import_dist645 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/cache/inmemory/helpers.js
var import_dist640 = __toESM(require_dist(), 1);
var import_dist641 = __toESM(require_dist2(), 1);
var import_dist642 = __toESM(require_dist3(), 1);
var hasOwn = Object.prototype.hasOwnProperty;
function isNullish(value) {
  return value === null || value === void 0;
}
function defaultDataIdFromObject(_a2, context) {
  var __typename = _a2.__typename, id = _a2.id, _id = _a2._id;
  if (typeof __typename === "string") {
    if (context) {
      context.keyObject = !isNullish(id) ? { id } : !isNullish(_id) ? { _id } : void 0;
    }
    if (isNullish(id) && !isNullish(_id)) {
      id = _id;
    }
    if (!isNullish(id)) {
      return "".concat(__typename, ":").concat(typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
    }
  }
}
var defaultConfig = {
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  // Thanks to the shouldCanonizeResults helper, this should be the only line
  // you have to change to reenable canonization by default in the future.
  canonizeResults: false
};
function normalizeConfig(config) {
  return compact(defaultConfig, config);
}
function shouldCanonizeResults(config) {
  var value = config.canonizeResults;
  return value === void 0 ? defaultConfig.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
  var match = storeFieldName.match(TypeOrFieldNameRegExp);
  return match ? match[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result2, variables) {
  if (isNonNullObject(result2)) {
    return isArray(result2) ? result2.every(function(item) {
      return selectionSetMatchesResult(selectionSet, item, variables);
    }) : selectionSet.selections.every(function(field) {
      if (isField(field) && shouldInclude(field, variables)) {
        var key = resultKeyNameFromField(field);
        return hasOwn.call(result2, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result2[key], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return isNonNullObject(value) && !isReference(value) && !isArray(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger();
}
function extractFragmentContext(document2, fragments) {
  var fragmentMap = createFragmentMap(getFragmentDefinitions(document2));
  return {
    fragmentMap,
    lookupFragment: function(name) {
      var def = fragmentMap[name];
      if (!def && fragments) {
        def = fragments.lookup(name);
      }
      return def || null;
    }
  };
}

// node_modules/@apollo/client/cache/inmemory/entityStore.js
var DELETE = /* @__PURE__ */ Object.create(null);
var delModifier = function() {
  return DELETE;
};
var INVALIDATE = /* @__PURE__ */ Object.create(null);
var EntityStore = (
  /** @class */
  function() {
    function EntityStore2(policies, group) {
      var _this = this;
      this.policies = policies;
      this.group = group;
      this.data = /* @__PURE__ */ Object.create(null);
      this.rootIds = /* @__PURE__ */ Object.create(null);
      this.refs = /* @__PURE__ */ Object.create(null);
      this.getFieldValue = function(objectOrReference, storeFieldName) {
        return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
      };
      this.canRead = function(objOrRef) {
        return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
      };
      this.toReference = function(objOrIdOrRef, mergeIntoStore) {
        if (typeof objOrIdOrRef === "string") {
          return makeReference(objOrIdOrRef);
        }
        if (isReference(objOrIdOrRef)) {
          return objOrIdOrRef;
        }
        var id = _this.policies.identify(objOrIdOrRef)[0];
        if (id) {
          var ref = makeReference(id);
          if (mergeIntoStore) {
            _this.merge(id, objOrIdOrRef);
          }
          return ref;
        }
      };
    }
    EntityStore2.prototype.toObject = function() {
      return __assign({}, this.data);
    };
    EntityStore2.prototype.has = function(dataId) {
      return this.lookup(dataId, true) !== void 0;
    };
    EntityStore2.prototype.get = function(dataId, fieldName) {
      this.group.depend(dataId, fieldName);
      if (hasOwn.call(this.data, dataId)) {
        var storeObject = this.data[dataId];
        if (storeObject && hasOwn.call(storeObject, fieldName)) {
          return storeObject[fieldName];
        }
      }
      if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
        return this.policies.rootTypenamesById[dataId];
      }
      if (this instanceof Layer) {
        return this.parent.get(dataId, fieldName);
      }
    };
    EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
      if (dependOnExistence)
        this.group.depend(dataId, "__exists");
      if (hasOwn.call(this.data, dataId)) {
        return this.data[dataId];
      }
      if (this instanceof Layer) {
        return this.parent.lookup(dataId, dependOnExistence);
      }
      if (this.policies.rootTypenamesById[dataId]) {
        return /* @__PURE__ */ Object.create(null);
      }
    };
    EntityStore2.prototype.merge = function(older, newer) {
      var _this = this;
      var dataId;
      if (isReference(older))
        older = older.__ref;
      if (isReference(newer))
        newer = newer.__ref;
      var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
      var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
      if (!incoming)
        return;
      invariant2(typeof dataId === "string", 2);
      var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
      this.data[dataId] = merged;
      if (merged !== existing) {
        delete this.refs[dataId];
        if (this.group.caching) {
          var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
          if (!existing)
            fieldsToDirty_1.__exists = 1;
          Object.keys(incoming).forEach(function(storeFieldName) {
            if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
              fieldsToDirty_1[storeFieldName] = 1;
              var fieldName = fieldNameFromStoreName(storeFieldName);
              if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                fieldsToDirty_1[fieldName] = 1;
              }
              if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                delete merged[storeFieldName];
              }
            }
          });
          if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && // Since we return default root __typename strings
          // automatically from store.get, we don't need to dirty the
          // ROOT_QUERY.__typename field if merged.__typename is equal
          // to the default string (usually "Query").
          this.policies.rootTypenamesById[dataId] === merged.__typename) {
            delete fieldsToDirty_1.__typename;
          }
          Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
            return _this.group.dirty(dataId, fieldName);
          });
        }
      }
    };
    EntityStore2.prototype.modify = function(dataId, fields) {
      var _this = this;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var changedFields_1 = /* @__PURE__ */ Object.create(null);
        var needToMerge_1 = false;
        var allDeleted_1 = true;
        var sharedDetails_1 = {
          DELETE,
          INVALIDATE,
          isReference,
          toReference: this.toReference,
          canRead: this.canRead,
          readField: function(fieldNameOrOptions, from2) {
            return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
              fieldName: fieldNameOrOptions,
              from: from2 || makeReference(dataId)
            } : fieldNameOrOptions, { store: _this });
          }
        };
        Object.keys(storeObject).forEach(function(storeFieldName) {
          var fieldName = fieldNameFromStoreName(storeFieldName);
          var fieldValue = storeObject[storeFieldName];
          if (fieldValue === void 0)
            return;
          var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
          if (modify) {
            var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
            if (newValue === INVALIDATE) {
              _this.group.dirty(dataId, storeFieldName);
            } else {
              if (newValue === DELETE)
                newValue = void 0;
              if (newValue !== fieldValue) {
                changedFields_1[storeFieldName] = newValue;
                needToMerge_1 = true;
                fieldValue = newValue;
                if (globalThis.__DEV__ !== false) {
                  var checkReference = function(ref) {
                    if (_this.lookup(ref.__ref) === void 0) {
                      globalThis.__DEV__ !== false && invariant2.warn(3, ref);
                      return true;
                    }
                  };
                  if (isReference(newValue)) {
                    checkReference(newValue);
                  } else if (Array.isArray(newValue)) {
                    var seenReference = false;
                    var someNonReference = void 0;
                    for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {
                      var value = newValue_1[_i];
                      if (isReference(value)) {
                        seenReference = true;
                        if (checkReference(value))
                          break;
                      } else {
                        if (typeof value === "object" && !!value) {
                          var id = _this.policies.identify(value)[0];
                          if (id) {
                            someNonReference = value;
                          }
                        }
                      }
                      if (seenReference && someNonReference !== void 0) {
                        globalThis.__DEV__ !== false && invariant2.warn(4, someNonReference);
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          if (fieldValue !== void 0) {
            allDeleted_1 = false;
          }
        });
        if (needToMerge_1) {
          this.merge(dataId, changedFields_1);
          if (allDeleted_1) {
            if (this instanceof Layer) {
              this.data[dataId] = void 0;
            } else {
              delete this.data[dataId];
            }
            this.group.dirty(dataId, "__exists");
          }
          return true;
        }
      }
      return false;
    };
    EntityStore2.prototype.delete = function(dataId, fieldName, args) {
      var _a2;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var typename = this.getFieldValue(storeObject, "__typename");
        var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
        return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier, _a2) : delModifier);
      }
      return false;
    };
    EntityStore2.prototype.evict = function(options, limit) {
      var evicted = false;
      if (options.id) {
        if (hasOwn.call(this.data, options.id)) {
          evicted = this.delete(options.id, options.fieldName, options.args);
        }
        if (this instanceof Layer && this !== limit) {
          evicted = this.parent.evict(options, limit) || evicted;
        }
        if (options.fieldName || evicted) {
          this.group.dirty(options.id, options.fieldName || "__exists");
        }
      }
      return evicted;
    };
    EntityStore2.prototype.clear = function() {
      this.replace(null);
    };
    EntityStore2.prototype.extract = function() {
      var _this = this;
      var obj = this.toObject();
      var extraRootIds = [];
      this.getRootIdSet().forEach(function(id) {
        if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
          extraRootIds.push(id);
        }
      });
      if (extraRootIds.length) {
        obj.__META = { extraRootIds: extraRootIds.sort() };
      }
      return obj;
    };
    EntityStore2.prototype.replace = function(newData) {
      var _this = this;
      Object.keys(this.data).forEach(function(dataId) {
        if (!(newData && hasOwn.call(newData, dataId))) {
          _this.delete(dataId);
        }
      });
      if (newData) {
        var __META = newData.__META, rest_1 = __rest(newData, ["__META"]);
        Object.keys(rest_1).forEach(function(dataId) {
          _this.merge(dataId, rest_1[dataId]);
        });
        if (__META) {
          __META.extraRootIds.forEach(this.retain, this);
        }
      }
    };
    EntityStore2.prototype.retain = function(rootId) {
      return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
    };
    EntityStore2.prototype.release = function(rootId) {
      if (this.rootIds[rootId] > 0) {
        var count3 = --this.rootIds[rootId];
        if (!count3)
          delete this.rootIds[rootId];
        return count3;
      }
      return 0;
    };
    EntityStore2.prototype.getRootIdSet = function(ids) {
      if (ids === void 0) {
        ids = /* @__PURE__ */ new Set();
      }
      Object.keys(this.rootIds).forEach(ids.add, ids);
      if (this instanceof Layer) {
        this.parent.getRootIdSet(ids);
      } else {
        Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
      }
      return ids;
    };
    EntityStore2.prototype.gc = function() {
      var _this = this;
      var ids = this.getRootIdSet();
      var snapshot = this.toObject();
      ids.forEach(function(id) {
        if (hasOwn.call(snapshot, id)) {
          Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
          delete snapshot[id];
        }
      });
      var idsToRemove = Object.keys(snapshot);
      if (idsToRemove.length) {
        var root_1 = this;
        while (root_1 instanceof Layer)
          root_1 = root_1.parent;
        idsToRemove.forEach(function(id) {
          return root_1.delete(id);
        });
      }
      return idsToRemove;
    };
    EntityStore2.prototype.findChildRefIds = function(dataId) {
      if (!hasOwn.call(this.refs, dataId)) {
        var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
        var root2 = this.data[dataId];
        if (!root2)
          return found_1;
        var workSet_1 = /* @__PURE__ */ new Set([root2]);
        workSet_1.forEach(function(obj) {
          if (isReference(obj)) {
            found_1[obj.__ref] = true;
          }
          if (isNonNullObject(obj)) {
            Object.keys(obj).forEach(function(key) {
              var child = obj[key];
              if (isNonNullObject(child)) {
                workSet_1.add(child);
              }
            });
          }
        });
      }
      return this.refs[dataId];
    };
    EntityStore2.prototype.makeCacheKey = function() {
      return this.group.keyMaker.lookupArray(arguments);
    };
    return EntityStore2;
  }()
);
var CacheGroup = (
  /** @class */
  function() {
    function CacheGroup2(caching, parent) {
      if (parent === void 0) {
        parent = null;
      }
      this.caching = caching;
      this.parent = parent;
      this.d = null;
      this.resetCaching();
    }
    CacheGroup2.prototype.resetCaching = function() {
      this.d = this.caching ? dep() : null;
      this.keyMaker = new Trie(canUseWeakMap);
    };
    CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
      if (this.d) {
        this.d(makeDepKey(dataId, storeFieldName));
        var fieldName = fieldNameFromStoreName(storeFieldName);
        if (fieldName !== storeFieldName) {
          this.d(makeDepKey(dataId, fieldName));
        }
        if (this.parent) {
          this.parent.depend(dataId, storeFieldName);
        }
      }
    };
    CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
      if (this.d) {
        this.d.dirty(
          makeDepKey(dataId, storeFieldName),
          // When storeFieldName === "__exists", that means the entity identified
          // by dataId has either disappeared from the cache or was newly added,
          // so the result caching system would do well to "forget everything it
          // knows" about that object. To achieve that kind of invalidation, we
          // not only dirty the associated result cache entry, but also remove it
          // completely from the dependency graph. For the optimism implementation
          // details, see https://github.com/benjamn/optimism/pull/195.
          storeFieldName === "__exists" ? "forget" : "setDirty"
        );
      }
    };
    return CacheGroup2;
  }()
);
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
  if (supportsResultCaching(store)) {
    store.group.depend(entityId, "__exists");
  }
}
(function(EntityStore2) {
  var Root4 = (
    /** @class */
    function(_super) {
      __extends(Root5, _super);
      function Root5(_a2) {
        var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a2.seed;
        var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
        _this.stump = new Stump(_this);
        _this.storageTrie = new Trie(canUseWeakMap);
        if (seed)
          _this.replace(seed);
        return _this;
      }
      Root5.prototype.addLayer = function(layerId, replay) {
        return this.stump.addLayer(layerId, replay);
      };
      Root5.prototype.removeLayer = function() {
        return this;
      };
      Root5.prototype.getStorage = function() {
        return this.storageTrie.lookupArray(arguments);
      };
      return Root5;
    }(EntityStore2)
  );
  EntityStore2.Root = Root4;
})(EntityStore || (EntityStore = {}));
var Layer = (
  /** @class */
  function(_super) {
    __extends(Layer2, _super);
    function Layer2(id, parent, replay, group) {
      var _this = _super.call(this, parent.policies, group) || this;
      _this.id = id;
      _this.parent = parent;
      _this.replay = replay;
      _this.group = group;
      replay(_this);
      return _this;
    }
    Layer2.prototype.addLayer = function(layerId, replay) {
      return new Layer2(layerId, this, replay, this.group);
    };
    Layer2.prototype.removeLayer = function(layerId) {
      var _this = this;
      var parent = this.parent.removeLayer(layerId);
      if (layerId === this.id) {
        if (this.group.caching) {
          Object.keys(this.data).forEach(function(dataId) {
            var ownStoreObject = _this.data[dataId];
            var parentStoreObject = parent["lookup"](dataId);
            if (!parentStoreObject) {
              _this.delete(dataId);
            } else if (!ownStoreObject) {
              _this.group.dirty(dataId, "__exists");
              Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                _this.group.dirty(dataId, storeFieldName);
              });
            } else if (ownStoreObject !== parentStoreObject) {
              Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                  _this.group.dirty(dataId, storeFieldName);
                }
              });
            }
          });
        }
        return parent;
      }
      if (parent === this.parent)
        return this;
      return parent.addLayer(this.id, this.replay);
    };
    Layer2.prototype.toObject = function() {
      return __assign(__assign({}, this.parent.toObject()), this.data);
    };
    Layer2.prototype.findChildRefIds = function(dataId) {
      var fromParent = this.parent.findChildRefIds(dataId);
      return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
    };
    Layer2.prototype.getStorage = function() {
      var p = this.parent;
      while (p.parent)
        p = p.parent;
      return p.getStorage.apply(
        p,
        // @ts-expect-error
        arguments
      );
    };
    return Layer2;
  }(EntityStore)
);
var Stump = (
  /** @class */
  function(_super) {
    __extends(Stump2, _super);
    function Stump2(root2) {
      return _super.call(this, "EntityStore.Stump", root2, function() {
      }, new CacheGroup(root2.group.caching, root2.group)) || this;
    }
    Stump2.prototype.removeLayer = function() {
      return this;
    };
    Stump2.prototype.merge = function(older, newer) {
      return this.parent.merge(older, newer);
    };
    return Stump2;
  }(Layer)
);
function storeObjectReconciler(existingObject, incomingObject, property) {
  var existingValue = existingObject[property];
  var incomingValue = incomingObject[property];
  return equal(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store instanceof EntityStore && store.group.caching);
}

// node_modules/@apollo/client/cache/inmemory/inMemoryCache.js
var import_dist667 = __toESM(require_dist(), 1);
var import_dist668 = __toESM(require_dist2(), 1);
var import_dist669 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/cache/inmemory/fixPolyfills.js
var import_dist646 = __toESM(require_dist(), 1);
var import_dist647 = __toESM(require_dist2(), 1);
var import_dist648 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/cache/inmemory/readFromStore.js
var import_dist652 = __toESM(require_dist(), 1);
var import_dist653 = __toESM(require_dist2(), 1);
var import_dist654 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/cache/inmemory/object-canon.js
var import_dist649 = __toESM(require_dist(), 1);
var import_dist650 = __toESM(require_dist2(), 1);
var import_dist651 = __toESM(require_dist3(), 1);
function shallowCopy(value) {
  if (isNonNullObject(value)) {
    return isArray(value) ? value.slice(0) : __assign({ __proto__: Object.getPrototypeOf(value) }, value);
  }
  return value;
}
var ObjectCanon = (
  /** @class */
  function() {
    function ObjectCanon2() {
      this.known = new (canUseWeakSet ? WeakSet : Set)();
      this.pool = new Trie(canUseWeakMap);
      this.passes = /* @__PURE__ */ new WeakMap();
      this.keysByJSON = /* @__PURE__ */ new Map();
      this.empty = this.admit({});
    }
    ObjectCanon2.prototype.isKnown = function(value) {
      return isNonNullObject(value) && this.known.has(value);
    };
    ObjectCanon2.prototype.pass = function(value) {
      if (isNonNullObject(value)) {
        var copy = shallowCopy(value);
        this.passes.set(copy, value);
        return copy;
      }
      return value;
    };
    ObjectCanon2.prototype.admit = function(value) {
      var _this = this;
      if (isNonNullObject(value)) {
        var original = this.passes.get(value);
        if (original)
          return original;
        var proto = Object.getPrototypeOf(value);
        switch (proto) {
          case Array.prototype: {
            if (this.known.has(value))
              return value;
            var array = value.map(this.admit, this);
            var node = this.pool.lookupArray(array);
            if (!node.array) {
              this.known.add(node.array = array);
              if (globalThis.__DEV__ !== false) {
                Object.freeze(array);
              }
            }
            return node.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(value))
              return value;
            var proto_1 = Object.getPrototypeOf(value);
            var array_1 = [proto_1];
            var keys = this.sortedKeys(value);
            array_1.push(keys.json);
            var firstValueIndex_1 = array_1.length;
            keys.sorted.forEach(function(key) {
              array_1.push(_this.admit(value[key]));
            });
            var node = this.pool.lookupArray(array_1);
            if (!node.object) {
              var obj_1 = node.object = Object.create(proto_1);
              this.known.add(obj_1);
              keys.sorted.forEach(function(key, i) {
                obj_1[key] = array_1[firstValueIndex_1 + i];
              });
              if (globalThis.__DEV__ !== false) {
                Object.freeze(obj_1);
              }
            }
            return node.object;
          }
        }
      }
      return value;
    };
    ObjectCanon2.prototype.sortedKeys = function(obj) {
      var keys = Object.keys(obj);
      var node = this.pool.lookupArray(keys);
      if (!node.keys) {
        keys.sort();
        var json = JSON.stringify(keys);
        if (!(node.keys = this.keysByJSON.get(json))) {
          this.keysByJSON.set(json, node.keys = { sorted: keys, json });
        }
      }
      return node.keys;
    };
    return ObjectCanon2;
  }()
);

// node_modules/@apollo/client/cache/inmemory/readFromStore.js
function execSelectionSetKeyArgs(options) {
  return [
    options.selectionSet,
    options.objectOrReference,
    options.context,
    // We split out this property so we can pass different values
    // independently without modifying options.context itself.
    options.context.canonizeResults
  ];
}
var StoreReader = (
  /** @class */
  function() {
    function StoreReader2(config) {
      var _this = this;
      this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
      this.config = compact(config, {
        addTypename: config.addTypename !== false,
        canonizeResults: shouldCanonizeResults(config)
      });
      this.canon = config.canon || new ObjectCanon();
      this.executeSelectionSet = wrap2(function(options) {
        var _a2;
        var canonizeResults = options.context.canonizeResults;
        var peekArgs = execSelectionSetKeyArgs(options);
        peekArgs[3] = !canonizeResults;
        var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
        if (other) {
          if (canonizeResults) {
            return __assign(__assign({}, other), {
              // If we previously read this result without canonizing it, we can
              // reuse that result simply by canonizing it now.
              result: _this.canon.admit(other.result)
            });
          }
          return other;
        }
        maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
        return _this.execSelectionSetImpl(options);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSelectionSet"] || 5e4,
        keyArgs: execSelectionSetKeyArgs,
        // Note that the parameters of makeCacheKey are determined by the
        // array returned by keyArgs.
        makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
          if (supportsResultCaching(context.store)) {
            return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
          }
        }
      });
      this.executeSubSelectedArray = wrap2(function(options) {
        maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
        return _this.execSubSelectedArrayImpl(options);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSubSelectedArray"] || 1e4,
        makeCacheKey: function(_a2) {
          var field = _a2.field, array = _a2.array, context = _a2.context;
          if (supportsResultCaching(context.store)) {
            return context.store.makeCacheKey(field, array, context.varString);
          }
        }
      });
    }
    StoreReader2.prototype.resetCanon = function() {
      this.canon = new ObjectCanon();
    };
    StoreReader2.prototype.diffQueryAgainstStore = function(_a2) {
      var store = _a2.store, query = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
      var policies = this.config.cache.policies;
      variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);
      var rootRef = makeReference(rootId);
      var execResult = this.executeSelectionSet({
        selectionSet: getMainDefinition(query).selectionSet,
        objectOrReference: rootRef,
        enclosingRef: rootRef,
        context: __assign({ store, query, policies, variables, varString: canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
      });
      var missing;
      if (execResult.missing) {
        missing = [
          new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)
        ];
        if (!returnPartialData) {
          throw missing[0];
        }
      }
      return {
        result: execResult.result,
        complete: !missing,
        missing
      };
    };
    StoreReader2.prototype.isFresh = function(result2, parent, selectionSet, context) {
      if (supportsResultCaching(context.store) && this.knownResults.get(result2) === selectionSet) {
        var latest = this.executeSelectionSet.peek(
          selectionSet,
          parent,
          context,
          // If result is canonical, then it could only have been previously
          // cached by the canonizing version of executeSelectionSet, so we can
          // avoid checking both possibilities here.
          this.canon.isKnown(result2)
        );
        if (latest && result2 === latest.result) {
          return true;
        }
      }
      return false;
    };
    StoreReader2.prototype.execSelectionSetImpl = function(_a2) {
      var _this = this;
      var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context = _a2.context;
      if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
        return {
          result: this.canon.empty,
          missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
        };
      }
      var variables = context.variables, policies = context.policies, store = context.store;
      var typename = store.getFieldValue(objectOrReference, "__typename");
      var objectsToMerge = [];
      var missing;
      var missingMerger = new DeepMerger();
      if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
        objectsToMerge.push({ __typename: typename });
      }
      function handleMissing(result3, resultName) {
        var _a3;
        if (result3.missing) {
          missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result3.missing, _a3));
        }
        return result3.result;
      }
      var workSet = new Set(selectionSet.selections);
      workSet.forEach(function(selection) {
        var _a3, _b;
        if (!shouldInclude(selection, variables))
          return;
        if (isField(selection)) {
          var fieldValue = policies.readField({
            fieldName: selection.name.value,
            field: selection,
            variables: context.variables,
            from: objectOrReference
          }, context);
          var resultName = resultKeyNameFromField(selection);
          if (fieldValue === void 0) {
            if (!addTypenameToDocument.added(selection)) {
              missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
            }
          } else if (isArray(fieldValue)) {
            if (fieldValue.length > 0) {
              fieldValue = handleMissing(_this.executeSubSelectedArray({
                field: selection,
                array: fieldValue,
                enclosingRef,
                context
              }), resultName);
            }
          } else if (!selection.selectionSet) {
            if (context.canonizeResults) {
              fieldValue = _this.canon.pass(fieldValue);
            }
          } else if (fieldValue != null) {
            fieldValue = handleMissing(_this.executeSelectionSet({
              selectionSet: selection.selectionSet,
              objectOrReference: fieldValue,
              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
              context
            }), resultName);
          }
          if (fieldValue !== void 0) {
            objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
          }
        } else {
          var fragment = getFragmentFromSelection(selection, context.lookupFragment);
          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
            throw newInvariantError(10, selection.name.value);
          }
          if (fragment && policies.fragmentMatches(fragment, typename)) {
            fragment.selectionSet.selections.forEach(workSet.add, workSet);
          }
        }
      });
      var result2 = mergeDeepArray(objectsToMerge);
      var finalResult = { result: result2, missing };
      var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
      if (frozen.result) {
        this.knownResults.set(frozen.result, selectionSet);
      }
      return frozen;
    };
    StoreReader2.prototype.execSubSelectedArrayImpl = function(_a2) {
      var _this = this;
      var field = _a2.field, array = _a2.array, enclosingRef = _a2.enclosingRef, context = _a2.context;
      var missing;
      var missingMerger = new DeepMerger();
      function handleMissing(childResult, i) {
        var _a3;
        if (childResult.missing) {
          missing = missingMerger.merge(missing, (_a3 = {}, _a3[i] = childResult.missing, _a3));
        }
        return childResult.result;
      }
      if (field.selectionSet) {
        array = array.filter(context.store.canRead);
      }
      array = array.map(function(item, i) {
        if (item === null) {
          return null;
        }
        if (isArray(item)) {
          return handleMissing(_this.executeSubSelectedArray({
            field,
            array: item,
            enclosingRef,
            context
          }), i);
        }
        if (field.selectionSet) {
          return handleMissing(_this.executeSelectionSet({
            selectionSet: field.selectionSet,
            objectOrReference: item,
            enclosingRef: isReference(item) ? item : enclosingRef,
            context
          }), i);
        }
        if (globalThis.__DEV__ !== false) {
          assertSelectionSetForIdValue(context.store, field, item);
        }
        return item;
      });
      return {
        result: context.canonizeResults ? this.canon.admit(array) : array,
        missing
      };
    };
    return StoreReader2;
  }()
);
function firstMissing(tree) {
  try {
    JSON.stringify(tree, function(_, value) {
      if (typeof value === "string")
        throw value;
      return value;
    });
  } catch (result2) {
    return result2;
  }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
  if (!field.selectionSet) {
    var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
    workSet_1.forEach(function(value) {
      if (isNonNullObject(value)) {
        invariant2(
          !isReference(value),
          11,
          getTypenameFromStoreObject(store, value),
          field.name.value
        );
        Object.values(value).forEach(workSet_1.add, workSet_1);
      }
    });
  }
}

// node_modules/@apollo/client/cache/inmemory/writeToStore.js
var import_dist664 = __toESM(require_dist(), 1);
var import_dist665 = __toESM(require_dist2(), 1);
var import_dist666 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/cache/inmemory/policies.js
var import_dist661 = __toESM(require_dist(), 1);
var import_dist662 = __toESM(require_dist2(), 1);
var import_dist663 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/cache/inmemory/reactiveVars.js
var import_dist655 = __toESM(require_dist(), 1);
var import_dist656 = __toESM(require_dist2(), 1);
var import_dist657 = __toESM(require_dist3(), 1);
var cacheSlot = new Slot2();
var cacheInfoMap = /* @__PURE__ */ new WeakMap();
function getCacheInfo(cache2) {
  var info = cacheInfoMap.get(cache2);
  if (!info) {
    cacheInfoMap.set(cache2, info = {
      vars: /* @__PURE__ */ new Set(),
      dep: dep()
    });
  }
  return info;
}
function forgetCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.forgetCache(cache2);
  });
}
function recallCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.attachCache(cache2);
  });
}
function makeVar(value) {
  var caches2 = /* @__PURE__ */ new Set();
  var listeners = /* @__PURE__ */ new Set();
  var rv = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        caches2.forEach(function(cache3) {
          getCacheInfo(cache3).dep.dirty(rv);
          broadcast(cache3);
        });
        var oldListeners = Array.from(listeners);
        listeners.clear();
        oldListeners.forEach(function(listener) {
          return listener(value);
        });
      }
    } else {
      var cache2 = cacheSlot.getValue();
      if (cache2) {
        attach(cache2);
        getCacheInfo(cache2).dep(rv);
      }
    }
    return value;
  };
  rv.onNextChange = function(listener) {
    listeners.add(listener);
    return function() {
      listeners.delete(listener);
    };
  };
  var attach = rv.attachCache = function(cache2) {
    caches2.add(cache2);
    getCacheInfo(cache2).vars.add(rv);
    return rv;
  };
  rv.forgetCache = function(cache2) {
    return caches2.delete(cache2);
  };
  return rv;
}
function broadcast(cache2) {
  if (cache2.broadcastWatches) {
    cache2.broadcastWatches();
  }
}

// node_modules/@apollo/client/cache/inmemory/key-extractor.js
var import_dist658 = __toESM(require_dist(), 1);
var import_dist659 = __toESM(require_dist2(), 1);
var import_dist660 = __toESM(require_dist3(), 1);
var specifierInfoCache = /* @__PURE__ */ Object.create(null);
function lookupSpecifierInfo(spec) {
  var cacheKey = JSON.stringify(spec);
  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyFieldsFn || (info.keyFieldsFn = function(object, context) {
    var extract = function(from2, key) {
      return context.readField(key, from2);
    };
    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
      var extracted = extractKeyPath(
        context.storeObject,
        schemaKeyPath,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        extract
      );
      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {
        extracted = extractKeyPath(object, schemaKeyPath, extractKey);
      }
      invariant2(extracted !== void 0, 5, schemaKeyPath.join("."), object);
      return extracted;
    });
    return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
  });
}
function keyArgsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
    var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
    var collected = collectSpecifierPaths(specifier, function(keyPath) {
      var firstKey = keyPath[0];
      var firstChar = firstKey.charAt(0);
      if (firstChar === "@") {
        if (field && isNonEmptyArray(field.directives)) {
          var directiveName_1 = firstKey.slice(1);
          var d = field.directives.find(function(d2) {
            return d2.name.value === directiveName_1;
          });
          var directiveArgs = d && argumentsObjectFromField(d, variables);
          return directiveArgs && extractKeyPath(
            directiveArgs,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            keyPath.slice(1)
          );
        }
        return;
      }
      if (firstChar === "$") {
        var variableName = firstKey.slice(1);
        if (variables && hasOwn.call(variables, variableName)) {
          var varKeyPath = keyPath.slice(0);
          varKeyPath[0] = variableName;
          return extractKeyPath(variables, varKeyPath);
        }
        return;
      }
      if (args) {
        return extractKeyPath(args, keyPath);
      }
    });
    var suffix = JSON.stringify(collected);
    if (args || suffix !== "{}") {
      fieldName += ":" + suffix;
    }
    return fieldName;
  });
}
function collectSpecifierPaths(specifier, extractor) {
  var merger = new DeepMerger();
  return getSpecifierPaths(specifier).reduce(function(collected, path) {
    var _a2;
    var toMerge = extractor(path);
    if (toMerge !== void 0) {
      for (var i = path.length - 1; i >= 0; --i) {
        toMerge = (_a2 = {}, _a2[path[i]] = toMerge, _a2);
      }
      collected = merger.merge(collected, toMerge);
    }
    return collected;
  }, /* @__PURE__ */ Object.create(null));
}
function getSpecifierPaths(spec) {
  var info = lookupSpecifierInfo(spec);
  if (!info.paths) {
    var paths_1 = info.paths = [];
    var currentPath_1 = [];
    spec.forEach(function(s, i) {
      if (isArray(s)) {
        getSpecifierPaths(s).forEach(function(p) {
          return paths_1.push(currentPath_1.concat(p));
        });
        currentPath_1.length = 0;
      } else {
        currentPath_1.push(s);
        if (!isArray(spec[i + 1])) {
          paths_1.push(currentPath_1.slice(0));
          currentPath_1.length = 0;
        }
      }
    });
  }
  return info.paths;
}
function extractKey(object, key) {
  return object[key];
}
function extractKeyPath(object, path, extract) {
  extract = extract || extractKey;
  return normalize(path.reduce(function reducer(obj, key) {
    return isArray(obj) ? obj.map(function(child) {
      return reducer(child, key);
    }) : obj && extract(obj, key);
  }, object));
}
function normalize(value) {
  if (isNonNullObject(value)) {
    if (isArray(value)) {
      return value.map(normalize);
    }
    return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
      return extractKeyPath(value, path);
    });
  }
  return value;
}

// node_modules/@apollo/client/cache/inmemory/policies.js
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = function() {
  return void 0;
};
var simpleKeyArgsFn = function(_args, context) {
  return context.fieldName;
};
var mergeTrueFn = function(existing, incoming, _a2) {
  var mergeObjects = _a2.mergeObjects;
  return mergeObjects(existing, incoming);
};
var mergeFalseFn = function(_, incoming) {
  return incoming;
};
var Policies = (
  /** @class */
  function() {
    function Policies2(config) {
      this.config = config;
      this.typePolicies = /* @__PURE__ */ Object.create(null);
      this.toBeAdded = /* @__PURE__ */ Object.create(null);
      this.supertypeMap = /* @__PURE__ */ new Map();
      this.fuzzySubtypes = /* @__PURE__ */ new Map();
      this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
      this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
      this.usingPossibleTypes = false;
      this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);
      this.cache = this.config.cache;
      this.setRootTypename("Query");
      this.setRootTypename("Mutation");
      this.setRootTypename("Subscription");
      if (config.possibleTypes) {
        this.addPossibleTypes(config.possibleTypes);
      }
      if (config.typePolicies) {
        this.addTypePolicies(config.typePolicies);
      }
    }
    Policies2.prototype.identify = function(object, partialContext) {
      var _a2;
      var policies = this;
      var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object.__typename;
      if (typename === this.rootTypenamesById.ROOT_QUERY) {
        return ["ROOT_QUERY"];
      }
      var storeObject = partialContext && partialContext.storeObject || object;
      var context = __assign(__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
        var options = normalizeReadFieldOptions(arguments, storeObject);
        return policies.readField(options, {
          store: policies.cache["data"],
          variables: options.variables
        });
      } });
      var id;
      var policy = typename && this.getTypePolicy(typename);
      var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
      disableWarningsSlot.withValue(true, function() {
        while (keyFn) {
          var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);
          if (isArray(specifierOrId)) {
            keyFn = keyFieldsFnFromSpecifier(specifierOrId);
          } else {
            id = specifierOrId;
            break;
          }
        }
      });
      id = id ? String(id) : void 0;
      return context.keyObject ? [id, context.keyObject] : [id];
    };
    Policies2.prototype.addTypePolicies = function(typePolicies) {
      var _this = this;
      Object.keys(typePolicies).forEach(function(typename) {
        var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = __rest(_a2, ["queryType", "mutationType", "subscriptionType"]);
        if (queryType)
          _this.setRootTypename("Query", typename);
        if (mutationType)
          _this.setRootTypename("Mutation", typename);
        if (subscriptionType)
          _this.setRootTypename("Subscription", typename);
        if (hasOwn.call(_this.toBeAdded, typename)) {
          _this.toBeAdded[typename].push(incoming);
        } else {
          _this.toBeAdded[typename] = [incoming];
        }
      });
    };
    Policies2.prototype.updateTypePolicy = function(typename, incoming) {
      var _this = this;
      var existing = this.getTypePolicy(typename);
      var keyFields = incoming.keyFields, fields = incoming.fields;
      function setMerge(existing2, merge) {
        existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;
      }
      setMerge(existing, incoming.merge);
      existing.keyFn = // Pass false to disable normalization for this typename.
      keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
      if (fields) {
        Object.keys(fields).forEach(function(fieldName) {
          var existing2 = _this.getFieldPolicy(typename, fieldName, true);
          var incoming2 = fields[fieldName];
          if (typeof incoming2 === "function") {
            existing2.read = incoming2;
          } else {
            var keyArgs = incoming2.keyArgs, read = incoming2.read, merge = incoming2.merge;
            existing2.keyFn = // Pass false to disable argument-based differentiation of
            // field identities.
            keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
            if (typeof read === "function") {
              existing2.read = read;
            }
            setMerge(existing2, merge);
          }
          if (existing2.read && existing2.merge) {
            existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
          }
        });
      }
    };
    Policies2.prototype.setRootTypename = function(which, typename) {
      if (typename === void 0) {
        typename = which;
      }
      var rootId = "ROOT_" + which.toUpperCase();
      var old = this.rootTypenamesById[rootId];
      if (typename !== old) {
        invariant2(!old || old === which, 6, which);
        if (old)
          delete this.rootIdsByTypename[old];
        this.rootIdsByTypename[typename] = rootId;
        this.rootTypenamesById[rootId] = typename;
      }
    };
    Policies2.prototype.addPossibleTypes = function(possibleTypes) {
      var _this = this;
      this.usingPossibleTypes = true;
      Object.keys(possibleTypes).forEach(function(supertype) {
        _this.getSupertypeSet(supertype, true);
        possibleTypes[supertype].forEach(function(subtype) {
          _this.getSupertypeSet(subtype, true).add(supertype);
          var match = subtype.match(TypeOrFieldNameRegExp);
          if (!match || match[0] !== subtype) {
            _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
          }
        });
      });
    };
    Policies2.prototype.getTypePolicy = function(typename) {
      var _this = this;
      if (!hasOwn.call(this.typePolicies, typename)) {
        var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
        policy_1.fields = /* @__PURE__ */ Object.create(null);
        var supertypes_1 = this.supertypeMap.get(typename);
        if (!supertypes_1 && this.fuzzySubtypes.size) {
          supertypes_1 = this.getSupertypeSet(typename, true);
          this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
            if (regExp.test(typename)) {
              var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
              if (fuzzySupertypes) {
                fuzzySupertypes.forEach(function(supertype) {
                  return supertypes_1.add(supertype);
                });
              }
            }
          });
        }
        if (supertypes_1 && supertypes_1.size) {
          supertypes_1.forEach(function(supertype) {
            var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = __rest(_a2, ["fields"]);
            Object.assign(policy_1, rest);
            Object.assign(policy_1.fields, fields);
          });
        }
      }
      var inbox = this.toBeAdded[typename];
      if (inbox && inbox.length) {
        inbox.splice(0).forEach(function(policy) {
          _this.updateTypePolicy(typename, policy);
        });
      }
      return this.typePolicies[typename];
    };
    Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
      if (typename) {
        var fieldPolicies = this.getTypePolicy(typename).fields;
        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
      }
    };
    Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
      var supertypeSet = this.supertypeMap.get(subtype);
      if (!supertypeSet && createIfMissing) {
        this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
      }
      return supertypeSet;
    };
    Policies2.prototype.fragmentMatches = function(fragment, typename, result2, variables) {
      var _this = this;
      if (!fragment.typeCondition)
        return true;
      if (!typename)
        return false;
      var supertype = fragment.typeCondition.name.value;
      if (typename === supertype)
        return true;
      if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
        var typenameSupertypeSet = this.getSupertypeSet(typename, true);
        var workQueue_1 = [typenameSupertypeSet];
        var maybeEnqueue_1 = function(subtype) {
          var supertypeSet2 = _this.getSupertypeSet(subtype, false);
          if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
            workQueue_1.push(supertypeSet2);
          }
        };
        var needToCheckFuzzySubtypes = !!(result2 && this.fuzzySubtypes.size);
        var checkingFuzzySubtypes = false;
        for (var i = 0; i < workQueue_1.length; ++i) {
          var supertypeSet = workQueue_1[i];
          if (supertypeSet.has(supertype)) {
            if (!typenameSupertypeSet.has(supertype)) {
              if (checkingFuzzySubtypes) {
                globalThis.__DEV__ !== false && invariant2.warn(7, typename, supertype);
              }
              typenameSupertypeSet.add(supertype);
            }
            return true;
          }
          supertypeSet.forEach(maybeEnqueue_1);
          if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all
          // non-fuzzy subtypes (after the final iteration of the loop).
          i === workQueue_1.length - 1 && // We could wait to compare fragment.selectionSet to result
          // after we verify the supertype, but this check is often less
          // expensive than that search, and we will have to do the
          // comparison anyway whenever we find a potential match.
          selectionSetMatchesResult(fragment.selectionSet, result2, variables)) {
            needToCheckFuzzySubtypes = false;
            checkingFuzzySubtypes = true;
            this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
              var match = typename.match(regExp);
              if (match && match[0] === typename) {
                maybeEnqueue_1(fuzzyString);
              }
            });
          }
        }
      }
      return false;
    };
    Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return !!(policy && policy.keyFn);
    };
    Policies2.prototype.getStoreFieldName = function(fieldSpec) {
      var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
      var policy = this.getFieldPolicy(typename, fieldName, false);
      var storeFieldName;
      var keyFn = policy && policy.keyFn;
      if (keyFn && typename) {
        var context = {
          typename,
          fieldName,
          field: fieldSpec.field || null,
          variables: fieldSpec.variables
        };
        var args = argsFromFieldSpecifier(fieldSpec);
        while (keyFn) {
          var specifierOrString = keyFn(args, context);
          if (isArray(specifierOrString)) {
            keyFn = keyArgsFnFromSpecifier(specifierOrString);
          } else {
            storeFieldName = specifierOrString || fieldName;
            break;
          }
        }
      }
      if (storeFieldName === void 0) {
        storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
      }
      if (storeFieldName === false) {
        return fieldName;
      }
      return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
    };
    Policies2.prototype.readField = function(options, context) {
      var objectOrReference = options.from;
      if (!objectOrReference)
        return;
      var nameOrField = options.field || options.fieldName;
      if (!nameOrField)
        return;
      if (options.typename === void 0) {
        var typename = context.store.getFieldValue(objectOrReference, "__typename");
        if (typename)
          options.typename = typename;
      }
      var storeFieldName = this.getStoreFieldName(options);
      var fieldName = fieldNameFromStoreName(storeFieldName);
      var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
      var policy = this.getFieldPolicy(options.typename, fieldName, false);
      var read = policy && policy.read;
      if (read) {
        var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
        return cacheSlot.withValue(this.cache, read, [
          existing,
          readOptions
        ]);
      }
      return existing;
    };
    Policies2.prototype.getReadFunction = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return policy && policy.read;
    };
    Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
      var policy = this.getFieldPolicy(parentTypename, fieldName, false);
      var merge = policy && policy.merge;
      if (!merge && childTypename) {
        policy = this.getTypePolicy(childTypename);
        merge = policy && policy.merge;
      }
      return merge;
    };
    Policies2.prototype.runMergeFunction = function(existing, incoming, _a2, context, storage) {
      var field = _a2.field, typename = _a2.typename, merge = _a2.merge;
      if (merge === mergeTrueFn) {
        return makeMergeObjectsFunction(context.store)(existing, incoming);
      }
      if (merge === mergeFalseFn) {
        return incoming;
      }
      if (context.overwrite) {
        existing = void 0;
      }
      return merge(existing, incoming, makeFieldFunctionOptions(
        this,
        // Unlike options.readField for read functions, we do not fall
        // back to the current object if no foreignObjOrRef is provided,
        // because it's not clear what the current object should be for
        // merge functions: the (possibly undefined) existing object, or
        // the incoming object? If you think your merge function needs
        // to read sibling fields in order to produce a new value for
        // the current field, you might want to rethink your strategy,
        // because that's a recipe for making merge behavior sensitive
        // to the order in which fields are written into the cache.
        // However, readField(name, ref) is useful for merge functions
        // that need to deduplicate child objects and references.
        void 0,
        {
          typename,
          fieldName: field.name.value,
          field,
          variables: context.variables
        },
        context,
        storage || /* @__PURE__ */ Object.create(null)
      ));
    };
    return Policies2;
  }()
);
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
  var storeFieldName = policies.getStoreFieldName(fieldSpec);
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var variables = fieldSpec.variables || context.variables;
  var _a2 = context.store, toReference = _a2.toReference, canRead = _a2.canRead;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField: function() {
      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);
    },
    mergeObjects: makeMergeObjectsFunction(context.store)
  };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
  var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
  var options;
  if (typeof fieldNameOrOptions === "string") {
    options = {
      fieldName: fieldNameOrOptions,
      // Default to objectOrReference only when no second argument was
      // passed for the from parameter, not when undefined is explicitly
      // passed as the second argument.
      from: argc > 1 ? from2 : objectOrReference
    };
  } else {
    options = __assign({}, fieldNameOrOptions);
    if (!hasOwn.call(options, "from")) {
      options.from = objectOrReference;
    }
  }
  if (globalThis.__DEV__ !== false && options.from === void 0) {
    globalThis.__DEV__ !== false && invariant2.warn(8, stringifyForDisplay(Array.from(readFieldArgs)));
  }
  if (void 0 === options.variables) {
    options.variables = variables;
  }
  return options;
}
function makeMergeObjectsFunction(store) {
  return function mergeObjects(existing, incoming) {
    if (isArray(existing) || isArray(incoming)) {
      throw newInvariantError(9);
    }
    if (isNonNullObject(existing) && isNonNullObject(incoming)) {
      var eType = store.getFieldValue(existing, "__typename");
      var iType = store.getFieldValue(incoming, "__typename");
      var typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer) {
        return incoming;
      }
      if (isReference(existing) && storeValueIsStoreObject(incoming)) {
        store.merge(existing.__ref, incoming);
        return existing;
      }
      if (storeValueIsStoreObject(existing) && isReference(incoming)) {
        store.merge(existing, incoming.__ref);
        return incoming;
      }
      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
        return __assign(__assign({}, existing), incoming);
      }
    }
    return incoming;
  };
}

// node_modules/@apollo/client/cache/inmemory/writeToStore.js
function getContextFlavor(context, clientOnly, deferred) {
  var key = "".concat(clientOnly).concat(deferred);
  var flavored = context.flavors.get(key);
  if (!flavored) {
    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), { clientOnly, deferred }));
  }
  return flavored;
}
var StoreWriter = (
  /** @class */
  function() {
    function StoreWriter2(cache2, reader, fragments) {
      this.cache = cache2;
      this.reader = reader;
      this.fragments = fragments;
    }
    StoreWriter2.prototype.writeToStore = function(store, _a2) {
      var _this = this;
      var query = _a2.query, result2 = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
      var operationDefinition = getOperationDefinition(query);
      var merger = makeProcessedFieldsMerger();
      variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);
      var context = __assign(__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
        return merger.merge(existing, incoming);
      }, variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
      var ref = this.processSelectionSet({
        result: result2 || /* @__PURE__ */ Object.create(null),
        dataId,
        selectionSet: operationDefinition.selectionSet,
        mergeTree: { map: /* @__PURE__ */ new Map() },
        context
      });
      if (!isReference(ref)) {
        throw newInvariantError(12, result2);
      }
      context.incomingById.forEach(function(_a3, dataId2) {
        var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
        var entityRef = makeReference(dataId2);
        if (mergeTree && mergeTree.map.size) {
          var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
          if (isReference(applied)) {
            return;
          }
          storeObject = applied;
        }
        if (globalThis.__DEV__ !== false && !context.overwrite) {
          var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
          fieldNodeSet.forEach(function(field) {
            if (field.selectionSet) {
              fieldsWithSelectionSets_1[field.name.value] = true;
            }
          });
          var hasSelectionSet_1 = function(storeFieldName) {
            return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
          };
          var hasMergeFunction_1 = function(storeFieldName) {
            var childTree = mergeTree && mergeTree.map.get(storeFieldName);
            return Boolean(childTree && childTree.info && childTree.info.merge);
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
              warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
            }
          });
        }
        store.merge(dataId2, storeObject);
      });
      store.retain(ref.__ref);
      return ref;
    };
    StoreWriter2.prototype.processSelectionSet = function(_a2) {
      var _this = this;
      var dataId = _a2.dataId, result2 = _a2.result, selectionSet = _a2.selectionSet, context = _a2.context, mergeTree = _a2.mergeTree;
      var policies = this.cache.policies;
      var incoming = /* @__PURE__ */ Object.create(null);
      var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result2, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
      if ("string" === typeof typename) {
        incoming.__typename = typename;
      }
      var readField = function() {
        var options = normalizeReadFieldOptions(arguments, incoming, context.variables);
        if (isReference(options.from)) {
          var info = context.incomingById.get(options.from.__ref);
          if (info) {
            var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);
            if (result_1 !== void 0) {
              return result_1;
            }
          }
        }
        return policies.readField(options, context);
      };
      var fieldNodeSet = /* @__PURE__ */ new Set();
      this.flattenFields(
        selectionSet,
        result2,
        // This WriteContext will be the default context value for fields returned
        // by the flattenFields method, but some fields may be assigned a modified
        // context, depending on the presence of @client and other directives.
        context,
        typename
      ).forEach(function(context2, field) {
        var _a3;
        var resultFieldKey = resultKeyNameFromField(field);
        var value = result2[resultFieldKey];
        fieldNodeSet.add(field);
        if (value !== void 0) {
          var storeFieldName = policies.getStoreFieldName({
            typename,
            fieldName: field.name.value,
            field,
            variables: context2.variables
          });
          var childTree = getChildMergeTree(mergeTree, storeFieldName);
          var incomingValue = _this.processFieldValue(
            value,
            field,
            // Reset context.clientOnly and context.deferred to their default
            // values before processing nested selection sets.
            field.selectionSet ? getContextFlavor(context2, false, false) : context2,
            childTree
          );
          var childTypename = void 0;
          if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
            childTypename = readField("__typename", incomingValue);
          }
          var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
          if (merge) {
            childTree.info = {
              // TODO Check compatibility against any existing childTree.field?
              field,
              typename,
              merge
            };
          } else {
            maybeRecycleChildMergeTree(mergeTree, storeFieldName);
          }
          incoming = context2.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
        } else if (globalThis.__DEV__ !== false && !context2.clientOnly && !context2.deferred && !addTypenameToDocument.added(field) && // If the field has a read function, it may be a synthetic field or
        // provide a default value, so its absence from the written data should
        // not be cause for alarm.
        !policies.getReadFunction(typename, field.name.value)) {
          globalThis.__DEV__ !== false && invariant2.error(13, resultKeyNameFromField(field), result2);
        }
      });
      try {
        var _b = policies.identify(result2, {
          typename,
          selectionSet,
          fragmentMap: context.fragmentMap,
          storeObject: incoming,
          readField
        }), id = _b[0], keyObject = _b[1];
        dataId = dataId || id;
        if (keyObject) {
          incoming = context.merge(incoming, keyObject);
        }
      } catch (e) {
        if (!dataId)
          throw e;
      }
      if ("string" === typeof dataId) {
        var dataRef = makeReference(dataId);
        var sets = context.written[dataId] || (context.written[dataId] = []);
        if (sets.indexOf(selectionSet) >= 0)
          return dataRef;
        sets.push(selectionSet);
        if (this.reader && this.reader.isFresh(result2, dataRef, selectionSet, context)) {
          return dataRef;
        }
        var previous_1 = context.incomingById.get(dataId);
        if (previous_1) {
          previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
          previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
          fieldNodeSet.forEach(function(field) {
            return previous_1.fieldNodeSet.add(field);
          });
        } else {
          context.incomingById.set(dataId, {
            storeObject: incoming,
            // Save a reference to mergeTree only if it is not empty, because
            // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
            // reused for entirely different parts of the result tree.
            mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
            fieldNodeSet
          });
        }
        return dataRef;
      }
      return incoming;
    };
    StoreWriter2.prototype.processFieldValue = function(value, field, context, mergeTree) {
      var _this = this;
      if (!field.selectionSet || value === null) {
        return globalThis.__DEV__ !== false ? cloneDeep(value) : value;
      }
      if (isArray(value)) {
        return value.map(function(item, i) {
          var value2 = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));
          maybeRecycleChildMergeTree(mergeTree, i);
          return value2;
        });
      }
      return this.processSelectionSet({
        result: value,
        selectionSet: field.selectionSet,
        context,
        mergeTree
      });
    };
    StoreWriter2.prototype.flattenFields = function(selectionSet, result2, context, typename) {
      if (typename === void 0) {
        typename = getTypenameFromResult(result2, selectionSet, context.fragmentMap);
      }
      var fieldMap = /* @__PURE__ */ new Map();
      var policies = this.cache.policies;
      var limitingTrie = new Trie(false);
      (function flatten(selectionSet2, inheritedContext) {
        var visitedNode = limitingTrie.lookup(
          selectionSet2,
          // Because we take inheritedClientOnly and inheritedDeferred into
          // consideration here (in addition to selectionSet), it's possible for
          // the same selection set to be flattened more than once, if it appears
          // in the query with different @client and/or @directive configurations.
          inheritedContext.clientOnly,
          inheritedContext.deferred
        );
        if (visitedNode.visited)
          return;
        visitedNode.visited = true;
        selectionSet2.selections.forEach(function(selection) {
          if (!shouldInclude(selection, context.variables))
            return;
          var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
          if (
            // Since the presence of @client or @defer on this field can only
            // cause clientOnly or deferred to become true, we can skip the
            // forEach loop if both clientOnly and deferred are already true.
            !(clientOnly && deferred) && isNonEmptyArray(selection.directives)
          ) {
            selection.directives.forEach(function(dir) {
              var name = dir.name.value;
              if (name === "client")
                clientOnly = true;
              if (name === "defer") {
                var args = argumentsObjectFromField(dir, context.variables);
                if (!args || args.if !== false) {
                  deferred = true;
                }
              }
            });
          }
          if (isField(selection)) {
            var existing = fieldMap.get(selection);
            if (existing) {
              clientOnly = clientOnly && existing.clientOnly;
              deferred = deferred && existing.deferred;
            }
            fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
          } else {
            var fragment = getFragmentFromSelection(selection, context.lookupFragment);
            if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
              throw newInvariantError(14, selection.name.value);
            }
            if (fragment && policies.fragmentMatches(fragment, typename, result2, context.variables)) {
              flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
            }
          }
        });
      })(selectionSet, context);
      return fieldMap;
    };
    StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
      var _a2;
      var _this = this;
      if (mergeTree.map.size && !isReference(incoming)) {
        var e_1 = (
          // Items in the same position in different arrays are not
          // necessarily related to each other, so when incoming is an array
          // we process its elements as if there was no existing data.
          !isArray(incoming) && // Likewise, existing must be either a Reference or a StoreObject
          // in order for its fields to be safe to merge with the fields of
          // the incoming object.
          (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0
        );
        var i_1 = incoming;
        if (e_1 && !getStorageArgs) {
          getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
        }
        var changedFields_1;
        var getValue_1 = function(from2, name) {
          return isArray(from2) ? typeof name === "number" ? from2[name] : void 0 : context.store.getFieldValue(from2, String(name));
        };
        mergeTree.map.forEach(function(childTree, storeFieldName) {
          var eVal = getValue_1(e_1, storeFieldName);
          var iVal = getValue_1(i_1, storeFieldName);
          if (void 0 === iVal)
            return;
          if (getStorageArgs) {
            getStorageArgs.push(storeFieldName);
          }
          var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
          if (aVal !== iVal) {
            changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
            changedFields_1.set(storeFieldName, aVal);
          }
          if (getStorageArgs) {
            invariant2(getStorageArgs.pop() === storeFieldName);
          }
        });
        if (changedFields_1) {
          incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);
          changedFields_1.forEach(function(value, name) {
            incoming[name] = value;
          });
        }
      }
      if (mergeTree.info) {
        return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a2 = context.store).getStorage.apply(_a2, getStorageArgs));
      }
      return incoming;
    };
    return StoreWriter2;
  }()
);
var emptyMergeTreePool = [];
function getChildMergeTree(_a2, name) {
  var map = _a2.map;
  if (!map.has(name)) {
    map.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
  }
  return map.get(name);
}
function mergeMergeTrees(left, right) {
  if (left === right || !right || mergeTreeIsEmpty(right))
    return left;
  if (!left || mergeTreeIsEmpty(left))
    return right;
  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;
  var needToMergeMaps = left.map.size && right.map.size;
  var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
  var merged = { info, map };
  if (needToMergeMaps) {
    var remainingRightKeys_1 = new Set(right.map.keys());
    left.map.forEach(function(leftTree, key) {
      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
      remainingRightKeys_1.delete(key);
    });
    remainingRightKeys_1.forEach(function(key) {
      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
    });
  }
  return merged;
}
function mergeTreeIsEmpty(tree) {
  return !tree || !(tree.info || tree.map.size);
}
function maybeRecycleChildMergeTree(_a2, name) {
  var map = _a2.map;
  var childTree = map.get(name);
  if (childTree && mergeTreeIsEmpty(childTree)) {
    emptyMergeTreePool.push(childTree);
    map.delete(name);
  }
}
var warnings = /* @__PURE__ */ new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
  var getChild = function(objOrRef) {
    var child = store.getFieldValue(objOrRef, storeFieldName);
    return typeof child === "object" && child;
  };
  var existing = getChild(existingRef);
  if (!existing)
    return;
  var incoming = getChild(incomingObj);
  if (!incoming)
    return;
  if (isReference(existing))
    return;
  if (equal(existing, incoming))
    return;
  if (Object.keys(existing).every(function(key) {
    return store.getFieldValue(incoming, key) !== void 0;
  })) {
    return;
  }
  var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var typeDotName = "".concat(parentType, ".").concat(fieldName);
  if (warnings.has(typeDotName))
    return;
  warnings.add(typeDotName);
  var childTypenames = [];
  if (!isArray(existing) && !isArray(incoming)) {
    [existing, incoming].forEach(function(child) {
      var typename = store.getFieldValue(child, "__typename");
      if (typeof typename === "string" && !childTypenames.includes(typename)) {
        childTypenames.push(typename);
      }
    });
  }
  globalThis.__DEV__ !== false && invariant2.warn(15, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, __assign({}, existing), __assign({}, incoming));
}

// node_modules/@apollo/client/cache/inmemory/inMemoryCache.js
var InMemoryCache = (
  /** @class */
  function(_super) {
    __extends(InMemoryCache2, _super);
    function InMemoryCache2(config) {
      if (config === void 0) {
        config = {};
      }
      var _this = _super.call(this) || this;
      _this.watches = /* @__PURE__ */ new Set();
      _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);
      _this.assumeImmutableResults = true;
      _this.makeVar = makeVar;
      _this.txCount = 0;
      _this.config = normalizeConfig(config);
      _this.addTypename = !!_this.config.addTypename;
      _this.policies = new Policies({
        cache: _this,
        dataIdFromObject: _this.config.dataIdFromObject,
        possibleTypes: _this.config.possibleTypes,
        typePolicies: _this.config.typePolicies
      });
      _this.init();
      return _this;
    }
    InMemoryCache2.prototype.init = function() {
      var rootStore = this.data = new EntityStore.Root({
        policies: this.policies,
        resultCaching: this.config.resultCaching
      });
      this.optimisticData = rootStore.stump;
      this.resetResultCache();
    };
    InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
      var _this = this;
      var previousReader = this.storeReader;
      var fragments = this.config.fragments;
      this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
        cache: this,
        addTypename: this.addTypename,
        resultCacheMaxSize: this.config.resultCacheMaxSize,
        canonizeResults: shouldCanonizeResults(this.config),
        canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
        fragments
      }), fragments);
      this.maybeBroadcastWatch = wrap2(function(c, options) {
        return _this.broadcastWatch(c, options);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5e3,
        makeCacheKey: function(c) {
          var store = c.optimistic ? _this.optimisticData : _this.data;
          if (supportsResultCaching(store)) {
            var optimistic = c.optimistic, id = c.id, variables = c.variables;
            return store.makeCacheKey(
              c.query,
              // Different watches can have the same query, optimistic
              // status, rootId, and variables, but if their callbacks are
              // different, the (identical) result needs to be delivered to
              // each distinct callback. The easiest way to achieve that
              // separation is to include c.callback in the cache key for
              // maybeBroadcastWatch calls. See issue #5733.
              c.callback,
              canonicalStringify({ optimistic, id, variables })
            );
          }
        }
      });
      (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
        return group.resetCaching();
      });
    };
    InMemoryCache2.prototype.restore = function(data) {
      this.init();
      if (data)
        this.data.replace(data);
      return this;
    };
    InMemoryCache2.prototype.extract = function(optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return (optimistic ? this.optimisticData : this.data).extract();
    };
    InMemoryCache2.prototype.read = function(options) {
      var _a2 = options.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
      try {
        return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
      } catch (e) {
        if (e instanceof MissingFieldError) {
          return null;
        }
        throw e;
      }
    };
    InMemoryCache2.prototype.write = function(options) {
      try {
        ++this.txCount;
        return this.storeWriter.writeToStore(this.data, options);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.modify = function(options) {
      if (hasOwn.call(options, "id") && !options.id) {
        return false;
      }
      var store = options.optimistic ? this.optimisticData : this.data;
      try {
        ++this.txCount;
        return store.modify(options.id || "ROOT_QUERY", options.fields);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.diff = function(options) {
      return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
    };
    InMemoryCache2.prototype.watch = function(watch) {
      var _this = this;
      if (!this.watches.size) {
        recallCache(this);
      }
      this.watches.add(watch);
      if (watch.immediate) {
        this.maybeBroadcastWatch(watch);
      }
      return function() {
        if (_this.watches.delete(watch) && !_this.watches.size) {
          forgetCache(_this);
        }
        _this.maybeBroadcastWatch.forget(watch);
      };
    };
    InMemoryCache2.prototype.gc = function(options) {
      var _a2;
      canonicalStringify.reset();
      print2.reset();
      this.addTypenameTransform.resetCache();
      (_a2 = this.config.fragments) === null || _a2 === void 0 ? void 0 : _a2.resetCaches();
      var ids = this.optimisticData.gc();
      if (options && !this.txCount) {
        if (options.resetResultCache) {
          this.resetResultCache(options.resetResultIdentities);
        } else if (options.resetResultIdentities) {
          this.storeReader.resetCanon();
        }
      }
      return ids;
    };
    InMemoryCache2.prototype.retain = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).retain(rootId);
    };
    InMemoryCache2.prototype.release = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).release(rootId);
    };
    InMemoryCache2.prototype.identify = function(object) {
      if (isReference(object))
        return object.__ref;
      try {
        return this.policies.identify(object)[0];
      } catch (e) {
        globalThis.__DEV__ !== false && invariant2.warn(e);
      }
    };
    InMemoryCache2.prototype.evict = function(options) {
      if (!options.id) {
        if (hasOwn.call(options, "id")) {
          return false;
        }
        options = __assign(__assign({}, options), { id: "ROOT_QUERY" });
      }
      try {
        ++this.txCount;
        return this.optimisticData.evict(options, this.data);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.reset = function(options) {
      var _this = this;
      this.init();
      canonicalStringify.reset();
      if (options && options.discardWatches) {
        this.watches.forEach(function(watch) {
          return _this.maybeBroadcastWatch.forget(watch);
        });
        this.watches.clear();
        forgetCache(this);
      } else {
        this.broadcastWatches();
      }
      return Promise.resolve();
    };
    InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
      var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
      if (newOptimisticData !== this.optimisticData) {
        this.optimisticData = newOptimisticData;
        this.broadcastWatches();
      }
    };
    InMemoryCache2.prototype.batch = function(options) {
      var _this = this;
      var update = options.update, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
      var updateResult;
      var perform = function(layer) {
        var _a3 = _this, data = _a3.data, optimisticData = _a3.optimisticData;
        ++_this.txCount;
        if (layer) {
          _this.data = _this.optimisticData = layer;
        }
        try {
          return updateResult = update(_this);
        } finally {
          --_this.txCount;
          _this.data = data;
          _this.optimisticData = optimisticData;
        }
      };
      var alreadyDirty = /* @__PURE__ */ new Set();
      if (onWatchUpdated && !this.txCount) {
        this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function(watch) {
          alreadyDirty.add(watch);
          return false;
        } }));
      }
      if (typeof optimistic === "string") {
        this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
      } else if (optimistic === false) {
        perform(this.data);
      } else {
        perform();
      }
      if (typeof removeOptimistic === "string") {
        this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
      }
      if (onWatchUpdated && alreadyDirty.size) {
        this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function(watch, diff) {
          var result2 = onWatchUpdated.call(this, watch, diff);
          if (result2 !== false) {
            alreadyDirty.delete(watch);
          }
          return result2;
        } }));
        if (alreadyDirty.size) {
          alreadyDirty.forEach(function(watch) {
            return _this.maybeBroadcastWatch.dirty(watch);
          });
        }
      } else {
        this.broadcastWatches(options);
      }
      return updateResult;
    };
    InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
      return this.batch({
        update,
        optimistic: optimisticId || optimisticId !== null
      });
    };
    InMemoryCache2.prototype.transformDocument = function(document2) {
      return this.addTypenameToDocument(this.addFragmentsToDocument(document2));
    };
    InMemoryCache2.prototype.fragmentMatches = function(fragment, typename) {
      return this.policies.fragmentMatches(fragment, typename);
    };
    InMemoryCache2.prototype.lookupFragment = function(fragmentName) {
      var _a2;
      return ((_a2 = this.config.fragments) === null || _a2 === void 0 ? void 0 : _a2.lookup(fragmentName)) || null;
    };
    InMemoryCache2.prototype.broadcastWatches = function(options) {
      var _this = this;
      if (!this.txCount) {
        this.watches.forEach(function(c) {
          return _this.maybeBroadcastWatch(c, options);
        });
      }
    };
    InMemoryCache2.prototype.addFragmentsToDocument = function(document2) {
      var fragments = this.config.fragments;
      return fragments ? fragments.transform(document2) : document2;
    };
    InMemoryCache2.prototype.addTypenameToDocument = function(document2) {
      if (this.addTypename) {
        return this.addTypenameTransform.transformDocument(document2);
      }
      return document2;
    };
    InMemoryCache2.prototype.broadcastWatch = function(c, options) {
      var lastDiff = c.lastDiff;
      var diff = this.diff(c);
      if (options) {
        if (c.optimistic && typeof options.optimistic === "string") {
          diff.fromOptimisticTransaction = true;
        }
        if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
          return;
        }
      }
      if (!lastDiff || !equal(lastDiff.result, diff.result)) {
        c.callback(c.lastDiff = diff, lastDiff);
      }
    };
    return InMemoryCache2;
  }(ApolloCache)
);
if (globalThis.__DEV__ !== false) {
  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;
}

// node_modules/@apollo/client/cache/inmemory/fragmentRegistry.js
var import_dist670 = __toESM(require_dist(), 1);
var import_dist671 = __toESM(require_dist2(), 1);
var import_dist672 = __toESM(require_dist3(), 1);
var FragmentRegistry = (
  /** @class */
  function() {
    function FragmentRegistry2() {
      var fragments = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fragments[_i] = arguments[_i];
      }
      this.registry = /* @__PURE__ */ Object.create(null);
      this.resetCaches();
      if (fragments.length) {
        this.register.apply(this, fragments);
      }
    }
    FragmentRegistry2.prototype.register = function() {
      var _this = this;
      var fragments = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fragments[_i] = arguments[_i];
      }
      var definitions = /* @__PURE__ */ new Map();
      fragments.forEach(function(doc) {
        getFragmentDefinitions(doc).forEach(function(node) {
          definitions.set(node.name.value, node);
        });
      });
      definitions.forEach(function(node, name) {
        if (node !== _this.registry[name]) {
          _this.registry[name] = node;
          _this.invalidate(name);
        }
      });
      return this;
    };
    FragmentRegistry2.prototype.invalidate = function(name) {
    };
    FragmentRegistry2.prototype.resetCaches = function() {
      var proto = FragmentRegistry2.prototype;
      this.invalidate = (this.lookup = wrap2(proto.lookup.bind(this), {
        makeCacheKey: function(arg) {
          return arg;
        },
        max: cacheSizes["fragmentRegistry.lookup"] || 1e3
      })).dirty;
      this.transform = wrap2(proto.transform.bind(this), {
        cache: WeakCache,
        max: cacheSizes["fragmentRegistry.transform"] || 2e3
      });
      this.findFragmentSpreads = wrap2(proto.findFragmentSpreads.bind(this), {
        cache: WeakCache,
        max: cacheSizes["fragmentRegistry.findFragmentSpreads"] || 4e3
      });
    };
    FragmentRegistry2.prototype.lookup = function(fragmentName) {
      return this.registry[fragmentName] || null;
    };
    FragmentRegistry2.prototype.transform = function(document2) {
      var _this = this;
      var defined = /* @__PURE__ */ new Map();
      getFragmentDefinitions(document2).forEach(function(def) {
        defined.set(def.name.value, def);
      });
      var unbound = /* @__PURE__ */ new Set();
      var enqueue2 = function(spreadName) {
        if (!defined.has(spreadName)) {
          unbound.add(spreadName);
        }
      };
      var enqueueChildSpreads = function(node) {
        return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue2);
      };
      enqueueChildSpreads(document2);
      var missing = [];
      var map = /* @__PURE__ */ Object.create(null);
      unbound.forEach(function(fragmentName) {
        var knownFragmentDef = defined.get(fragmentName);
        if (knownFragmentDef) {
          enqueueChildSpreads(map[fragmentName] = knownFragmentDef);
        } else {
          missing.push(fragmentName);
          var def = _this.lookup(fragmentName);
          if (def) {
            enqueueChildSpreads(map[fragmentName] = def);
          }
        }
      });
      if (missing.length) {
        var defsToAppend_1 = [];
        missing.forEach(function(name) {
          var def = map[name];
          if (def) {
            defsToAppend_1.push(def);
          }
        });
        if (defsToAppend_1.length) {
          document2 = __assign(__assign({}, document2), { definitions: document2.definitions.concat(defsToAppend_1) });
        }
      }
      return document2;
    };
    FragmentRegistry2.prototype.findFragmentSpreads = function(root2) {
      var spreads = /* @__PURE__ */ Object.create(null);
      visit(root2, {
        FragmentSpread: function(node) {
          spreads[node.name.value] = node;
        }
      });
      return spreads;
    };
    return FragmentRegistry2;
  }()
);

// node_modules/@apollo/client/cache/inmemory/types.js
var import_dist673 = __toESM(require_dist(), 1);
var import_dist674 = __toESM(require_dist2(), 1);
var import_dist675 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/core/ObservableQuery.js
var import_dist682 = __toESM(require_dist(), 1);
var import_dist683 = __toESM(require_dist2(), 1);
var import_dist684 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/core/networkStatus.js
var import_dist679 = __toESM(require_dist(), 1);
var import_dist680 = __toESM(require_dist2(), 1);
var import_dist681 = __toESM(require_dist3(), 1);
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus ? networkStatus < 7 : false;
}

// node_modules/@apollo/client/core/ObservableQuery.js
var assign = Object.assign;
var hasOwnProperty6 = Object.hasOwnProperty;
var ObservableQuery = (
  /** @class */
  function(_super) {
    __extends(ObservableQuery2, _super);
    function ObservableQuery2(_a2) {
      var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options = _a2.options;
      var _this = _super.call(this, function(observer) {
        try {
          var subObserver = observer._subscription._observer;
          if (subObserver && !subObserver.error) {
            subObserver.error = defaultSubscriptionObserverErrorCallback;
          }
        } catch (_a3) {
        }
        var first = !_this.observers.size;
        _this.observers.add(observer);
        var last = _this.last;
        if (last && last.error) {
          observer.error && observer.error(last.error);
        } else if (last && last.result) {
          observer.next && observer.next(_this.maskResult(last.result));
        }
        if (first) {
          _this.reobserve().catch(function() {
          });
        }
        return function() {
          if (_this.observers.delete(observer) && !_this.observers.size) {
            _this.tearDownQuery();
          }
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.subscriptions = /* @__PURE__ */ new Set();
      _this.queryInfo = queryInfo;
      _this.queryManager = queryManager;
      _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);
      _this.isTornDown = false;
      _this.subscribeToMore = _this.subscribeToMore.bind(_this);
      _this.maskResult = _this.maskResult.bind(_this);
      var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
      var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
      _this.options = __assign(__assign({}, options), {
        // Remember the initial options.fetchPolicy so we can revert back to this
        // policy when variables change. This information can also be specified
        // (or overridden) by providing options.initialFetchPolicy explicitly.
        initialFetchPolicy,
        // This ensures this.options.fetchPolicy always has a string value, in
        // case options.fetchPolicy was not provided.
        fetchPolicy
      });
      _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
      var opDef = getOperationDefinition(_this.query);
      _this.queryName = opDef && opDef.name && opDef.name.value;
      return _this;
    }
    Object.defineProperty(ObservableQuery2.prototype, "query", {
      // The `query` computed property will always reflect the document transformed
      // by the last run query. `this.options.query` will always reflect the raw
      // untransformed query to ensure document transforms with runtime conditionals
      // are run on the original document.
      get: function() {
        return this.lastQuery || this.options.query;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservableQuery2.prototype, "variables", {
      // Computed shorthand for this.options.variables, preserved for
      // backwards compatibility.
      /**
       * An object containing the variables that were provided for the query.
       */
      get: function() {
        return this.options.variables;
      },
      enumerable: false,
      configurable: true
    });
    ObservableQuery2.prototype.result = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var observer = {
          next: function(result2) {
            resolve(result2);
            _this.observers.delete(observer);
            if (!_this.observers.size) {
              _this.queryManager.removeQuery(_this.queryId);
            }
            setTimeout(function() {
              subscription.unsubscribe();
            }, 0);
          },
          error: reject
        };
        var subscription = _this.subscribe(observer);
      });
    };
    ObservableQuery2.prototype.resetDiff = function() {
      this.queryInfo.resetDiff();
    };
    ObservableQuery2.prototype.getCurrentFullResult = function(saveAsLastResult) {
      if (saveAsLastResult === void 0) {
        saveAsLastResult = true;
      }
      var lastResult = this.getLastResult(true);
      var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
      var result2 = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
      var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
      if (
        // These fetch policies should never deliver data from the cache, unless
        // redelivering a previously delivered result.
        skipCacheDataFor(fetchPolicy) || // If this.options.query has @client(always: true) fields, we cannot
        // trust diff.result, since it was read from the cache without running
        // local resolvers (and it's too late to run resolvers now, since we must
        // return a result synchronously).
        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers
      ) {
      } else if (this.waitForOwnResult) {
        this.queryInfo["updateWatch"]();
      } else {
        var diff = this.queryInfo.getDiff();
        if (diff.complete || this.options.returnPartialData) {
          result2.data = diff.result;
        }
        if (equal(result2.data, {})) {
          result2.data = void 0;
        }
        if (diff.complete) {
          delete result2.partial;
          if (diff.complete && result2.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
            result2.networkStatus = NetworkStatus.ready;
            result2.loading = false;
          }
        } else {
          result2.partial = true;
        }
        if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result2.loading && !result2.data && !result2.error) {
          logMissingFieldErrors(diff.missing);
        }
      }
      if (saveAsLastResult) {
        this.updateLastResult(result2);
      }
      return result2;
    };
    ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
      if (saveAsLastResult === void 0) {
        saveAsLastResult = true;
      }
      return this.maskResult(this.getCurrentFullResult(saveAsLastResult));
    };
    ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
      if (!this.last) {
        return true;
      }
      var documentInfo = this.queryManager.getDocumentInfo(this.query);
      var dataMasking = this.queryManager.dataMasking;
      var query = dataMasking ? documentInfo.nonReactiveQuery : this.query;
      var resultIsDifferent = dataMasking || documentInfo.hasNonreactiveDirective ? !equalByQuery(query, this.last.result, newResult, this.variables) : !equal(this.last.result, newResult);
      return resultIsDifferent || variables && !equal(this.last.variables, variables);
    };
    ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
      var last = this.last;
      if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {
        return last[key];
      }
    };
    ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
      return this.getLast("result", variablesMustMatch);
    };
    ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
      return this.getLast("error", variablesMustMatch);
    };
    ObservableQuery2.prototype.resetLastResults = function() {
      delete this.last;
      this.isTornDown = false;
    };
    ObservableQuery2.prototype.resetQueryStoreErrors = function() {
      this.queryManager.resetErrors(this.queryId);
    };
    ObservableQuery2.prototype.refetch = function(variables) {
      var _a2;
      var reobserveOptions = {
        // Always disable polling for refetches.
        pollInterval: 0
      };
      var fetchPolicy = this.options.fetchPolicy;
      if (fetchPolicy === "cache-and-network") {
        reobserveOptions.fetchPolicy = fetchPolicy;
      } else if (fetchPolicy === "no-cache") {
        reobserveOptions.fetchPolicy = "no-cache";
      } else {
        reobserveOptions.fetchPolicy = "network-only";
      }
      if (globalThis.__DEV__ !== false && variables && hasOwnProperty6.call(variables, "variables")) {
        var queryDef = getQueryDefinition(this.query);
        var vars = queryDef.variableDefinitions;
        if (!vars || !vars.some(function(v) {
          return v.variable.name.value === "variables";
        })) {
          globalThis.__DEV__ !== false && invariant2.warn(
            21,
            variables,
            ((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || queryDef
          );
        }
      }
      if (variables && !equal(this.options.variables, variables)) {
        reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);
      }
      this.queryInfo.resetLastWrite();
      return this.reobserve(reobserveOptions, NetworkStatus.refetch);
    };
    ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
      var _this = this;
      var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })), {
        // The fetchMore request goes immediately to the network and does
        // not automatically write its result to the cache (hence no-cache
        // instead of network-only), because we allow the caller of
        // fetchMore to provide an updateQuery callback that determines how
        // the data gets written to the cache.
        fetchPolicy: "no-cache"
      });
      combinedOptions.query = this.transformDocument(combinedOptions.query);
      var qid = this.queryManager.generateQueryId();
      this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
      var queryInfo = this.queryInfo;
      var originalNetworkStatus = queryInfo.networkStatus;
      queryInfo.networkStatus = NetworkStatus.fetchMore;
      if (combinedOptions.notifyOnNetworkStatusChange) {
        this.observe();
      }
      var updatedQuerySet = /* @__PURE__ */ new Set();
      var updateQuery = fetchMoreOptions === null || fetchMoreOptions === void 0 ? void 0 : fetchMoreOptions.updateQuery;
      var isCached = this.options.fetchPolicy !== "no-cache";
      if (!isCached) {
        invariant2(updateQuery, 22);
      }
      return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
        _this.queryManager.removeQuery(qid);
        if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
          queryInfo.networkStatus = originalNetworkStatus;
        }
        if (isCached) {
          _this.queryManager.cache.batch({
            update: function(cache2) {
              var updateQuery2 = fetchMoreOptions.updateQuery;
              if (updateQuery2) {
                cache2.updateQuery({
                  query: _this.query,
                  variables: _this.variables,
                  returnPartialData: true,
                  optimistic: false
                }, function(previous) {
                  return updateQuery2(previous, {
                    fetchMoreResult: fetchMoreResult.data,
                    variables: combinedOptions.variables
                  });
                });
              } else {
                cache2.writeQuery({
                  query: combinedOptions.query,
                  variables: combinedOptions.variables,
                  data: fetchMoreResult.data
                });
              }
            },
            onWatchUpdated: function(watch) {
              updatedQuerySet.add(watch.query);
            }
          });
        } else {
          var lastResult = _this.getLast("result");
          var data = updateQuery(lastResult.data, {
            fetchMoreResult: fetchMoreResult.data,
            variables: combinedOptions.variables
          });
          _this.reportResult(__assign(__assign({}, lastResult), { data }), _this.variables);
        }
        return _this.maskResult(fetchMoreResult);
      }).finally(function() {
        if (isCached && !updatedQuerySet.has(_this.query)) {
          reobserveCacheFirst(_this);
        }
      });
    };
    ObservableQuery2.prototype.subscribeToMore = function(options) {
      var _this = this;
      var subscription = this.queryManager.startGraphQLSubscription({
        query: options.document,
        variables: options.variables,
        context: options.context
      }).subscribe({
        next: function(subscriptionData) {
          var updateQuery = options.updateQuery;
          if (updateQuery) {
            _this.updateQuery(function(previous, _a2) {
              var variables = _a2.variables;
              return updateQuery(previous, {
                subscriptionData,
                variables
              });
            });
          }
        },
        error: function(err) {
          if (options.onError) {
            options.onError(err);
            return;
          }
          globalThis.__DEV__ !== false && invariant2.error(23, err);
        }
      });
      this.subscriptions.add(subscription);
      return function() {
        if (_this.subscriptions.delete(subscription)) {
          subscription.unsubscribe();
        }
      };
    };
    ObservableQuery2.prototype.setOptions = function(newOptions) {
      return this.reobserve(newOptions);
    };
    ObservableQuery2.prototype.silentSetOptions = function(newOptions) {
      var mergedOptions = compact(this.options, newOptions || {});
      assign(this.options, mergedOptions);
    };
    ObservableQuery2.prototype.setVariables = function(variables) {
      if (equal(this.variables, variables)) {
        return this.observers.size ? this.result() : Promise.resolve();
      }
      this.options.variables = variables;
      if (!this.observers.size) {
        return Promise.resolve();
      }
      return this.reobserve({
        // Reset options.fetchPolicy to its original value.
        fetchPolicy: this.options.initialFetchPolicy,
        variables
      }, NetworkStatus.setVariables);
    };
    ObservableQuery2.prototype.updateQuery = function(mapFn) {
      var queryManager = this.queryManager;
      var result2 = queryManager.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: true,
        optimistic: false
      }).result;
      var newResult = mapFn(result2, {
        variables: this.variables
      });
      if (newResult) {
        queryManager.cache.writeQuery({
          query: this.options.query,
          data: newResult,
          variables: this.variables
        });
        queryManager.broadcastQueries();
      }
    };
    ObservableQuery2.prototype.startPolling = function(pollInterval) {
      this.options.pollInterval = pollInterval;
      this.updatePolling();
    };
    ObservableQuery2.prototype.stopPolling = function() {
      this.options.pollInterval = 0;
      this.updatePolling();
    };
    ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
      if (options.nextFetchPolicy) {
        var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
        if (fetchPolicy === "standby") {
        } else if (typeof options.nextFetchPolicy === "function") {
          options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
            reason,
            options,
            observable: this,
            initialFetchPolicy
          });
        } else if (reason === "variables-changed") {
          options.fetchPolicy = initialFetchPolicy;
        } else {
          options.fetchPolicy = options.nextFetchPolicy;
        }
      }
      return options.fetchPolicy;
    };
    ObservableQuery2.prototype.fetch = function(options, newNetworkStatus, query) {
      this.queryManager.setObservableQuery(this);
      return this.queryManager["fetchConcastWithInfo"](this.queryId, options, newNetworkStatus, query);
    };
    ObservableQuery2.prototype.updatePolling = function() {
      var _this = this;
      if (this.queryManager.ssrMode) {
        return;
      }
      var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
      if (!pollInterval || !this.hasObservers()) {
        if (pollingInfo) {
          clearTimeout(pollingInfo.timeout);
          delete this.pollingInfo;
        }
        return;
      }
      if (pollingInfo && pollingInfo.interval === pollInterval) {
        return;
      }
      invariant2(pollInterval, 24);
      var info = pollingInfo || (this.pollingInfo = {});
      info.interval = pollInterval;
      var maybeFetch = function() {
        var _a3, _b;
        if (_this.pollingInfo) {
          if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b = (_a3 = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a3))) {
            _this.reobserve({
              // Most fetchPolicy options don't make sense to use in a polling context, as
              // users wouldn't want to be polling the cache directly. However, network-only and
              // no-cache are both useful for when the user wants to control whether or not the
              // polled results are written to the cache.
              fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
            }, NetworkStatus.poll).then(poll, poll);
          } else {
            poll();
          }
        }
      };
      var poll = function() {
        var info2 = _this.pollingInfo;
        if (info2) {
          clearTimeout(info2.timeout);
          info2.timeout = setTimeout(maybeFetch, info2.interval);
        }
      };
      poll();
    };
    ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
      if (variables === void 0) {
        variables = this.variables;
      }
      var error = this.getLastError();
      if (error && this.last && !equal(variables, this.last.variables)) {
        error = void 0;
      }
      return this.last = __assign({ result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables }, error ? { error } : null);
    };
    ObservableQuery2.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
      var _this = this;
      this.isTornDown = false;
      var useDisposableConcast = (
        // Refetching uses a disposable Concast to allow refetches using different
        // options/variables, without permanently altering the options of the
        // original ObservableQuery.
        newNetworkStatus === NetworkStatus.refetch || // The fetchMore method does not actually call the reobserve method, but,
        // if it did, it would definitely use a disposable Concast.
        newNetworkStatus === NetworkStatus.fetchMore || // Polling uses a disposable Concast so the polling options (which force
        // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
        newNetworkStatus === NetworkStatus.poll
      );
      var oldVariables = this.options.variables;
      var oldFetchPolicy = this.options.fetchPolicy;
      var mergedOptions = compact(this.options, newOptions || {});
      var options = useDisposableConcast ? (
        // Disposable Concast fetches receive a shallow copy of this.options
        // (merged with newOptions), leaving this.options unmodified.
        mergedOptions
      ) : assign(this.options, mergedOptions);
      var query = this.transformDocument(options.query);
      this.lastQuery = query;
      if (!useDisposableConcast) {
        this.updatePolling();
        if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && // Don't mess with the fetchPolicy if it's currently "standby".
        options.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
        (options.fetchPolicy === oldFetchPolicy || // A `nextFetchPolicy` function has even higher priority, though,
        // so in that case `applyNextFetchPolicy` must be called.
        typeof options.nextFetchPolicy === "function")) {
          this.applyNextFetchPolicy("variables-changed", options);
          if (newNetworkStatus === void 0) {
            newNetworkStatus = NetworkStatus.setVariables;
          }
        }
      }
      this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));
      var finishWaitingForOwnResult = function() {
        if (_this.concast === concast) {
          _this.waitForOwnResult = false;
        }
      };
      var variables = options.variables && __assign({}, options.variables);
      var _a2 = this.fetch(options, newNetworkStatus, query), concast = _a2.concast, fromLink = _a2.fromLink;
      var observer = {
        next: function(result2) {
          if (equal(_this.variables, variables)) {
            finishWaitingForOwnResult();
            _this.reportResult(result2, variables);
          }
        },
        error: function(error) {
          if (equal(_this.variables, variables)) {
            if (!isApolloError(error)) {
              error = new ApolloError({ networkError: error });
            }
            finishWaitingForOwnResult();
            _this.reportError(error, variables);
          }
        }
      };
      if (!useDisposableConcast && (fromLink || !this.concast)) {
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
        }
        this.concast = concast;
        this.observer = observer;
      }
      concast.addObserver(observer);
      return concast;
    };
    ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
      return preventUnhandledRejection(this.reobserveAsConcast(newOptions, newNetworkStatus).promise.then(this.maskResult));
    };
    ObservableQuery2.prototype.resubscribeAfterError = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var last = this.last;
      this.resetLastResults();
      var subscription = this.subscribe.apply(this, args);
      this.last = last;
      return subscription;
    };
    ObservableQuery2.prototype.observe = function() {
      this.reportResult(
        // Passing false is important so that this.getCurrentResult doesn't
        // save the fetchMore result as this.lastResult, causing it to be
        // ignored due to the this.isDifferentFromLastResult check in
        // this.reportResult.
        this.getCurrentFullResult(false),
        this.variables
      );
    };
    ObservableQuery2.prototype.reportResult = function(result2, variables) {
      var lastError = this.getLastError();
      var isDifferent = this.isDifferentFromLastResult(result2, variables);
      if (lastError || !result2.partial || this.options.returnPartialData) {
        this.updateLastResult(result2, variables);
      }
      if (lastError || isDifferent) {
        iterateObserversSafely(this.observers, "next", this.maskResult(result2));
      }
    };
    ObservableQuery2.prototype.reportError = function(error, variables) {
      var errorResult = __assign(__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
      this.updateLastResult(errorResult, variables);
      iterateObserversSafely(this.observers, "error", this.last.error = error);
    };
    ObservableQuery2.prototype.hasObservers = function() {
      return this.observers.size > 0;
    };
    ObservableQuery2.prototype.tearDownQuery = function() {
      if (this.isTornDown)
        return;
      if (this.concast && this.observer) {
        this.concast.removeObserver(this.observer);
        delete this.concast;
        delete this.observer;
      }
      this.stopPolling();
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      this.subscriptions.clear();
      this.queryManager.stopQuery(this.queryId);
      this.observers.clear();
      this.isTornDown = true;
    };
    ObservableQuery2.prototype.transformDocument = function(document2) {
      return this.queryManager.transform(document2);
    };
    ObservableQuery2.prototype.maskResult = function(result2) {
      return result2 && "data" in result2 ? __assign(__assign({}, result2), { data: this.queryManager.maskOperation({
        document: this.query,
        data: result2.data,
        fetchPolicy: this.options.fetchPolicy,
        id: this.queryId
      }) }) : result2;
    };
    return ObservableQuery2;
  }(Observable)
);
fixObservableSubclass(ObservableQuery);
function reobserveCacheFirst(obsQuery) {
  var _a2 = obsQuery.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
  if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
    return obsQuery.reobserve({
      fetchPolicy: "cache-first",
      // Use a temporary nextFetchPolicy function that replaces itself with the
      // previous nextFetchPolicy value and returns the original fetchPolicy.
      nextFetchPolicy: function(currentFetchPolicy, context) {
        this.nextFetchPolicy = nextFetchPolicy;
        if (typeof this.nextFetchPolicy === "function") {
          return this.nextFetchPolicy(currentFetchPolicy, context);
        }
        return fetchPolicy;
      }
    });
  }
  return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error) {
  globalThis.__DEV__ !== false && invariant2.error(25, error.message, error.stack);
}
function logMissingFieldErrors(missing) {
  if (globalThis.__DEV__ !== false && missing) {
    globalThis.__DEV__ !== false && invariant2.debug(26, missing);
  }
}
function skipCacheDataFor(fetchPolicy) {
  return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
}

// node_modules/@apollo/client/core/QueryInfo.js
var import_dist685 = __toESM(require_dist(), 1);
var import_dist686 = __toESM(require_dist2(), 1);
var import_dist687 = __toESM(require_dist3(), 1);
var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache2, methodName) {
  var original = cache2[methodName];
  if (typeof original === "function") {
    cache2[methodName] = function() {
      destructiveMethodCounts.set(
        cache2,
        // The %1e15 allows the count to wrap around to 0 safely every
        // quadrillion evictions, so there's no risk of overflow. To be
        // clear, this is more of a pedantic principle than something
        // that matters in any conceivable practical scenario.
        (destructiveMethodCounts.get(cache2) + 1) % 1e15
      );
      return original.apply(this, arguments);
    };
  }
}
function cancelNotifyTimeout(info) {
  if (info["notifyTimeout"]) {
    clearTimeout(info["notifyTimeout"]);
    info["notifyTimeout"] = void 0;
  }
}
var QueryInfo = (
  /** @class */
  function() {
    function QueryInfo2(queryManager, queryId) {
      if (queryId === void 0) {
        queryId = queryManager.generateQueryId();
      }
      this.queryId = queryId;
      this.listeners = /* @__PURE__ */ new Set();
      this.document = null;
      this.lastRequestId = 1;
      this.stopped = false;
      this.dirty = false;
      this.observableQuery = null;
      var cache2 = this.cache = queryManager.cache;
      if (!destructiveMethodCounts.has(cache2)) {
        destructiveMethodCounts.set(cache2, 0);
        wrapDestructiveCacheMethod(cache2, "evict");
        wrapDestructiveCacheMethod(cache2, "modify");
        wrapDestructiveCacheMethod(cache2, "reset");
      }
    }
    QueryInfo2.prototype.init = function(query) {
      var networkStatus = query.networkStatus || NetworkStatus.loading;
      if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {
        networkStatus = NetworkStatus.setVariables;
      }
      if (!equal(query.variables, this.variables)) {
        this.lastDiff = void 0;
      }
      Object.assign(this, {
        document: query.document,
        variables: query.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus
      });
      if (query.observableQuery) {
        this.setObservableQuery(query.observableQuery);
      }
      if (query.lastRequestId) {
        this.lastRequestId = query.lastRequestId;
      }
      return this;
    };
    QueryInfo2.prototype.reset = function() {
      cancelNotifyTimeout(this);
      this.dirty = false;
    };
    QueryInfo2.prototype.resetDiff = function() {
      this.lastDiff = void 0;
    };
    QueryInfo2.prototype.getDiff = function() {
      var options = this.getDiffOptions();
      if (this.lastDiff && equal(options, this.lastDiff.options)) {
        return this.lastDiff.diff;
      }
      this.updateWatch(this.variables);
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return { complete: false };
      }
      var diff = this.cache.diff(options);
      this.updateLastDiff(diff, options);
      return diff;
    };
    QueryInfo2.prototype.updateLastDiff = function(diff, options) {
      this.lastDiff = diff ? {
        diff,
        options: options || this.getDiffOptions()
      } : void 0;
    };
    QueryInfo2.prototype.getDiffOptions = function(variables) {
      var _a2;
      if (variables === void 0) {
        variables = this.variables;
      }
      return {
        query: this.document,
        variables,
        returnPartialData: true,
        optimistic: true,
        canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
      };
    };
    QueryInfo2.prototype.setDiff = function(diff) {
      var _this = this;
      var _a2;
      var oldDiff = this.lastDiff && this.lastDiff.diff;
      if (diff && !diff.complete && ((_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.getLastError())) {
        return;
      }
      this.updateLastDiff(diff);
      if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {
        this.dirty = true;
        if (!this.notifyTimeout) {
          this.notifyTimeout = setTimeout(function() {
            return _this.notify();
          }, 0);
        }
      }
    };
    QueryInfo2.prototype.setObservableQuery = function(oq) {
      var _this = this;
      if (oq === this.observableQuery)
        return;
      if (this.oqListener) {
        this.listeners.delete(this.oqListener);
      }
      this.observableQuery = oq;
      if (oq) {
        oq["queryInfo"] = this;
        this.listeners.add(this.oqListener = function() {
          var diff = _this.getDiff();
          if (diff.fromOptimisticTransaction) {
            oq["observe"]();
          } else {
            reobserveCacheFirst(oq);
          }
        });
      } else {
        delete this.oqListener;
      }
    };
    QueryInfo2.prototype.notify = function() {
      var _this = this;
      cancelNotifyTimeout(this);
      if (this.shouldNotify()) {
        this.listeners.forEach(function(listener) {
          return listener(_this);
        });
      }
      this.dirty = false;
    };
    QueryInfo2.prototype.shouldNotify = function() {
      if (!this.dirty || !this.listeners.size) {
        return false;
      }
      if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
        var fetchPolicy = this.observableQuery.options.fetchPolicy;
        if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
          return false;
        }
      }
      return true;
    };
    QueryInfo2.prototype.stop = function() {
      if (!this.stopped) {
        this.stopped = true;
        this.reset();
        this.cancel();
        this.cancel = QueryInfo2.prototype.cancel;
        var oq = this.observableQuery;
        if (oq)
          oq.stopPolling();
      }
    };
    QueryInfo2.prototype.cancel = function() {
    };
    QueryInfo2.prototype.updateWatch = function(variables) {
      var _this = this;
      if (variables === void 0) {
        variables = this.variables;
      }
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return;
      }
      var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
        return _this.setDiff(diff);
      } });
      if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {
        this.cancel();
        this.cancel = this.cache.watch(this.lastWatch = watchOptions);
      }
    };
    QueryInfo2.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    };
    QueryInfo2.prototype.shouldWrite = function(result2, variables) {
      var lastWrite = this.lastWrite;
      return !(lastWrite && // If cache.evict has been called since the last time we wrote this
      // data into the cache, there's a chance writing this result into
      // the cache will repair what was evicted.
      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result2.data, lastWrite.result.data));
    };
    QueryInfo2.prototype.markResult = function(result2, document2, options, cacheWriteBehavior) {
      var _this = this;
      var merger = new DeepMerger();
      var graphQLErrors = isNonEmptyArray(result2.errors) ? result2.errors.slice(0) : [];
      this.reset();
      if ("incremental" in result2 && isNonEmptyArray(result2.incremental)) {
        var mergedData = mergeIncrementalData(this.getDiff().result, result2);
        result2.data = mergedData;
      } else if ("hasNext" in result2 && result2.hasNext) {
        var diff = this.getDiff();
        result2.data = merger.merge(diff.result, result2.data);
      }
      this.graphQLErrors = graphQLErrors;
      if (options.fetchPolicy === "no-cache") {
        this.updateLastDiff({ result: result2.data, complete: true }, this.getDiffOptions(options.variables));
      } else if (cacheWriteBehavior !== 0) {
        if (shouldWriteResult(result2, options.errorPolicy)) {
          this.cache.performTransaction(function(cache2) {
            if (_this.shouldWrite(result2, options.variables)) {
              cache2.writeQuery({
                query: document2,
                data: result2.data,
                variables: options.variables,
                overwrite: cacheWriteBehavior === 1
              });
              _this.lastWrite = {
                result: result2,
                variables: options.variables,
                dmCount: destructiveMethodCounts.get(_this.cache)
              };
            } else {
              if (_this.lastDiff && _this.lastDiff.diff.complete) {
                result2.data = _this.lastDiff.diff.result;
                return;
              }
            }
            var diffOptions = _this.getDiffOptions(options.variables);
            var diff2 = cache2.diff(diffOptions);
            if (!_this.stopped && equal(_this.variables, options.variables)) {
              _this.updateWatch(options.variables);
            }
            _this.updateLastDiff(diff2, diffOptions);
            if (diff2.complete) {
              result2.data = diff2.result;
            }
          });
        } else {
          this.lastWrite = void 0;
        }
      }
    };
    QueryInfo2.prototype.markReady = function() {
      this.networkError = null;
      return this.networkStatus = NetworkStatus.ready;
    };
    QueryInfo2.prototype.markError = function(error) {
      this.networkStatus = NetworkStatus.error;
      this.lastWrite = void 0;
      this.reset();
      if (error.graphQLErrors) {
        this.graphQLErrors = error.graphQLErrors;
      }
      if (error.networkError) {
        this.networkError = error.networkError;
      }
      return error;
    };
    return QueryInfo2;
  }()
);
function shouldWriteResult(result2, errorPolicy) {
  if (errorPolicy === void 0) {
    errorPolicy = "none";
  }
  var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  var writeWithErrors = !graphQLResultHasError(result2);
  if (!writeWithErrors && ignoreErrors && result2.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}

// node_modules/@apollo/client/core/QueryManager.js
var hasOwnProperty7 = Object.prototype.hasOwnProperty;
var IGNORE = /* @__PURE__ */ Object.create(null);
var QueryManager = (
  /** @class */
  function() {
    function QueryManager2(options) {
      var _this = this;
      this.clientAwareness = {};
      this.queries = /* @__PURE__ */ new Map();
      this.fetchCancelFns = /* @__PURE__ */ new Map();
      this.transformCache = new AutoCleanedWeakCache(
        cacheSizes["queryManager.getDocumentInfo"] || 2e3
        /* defaultCacheSizes["queryManager.getDocumentInfo"] */
      );
      this.queryIdCounter = 1;
      this.requestIdCounter = 1;
      this.mutationIdCounter = 1;
      this.inFlightLinkObservables = new Trie(false);
      this.noCacheWarningsByQueryId = /* @__PURE__ */ new Set();
      var defaultDocumentTransform = new DocumentTransform(
        function(document2) {
          return _this.cache.transformDocument(document2);
        },
        // Allow the apollo cache to manage its own transform caches
        { cache: false }
      );
      this.cache = options.cache;
      this.link = options.link;
      this.defaultOptions = options.defaultOptions;
      this.queryDeduplication = options.queryDeduplication;
      this.clientAwareness = options.clientAwareness;
      this.localState = options.localState;
      this.ssrMode = options.ssrMode;
      this.assumeImmutableResults = options.assumeImmutableResults;
      this.dataMasking = options.dataMasking;
      var documentTransform = options.documentTransform;
      this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
      this.defaultContext = options.defaultContext || /* @__PURE__ */ Object.create(null);
      if (this.onBroadcast = options.onBroadcast) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
    }
    QueryManager2.prototype.stop = function() {
      var _this = this;
      this.queries.forEach(function(_info, queryId) {
        _this.stopQueryNoBroadcast(queryId);
      });
      this.cancelPendingFetches(newInvariantError(27));
    };
    QueryManager2.prototype.cancelPendingFetches = function(error) {
      this.fetchCancelFns.forEach(function(cancel) {
        return cancel(error);
      });
      this.fetchCancelFns.clear();
    };
    QueryManager2.prototype.mutate = function(_a2) {
      return __awaiter(this, arguments, void 0, function(_b) {
        var mutationId, hasClientExports2, mutationStoreValue, isOptimistic, self2;
        var _c, _d;
        var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || "network-only" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b.keepRootFields, context = _b.context;
        return __generator(this, function(_j) {
          switch (_j.label) {
            case 0:
              invariant2(mutation, 28);
              invariant2(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 29);
              mutationId = this.generateMutationId();
              mutation = this.cache.transformForLink(this.transform(mutation));
              hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;
              variables = this.getVariables(mutation, variables);
              if (!hasClientExports2) return [3, 2];
              return [4, this.localState.addExportedVariables(mutation, variables, context)];
            case 1:
              variables = _j.sent();
              _j.label = 2;
            case 2:
              mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                mutation,
                variables,
                loading: true,
                error: null
              });
              isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                mutationId,
                document: mutation,
                variables,
                fetchPolicy,
                errorPolicy,
                context,
                updateQueries,
                update: updateWithProxyFn,
                keepRootFields
              });
              this.broadcastQueries();
              self2 = this;
              return [2, new Promise(function(resolve, reject) {
                return asyncMap(self2.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function(result2) {
                  if (graphQLResultHasError(result2) && errorPolicy === "none") {
                    throw new ApolloError({
                      graphQLErrors: getGraphQLErrorsFromResult(result2)
                    });
                  }
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = null;
                  }
                  var storeResult = __assign({}, result2);
                  if (typeof refetchQueries === "function") {
                    refetchQueries = refetchQueries(storeResult);
                  }
                  if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                    delete storeResult.errors;
                  }
                  return self2.markMutationResult({
                    mutationId,
                    result: storeResult,
                    document: mutation,
                    variables,
                    fetchPolicy,
                    errorPolicy,
                    context,
                    update: updateWithProxyFn,
                    updateQueries,
                    awaitRefetchQueries,
                    refetchQueries,
                    removeOptimistic: isOptimistic ? mutationId : void 0,
                    onQueryUpdated,
                    keepRootFields
                  });
                }).subscribe({
                  next: function(storeResult) {
                    self2.broadcastQueries();
                    if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                      resolve(__assign(__assign({}, storeResult), { data: self2.maskOperation({
                        document: mutation,
                        data: storeResult.data,
                        fetchPolicy,
                        id: mutationId
                      }) }));
                    }
                  },
                  error: function(err) {
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = err;
                    }
                    if (isOptimistic) {
                      self2.cache.removeOptimistic(mutationId);
                    }
                    self2.broadcastQueries();
                    reject(err instanceof ApolloError ? err : new ApolloError({
                      networkError: err
                    }));
                  }
                });
              })];
          }
        });
      });
    };
    QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
      var _this = this;
      if (cache2 === void 0) {
        cache2 = this.cache;
      }
      var result2 = mutation.result;
      var cacheWrites = [];
      var skipCache = mutation.fetchPolicy === "no-cache";
      if (!skipCache && shouldWriteResult(result2, mutation.errorPolicy)) {
        if (!isExecutionPatchIncrementalResult(result2)) {
          cacheWrites.push({
            result: result2.data,
            dataId: "ROOT_MUTATION",
            query: mutation.document,
            variables: mutation.variables
          });
        }
        if (isExecutionPatchIncrementalResult(result2) && isNonEmptyArray(result2.incremental)) {
          var diff = cache2.diff({
            id: "ROOT_MUTATION",
            // The cache complains if passed a mutation where it expects a
            // query, so we transform mutations and subscriptions to queries
            // (only once, thanks to this.transformCache).
            query: this.getDocumentInfo(mutation.document).asQuery,
            variables: mutation.variables,
            optimistic: false,
            returnPartialData: true
          });
          var mergedData = void 0;
          if (diff.result) {
            mergedData = mergeIncrementalData(diff.result, result2);
          }
          if (typeof mergedData !== "undefined") {
            result2.data = mergedData;
            cacheWrites.push({
              result: mergedData,
              dataId: "ROOT_MUTATION",
              query: mutation.document,
              variables: mutation.variables
            });
          }
        }
        var updateQueries_1 = mutation.updateQueries;
        if (updateQueries_1) {
          this.queries.forEach(function(_a2, queryId) {
            var observableQuery = _a2.observableQuery;
            var queryName = observableQuery && observableQuery.queryName;
            if (!queryName || !hasOwnProperty7.call(updateQueries_1, queryName)) {
              return;
            }
            var updater = updateQueries_1[queryName];
            var _b = _this.queries.get(queryId), document2 = _b.document, variables = _b.variables;
            var _c = cache2.diff({
              query: document2,
              variables,
              returnPartialData: true,
              optimistic: false
            }), currentQueryResult = _c.result, complete = _c.complete;
            if (complete && currentQueryResult) {
              var nextQueryResult = updater(currentQueryResult, {
                mutationResult: result2,
                queryName: document2 && getOperationName(document2) || void 0,
                queryVariables: variables
              });
              if (nextQueryResult) {
                cacheWrites.push({
                  result: nextQueryResult,
                  dataId: "ROOT_QUERY",
                  query: document2,
                  variables
                });
              }
            }
          });
        }
      }
      if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
        var results_1 = [];
        this.refetchQueries({
          updateCache: function(cache3) {
            if (!skipCache) {
              cacheWrites.forEach(function(write) {
                return cache3.write(write);
              });
            }
            var update = mutation.update;
            var isFinalResult = !isExecutionPatchResult(result2) || isExecutionPatchIncrementalResult(result2) && !result2.hasNext;
            if (update) {
              if (!skipCache) {
                var diff2 = cache3.diff({
                  id: "ROOT_MUTATION",
                  // The cache complains if passed a mutation where it expects a
                  // query, so we transform mutations and subscriptions to queries
                  // (only once, thanks to this.transformCache).
                  query: _this.getDocumentInfo(mutation.document).asQuery,
                  variables: mutation.variables,
                  optimistic: false,
                  returnPartialData: true
                });
                if (diff2.complete) {
                  result2 = __assign(__assign({}, result2), { data: diff2.result });
                  if ("incremental" in result2) {
                    delete result2.incremental;
                  }
                  if ("hasNext" in result2) {
                    delete result2.hasNext;
                  }
                }
              }
              if (isFinalResult) {
                update(cache3, result2, {
                  context: mutation.context,
                  variables: mutation.variables
                });
              }
            }
            if (!skipCache && !mutation.keepRootFields && isFinalResult) {
              cache3.modify({
                id: "ROOT_MUTATION",
                fields: function(value, _a2) {
                  var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                  return fieldName === "__typename" ? value : DELETE2;
                }
              });
            }
          },
          include: mutation.refetchQueries,
          // Write the final mutation.result to the root layer of the cache.
          optimistic: false,
          // Remove the corresponding optimistic layer at the same time as we
          // write the final non-optimistic result.
          removeOptimistic: mutation.removeOptimistic,
          // Let the caller of client.mutate optionally determine the refetching
          // behavior for watched queries after the mutation.update function runs.
          // If no onQueryUpdated function was provided for this mutation, pass
          // null instead of undefined to disable the default refetching behavior.
          onQueryUpdated: mutation.onQueryUpdated || null
        }).forEach(function(result3) {
          return results_1.push(result3);
        });
        if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
          return Promise.all(results_1).then(function() {
            return result2;
          });
        }
      }
      return Promise.resolve(result2);
    };
    QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
      var _this = this;
      var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE }) : optimisticResponse;
      if (data === IGNORE) {
        return false;
      }
      this.cache.recordOptimisticTransaction(function(cache2) {
        try {
          _this.markMutationResult(__assign(__assign({}, mutation), { result: { data } }), cache2);
        } catch (error) {
          globalThis.__DEV__ !== false && invariant2.error(error);
        }
      }, mutation.mutationId);
      return true;
    };
    QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
      return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;
    };
    QueryManager2.prototype.getQueryStore = function() {
      var store = /* @__PURE__ */ Object.create(null);
      this.queries.forEach(function(info, queryId) {
        store[queryId] = {
          variables: info.variables,
          networkStatus: info.networkStatus,
          networkError: info.networkError,
          graphQLErrors: info.graphQLErrors
        };
      });
      return store;
    };
    QueryManager2.prototype.resetErrors = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo) {
        queryInfo.networkError = void 0;
        queryInfo.graphQLErrors = [];
      }
    };
    QueryManager2.prototype.transform = function(document2) {
      return this.documentTransform.transformDocument(document2);
    };
    QueryManager2.prototype.getDocumentInfo = function(document2) {
      var transformCache = this.transformCache;
      if (!transformCache.has(document2)) {
        var cacheEntry = {
          // TODO These three calls (hasClientExports, shouldForceResolvers, and
          // usesNonreactiveDirective) are performing independent full traversals
          // of the transformed document. We should consider merging these
          // traversals into a single pass in the future, though the work is
          // cached after the first time.
          hasClientExports: hasClientExports(document2),
          hasForcedResolvers: this.localState.shouldForceResolvers(document2),
          hasNonreactiveDirective: hasDirectives(["nonreactive"], document2),
          nonReactiveQuery: addNonReactiveToNamedFragments(document2),
          clientQuery: this.localState.clientQuery(document2),
          serverQuery: removeDirectivesFromDocument([
            { name: "client", remove: true },
            { name: "connection" },
            { name: "nonreactive" },
            { name: "unmask" }
          ], document2),
          defaultVars: getDefaultValues(getOperationDefinition(document2)),
          // Transform any mutation or subscription operations to query operations
          // so we can read/write them from/to the cache.
          asQuery: __assign(__assign({}, document2), { definitions: document2.definitions.map(function(def) {
            if (def.kind === "OperationDefinition" && def.operation !== "query") {
              return __assign(__assign({}, def), { operation: "query" });
            }
            return def;
          }) })
        };
        transformCache.set(document2, cacheEntry);
      }
      return transformCache.get(document2);
    };
    QueryManager2.prototype.getVariables = function(document2, variables) {
      return __assign(__assign({}, this.getDocumentInfo(document2).defaultVars), variables);
    };
    QueryManager2.prototype.watchQuery = function(options) {
      var query = this.transform(options.query);
      options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });
      if (typeof options.notifyOnNetworkStatusChange === "undefined") {
        options.notifyOnNetworkStatusChange = false;
      }
      var queryInfo = new QueryInfo(this);
      var observable = new ObservableQuery({
        queryManager: this,
        queryInfo,
        options
      });
      observable["lastQuery"] = query;
      this.queries.set(observable.queryId, queryInfo);
      queryInfo.init({
        document: query,
        observableQuery: observable,
        variables: observable.variables
      });
      return observable;
    };
    QueryManager2.prototype.query = function(options, queryId) {
      var _this = this;
      if (queryId === void 0) {
        queryId = this.generateQueryId();
      }
      invariant2(options.query, 30);
      invariant2(options.query.kind === "Document", 31);
      invariant2(!options.returnPartialData, 32);
      invariant2(!options.pollInterval, 33);
      var query = this.transform(options.query);
      return this.fetchQuery(queryId, __assign(__assign({}, options), { query })).then(function(result2) {
        return result2 && __assign(__assign({}, result2), { data: _this.maskOperation({
          document: query,
          data: result2.data,
          fetchPolicy: options.fetchPolicy,
          id: queryId
        }) });
      }).finally(function() {
        return _this.stopQuery(queryId);
      });
    };
    QueryManager2.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    };
    QueryManager2.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    };
    QueryManager2.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    };
    QueryManager2.prototype.stopQueryInStore = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo)
        queryInfo.stop();
    };
    QueryManager2.prototype.clearStore = function(options) {
      if (options === void 0) {
        options = {
          discardWatches: true
        };
      }
      this.cancelPendingFetches(newInvariantError(34));
      this.queries.forEach(function(queryInfo) {
        if (queryInfo.observableQuery) {
          queryInfo.networkStatus = NetworkStatus.loading;
        } else {
          queryInfo.stop();
        }
      });
      if (this.mutationStore) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
      return this.cache.reset(options);
    };
    QueryManager2.prototype.getObservableQueries = function(include) {
      var _this = this;
      if (include === void 0) {
        include = "active";
      }
      var queries = /* @__PURE__ */ new Map();
      var queryNamesAndDocs = /* @__PURE__ */ new Map();
      var legacyQueryOptions = /* @__PURE__ */ new Set();
      if (Array.isArray(include)) {
        include.forEach(function(desc) {
          if (typeof desc === "string") {
            queryNamesAndDocs.set(desc, false);
          } else if (isDocumentNode(desc)) {
            queryNamesAndDocs.set(_this.transform(desc), false);
          } else if (isNonNullObject(desc) && desc.query) {
            legacyQueryOptions.add(desc);
          }
        });
      }
      this.queries.forEach(function(_a2, queryId) {
        var oq = _a2.observableQuery, document2 = _a2.document;
        if (oq) {
          if (include === "all") {
            queries.set(queryId, oq);
            return;
          }
          var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
          if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
            return;
          }
          if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document2 && queryNamesAndDocs.has(document2)) {
            queries.set(queryId, oq);
            if (queryName)
              queryNamesAndDocs.set(queryName, true);
            if (document2)
              queryNamesAndDocs.set(document2, true);
          }
        }
      });
      if (legacyQueryOptions.size) {
        legacyQueryOptions.forEach(function(options) {
          var queryId = makeUniqueId("legacyOneTimeQuery");
          var queryInfo = _this.getQuery(queryId).init({
            document: options.query,
            variables: options.variables
          });
          var oq = new ObservableQuery({
            queryManager: _this,
            queryInfo,
            options: __assign(__assign({}, options), { fetchPolicy: "network-only" })
          });
          invariant2(oq.queryId === queryId);
          queryInfo.setObservableQuery(oq);
          queries.set(queryId, oq);
        });
      }
      if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {
        queryNamesAndDocs.forEach(function(included, nameOrDoc) {
          if (!included) {
            globalThis.__DEV__ !== false && invariant2.warn(typeof nameOrDoc === "string" ? 35 : 36, nameOrDoc);
          }
        });
      }
      return queries;
    };
    QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
      var _this = this;
      if (includeStandby === void 0) {
        includeStandby = false;
      }
      var observableQueryPromises = [];
      this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
        var fetchPolicy = observableQuery.options.fetchPolicy;
        observableQuery.resetLastResults();
        if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
          observableQueryPromises.push(observableQuery.refetch());
        }
        _this.getQuery(queryId).setDiff(null);
      });
      this.broadcastQueries();
      return Promise.all(observableQueryPromises);
    };
    QueryManager2.prototype.setObservableQuery = function(observableQuery) {
      this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
    };
    QueryManager2.prototype.startGraphQLSubscription = function(options) {
      var _this = this;
      var query = options.query, variables = options.variables;
      var fetchPolicy = options.fetchPolicy, _a2 = options.errorPolicy, errorPolicy = _a2 === void 0 ? "none" : _a2, _b = options.context, context = _b === void 0 ? {} : _b, _c = options.extensions, extensions = _c === void 0 ? {} : _c;
      query = this.transform(query);
      variables = this.getVariables(query, variables);
      var makeObservable = function(variables2) {
        return _this.getObservableFromLink(query, context, variables2, extensions).map(function(result2) {
          if (fetchPolicy !== "no-cache") {
            if (shouldWriteResult(result2, errorPolicy)) {
              _this.cache.write({
                query,
                result: result2.data,
                dataId: "ROOT_SUBSCRIPTION",
                variables: variables2
              });
            }
            _this.broadcastQueries();
          }
          var hasErrors = graphQLResultHasError(result2);
          var hasProtocolErrors = graphQLResultHasProtocolErrors(result2);
          if (hasErrors || hasProtocolErrors) {
            var errors = {};
            if (hasErrors) {
              errors.graphQLErrors = result2.errors;
            }
            if (hasProtocolErrors) {
              errors.protocolErrors = result2.extensions[PROTOCOL_ERRORS_SYMBOL];
            }
            if (errorPolicy === "none" || hasProtocolErrors) {
              throw new ApolloError(errors);
            }
          }
          if (errorPolicy === "ignore") {
            delete result2.errors;
          }
          return result2;
        });
      };
      if (this.getDocumentInfo(query).hasClientExports) {
        var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
        return new Observable(function(observer) {
          var sub = null;
          observablePromise_1.then(function(observable) {
            return sub = observable.subscribe(observer);
          }, observer.error);
          return function() {
            return sub && sub.unsubscribe();
          };
        });
      }
      return makeObservable(variables);
    };
    QueryManager2.prototype.stopQuery = function(queryId) {
      this.stopQueryNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.removeQuery(queryId);
    };
    QueryManager2.prototype.removeQuery = function(queryId) {
      this.fetchCancelFns.delete(queryId);
      if (this.queries.has(queryId)) {
        this.getQuery(queryId).stop();
        this.queries.delete(queryId);
      }
    };
    QueryManager2.prototype.broadcastQueries = function() {
      if (this.onBroadcast)
        this.onBroadcast();
      this.queries.forEach(function(info) {
        return info.notify();
      });
    };
    QueryManager2.prototype.getLocalState = function() {
      return this.localState;
    };
    QueryManager2.prototype.getObservableFromLink = function(query, context, variables, extensions, deduplication) {
      var _this = this;
      var _a2;
      if (deduplication === void 0) {
        deduplication = (_a2 = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
      }
      var observable;
      var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;
      if (serverQuery) {
        var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;
        var operation = {
          query: serverQuery,
          variables,
          operationName: getOperationName(serverQuery) || void 0,
          context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),
          extensions
        };
        context = operation.context;
        if (deduplication) {
          var printedServerQuery_1 = print2(serverQuery);
          var varJson_1 = canonicalStringify(variables);
          var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
          observable = entry.observable;
          if (!observable) {
            var concast = new Concast([
              execute(link, operation)
            ]);
            observable = entry.observable = concast;
            concast.beforeNext(function() {
              inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
            });
          }
        } else {
          observable = new Concast([
            execute(link, operation)
          ]);
        }
      } else {
        observable = new Concast([Observable.of({ data: {} })]);
        context = this.prepareContext(context);
      }
      if (clientQuery) {
        observable = asyncMap(observable, function(result2) {
          return _this.localState.runResolvers({
            document: clientQuery,
            remoteResult: result2,
            context,
            variables
          });
        });
      }
      return observable;
    };
    QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
      var requestId = queryInfo.lastRequestId = this.generateRequestId();
      var linkDocument = this.cache.transformForLink(options.query);
      return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result2) {
        var graphQLErrors = getGraphQLErrorsFromResult(result2);
        var hasErrors = graphQLErrors.length > 0;
        var errorPolicy = options.errorPolicy;
        if (requestId >= queryInfo.lastRequestId) {
          if (hasErrors && errorPolicy === "none") {
            throw queryInfo.markError(new ApolloError({
              graphQLErrors
            }));
          }
          queryInfo.markResult(result2, linkDocument, options, cacheWriteBehavior);
          queryInfo.markReady();
        }
        var aqr = {
          data: result2.data,
          loading: false,
          networkStatus: NetworkStatus.ready
        };
        if (hasErrors && errorPolicy === "none") {
          aqr.data = void 0;
        }
        if (hasErrors && errorPolicy !== "ignore") {
          aqr.errors = graphQLErrors;
          aqr.networkStatus = NetworkStatus.error;
        }
        return aqr;
      }, function(networkError) {
        var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
        if (requestId >= queryInfo.lastRequestId) {
          queryInfo.markError(error);
        }
        throw error;
      });
    };
    QueryManager2.prototype.fetchConcastWithInfo = function(queryId, options, networkStatus, query) {
      var _this = this;
      if (networkStatus === void 0) {
        networkStatus = NetworkStatus.loading;
      }
      if (query === void 0) {
        query = options.query;
      }
      var variables = this.getVariables(query, options.variables);
      var queryInfo = this.getQuery(queryId);
      var defaults = this.defaultOptions.watchQuery;
      var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a2, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;
      var normalized = Object.assign({}, options, {
        query,
        variables,
        fetchPolicy,
        errorPolicy,
        returnPartialData,
        notifyOnNetworkStatusChange,
        context
      });
      var fromVariables = function(variables2) {
        normalized.variables = variables2;
        var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
        if (
          // If we're in standby, postpone advancing options.fetchPolicy using
          // applyNextFetchPolicy.
          normalized.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
          // this is another way to detect when nothing was done/fetched.
          sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery
        ) {
          queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
        }
        return sourcesWithInfo2;
      };
      var cleanupCancelFn = function() {
        return _this.fetchCancelFns.delete(queryId);
      };
      this.fetchCancelFns.set(queryId, function(reason) {
        cleanupCancelFn();
        setTimeout(function() {
          return concast.cancel(reason);
        });
      });
      var concast, containsDataFromLink;
      if (this.getDocumentInfo(normalized.query).hasClientExports) {
        concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
          return sourcesWithInfo2.sources;
        }));
        containsDataFromLink = true;
      } else {
        var sourcesWithInfo = fromVariables(normalized.variables);
        containsDataFromLink = sourcesWithInfo.fromLink;
        concast = new Concast(sourcesWithInfo.sources);
      }
      concast.promise.then(cleanupCancelFn, cleanupCancelFn);
      return {
        concast,
        fromLink: containsDataFromLink
      };
    };
    QueryManager2.prototype.refetchQueries = function(_a2) {
      var _this = this;
      var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
      var includedQueriesById = /* @__PURE__ */ new Map();
      if (include) {
        this.getObservableQueries(include).forEach(function(oq, queryId) {
          includedQueriesById.set(queryId, {
            oq,
            lastDiff: _this.getQuery(queryId).getDiff()
          });
        });
      }
      var results = /* @__PURE__ */ new Map();
      if (updateCache) {
        this.cache.batch({
          update: updateCache,
          // Since you can perform any combination of cache reads and/or writes in
          // the cache.batch update function, its optimistic option can be either
          // a boolean or a string, representing three distinct modes of
          // operation:
          //
          // * false: read/write only the root layer
          // * true: read/write the topmost layer
          // * string: read/write a fresh optimistic layer with that ID string
          //
          // When typeof optimistic === "string", a new optimistic layer will be
          // temporarily created within cache.batch with that string as its ID. If
          // we then pass that same string as the removeOptimistic option, we can
          // make cache.batch immediately remove the optimistic layer after
          // running the updateCache function, triggering only one broadcast.
          //
          // However, the refetchQueries method accepts only true or false for its
          // optimistic option (not string). We interpret true to mean a temporary
          // optimistic layer should be created, to allow efficiently rolling back
          // the effect of the updateCache function, which involves passing a
          // string instead of true as the optimistic option to cache.batch, when
          // refetchQueries receives optimistic: true.
          //
          // In other words, we are deliberately not supporting the use case of
          // writing to an *existing* optimistic layer (using the refetchQueries
          // updateCache function), since that would potentially interfere with
          // other optimistic updates in progress. Instead, you can read/write
          // only the root layer by passing optimistic: false to refetchQueries,
          // or you can read/write a brand new optimistic layer that will be
          // automatically removed by passing optimistic: true.
          optimistic: optimistic && removeOptimistic || false,
          // The removeOptimistic option can also be provided by itself, even if
          // optimistic === false, to remove some previously-added optimistic
          // layer safely and efficiently, like we do in markMutationResult.
          //
          // If an explicit removeOptimistic string is provided with optimistic:
          // true, the removeOptimistic string will determine the ID of the
          // temporary optimistic layer, in case that ever matters.
          removeOptimistic,
          onWatchUpdated: function(watch, diff, lastDiff) {
            var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
            if (oq) {
              if (onQueryUpdated) {
                includedQueriesById.delete(oq.queryId);
                var result2 = onQueryUpdated(oq, diff, lastDiff);
                if (result2 === true) {
                  result2 = oq.refetch();
                }
                if (result2 !== false) {
                  results.set(oq, result2);
                }
                return result2;
              }
              if (onQueryUpdated !== null) {
                includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
              }
            }
          }
        });
      }
      if (includedQueriesById.size) {
        includedQueriesById.forEach(function(_a3, queryId) {
          var oq = _a3.oq, lastDiff = _a3.lastDiff, diff = _a3.diff;
          var result2;
          if (onQueryUpdated) {
            if (!diff) {
              var info = oq["queryInfo"];
              info.reset();
              diff = info.getDiff();
            }
            result2 = onQueryUpdated(oq, diff, lastDiff);
          }
          if (!onQueryUpdated || result2 === true) {
            result2 = oq.refetch();
          }
          if (result2 !== false) {
            results.set(oq, result2);
          }
          if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
            _this.stopQueryNoBroadcast(queryId);
          }
        });
      }
      if (removeOptimistic) {
        this.cache.removeOptimistic(removeOptimistic);
      }
      return results;
    };
    QueryManager2.prototype.maskOperation = function(options) {
      var _a2, _b, _c;
      var document2 = options.document, data = options.data;
      if (globalThis.__DEV__ !== false) {
        var fetchPolicy = options.fetchPolicy, id = options.id;
        var operationType = (_a2 = getOperationDefinition(document2)) === null || _a2 === void 0 ? void 0 : _a2.operation;
        var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : "o") + id;
        if (this.dataMasking && fetchPolicy === "no-cache" && !isFullyUnmaskedOperation(document2) && !this.noCacheWarningsByQueryId.has(operationId)) {
          this.noCacheWarningsByQueryId.add(operationId);
          globalThis.__DEV__ !== false && invariant2.warn(
            37,
            (_c = getOperationName(document2)) !== null && _c !== void 0 ? _c : "Unnamed ".concat(operationType !== null && operationType !== void 0 ? operationType : "operation")
          );
        }
      }
      return this.dataMasking ? maskOperation(data, document2, this.cache) : data;
    };
    QueryManager2.prototype.maskFragment = function(options) {
      var data = options.data, fragment = options.fragment, fragmentName = options.fragmentName;
      return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;
    };
    QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
      var _this = this;
      var query = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
      var oldNetworkStatus = queryInfo.networkStatus;
      queryInfo.init({
        document: query,
        variables,
        networkStatus
      });
      var readCache = function() {
        return queryInfo.getDiff();
      };
      var resultsFromCache = function(diff2, networkStatus2) {
        if (networkStatus2 === void 0) {
          networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
        }
        var data = diff2.result;
        if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {
          logMissingFieldErrors(diff2.missing);
        }
        var fromData = function(data2) {
          return Observable.of(__assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
        };
        if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
          return _this.localState.runResolvers({
            document: query,
            remoteResult: { data },
            context,
            variables,
            onlyRunForcedResolvers: true
          }).then(function(resolved) {
            return fromData(resolved.data || void 0);
          });
        }
        if (errorPolicy === "none" && networkStatus2 === NetworkStatus.refetch && Array.isArray(diff2.missing)) {
          return fromData(void 0);
        }
        return fromData(data);
      };
      var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
      var resultsFromLink = function() {
        return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
          query,
          variables,
          context,
          fetchPolicy,
          errorPolicy
        });
      };
      var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
      switch (fetchPolicy) {
        default:
        case "cache-first": {
          var diff = readCache();
          if (diff.complete) {
            return {
              fromLink: false,
              sources: [resultsFromCache(diff, queryInfo.markReady())]
            };
          }
          if (returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-and-network": {
          var diff = readCache();
          if (diff.complete || returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-only":
          return {
            fromLink: false,
            sources: [resultsFromCache(readCache(), queryInfo.markReady())]
          };
        case "network-only":
          if (shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(readCache()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "no-cache":
          if (shouldNotify) {
            return {
              fromLink: true,
              // Note that queryInfo.getDiff() for no-cache queries does not call
              // cache.diff, but instead returns a { complete: false } stub result
              // when there is no queryInfo.diff already defined.
              sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "standby":
          return { fromLink: false, sources: [] };
      }
    };
    QueryManager2.prototype.getQuery = function(queryId) {
      if (queryId && !this.queries.has(queryId)) {
        this.queries.set(queryId, new QueryInfo(this, queryId));
      }
      return this.queries.get(queryId);
    };
    QueryManager2.prototype.prepareContext = function(context) {
      if (context === void 0) {
        context = {};
      }
      var newContext = this.localState.prepareContext(context);
      return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });
    };
    return QueryManager2;
  }()
);

// node_modules/@apollo/client/core/LocalState.js
var import_dist691 = __toESM(require_dist(), 1);
var import_dist692 = __toESM(require_dist2(), 1);
var import_dist693 = __toESM(require_dist3(), 1);
var LocalState = (
  /** @class */
  function() {
    function LocalState2(_a2) {
      var cache2 = _a2.cache, client = _a2.client, resolvers = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
      this.cache = cache2;
      if (client) {
        this.client = client;
      }
      if (resolvers) {
        this.addResolvers(resolvers);
      }
      if (fragmentMatcher) {
        this.setFragmentMatcher(fragmentMatcher);
      }
    }
    LocalState2.prototype.addResolvers = function(resolvers) {
      var _this = this;
      this.resolvers = this.resolvers || {};
      if (Array.isArray(resolvers)) {
        resolvers.forEach(function(resolverGroup) {
          _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
        });
      } else {
        this.resolvers = mergeDeep(this.resolvers, resolvers);
      }
    };
    LocalState2.prototype.setResolvers = function(resolvers) {
      this.resolvers = {};
      this.addResolvers(resolvers);
    };
    LocalState2.prototype.getResolvers = function() {
      return this.resolvers || {};
    };
    LocalState2.prototype.runResolvers = function(_a2) {
      return __awaiter(this, arguments, void 0, function(_b) {
        var document2 = _b.document, remoteResult = _b.remoteResult, context = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;
        return __generator(this, function(_d) {
          if (document2) {
            return [2, this.resolveDocument(document2, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
              return __assign(__assign({}, remoteResult), { data: localResult.result });
            })];
          }
          return [2, remoteResult];
        });
      });
    };
    LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
      this.fragmentMatcher = fragmentMatcher;
    };
    LocalState2.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    };
    LocalState2.prototype.clientQuery = function(document2) {
      if (hasDirectives(["client"], document2)) {
        if (this.resolvers) {
          return document2;
        }
      }
      return null;
    };
    LocalState2.prototype.serverQuery = function(document2) {
      return removeClientSetsFromDocument(document2);
    };
    LocalState2.prototype.prepareContext = function(context) {
      var cache2 = this.cache;
      return __assign(__assign({}, context), {
        cache: cache2,
        // Getting an entry's cache key is useful for local state resolvers.
        getCacheKey: function(obj) {
          return cache2.identify(obj);
        }
      });
    };
    LocalState2.prototype.addExportedVariables = function(document_1) {
      return __awaiter(this, arguments, void 0, function(document2, variables, context) {
        if (variables === void 0) {
          variables = {};
        }
        if (context === void 0) {
          context = {};
        }
        return __generator(this, function(_a2) {
          if (document2) {
            return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context), variables).then(function(data) {
              return __assign(__assign({}, variables), data.exportedVariables);
            })];
          }
          return [2, __assign({}, variables)];
        });
      });
    };
    LocalState2.prototype.shouldForceResolvers = function(document2) {
      var forceResolvers = false;
      visit(document2, {
        Directive: {
          enter: function(node) {
            if (node.name.value === "client" && node.arguments) {
              forceResolvers = node.arguments.some(function(arg) {
                return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
              });
              if (forceResolvers) {
                return BREAK;
              }
            }
          }
        }
      });
      return forceResolvers;
    };
    LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
      return this.cache.diff({
        query: buildQueryFromSelectionSet(document2),
        variables,
        returnPartialData: true,
        optimistic: false
      }).result;
    };
    LocalState2.prototype.resolveDocument = function(document_1, rootValue_1) {
      return __awaiter(this, arguments, void 0, function(document2, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
        var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a2, cache2, client, execContext, isClientFieldDescendant;
        if (context === void 0) {
          context = {};
        }
        if (variables === void 0) {
          variables = {};
        }
        if (fragmentMatcher === void 0) {
          fragmentMatcher = function() {
            return true;
          };
        }
        if (onlyRunForcedResolvers === void 0) {
          onlyRunForcedResolvers = false;
        }
        return __generator(this, function(_b) {
          mainDefinition = getMainDefinition(document2);
          fragments = getFragmentDefinitions(document2);
          fragmentMap = createFragmentMap(fragments);
          selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
          definitionOperation = mainDefinition.operation;
          defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
          _a2 = this, cache2 = _a2.cache, client = _a2.client;
          execContext = {
            fragmentMap,
            context: __assign(__assign({}, context), { cache: cache2, client }),
            variables,
            fragmentMatcher,
            defaultOperationType,
            exportedVariables: {},
            selectionsToResolve,
            onlyRunForcedResolvers
          };
          isClientFieldDescendant = false;
          return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result2) {
            return {
              result: result2,
              exportedVariables: execContext.exportedVariables
            };
          })];
        });
      });
    };
    LocalState2.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
      return __awaiter(this, void 0, void 0, function() {
        var fragmentMap, context, variables, resultsToMerge, execute2;
        var _this = this;
        return __generator(this, function(_a2) {
          fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
          resultsToMerge = [rootValue];
          execute2 = function(selection) {
            return __awaiter(_this, void 0, void 0, function() {
              var fragment, typeCondition;
              return __generator(this, function(_a3) {
                if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (!shouldInclude(selection, variables)) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (isField(selection)) {
                  return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                    var _a4;
                    if (typeof fieldResult !== "undefined") {
                      resultsToMerge.push((_a4 = {}, _a4[resultKeyNameFromField(selection)] = fieldResult, _a4));
                    }
                  })];
                }
                if (isInlineFragment(selection)) {
                  fragment = selection;
                } else {
                  fragment = fragmentMap[selection.name.value];
                  invariant2(fragment, 19, selection.name.value);
                }
                if (fragment && fragment.typeCondition) {
                  typeCondition = fragment.typeCondition.name.value;
                  if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                    return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                      resultsToMerge.push(fragmentResult);
                    })];
                  }
                }
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
            return mergeDeepArray(resultsToMerge);
          })];
        });
      });
    };
    LocalState2.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
      return __awaiter(this, void 0, void 0, function() {
        var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
        var _this = this;
        return __generator(this, function(_a2) {
          if (!rootValue) {
            return [2, null];
          }
          variables = execContext.variables;
          fieldName = field.name.value;
          aliasedFieldName = resultKeyNameFromField(field);
          aliasUsed = fieldName !== aliasedFieldName;
          defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
          resultPromise = Promise.resolve(defaultResult);
          if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
            resolverType = rootValue.__typename || execContext.defaultOperationType;
            resolverMap = this.resolvers && this.resolvers[resolverType];
            if (resolverMap) {
              resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
              if (resolve) {
                resultPromise = Promise.resolve(
                  // In case the resolve function accesses reactive variables,
                  // set cacheSlot to the current cache instance.
                  cacheSlot.withValue(this.cache, resolve, [
                    rootValue,
                    argumentsObjectFromField(field, variables),
                    execContext.context,
                    { field, fragmentMap: execContext.fragmentMap }
                  ])
                );
              }
            }
          }
          return [2, resultPromise.then(function(result2) {
            var _a3, _b;
            if (result2 === void 0) {
              result2 = defaultResult;
            }
            if (field.directives) {
              field.directives.forEach(function(directive) {
                if (directive.name.value === "export" && directive.arguments) {
                  directive.arguments.forEach(function(arg) {
                    if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                      execContext.exportedVariables[arg.value.value] = result2;
                    }
                  });
                }
              });
            }
            if (!field.selectionSet) {
              return result2;
            }
            if (result2 == null) {
              return result2;
            }
            var isClientField = (_b = (_a3 = field.directives) === null || _a3 === void 0 ? void 0 : _a3.some(function(d) {
              return d.name.value === "client";
            })) !== null && _b !== void 0 ? _b : false;
            if (Array.isArray(result2)) {
              return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result2, execContext);
            }
            if (field.selectionSet) {
              return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result2, execContext);
            }
          })];
        });
      });
    };
    LocalState2.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result2, execContext) {
      var _this = this;
      return Promise.all(result2.map(function(item) {
        if (item === null) {
          return null;
        }
        if (Array.isArray(item)) {
          return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
        }
        if (field.selectionSet) {
          return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
        }
      }));
    };
    LocalState2.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
      var isSingleASTNode = function(node) {
        return !Array.isArray(node);
      };
      var selectionsToResolveCache = this.selectionsToResolveCache;
      function collectByDefinition(definitionNode) {
        if (!selectionsToResolveCache.has(definitionNode)) {
          var matches_1 = /* @__PURE__ */ new Set();
          selectionsToResolveCache.set(definitionNode, matches_1);
          visit(definitionNode, {
            Directive: function(node, _, __, ___, ancestors) {
              if (node.name.value === "client") {
                ancestors.forEach(function(node2) {
                  if (isSingleASTNode(node2) && isSelectionNode(node2)) {
                    matches_1.add(node2);
                  }
                });
              }
            },
            FragmentSpread: function(spread, _, __, ___, ancestors) {
              var fragment = fragmentMap[spread.name.value];
              invariant2(fragment, 20, spread.name.value);
              var fragmentSelections = collectByDefinition(fragment);
              if (fragmentSelections.size > 0) {
                ancestors.forEach(function(node) {
                  if (isSingleASTNode(node) && isSelectionNode(node)) {
                    matches_1.add(node);
                  }
                });
                matches_1.add(spread);
                fragmentSelections.forEach(function(selection) {
                  matches_1.add(selection);
                });
              }
            }
          });
        }
        return selectionsToResolveCache.get(definitionNode);
      }
      return collectByDefinition(mainDefinition);
    };
    return LocalState2;
  }()
);

// node_modules/@apollo/client/core/ApolloClient.js
var hasSuggestedDevtools = false;
var ApolloClient = (
  /** @class */
  function() {
    function ApolloClient2(options) {
      var _this = this;
      var _a2;
      this.resetStoreCallbacks = [];
      this.clearStoreCallbacks = [];
      if (!options.cache) {
        throw newInvariantError(16);
      }
      var uri = options.uri, credentials = options.credentials, headers = options.headers, cache2 = options.cache, documentTransform = options.documentTransform, _b = options.ssrMode, ssrMode = _b === void 0 ? false : _b, _c = options.ssrForceFetchDelay, ssrForceFetchDelay = _c === void 0 ? 0 : _c, connectToDevTools = options.connectToDevTools, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions3 = options.defaultOptions, defaultContext = options.defaultContext, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? cache2.assumeImmutableResults : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version, devtools = options.devtools, dataMasking = options.dataMasking;
      var link = options.link;
      if (!link) {
        link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
      }
      this.link = link;
      this.cache = cache2;
      this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
      this.queryDeduplication = queryDeduplication;
      this.defaultOptions = defaultOptions3 || /* @__PURE__ */ Object.create(null);
      this.typeDefs = typeDefs;
      this.devtoolsConfig = __assign(__assign({}, devtools), { enabled: (_a2 = devtools === null || devtools === void 0 ? void 0 : devtools.enabled) !== null && _a2 !== void 0 ? _a2 : connectToDevTools });
      if (this.devtoolsConfig.enabled === void 0) {
        this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
      }
      if (ssrForceFetchDelay) {
        setTimeout(function() {
          return _this.disableNetworkFetches = false;
        }, ssrForceFetchDelay);
      }
      this.watchQuery = this.watchQuery.bind(this);
      this.query = this.query.bind(this);
      this.mutate = this.mutate.bind(this);
      this.watchFragment = this.watchFragment.bind(this);
      this.resetStore = this.resetStore.bind(this);
      this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
      this.version = version;
      this.localState = new LocalState({
        cache: cache2,
        client: this,
        resolvers,
        fragmentMatcher
      });
      this.queryManager = new QueryManager({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        defaultContext,
        documentTransform,
        queryDeduplication,
        ssrMode,
        dataMasking: !!dataMasking,
        clientAwareness: {
          name: clientAwarenessName,
          version: clientAwarenessVersion
        },
        localState: this.localState,
        assumeImmutableResults,
        onBroadcast: this.devtoolsConfig.enabled ? function() {
          if (_this.devToolsHookCb) {
            _this.devToolsHookCb({
              action: {},
              state: {
                queries: _this.queryManager.getQueryStore(),
                mutations: _this.queryManager.mutationStore || {}
              },
              dataWithOptimisticResults: _this.cache.extract(true)
            });
          }
        } : void 0
      });
      if (this.devtoolsConfig.enabled)
        this.connectToDevTools();
    }
    ApolloClient2.prototype.connectToDevTools = function() {
      if (typeof window === "undefined") {
        return;
      }
      var windowWithDevTools = window;
      var devtoolsSymbol = Symbol.for("apollo.devtools");
      (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
      windowWithDevTools.__APOLLO_CLIENT__ = this;
      if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {
        hasSuggestedDevtools = true;
        if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
          setTimeout(function() {
            if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
              var nav = window.navigator;
              var ua = nav && nav.userAgent;
              var url = void 0;
              if (typeof ua === "string") {
                if (ua.indexOf("Chrome/") > -1) {
                  url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                } else if (ua.indexOf("Firefox/") > -1) {
                  url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                }
              }
              if (url) {
                globalThis.__DEV__ !== false && invariant2.log("Download the Apollo DevTools for a better development experience: %s", url);
              }
            }
          }, 1e4);
        }
      }
    };
    Object.defineProperty(ApolloClient2.prototype, "documentTransform", {
      /**
       * The `DocumentTransform` used to modify GraphQL documents before a request
       * is made. If a custom `DocumentTransform` is not provided, this will be the
       * default document transform.
       */
      get: function() {
        return this.queryManager.documentTransform;
      },
      enumerable: false,
      configurable: true
    });
    ApolloClient2.prototype.stop = function() {
      this.queryManager.stop();
    };
    ApolloClient2.prototype.watchQuery = function(options) {
      if (this.defaultOptions.watchQuery) {
        options = mergeOptions(this.defaultOptions.watchQuery, options);
      }
      if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
        options = __assign(__assign({}, options), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.watchQuery(options);
    };
    ApolloClient2.prototype.query = function(options) {
      if (this.defaultOptions.query) {
        options = mergeOptions(this.defaultOptions.query, options);
      }
      invariant2(options.fetchPolicy !== "cache-and-network", 17);
      if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
        options = __assign(__assign({}, options), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.query(options);
    };
    ApolloClient2.prototype.mutate = function(options) {
      if (this.defaultOptions.mutate) {
        options = mergeOptions(this.defaultOptions.mutate, options);
      }
      return this.queryManager.mutate(options);
    };
    ApolloClient2.prototype.subscribe = function(options) {
      var _this = this;
      var id = this.queryManager.generateQueryId();
      return this.queryManager.startGraphQLSubscription(options).map(function(result2) {
        return __assign(__assign({}, result2), { data: _this.queryManager.maskOperation({
          document: options.query,
          data: result2.data,
          fetchPolicy: options.fetchPolicy,
          id
        }) });
      });
    };
    ApolloClient2.prototype.readQuery = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readQuery(options, optimistic);
    };
    ApolloClient2.prototype.watchFragment = function(options) {
      var _a2;
      return this.cache.watchFragment(__assign(__assign({}, options), (_a2 = {}, _a2[Symbol.for("apollo.dataMasking")] = this.queryManager.dataMasking, _a2)));
    };
    ApolloClient2.prototype.readFragment = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readFragment(options, optimistic);
    };
    ApolloClient2.prototype.writeQuery = function(options) {
      var ref = this.cache.writeQuery(options);
      if (options.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient2.prototype.writeFragment = function(options) {
      var ref = this.cache.writeFragment(options);
      if (options.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
      this.devToolsHookCb = cb;
    };
    ApolloClient2.prototype.__requestRaw = function(payload) {
      return execute(this.link, payload);
    };
    ApolloClient2.prototype.resetStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: false
        });
      }).then(function() {
        return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
          return fn();
        }));
      }).then(function() {
        return _this.reFetchObservableQueries();
      });
    };
    ApolloClient2.prototype.clearStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: true
        });
      }).then(function() {
        return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
          return fn();
        }));
      });
    };
    ApolloClient2.prototype.onResetStore = function(cb) {
      var _this = this;
      this.resetStoreCallbacks.push(cb);
      return function() {
        _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
          return c !== cb;
        });
      };
    };
    ApolloClient2.prototype.onClearStore = function(cb) {
      var _this = this;
      this.clearStoreCallbacks.push(cb);
      return function() {
        _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
          return c !== cb;
        });
      };
    };
    ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
      return this.queryManager.reFetchObservableQueries(includeStandby);
    };
    ApolloClient2.prototype.refetchQueries = function(options) {
      var map = this.queryManager.refetchQueries(options);
      var queries = [];
      var results = [];
      map.forEach(function(result3, obsQuery) {
        queries.push(obsQuery);
        results.push(result3);
      });
      var result2 = Promise.all(results);
      result2.queries = queries;
      result2.results = results;
      result2.catch(function(error) {
        globalThis.__DEV__ !== false && invariant2.debug(18, error);
      });
      return result2;
    };
    ApolloClient2.prototype.getObservableQueries = function(include) {
      if (include === void 0) {
        include = "active";
      }
      return this.queryManager.getObservableQueries(include);
    };
    ApolloClient2.prototype.extract = function(optimistic) {
      return this.cache.extract(optimistic);
    };
    ApolloClient2.prototype.restore = function(serializedState) {
      return this.cache.restore(serializedState);
    };
    ApolloClient2.prototype.addResolvers = function(resolvers) {
      this.localState.addResolvers(resolvers);
    };
    ApolloClient2.prototype.setResolvers = function(resolvers) {
      this.localState.setResolvers(resolvers);
    };
    ApolloClient2.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    };
    ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
      this.localState.setFragmentMatcher(fragmentMatcher);
    };
    ApolloClient2.prototype.setLink = function(newLink) {
      this.link = this.queryManager.link = newLink;
    };
    Object.defineProperty(ApolloClient2.prototype, "defaultContext", {
      get: function() {
        return this.queryManager.defaultContext;
      },
      enumerable: false,
      configurable: true
    });
    return ApolloClient2;
  }()
);
if (globalThis.__DEV__ !== false) {
  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;
}

// node_modules/@apollo/client/core/types.js
var import_dist697 = __toESM(require_dist(), 1);
var import_dist698 = __toESM(require_dist2(), 1);
var import_dist699 = __toESM(require_dist3(), 1);

// node_modules/graphql-tag/lib/index.js
var import_dist700 = __toESM(require_dist());
var import_dist701 = __toESM(require_dist2());
var import_dist702 = __toESM(require_dist3());
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize2(string) {
  return string.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize2(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize2(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result2 = literals[0];
  args.forEach(function(arg, i) {
    if (arg && arg.kind === "Document") {
      result2 += arg.loc.source.body;
    } else {
      result2 += arg;
    }
    result2 += literals[i + 1];
  });
  return parseDocument(result2);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;

// node_modules/@apollo/client/core/index.js
setVerbosity(globalThis.__DEV__ !== false ? "log" : "silent");

// node_modules/@apollo/client/react/index.js
var import_dist802 = __toESM(require_dist(), 1);
var import_dist803 = __toESM(require_dist2(), 1);
var import_dist804 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/react/context/index.js
var import_dist715 = __toESM(require_dist(), 1);
var import_dist716 = __toESM(require_dist2(), 1);
var import_dist717 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/react/context/ApolloConsumer.js
var import_dist709 = __toESM(require_dist(), 1);
var import_dist710 = __toESM(require_dist2(), 1);
var import_dist711 = __toESM(require_dist3(), 1);
var React36 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/context/ApolloContext.js
var import_dist706 = __toESM(require_dist(), 1);
var import_dist707 = __toESM(require_dist2(), 1);
var import_dist708 = __toESM(require_dist3(), 1);
var React35 = __toESM(require_rehackt(), 1);
var contextKey = canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";

// node_modules/@apollo/client/react/context/ApolloProvider.js
var import_dist712 = __toESM(require_dist(), 1);
var import_dist713 = __toESM(require_dist2(), 1);
var import_dist714 = __toESM(require_dist3(), 1);
var React37 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/index.js
var import_dist793 = __toESM(require_dist(), 1);
var import_dist794 = __toESM(require_dist2(), 1);
var import_dist795 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/react/hooks/useApolloClient.js
var import_dist718 = __toESM(require_dist(), 1);
var import_dist719 = __toESM(require_dist2(), 1);
var import_dist720 = __toESM(require_dist3(), 1);
var React38 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/useLazyQuery.js
var import_dist748 = __toESM(require_dist(), 1);
var import_dist749 = __toESM(require_dist2(), 1);
var import_dist750 = __toESM(require_dist3(), 1);
var React45 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/useQuery.js
var import_dist745 = __toESM(require_dist(), 1);
var import_dist746 = __toESM(require_dist2(), 1);
var import_dist747 = __toESM(require_dist3(), 1);
var React44 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/useSyncExternalStore.js
var import_dist721 = __toESM(require_dist(), 1);
var import_dist722 = __toESM(require_dist2(), 1);
var import_dist723 = __toESM(require_dist3(), 1);
var React39 = __toESM(require_rehackt(), 1);
var uSESKey = "useSyncExternalStore";
var realHook = React39[uSESKey];

// node_modules/@apollo/client/react/parser/index.js
var import_dist724 = __toESM(require_dist(), 1);
var import_dist725 = __toESM(require_dist2(), 1);
var import_dist726 = __toESM(require_dist3(), 1);
var DocumentType;
(function(DocumentType2) {
  DocumentType2[DocumentType2["Query"] = 0] = "Query";
  DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
  DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
})(DocumentType || (DocumentType = {}));
var cache;
function parser(document2) {
  if (!cache) {
    cache = new AutoCleanedWeakCache(
      cacheSizes.parser || 1e3
      /* defaultCacheSizes.parser */
    );
  }
  var cached = cache.get(document2);
  if (cached)
    return cached;
  var variables, type, name;
  invariant2(!!document2 && !!document2.kind, 70, document2);
  var fragments = [];
  var queries = [];
  var mutations = [];
  var subscriptions = [];
  for (var _i = 0, _a2 = document2.definitions; _i < _a2.length; _i++) {
    var x = _a2[_i];
    if (x.kind === "FragmentDefinition") {
      fragments.push(x);
      continue;
    }
    if (x.kind === "OperationDefinition") {
      switch (x.operation) {
        case "query":
          queries.push(x);
          break;
        case "mutation":
          mutations.push(x);
          break;
        case "subscription":
          subscriptions.push(x);
          break;
      }
    }
  }
  invariant2(!fragments.length || queries.length || mutations.length || subscriptions.length, 71);
  invariant2(
    queries.length + mutations.length + subscriptions.length <= 1,
    72,
    document2,
    queries.length,
    subscriptions.length,
    mutations.length
  );
  type = queries.length ? DocumentType.Query : DocumentType.Mutation;
  if (!queries.length && !mutations.length)
    type = DocumentType.Subscription;
  var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
  invariant2(definitions.length === 1, 73, document2, definitions.length);
  var definition = definitions[0];
  variables = definition.variableDefinitions || [];
  if (definition.name && definition.name.kind === "Name") {
    name = definition.name.value;
  } else {
    name = "data";
  }
  var payload = { name, type, variables };
  cache.set(document2, payload);
  return payload;
}
parser.resetCache = function() {
  cache = void 0;
};
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("parser", function() {
    return cache ? cache.size : 0;
  });
}

// node_modules/@apollo/client/react/hooks/internal/index.js
var import_dist742 = __toESM(require_dist(), 1);
var import_dist743 = __toESM(require_dist2(), 1);
var import_dist744 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/react/hooks/internal/useDeepMemo.js
var import_dist727 = __toESM(require_dist(), 1);
var import_dist728 = __toESM(require_dist2(), 1);
var import_dist729 = __toESM(require_dist3(), 1);
var React40 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/internal/useIsomorphicLayoutEffect.js
var import_dist730 = __toESM(require_dist(), 1);
var import_dist731 = __toESM(require_dist2(), 1);
var import_dist732 = __toESM(require_dist3(), 1);
var React41 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/internal/useRenderGuard.js
var import_dist733 = __toESM(require_dist(), 1);
var import_dist734 = __toESM(require_dist2(), 1);
var import_dist735 = __toESM(require_dist3(), 1);
var React42 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/internal/__use.js
var import_dist736 = __toESM(require_dist(), 1);
var import_dist737 = __toESM(require_dist2(), 1);
var import_dist738 = __toESM(require_dist3(), 1);
var React43 = __toESM(require_rehackt(), 1);
var useKey = "use";
var realHook2 = React43[useKey];

// node_modules/@apollo/client/react/hooks/internal/wrapHook.js
var import_dist739 = __toESM(require_dist(), 1);
var import_dist740 = __toESM(require_dist2(), 1);
var import_dist741 = __toESM(require_dist3(), 1);
var wrapperSymbol = Symbol.for("apollo.hook.wrappers");

// node_modules/@apollo/client/react/hooks/useQuery.js
var lastWatchOptions = Symbol();
var ssrDisabledResult = maybeDeepFreeze({
  loading: true,
  data: void 0,
  error: void 0,
  networkStatus: NetworkStatus.loading
});
var skipStandbyResult = maybeDeepFreeze({
  loading: false,
  data: void 0,
  error: void 0,
  networkStatus: NetworkStatus.ready
});

// node_modules/@apollo/client/react/hooks/useMutation.js
var import_dist751 = __toESM(require_dist(), 1);
var import_dist752 = __toESM(require_dist2(), 1);
var import_dist753 = __toESM(require_dist3(), 1);
var React46 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/useSubscription.js
var import_dist754 = __toESM(require_dist(), 1);
var import_dist755 = __toESM(require_dist2(), 1);
var import_dist756 = __toESM(require_dist3(), 1);
var React47 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/useReactiveVar.js
var import_dist757 = __toESM(require_dist(), 1);
var import_dist758 = __toESM(require_dist2(), 1);
var import_dist759 = __toESM(require_dist3(), 1);
var React48 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/useFragment.js
var import_dist760 = __toESM(require_dist(), 1);
var import_dist761 = __toESM(require_dist2(), 1);
var import_dist762 = __toESM(require_dist3(), 1);
var React49 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/useSuspenseQuery.js
var import_dist778 = __toESM(require_dist(), 1);
var import_dist779 = __toESM(require_dist2(), 1);
var import_dist780 = __toESM(require_dist3(), 1);
var React50 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/internal/index.js
var import_dist772 = __toESM(require_dist(), 1);
var import_dist773 = __toESM(require_dist2(), 1);
var import_dist774 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/react/internal/cache/getSuspenseCache.js
var import_dist769 = __toESM(require_dist(), 1);
var import_dist770 = __toESM(require_dist2(), 1);
var import_dist771 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/react/internal/cache/SuspenseCache.js
var import_dist766 = __toESM(require_dist(), 1);
var import_dist767 = __toESM(require_dist2(), 1);
var import_dist768 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/react/internal/cache/QueryReference.js
var import_dist763 = __toESM(require_dist(), 1);
var import_dist764 = __toESM(require_dist2(), 1);
var import_dist765 = __toESM(require_dist3(), 1);
var QUERY_REFERENCE_SYMBOL = Symbol();
var PROMISE_SYMBOL = Symbol();
var OBSERVED_CHANGED_OPTIONS = [
  "canonizeResults",
  "context",
  "errorPolicy",
  "fetchPolicy",
  "refetchWritePolicy",
  "returnPartialData"
];
var InternalQueryReference = (
  /** @class */
  function() {
    function InternalQueryReference2(observable, options) {
      var _this = this;
      this.key = {};
      this.listeners = /* @__PURE__ */ new Set();
      this.references = 0;
      this.softReferences = 0;
      this.handleNext = this.handleNext.bind(this);
      this.handleError = this.handleError.bind(this);
      this.dispose = this.dispose.bind(this);
      this.observable = observable;
      if (options.onDispose) {
        this.onDispose = options.onDispose;
      }
      this.setResult();
      this.subscribeToQuery();
      var startDisposeTimer = function() {
        var _a2;
        if (!_this.references) {
          _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a2 = options.autoDisposeTimeoutMs) !== null && _a2 !== void 0 ? _a2 : 3e4);
        }
      };
      this.promise.then(startDisposeTimer, startDisposeTimer);
    }
    Object.defineProperty(InternalQueryReference2.prototype, "disposed", {
      get: function() {
        return this.subscription.closed;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InternalQueryReference2.prototype, "watchQueryOptions", {
      get: function() {
        return this.observable.options;
      },
      enumerable: false,
      configurable: true
    });
    InternalQueryReference2.prototype.reinitialize = function() {
      var observable = this.observable;
      var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;
      var avoidNetworkRequests = originalFetchPolicy === "no-cache" || originalFetchPolicy === "standby";
      try {
        if (avoidNetworkRequests) {
          observable.silentSetOptions({ fetchPolicy: "standby" });
        } else {
          observable.resetLastResults();
          observable.silentSetOptions({ fetchPolicy: "cache-first" });
        }
        this.subscribeToQuery();
        if (avoidNetworkRequests) {
          return;
        }
        observable.resetDiff();
        this.setResult();
      } finally {
        observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });
      }
    };
    InternalQueryReference2.prototype.retain = function() {
      var _this = this;
      this.references++;
      clearTimeout(this.autoDisposeTimeoutId);
      var disposed = false;
      return function() {
        if (disposed) {
          return;
        }
        disposed = true;
        _this.references--;
        setTimeout(function() {
          if (!_this.references) {
            _this.dispose();
          }
        });
      };
    };
    InternalQueryReference2.prototype.softRetain = function() {
      var _this = this;
      this.softReferences++;
      var disposed = false;
      return function() {
        if (disposed) {
          return;
        }
        disposed = true;
        _this.softReferences--;
        setTimeout(function() {
          if (!_this.softReferences && !_this.references) {
            _this.dispose();
          }
        });
      };
    };
    InternalQueryReference2.prototype.didChangeOptions = function(watchQueryOptions) {
      var _this = this;
      return OBSERVED_CHANGED_OPTIONS.some(function(option) {
        return option in watchQueryOptions && !equal(_this.watchQueryOptions[option], watchQueryOptions[option]);
      });
    };
    InternalQueryReference2.prototype.applyOptions = function(watchQueryOptions) {
      var _a2 = this.watchQueryOptions, currentFetchPolicy = _a2.fetchPolicy, currentCanonizeResults = _a2.canonizeResults;
      if (currentFetchPolicy === "standby" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {
        this.initiateFetch(this.observable.reobserve(watchQueryOptions));
      } else {
        this.observable.silentSetOptions(watchQueryOptions);
        if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {
          this.result = __assign(__assign({}, this.result), this.observable.getCurrentResult());
          this.promise = createFulfilledPromise(this.result);
        }
      }
      return this.promise;
    };
    InternalQueryReference2.prototype.listen = function(listener) {
      var _this = this;
      this.listeners.add(listener);
      return function() {
        _this.listeners.delete(listener);
      };
    };
    InternalQueryReference2.prototype.refetch = function(variables) {
      return this.initiateFetch(this.observable.refetch(variables));
    };
    InternalQueryReference2.prototype.fetchMore = function(options) {
      return this.initiateFetch(this.observable.fetchMore(options));
    };
    InternalQueryReference2.prototype.dispose = function() {
      this.subscription.unsubscribe();
      this.onDispose();
    };
    InternalQueryReference2.prototype.onDispose = function() {
    };
    InternalQueryReference2.prototype.handleNext = function(result2) {
      var _a2;
      switch (this.promise.status) {
        case "pending": {
          if (result2.data === void 0) {
            result2.data = this.result.data;
          }
          this.result = result2;
          (_a2 = this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, result2);
          break;
        }
        default: {
          if (result2.data === this.result.data && result2.networkStatus === this.result.networkStatus) {
            return;
          }
          if (result2.data === void 0) {
            result2.data = this.result.data;
          }
          this.result = result2;
          this.promise = createFulfilledPromise(result2);
          this.deliver(this.promise);
          break;
        }
      }
    };
    InternalQueryReference2.prototype.handleError = function(error) {
      var _a2;
      this.subscription.unsubscribe();
      this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);
      switch (this.promise.status) {
        case "pending": {
          (_a2 = this.reject) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
          break;
        }
        default: {
          this.promise = createRejectedPromise(error);
          this.deliver(this.promise);
        }
      }
    };
    InternalQueryReference2.prototype.deliver = function(promise) {
      this.listeners.forEach(function(listener) {
        return listener(promise);
      });
    };
    InternalQueryReference2.prototype.initiateFetch = function(returnedPromise) {
      var _this = this;
      this.promise = this.createPendingPromise();
      this.promise.catch(function() {
      });
      returnedPromise.then(function() {
        setTimeout(function() {
          var _a2;
          if (_this.promise.status === "pending") {
            _this.result = _this.observable.getCurrentResult();
            (_a2 = _this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(_this, _this.result);
          }
        });
      }).catch(function(error) {
        var _a2;
        return (_a2 = _this.reject) === null || _a2 === void 0 ? void 0 : _a2.call(_this, error);
      });
      return returnedPromise;
    };
    InternalQueryReference2.prototype.subscribeToQuery = function() {
      var _this = this;
      this.subscription = this.observable.filter(function(result2) {
        return !equal(result2.data, {}) && !equal(result2, _this.result);
      }).subscribe(this.handleNext, this.handleError);
    };
    InternalQueryReference2.prototype.setResult = function() {
      var result2 = this.observable.getCurrentResult(false);
      if (equal(result2, this.result)) {
        return;
      }
      this.result = result2;
      this.promise = result2.data && (!result2.partial || this.watchQueryOptions.returnPartialData) ? createFulfilledPromise(result2) : this.createPendingPromise();
    };
    InternalQueryReference2.prototype.createPendingPromise = function() {
      var _this = this;
      return wrapPromiseWithState(new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      }));
    };
    return InternalQueryReference2;
  }()
);

// node_modules/@apollo/client/react/internal/cache/SuspenseCache.js
var SuspenseCache = (
  /** @class */
  function() {
    function SuspenseCache2(options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      this.queryRefs = new Trie(canUseWeakMap);
      this.options = options;
    }
    SuspenseCache2.prototype.getQueryRef = function(cacheKey, createObservable) {
      var ref = this.queryRefs.lookupArray(cacheKey);
      if (!ref.current) {
        ref.current = new InternalQueryReference(createObservable(), {
          autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,
          onDispose: function() {
            delete ref.current;
          }
        });
      }
      return ref.current;
    };
    SuspenseCache2.prototype.add = function(cacheKey, queryRef) {
      var ref = this.queryRefs.lookupArray(cacheKey);
      ref.current = queryRef;
    };
    return SuspenseCache2;
  }()
);

// node_modules/@apollo/client/react/internal/cache/getSuspenseCache.js
var suspenseCacheSymbol = Symbol.for("apollo.suspenseCache");

// node_modules/@apollo/client/react/hooks/constants.js
var import_dist775 = __toESM(require_dist(), 1);
var import_dist776 = __toESM(require_dist2(), 1);
var import_dist777 = __toESM(require_dist3(), 1);
var skipToken = Symbol.for("apollo.skipToken");

// node_modules/@apollo/client/react/hooks/useBackgroundQuery.js
var import_dist781 = __toESM(require_dist(), 1);
var import_dist782 = __toESM(require_dist2(), 1);
var import_dist783 = __toESM(require_dist3(), 1);
var React51 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/useLoadableQuery.js
var import_dist784 = __toESM(require_dist(), 1);
var import_dist785 = __toESM(require_dist2(), 1);
var import_dist786 = __toESM(require_dist3(), 1);
var React52 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/useQueryRefHandlers.js
var import_dist787 = __toESM(require_dist(), 1);
var import_dist788 = __toESM(require_dist2(), 1);
var import_dist789 = __toESM(require_dist3(), 1);
var React53 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/hooks/useReadQuery.js
var import_dist790 = __toESM(require_dist(), 1);
var import_dist791 = __toESM(require_dist2(), 1);
var import_dist792 = __toESM(require_dist3(), 1);
var React54 = __toESM(require_rehackt(), 1);

// node_modules/@apollo/client/react/query-preloader/createQueryPreloader.js
var import_dist796 = __toESM(require_dist(), 1);
var import_dist797 = __toESM(require_dist2(), 1);
var import_dist798 = __toESM(require_dist3(), 1);

// node_modules/@apollo/client/react/types/types.js
var import_dist799 = __toESM(require_dist(), 1);
var import_dist800 = __toESM(require_dist2(), 1);
var import_dist801 = __toESM(require_dist3(), 1);

// node_modules/@burnt-labs/signers/dist/index.mjs
var import_cosmwasm_stargate = __toESM(require_build9(), 1);
var import_tx2 = __toESM(require_tx(), 1);
var import_service = __toESM(require_service(), 1);
var import_crypto = __toESM(require_build4(), 1);
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var require_aspromise = __commonJS2({
  "../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset4 = 0, index2 = 2, pending = true;
      while (index2 < arguments.length)
        params[offset4++] = arguments[index2++];
      return new Promise(function executor(resolve, reject) {
        params[offset4] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset22 = 0;
              while (offset22 < params2.length)
                params2[offset22++] = arguments[offset22];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});
var require_base64 = __commonJS2({
  "../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js"(exports2) {
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode3(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode2(string, buffer, offset4) {
      var start = offset4;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset4++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset4++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset4++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset4 - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});
var require_eventemitter = __commonJS2({
  "../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});
var require_float = __commonJS2({
  "../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js"(exports2, module2) {
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});
var require_inquire = __commonJS2({
  "../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js"(exports, module) {
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});
var require_utf8 = __commonJS2({
  "../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js"(exports2) {
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset4) {
      var start = offset4, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset4++] = c1;
        } else if (c1 < 2048) {
          buffer[offset4++] = c1 >> 6 | 192;
          buffer[offset4++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset4++] = c1 >> 18 | 240;
          buffer[offset4++] = c1 >> 12 & 63 | 128;
          buffer[offset4++] = c1 >> 6 & 63 | 128;
          buffer[offset4++] = c1 & 63 | 128;
        } else {
          buffer[offset4++] = c1 >> 12 | 224;
          buffer[offset4++] = c1 >> 6 & 63 | 128;
          buffer[offset4++] = c1 & 63 | 128;
        }
      }
      return offset4 - start;
    };
  }
});
var require_pool = __commonJS2({
  "../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    module2.exports = pool;
    function pool(alloc, slice2, size4) {
      var SIZE = size4 || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset4 = SIZE;
      return function pool_alloc(size22) {
        if (size22 < 1 || size22 > MAX)
          return alloc(size22);
        if (offset4 + size22 > SIZE) {
          slab = alloc(SIZE);
          offset4 = 0;
        }
        var buf = slice2.call(slab, offset4, offset4 += size22);
        if (offset4 & 7)
          offset4 = (offset4 | 7) + 1;
        return buf;
      };
    }
  }
});
var require_longbits = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    module2.exports = LongBits;
    var util = require_minimal2();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber2(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from2(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber2(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
        (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});
var require_minimal2 = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger3(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
    * Checks if a property on a message is considered to be present.
    * @param {Object} obj Plain object or message instance
    * @param {string} prop Property name
    * @returns {boolean} `true` if considered to be present, otherwise `false`
    */
    util.isSet = function isSet3(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size4) {
        return new Buffer2(size4);
      };
    };
  }
});
var require_writer = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    module2.exports = Writer;
    var util = require_minimal2();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size4) {
      return new util.Array(size4);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});
var require_writer_buffer = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal2();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});
var require_reader = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    module2.exports = Reader;
    var util = require_minimal2();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});
var require_reader_buffer = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal2();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});
var require_service2 = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    module2.exports = Service;
    var util = require_minimal2();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});
var require_rpc = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/rpc.js"(exports2) {
    var rpc = exports2;
    rpc.Service = require_service2();
  }
});
var require_roots = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    module2.exports = {};
  }
});
var require_index_minimal = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal2();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});
var require_minimal22 = __commonJS2({
  "../../node_modules/.pnpm/protobufjs@7.2.5/node_modules/protobufjs/minimal.js"(exports2, module2) {
    module2.exports = require_index_minimal();
  }
});
var xionGasValues2 = {
  gasPrice: "0.025uxion",
  gasAdjustment: 1.4,
  gasAdjustmentMargin: 5e3
};
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch (e) {
}
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}
Long.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache2;
  if (unsigned) {
    value >>>= 0;
    if (cache2 = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache2)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache2 = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache2)
      INT_CACHE[value] = obj;
    return obj;
  }
}
Long.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits(value % TWO_PWR_32_DBL3 | 0, value / TWO_PWR_32_DBL3 | 0, unsigned);
}
Long.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  var p;
  if ((p = str.indexOf("-")) > 0)
    throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result2 = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size4 = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size4), radix);
    if (size4 < 8) {
      var power = fromNumber(pow_dbl(radix, size4));
      result2 = result2.mul(power).add(fromNumber(value));
    } else {
      result2 = result2.mul(radixToPower);
      result2 = result2.add(fromNumber(value));
    }
  }
  result2.unsigned = unsigned;
  return result2;
}
Long.fromString = fromString;
function fromValue(val, unsigned) {
  if (typeof val === "number")
    return fromNumber(val, unsigned);
  if (typeof val === "string")
    return fromString(val, unsigned);
  return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL3 = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL3 * TWO_PWR_32_DBL3;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, true);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL3 + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL3 + (this.low >>> 0);
};
LongPrototype.toString = function toString3(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else
      return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result2 = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero())
      return digits + result2;
    else {
      while (digits.length < 6)
        digits = "0" + digits;
      result2 = "" + digits + result2;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--)
    if ((val & 1 << bit) != 0)
      break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(
    /* validates */
    other
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(
    /* validates */
    other
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(
    /* validates */
    other
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.eq(other))
    return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg)
    return -1;
  if (!thisNeg && otherNeg)
    return 1;
  if (!this.unsigned)
    return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE))
    return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add(addend) {
  if (!isLong(addend))
    addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend))
    subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero())
    return this;
  if (!isLong(multiplier))
    multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm["mul"](
      this.low,
      this.high,
      multiplier.low,
      multiplier.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (multiplier.isZero())
    return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE))
    return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative())
      return this.neg().mul(multiplier.neg());
    else
      return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (divisor.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE))
        return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative())
        return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative())
      return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned)
      divisor = divisor.toUnsigned();
    if (divisor.gt(this))
      return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero())
      approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function and(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
  else
    return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
  else
    return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  if (numBits < 32)
    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
  if (numBits === 32)
    return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b;
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  if (numBits === 32)
    return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b;
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  if (numBits === 32)
    return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned)
    return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned)
    return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [
    lo & 255,
    lo >>> 8 & 255,
    lo >>> 16 & 255,
    lo >>> 24,
    hi & 255,
    hi >>> 8 & 255,
    hi >>> 16 & 255,
    hi >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 255,
    hi >>> 8 & 255,
    hi & 255,
    lo >>> 24,
    lo >>> 16 & 255,
    lo >>> 8 & 255,
    lo & 255
  ];
};
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long(
    bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
    bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
    unsigned
  );
};
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long(
    bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
    bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
    unsigned
  );
};
var long_default = Long;
var import_minimal3 = __toESM2(require_minimal22());
var import_minimal = __toESM2(require_minimal22());
function createBaseCoin() {
  return { denom: "", amount: "" };
}
var Coin = {
  encode(message, writer = import_minimal.default.Writer.create()) {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.denom = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.amount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },
  create(base) {
    return Coin.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCoin();
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    return message;
  }
};
if (import_minimal.default.util.Long !== long_default) {
  import_minimal.default.util.Long = long_default;
  import_minimal.default.configure();
}
function isSet(value) {
  return value !== null && value !== void 0;
}
var import_minimal2 = __toESM2(require_minimal22());
if (import_minimal2.default.util.Long !== long_default) {
  import_minimal2.default.util.Long = long_default;
  import_minimal2.default.configure();
}
function createBaseMsgRegisterAccount() {
  return { sender: "", codeId: long_default.UZERO, msg: new Uint8Array(0), funds: [], salt: new Uint8Array(0) };
}
var MsgRegisterAccount = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (!message.codeId.isZero()) {
      writer.uint32(16).uint64(message.codeId);
    }
    if (message.msg.length !== 0) {
      writer.uint32(26).bytes(message.msg);
    }
    for (const v of message.funds) {
      Coin.encode(v, writer.uint32(34).fork()).ldelim();
    }
    if (message.salt.length !== 0) {
      writer.uint32(42).bytes(message.salt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.sender = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }
          message.codeId = reader.uint64();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }
          message.msg = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }
          message.funds.push(Coin.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }
          message.salt = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sender: isSet2(object.sender) ? globalThis.String(object.sender) : "",
      codeId: isSet2(object.codeId) ? long_default.fromValue(object.codeId) : long_default.UZERO,
      msg: isSet2(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(0),
      funds: globalThis.Array.isArray(object == null ? void 0 : object.funds) ? object.funds.map((e) => Coin.fromJSON(e)) : [],
      salt: isSet2(object.salt) ? bytesFromBase64(object.salt) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    var _a2;
    const obj = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (!message.codeId.isZero()) {
      obj.codeId = (message.codeId || long_default.UZERO).toString();
    }
    if (message.msg.length !== 0) {
      obj.msg = base64FromBytes(message.msg);
    }
    if ((_a2 = message.funds) == null ? void 0 : _a2.length) {
      obj.funds = message.funds.map((e) => Coin.toJSON(e));
    }
    if (message.salt.length !== 0) {
      obj.salt = base64FromBytes(message.salt);
    }
    return obj;
  },
  create(base) {
    return MsgRegisterAccount.fromPartial(base ?? {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseMsgRegisterAccount();
    message.sender = object.sender ?? "";
    message.codeId = object.codeId !== void 0 && object.codeId !== null ? long_default.fromValue(object.codeId) : long_default.UZERO;
    message.msg = object.msg ?? new Uint8Array(0);
    message.funds = ((_a2 = object.funds) == null ? void 0 : _a2.map((e) => Coin.fromPartial(e))) || [];
    message.salt = object.salt ?? new Uint8Array(0);
    return message;
  }
};
function createBaseMsgRegisterAccountResponse() {
  return { address: "", data: new Uint8Array(0) };
}
var MsgRegisterAccountResponse = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }
          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }
          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet2(object.address) ? globalThis.String(object.address) : "",
      data: isSet2(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },
  create(base) {
    return MsgRegisterAccountResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMsgRegisterAccountResponse();
    message.address = object.address ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  }
};
function bytesFromBase64(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
if (import_minimal3.default.util.Long !== long_default) {
  import_minimal3.default.util.Long = long_default;
  import_minimal3.default.configure();
}
function isSet2(value) {
  return value !== null && value !== void 0;
}
var typeUrlMsgRegisterAccount = "/abstractaccount.v1.MsgRegisterAccount";
var typeUrlMsgRegisterAccountResponse = "/abstractaccount.v1.MsgRegisterAccountResponse";
var abstractAccountTypes = [
  [typeUrlMsgRegisterAccount, MsgRegisterAccount],
  [typeUrlMsgRegisterAccountResponse, MsgRegisterAccountResponse]
];
var AbstractAccount$Type = class extends MessageType {
  constructor() {
    super(
      "abstractaccount.v1.AbstractAccount",
      [
        {
          no: 1,
          name: "address",
          kind: "scalar",
          T: 9,
          options: { "cosmos_proto.scalar": "cosmos.AddressString" }
        },
        {
          no: 2,
          name: "account_number",
          kind: "scalar",
          T: 4,
          L: 0
        },
        {
          no: 3,
          name: "sequence",
          kind: "scalar",
          T: 4,
          L: 0
        }
      ],
      {
        "cosmos_proto.implements_interface": ["cosmos.auth.v1beta1.AccountI"],
        "gogoproto.goproto_getters": false,
        "gogoproto.equal": false
      }
    );
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.address = "";
    message.accountNumber = 0n;
    message.sequence = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string address */
        1:
          message.address = reader.string();
          break;
        case /* uint64 account_number */
        2:
          message.accountNumber = reader.uint64().toBigInt();
          break;
        case /* uint64 sequence */
        3:
          message.sequence = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.accountNumber !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.accountNumber);
    if (message.sequence !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.sequence);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
};
var AbstractAccount = new AbstractAccount$Type();
var NilPubKey$Type = class extends MessageType {
  constructor() {
    super(
      "abstractaccount.v1.NilPubKey",
      [
        {
          no: 1,
          name: "address_bytes",
          kind: "scalar",
          T: 12
        }
      ],
      { "gogoproto.goproto_stringer": false }
    );
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.addressBytes = new Uint8Array(0);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes address_bytes */
        1:
          message.addressBytes = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.addressBytes.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.addressBytes);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
};
new NilPubKey$Type();
var AAAlgo = ((AAAlgo2) => {
  AAAlgo2["Secp256K1"] = "secp256k1";
  AAAlgo2["secp256k1"] = "Secp256K1";
  AAAlgo2["Ed25519"] = "ed25519";
  AAAlgo2["ed25519"] = "Ed25519";
  AAAlgo2["Sr25519"] = "sr25519";
  AAAlgo2["sr25519"] = "Sr25519";
  AAAlgo2["jwt"] = "JWT";
  AAAlgo2["JWT"] = "jwt";
  AAAlgo2["ethWallet"] = "ethWallet";
  AAAlgo2["ETHWALLET"] = "EthWallet";
  return AAAlgo2;
})(AAAlgo || {});
var SMART_ACCOUNT_FRAGMENT = gql`
  fragment SmartAccountFragment on SmartAccountAuthenticator {
    id
    type
    authenticator
    authenticatorIndex
    version
  }
`;
gql`
  ${SMART_ACCOUNT_FRAGMENT}
  query ($authenticator: String!) {
    smartAccounts(
      filter: {
        authenticators: { some: { authenticator: { equalTo: $authenticator } } }
      }
    ) {
      nodes {
        authenticators {
          nodes {
            ...SmartAccountFragment
          }
        }
      }
    }
  }
`;
gql`
  ${SMART_ACCOUNT_FRAGMENT}
  query ($id: String!) {
    smartAccount(id: $id) {
      id
      latestAuthenticatorId
      authenticators {
        nodes {
          ...SmartAccountFragment
        }
      }
    }
  }
`;
gql`
  ${SMART_ACCOUNT_FRAGMENT}
  query ($id: String!) {
    smartAccounts(filter: { id: { equalTo: $id } }) {
      nodes {
        authenticators {
          nodes {
            ...SmartAccountFragment
          }
        }
      }
    }
  }
`;
var SmartWalletIndexQueryByAccountId = gql`
  ${SMART_ACCOUNT_FRAGMENT}
  query ($id: String!, $index: Int!) {
    smartAccounts(filter: { id: { equalTo: $id } }) {
      nodes {
        authenticators(filter: { authenticatorIndex: { equalTo: $index } }) {
          nodes {
            ...SmartAccountFragment
          }
        }
      }
    }
  }
`;
gql`
  ${SMART_ACCOUNT_FRAGMENT}
  query ($id: String!, $authenticator: String!) {
    smartAccounts(
      filter: {
        id: { equalTo: $id }
        authenticators: { some: { authenticator: { equalTo: $authenticator } } }
      }
    ) {
      nodes {
        authenticators {
          nodes {
            ...SmartAccountFragment
          }
        }
      }
    }
  }
`;
gql`
  ${SMART_ACCOUNT_FRAGMENT}
  query ($id: String!, $type: String!) {
    smartAccounts(
      filter: {
        id: { equalTo: $id }
        authenticators: { some: { type: { equalTo: $type } } }
      }
    ) {
      nodes {
        authenticators {
          nodes {
            ...SmartAccountFragment
          }
        }
      }
    }
  }
`;
var AllSmartWalletQueryByIdAndTypeAndAuthenticator = gql`
  ${SMART_ACCOUNT_FRAGMENT}
  query ($id: String!, $type: String!, $authenticator: String!) {
    smartAccounts(
      filter: {
        id: { equalTo: $id }
        authenticators: {
          some: {
            authenticator: { equalTo: $authenticator }
            type: { equalTo: $type }
          }
        }
      }
    ) {
      nodes {
        authenticators {
          nodes {
            ...SmartAccountFragment
          }
        }
      }
    }
  }
`;
var apolloClientInstance;
var getApolloClient = (url) => {
  if (!apolloClientInstance) {
    apolloClientInstance = new ApolloClient({
      uri: url || "https://api.subquery.network/sq/burnt-labs/xion-indexer",
      cache: new InMemoryCache(),
      assumeImmutableResults: true
    });
  }
  return apolloClientInstance;
};
function uint64FromProto(input) {
  return import_math.Uint64.fromString(input.toString());
}
function accountFromBaseAccount(input) {
  const { address, pubKey, accountNumber, sequence } = input;
  let pubkey = null;
  if (pubKey) {
    pubkey = (0, import_proto_signing.decodePubkey)(pubKey);
  }
  return {
    address,
    pubkey,
    accountNumber: uint64FromProto(accountNumber).toNumber(),
    sequence: uint64FromProto(sequence).toNumber()
  };
}
function customAccountFromAny(input) {
  const { typeUrl, value } = input;
  switch (typeUrl) {
    case "/abstractaccount.v1.AbstractAccount": {
      const abstractAccount = AbstractAccount.fromBinary(value);
      (0, import_utils14.assert)(abstractAccount);
      return accountFromBaseAccount(abstractAccount);
    }
    default:
      return (0, import_accounts.accountFromAny)(input);
  }
}
function makeAAuthInfo(account, pubKey, fee) {
  return import_tx.AuthInfo.fromPartial({
    signerInfos: [
      import_tx.SignerInfo.fromPartial({
        publicKey: {
          typeUrl: "/abstractaccount.v1.NilPubKey",
          value: new Uint8Array([10, 32, ...pubKey])
          // a little hack to encode the pk into proto bytes
        },
        modeInfo: {
          single: {
            mode: import_signing.SignMode.SIGN_MODE_DIRECT
          }
        },
        sequence: BigInt(account.sequence)
      })
    ],
    fee: {
      amount: fee.amount ? (0, import_amino.coins)(fee.amount[0].amount, fee.amount[0].denom) : (0, import_amino.coins)(1, "uxion"),
      gasLimit: BigInt(fee.gas),
      granter: fee.granter || "",
      payer: fee.payer || ""
    }
  });
}
async function getAAccounts(accounts, abstractAccount, indexerUrl) {
  const defaultData = {
    address: "",
    accountAddress: "",
    algo: "secp256k1",
    pubkey: new Uint8Array(),
    authenticatorId: 0
  };
  const allAAAcounts = [];
  const apolloClient = getApolloClient(indexerUrl);
  if (!apolloClient || !accounts || accounts.length === 0) {
    return [defaultData];
  }
  for (const account of accounts) {
    const { data } = await apolloClient.query({
      query: AllSmartWalletQueryByIdAndTypeAndAuthenticator,
      variables: {
        id: abstractAccount,
        type: AAAlgo[account.algo],
        authenticator: Buffer.from(account.pubkey).toString("base64")
      }
    });
    if (data) {
      const smartAccounts = data.smartAccounts;
      if (!smartAccounts.nodes.length) {
        continue;
      }
      for (const node of smartAccounts.nodes) {
        const smartAccountAuthenticators = node.authenticators;
        if (!smartAccountAuthenticators.nodes.length) {
          continue;
        }
        for (const authenticator of smartAccountAuthenticators.nodes) {
          const splitAuthenticatorId = authenticator.id.split("-");
          allAAAcounts.push({
            address: splitAuthenticatorId[0],
            accountAddress: account.address,
            algo: authenticator.type.toLowerCase(),
            pubkey: new Uint8Array(),
            // to signify an AA account
            authenticatorId: Number(splitAuthenticatorId[1])
          });
        }
      }
    }
  }
  return allAAAcounts;
}
async function getAuthenticatorIdByAuthenticatorIndex(abstractAccount, authenticatorIndex, indexerUrl) {
  const apolloClient = getApolloClient(indexerUrl);
  const { data } = await apolloClient.query({
    query: SmartWalletIndexQueryByAccountId,
    variables: {
      id: abstractAccount,
      index: authenticatorIndex
    }
  });
  if (!data || !data.smartAccounts) {
    return 0;
  }
  if (data.smartAccounts.nodes.length > 1) {
    console.warn(
      "Unexpected behavior. Indexer returned multiple smart accounts"
    );
  }
  if (data.smartAccounts.nodes[0].authenticators.nodes.length > 1) {
    console.warn(
      "Unexpected behavior. Indexer returned multiple authenticators"
    );
  }
  return data.smartAccounts.nodes[0].authenticators.nodes[0].authenticatorIndex || 0;
}
function encodeHex(bytes) {
  return [...bytes].map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
var AADefaultRegistryTypes = [
  ...import_stargate.defaultRegistryTypes,
  ...import_cosmwasm_stargate.wasmTypes,
  ...abstractAccountTypes
];
function createDefaultRegistry() {
  return new import_proto_signing.Registry(AADefaultRegistryTypes);
}
var AAClient = class extends import_cosmwasm_stargate.SigningCosmWasmClient {
  constructor(tmClient, signer, options) {
    super(tmClient, signer, options);
    this.abstractSigner = signer;
  }
  static async connectWithSigner(endpoint, signer, options = {}) {
    const tmClient = await import_tendermint_rpc.Tendermint37Client.connect(endpoint);
    return new AAClient(tmClient, signer, {
      registry: createDefaultRegistry(),
      ...options,
      accountParser: customAccountFromAny
    });
  }
  /**
   * Creates a MsgRegisterAbstractAccount message and broadcasts it
   * @param msg the message to be sent
   * @returns
   */
  async registerAbstractAccount(msg) {
    const { sender } = msg;
    const createMsg = {
      typeUrl: typeUrlMsgRegisterAccount,
      value: msg
    };
    return this.signAndBroadcast(sender, [createMsg], "auto");
  }
  /**
   * Simulates a transaction to estimate the gas and calculates the default fee.
   *
   * @param {string} sender - The address of the sender.
   * @param {readonly EncodeObject[]} messages - An array of messages to include in the transaction.
   * @param {string | undefined} memo - An optional memo to include in the transaction.
   * @returns {Promise<StdFee>} - The calculated default fee for the transaction.
   */
  async simulateDefaultFee(sender, messages, memo2) {
    const {
      gasPrice: gasPriceString,
      gasAdjustment,
      gasAdjustmentMargin
    } = xionGasValues2;
    const simmedGas = await this.simulate(sender, messages, memo2);
    const gasPrice = import_stargate.GasPrice.fromString(gasPriceString);
    const calculatedFee = (0, import_stargate.calculateFee)(simmedGas, gasPrice);
    let defaultFee;
    let gas = Math.ceil(
      parseInt(calculatedFee.gas) * gasAdjustment + gasAdjustmentMargin
    ).toString();
    const chainId = await this.getChainId();
    if (/testnet/.test(chainId)) {
      defaultFee = { amount: [{ amount: "0", denom: "uxion" }], gas };
    } else {
      defaultFee = { amount: calculatedFee.amount, gas };
    }
    return defaultFee;
  }
  /**
   * Create and a cosmwasm add authenticator msg to the abstract account
   * @param msg the message to be sent
   * @returns
   */
  async addAbstractAccountAuthenticator(msg, memo2 = "", fee) {
    if (!this.abstractSigner.abstractAccount) {
      throw new Error("Abstract account address not set in signer");
    }
    const sender = this.abstractSigner.abstractAccount;
    const addMsg = {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: import_tx2.MsgExecuteContract.fromPartial({
        sender,
        contract: sender,
        msg: Buffer.from(JSON.stringify(msg), "utf-8"),
        funds: []
      })
    };
    const defaultFee = await this.simulateDefaultFee(sender, [addMsg], memo2);
    const tx = await this.sign(sender, [addMsg], fee || defaultFee, memo2);
    return this.broadcastTx(import_tx.TxRaw.encode(tx).finish());
  }
  /**
   * Create a cosmwasm remove authenticator msg to the abstract account
   * @param msg the message to be sent
   * @returns
   */
  async removeAbstractAccountAuthenticator(msg, memo2 = "", fee) {
    if (!this.abstractSigner.abstractAccount) {
      throw new Error("Abstract account address not set in signer");
    }
    const sender = this.abstractSigner.abstractAccount;
    const addMsg = {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: import_tx2.MsgExecuteContract.fromPartial({
        sender,
        contract: sender,
        msg: Buffer.from(JSON.stringify(msg), "utf-8"),
        funds: []
      })
    };
    const defaultFee = await this.simulateDefaultFee(sender, [addMsg], memo2);
    const tx = await this.sign(sender, [addMsg], fee || defaultFee, memo2);
    return this.broadcastTx(import_tx.TxRaw.encode(tx).finish());
  }
  /**
   * Simulates a transaction and returns the gas used.
   *
   * @param {string} signerAddress - The address of the signer.
   * @param {readonly EncodeObject[]} messages - An array of messages to include in the transaction.
   * @param {string | undefined} memo - An optional memo to include in the transaction.
   * @returns {Promise<number>} - The gas used by the simulated transaction.
   * @throws Will throw an error if the account is not found or if the query client cannot be retrieved.
   */
  async simulate(signerAddress, messages, memo2) {
    const { sequence } = await this.getSequence(signerAddress);
    const accountFromSigner = (await this.abstractSigner.getAccounts()).find(
      (account) => account.address === signerAddress
    );
    if (!accountFromSigner) {
      throw new Error("No account found.");
    }
    const pubKeyBytes = import_bech32.bech32.fromWords(
      import_bech32.bech32.decode(accountFromSigner.address).words
    );
    const pubkey = Uint8Array.from(pubKeyBytes);
    const queryClient = this.getQueryClient();
    if (!queryClient) {
      throw new Error("Couldn't get query client");
    }
    const rpc = (0, import_stargate.createProtobufRpcClient)(queryClient);
    const queryService = new import_service.ServiceClientImpl(rpc);
    const authInfo = import_tx.AuthInfo.fromPartial({
      fee: import_tx.Fee.fromPartial({}),
      signerInfos: [
        {
          publicKey: {
            typeUrl: "/abstractaccount.v1.NilPubKey",
            value: new Uint8Array([10, 32, ...pubkey])
            // a little hack to encode the pk into proto bytes
          },
          modeInfo: {
            single: {
              mode: import_signing.SignMode.SIGN_MODE_DIRECT
            }
          },
          sequence: BigInt(sequence)
        }
      ]
    });
    const authInfoBytes = import_tx.AuthInfo.encode(authInfo).finish();
    const txBodyEncodeObject = {
      typeUrl: "/cosmos.tx.v1beta1.TxBody",
      value: {
        messages,
        memo: memo2 || "AA Gas Simulation"
      }
    };
    const bodyBytes = this.registry.encode(txBodyEncodeObject);
    const tx = import_tx.TxRaw.fromPartial({
      bodyBytes,
      authInfoBytes,
      signatures: [new Uint8Array()]
    });
    const request = import_service.SimulateRequest.fromPartial({
      txBytes: import_tx.TxRaw.encode(tx).finish()
    });
    const { gasInfo } = await queryService.Simulate(request);
    if (!gasInfo) {
      throw new Error("No gas info returned");
    }
    return import_math.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
  }
  async getAccount(searchAddress) {
    const account = await this.forceGetQueryClient().auth.account(searchAddress);
    if (!account) {
      return null;
    }
    return customAccountFromAny(account);
  }
  /**
   * This method is a replacement of the sign method from SigningStargateClient
   * it uses the signDirect method from the custom signer(AASigner) to create the Abstract Account signature
   * required to verify the transaction on the chain and also builds the authInfoBytes using
   * the Abstract Account pubkey type NilPubKey
   * NB: This method is not compatible with regular signers. Use the sign method from SigningStargateClient
   * @param signerAddress // the abstract account address to be used as the signer
   * @param messages // the messages to be signed
   * @param fee
   * @param memo
   * @param explicitSignerData
   * @returns
   */
  async sign(signerAddress, messages, fee, memo2, explicitSignerData) {
    const aaAcount = await this.getAccount(signerAddress);
    if (aaAcount && aaAcount.pubkey) {
      this.abstractSigner.abstractAccount = void 0;
      return super.sign(signerAddress, messages, fee, memo2, explicitSignerData);
    }
    let signerData;
    if (!this.abstractSigner.abstractAccount) {
      this.abstractSigner.abstractAccount = signerAddress;
    }
    const accounts = await this.abstractSigner.getAccounts();
    const accountFromSigner = accounts.find(
      (account) => account.authenticatorId === this.abstractSigner.accountAuthenticatorIndex
    );
    if (!accountFromSigner) {
      throw new Error("Failed to retrieve account from signer");
    }
    if (!aaAcount) {
      throw new Error("Failed to retrieve AA account from chain");
    }
    if (explicitSignerData) {
      signerData = explicitSignerData;
    } else {
      const { accountNumber, sequence } = aaAcount;
      const chainId = await this.getChainId();
      signerData = {
        accountNumber,
        sequence,
        chainId
      };
    }
    const pubKeyBytes = import_bech32.bech32.fromWords(
      import_bech32.bech32.decode(accountFromSigner.address).words
    );
    const txBodyEncodeObject = {
      typeUrl: "/cosmos.tx.v1beta1.TxBody",
      value: {
        messages,
        memo: memo2
      }
    };
    const authInfo = makeAAuthInfo(aaAcount, Uint8Array.from(pubKeyBytes), fee);
    const bodyBytes = this.registry.encode(txBodyEncodeObject);
    const authInfoBytes = import_tx.AuthInfo.encode(authInfo).finish();
    const signDoc = import_tx.SignDoc.fromPartial({
      bodyBytes,
      authInfoBytes,
      chainId: signerData.chainId,
      accountNumber: BigInt(aaAcount.accountNumber)
    });
    const signature = await this.abstractSigner.signDirect(accountFromSigner.accountAddress, signDoc).then((sig) => {
      return Buffer.from(
        new Uint8Array([
          accountFromSigner.authenticatorId,
          ...Buffer.from(sig.signature.signature, "base64")
        ])
      ).toString("base64");
    });
    return import_tx.TxRaw.fromPartial({
      bodyBytes,
      authInfoBytes,
      signatures: [Buffer.from(signature, "base64")]
    });
  }
};
var AASigner = class {
  constructor(abstractAccount) {
    this.abstractAccount = abstractAccount;
  }
  /**
   * This method is to be implemented by every class that implements this interface
   * it will be used by the client to create the transaction AA signature
   * required to verify the transaction on the chain
   * This method should return a DirectSignResponse object but only the signature field is required
   * to be set
   * @param _signerAddress the abstract account address to be used as the signer
   * @param signDoc the sign doc to be signed
   * @returns
   */
  signDirect(_signerAddress, signDoc) {
    return Promise.resolve({
      signed: signDoc,
      signature: {
        signature: "",
        pub_key: {
          type: "tendermint/PubKeySecp256k1",
          value: new Uint8Array()
        }
      }
    });
  }
};
var AADefaultSigner = class extends AASigner {
  constructor(abstractAccount) {
    super(abstractAccount);
  }
  getAccounts() {
    throw new Error("Cannot get accounts from default signer");
  }
};
var AADirectSigner = class extends AASigner {
  constructor(initializedSigner, abstractAccount, accountAuthenticatorIndex, signArbFn, indexerUrl) {
    super(abstractAccount);
    this.signer = initializedSigner;
    this.accountAuthenticatorIndex = accountAuthenticatorIndex;
    this.signArbFn = signArbFn;
    this.indexerUrl = indexerUrl || "https://api.subquery.network/sq/burnt-labs/xion-indexer";
  }
  async signDirect(signerAddress, signDoc) {
    const signBytes = (0, import_proto_signing.makeSignBytes)(signDoc);
    const signature = await this.signArbFn(
      signDoc.chainId,
      signerAddress,
      signBytes
    );
    return {
      signed: signDoc,
      signature: {
        pub_key: {
          type: "tendermint/PubKeySecp256k1",
          value: ""
          // This doesn't matter. All we need is signature below
        },
        signature: signature.signature
      }
    };
  }
  async getAccounts() {
    const accounts = await this.signer.getAccounts();
    if (accounts.length === 0) {
      return [];
    }
    if (this.abstractAccount === void 0) {
      return accounts.map((account) => {
        return {
          ...account,
          authenticatorId: 0,
          accountAddress: account.address
        };
      });
    }
    return await getAAccounts(accounts, this.abstractAccount, this.indexerUrl);
  }
};
var AbstractAccountJWTSigner = class extends AASigner {
  constructor(abstractAccount, accountAuthenticatorIndex, sessionToken, indexerUrl, apiUrl) {
    super(abstractAccount);
    this.sessionToken = sessionToken;
    this.accountAuthenticatorIndex = accountAuthenticatorIndex;
    this.indexerUrl = indexerUrl || "https://api.subquery.network/sq/burnt-labs/xion-indexer";
    this.apiUrl = apiUrl || "https://aa.xion-testnet-1.burnt.com";
  }
  async getAccounts() {
    if (this.abstractAccount === void 0) {
      return [];
    }
    return [
      {
        address: this.abstractAccount,
        algo: "secp256k1",
        // we don't really care about this
        pubkey: new Uint8Array(),
        authenticatorId: await getAuthenticatorIdByAuthenticatorIndex(
          this.abstractAccount,
          this.accountAuthenticatorIndex,
          this.indexerUrl
        ),
        accountAddress: this.abstractAccount,
        aaalgo: "jwt"
        /* JWT */
      }
    ];
  }
  async signDirect(signerAddress, signDoc) {
    if (this.sessionToken === void 0) {
      throw new Error("stytch session token is undefined");
    }
    const signBytes = import_tx.SignDoc.encode(signDoc).finish();
    const hashSignBytes = (0, import_crypto.sha256)(signBytes);
    const message = Buffer.from(hashSignBytes).toString("base64");
    const authResponse = await fetch(
      `${this.apiUrl}/api/v1/sessions/authenticate`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({
          session_token: this.sessionToken,
          session_duration_minutes: 60 * 24 * 30,
          session_custom_claims: {
            transaction_hash: message
          }
        })
      }
    );
    if (!authResponse.ok) {
      throw new Error("Failed to authenticate with stytch");
    }
    const authResponseData = await authResponse.json();
    return {
      signed: signDoc,
      signature: {
        pub_key: {
          type: "",
          value: new Uint8Array()
        },
        signature: Buffer.from(
          authResponseData.data.session_jwt,
          "utf-8"
        ).toString("base64")
      }
    };
  }
  /**
   * This method allows for signing arbitrary messages
   * It does not compose a SignDoc but simply sets the transaction_hash
   * property of the session claims property to the hash of the passed msg
   * @param signerAddress
   * @param message Arbitrary message to be signed
   * @returns
   */
  async signDirectArb(message) {
    if (this.sessionToken === void 0) {
      throw new Error("stytch session token is undefined");
    }
    const hashSignBytes = (0, import_crypto.sha256)(Buffer.from(message, "utf-8"));
    const hashedMessage = Buffer.from(hashSignBytes).toString("base64");
    const authResponse = await fetch(
      `${this.apiUrl}/api/v1/sessions/authenticate`,
      {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify({
          session_token: this.sessionToken,
          session_duration_minutes: 60 * 24 * 30,
          session_custom_claims: {
            transaction_hash: hashedMessage
          }
        })
      }
    );
    if (!authResponse.ok) {
      throw new Error("Failed to authenticate with stytch");
    }
    const authResponseData = await authResponse.json();
    return {
      signature: Buffer.from(
        authResponseData.data.session_jwt,
        "utf-8"
      ).toString("base64")
    };
  }
};
var AAEthSigner = class extends AASigner {
  constructor(abstractAccount, accountAuthenticatorIndex, personalSign, indexerUrl) {
    super(abstractAccount);
    this.accountAuthenticatorIndex = accountAuthenticatorIndex;
    this.personalSign = personalSign;
    this.indexerUrl = indexerUrl || "https://api.subquery.network/sq/burnt-labs/xion-indexer";
  }
  async signDirect(signerAddress, signDoc) {
    const signBytes = (0, import_proto_signing.makeSignBytes)(signDoc);
    const signBytesHex = "0x" + encodeHex(signBytes);
    const signature = await this.personalSign(signBytesHex);
    const byteArray2 = new Uint8Array(
      signature.match(/[\da-f]{2}/gi).map((hex) => parseInt(hex, 16))
    );
    const base64String = btoa(
      String.fromCharCode.apply(null, byteArray2)
    );
    return {
      signed: signDoc,
      signature: {
        pub_key: {
          type: "tendermint/PubKeySecp256k1",
          value: ""
          // This doesn't matter. All we need is signature below
        },
        signature: base64String
      }
    };
  }
  async getAccounts() {
    if (this.abstractAccount === void 0) {
      return [];
    }
    return [
      {
        address: this.abstractAccount,
        algo: "secp256k1",
        // we don't really care about this
        pubkey: new Uint8Array(),
        authenticatorId: await getAuthenticatorIdByAuthenticatorIndex(
          this.abstractAccount,
          this.accountAuthenticatorIndex,
          this.indexerUrl
        ),
        accountAddress: this.abstractAccount,
        aaalgo: "EthWallet"
        /* ETHWALLET */
      }
    ];
  }
};

// node_modules/@burnt-labs/abstraxion-core/dist/index.mjs
init_dist();
var import_proto_signing2 = __toESM(require_build6(), 1);
var import_amino2 = __toESM(require_build5(), 1);
var import_utils15 = __toESM(require_build3(), 1);
var import_crypto2 = __toESM(require_build10(), 1);
var import_crypto3 = __toESM(require_build4(), 1);
var import_encoding = __toESM(require_build(), 1);
var import_cosmos = __toESM(require_build14(), 1);
var import_wallet = __toESM(require_wallet(), 1);
var GranteeSignerClient = class extends import_cosmwasm_stargate2.SigningCosmWasmClient {
  constructor(cometClient, signer, {
    granterAddress,
    granteeAddress,
    gasPrice,
    treasuryAddress,
    ...options
  }) {
    super(cometClient, signer, { ...options, gasPrice });
    __publicField(this, "granterAddress");
    __publicField(this, "_granteeAddress");
    __publicField(this, "_signer");
    __publicField(this, "_gasPrice");
    __publicField(this, "_treasury");
    __publicField(this, "_defaultGasMultiplier", 1.4);
    if (granterAddress === void 0) {
      throw new Error("granterAddress is required");
    }
    this.granterAddress = granterAddress;
    if (granteeAddress === void 0) {
      throw new Error("granteeAddress is required");
    }
    this._granteeAddress = granteeAddress;
    this._gasPrice = gasPrice;
    this._treasury = treasuryAddress;
    this._signer = signer;
  }
  // cosmjs 0.32.4 default
  get granteeAddress() {
    return this._granteeAddress;
  }
  async getGranteeAccountData() {
    return this._signer.getAccounts().then((accounts) => {
      for (const account of accounts) {
        if (account.address === this._granteeAddress) {
          return account;
        }
      }
    });
  }
  static async connectWithSigner(endpoint, signer, options) {
    const tmClient = await import_tendermint_rpc2.Tendermint37Client.connect(endpoint);
    return GranteeSignerClient.createWithSigner(tmClient, signer, options);
  }
  static async createWithSigner(cometClient, signer, options) {
    return new GranteeSignerClient(cometClient, signer, options);
  }
  async getAccount(searchAddress) {
    const account = await this.forceGetQueryClient().auth.account(searchAddress);
    if (!account) {
      return null;
    }
    return customAccountFromAny(account);
  }
  async signAndBroadcast(signerAddress, messages, fee, memo2 = "") {
    if (signerAddress === this.granterAddress) {
      signerAddress = this.granteeAddress;
      messages = [
        {
          typeUrl: "/cosmos.authz.v1beta1.MsgExec",
          value: import_tx4.MsgExec.fromPartial({
            grantee: this.granteeAddress,
            msgs: messages.map((msg) => this.registry.encodeAsAny(msg))
          })
        }
      ];
    }
    let usedFee;
    const granter = this._treasury ? this._treasury : this.granterAddress;
    if (fee == "auto" || typeof fee === "number") {
      if (!this._gasPrice) {
        throw new Error(
          "Gas price must be set in the client options when auto gas is used"
        );
      }
      const gasEstimation = await this.simulate(signerAddress, messages, memo2);
      const multiplier = typeof fee == "number" ? fee : this._defaultGasMultiplier;
      const calculatedFee = (0, import_stargate3.calculateFee)(
        Math.round(gasEstimation * multiplier),
        this._gasPrice
      );
      usedFee = {
        ...calculatedFee,
        granter
      };
    } else {
      usedFee = { ...fee, granter };
    }
    const txRaw = await this.sign(
      signerAddress,
      messages,
      usedFee,
      memo2,
      void 0
    );
    const txBytes = import_tx3.TxRaw.encode(txRaw).finish();
    return this.broadcastTx(
      txBytes,
      this.broadcastTimeoutMs,
      this.broadcastPollIntervalMs
    );
  }
  async sign(signerAddress, messages, fee, memo2, explicitSignerData) {
    if (signerAddress === this.granterAddress) {
      signerAddress = this.granteeAddress;
      messages = [
        {
          typeUrl: "/cosmos.authz.v1beta1.MsgExec",
          value: import_tx4.MsgExec.fromPartial({
            grantee: signerAddress,
            msgs: messages.map((msg) => this.registry.encodeAsAny(msg))
          })
        }
      ];
    }
    return super.sign(signerAddress, messages, fee, memo2, explicitSignerData);
  }
};
var serializationTypeV1 = "directsecp256k1hdwallet-v1";
var basicPasswordHashingOptions = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function isDerivationJson(thing) {
  if (!(0, import_utils15.isNonNullObject)(thing))
    return false;
  if (typeof thing.hdPath !== "string")
    return false;
  if (typeof thing.prefix !== "string")
    return false;
  return true;
}
var defaultOptions2 = {
  bip39Password: "",
  hdPaths: [(0, import_amino2.makeCosmoshubPath)(0)],
  prefix: "cosmos"
};
var SignArbSecp256k1HdWallet = class {
  constructor(mnemonic, options) {
    /** Base secret */
    __publicField(this, "secret");
    /** BIP39 seed */
    __publicField(this, "seed");
    /** Derivation instructions */
    __publicField(this, "accounts");
    __publicField(this, "signArb", async (signerAddress, message) => {
      const accounts = await this.getAccountsWithPrivkeys();
      const account = accounts.find(({ address }) => address === signerAddress);
      if (account === void 0) {
        throw new Error(`Address ${signerAddress} not found in wallet`);
      }
      const { privkey } = account;
      const signDoc = (0, import_cosmos.makeADR36AminoSignDoc)(signerAddress, message);
      const serializedSignDoc = (0, import_cosmos.serializeSignDoc)(signDoc);
      const digest = import_crypto2.Hash.sha256(serializedSignDoc);
      const cryptoPrivKey = new import_crypto2.PrivKeySecp256k1(privkey);
      const signature = cryptoPrivKey.signDigest32(digest);
      return Buffer$1.from(
        new Uint8Array([...signature.r, ...signature.s])
      ).toString("base64");
    });
    const prefix = options.prefix ?? defaultOptions2.prefix;
    const hdPaths = options.hdPaths ?? defaultOptions2.hdPaths;
    this.secret = mnemonic;
    this.seed = options.seed;
    this.accounts = hdPaths.map((hdPath) => ({
      hdPath,
      prefix
    }));
  }
  static async fromMnemonic(mnemonic, options = {}) {
    const mnemonicChecked = new import_crypto3.EnglishMnemonic(mnemonic);
    const seed = await import_crypto3.Bip39.mnemonicToSeed(
      mnemonicChecked,
      options.bip39Password
    );
    return new SignArbSecp256k1HdWallet(mnemonicChecked, {
      ...options,
      seed
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(length = 12, options = {}) {
    const entropyLength = 4 * Math.floor(11 * length / 33);
    const entropy = import_crypto3.Random.getBytes(entropyLength);
    const mnemonic = import_crypto3.Bip39.encode(entropy);
    return this.fromMnemonic(mnemonic.toString(), options);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password - The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(serialization, password) {
    const root2 = JSON.parse(serialization);
    if (!(0, import_utils15.isNonNullObject)(root2))
      throw new Error("Root document is not an object.");
    if (root2.type === serializationTypeV1) {
      return this.deserializeTypeV1(serialization, password);
    }
    throw new Error("Unsupported serialization type");
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(serialization, encryptionKey) {
    const root2 = JSON.parse(serialization);
    if (!(0, import_utils15.isNonNullObject)(root2))
      throw new Error("Root document is not an object.");
    const untypedRoot = root2;
    switch (untypedRoot.type) {
      case serializationTypeV1: {
        const decryptedBytes = await (0, import_wallet.decrypt)(
          (0, import_encoding.fromBase64)(untypedRoot.data),
          encryptionKey,
          untypedRoot.encryption
        );
        const decryptedDocument = JSON.parse((0, import_encoding.fromUtf8)(decryptedBytes));
        const { mnemonic, accounts } = decryptedDocument;
        (0, import_utils15.assert)(typeof mnemonic.data === "string");
        if (!Array.isArray(accounts))
          throw new Error("Property 'accounts' is not an array");
        if (!accounts.every((account) => isDerivationJson(account))) {
          throw new Error("Account is not in the correct format.");
        }
        const firstPrefix = accounts[0].prefix;
        if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
          throw new Error("Accounts do not all have the same prefix");
        }
        const hdPaths = accounts.map(
          ({ hdPath }) => (0, import_crypto3.stringToPath)(hdPath)
        );
        return this.fromMnemonic(mnemonic.data, {
          hdPaths,
          prefix: firstPrefix
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(serialization, password) {
    const root2 = JSON.parse(serialization);
    if (!(0, import_utils15.isNonNullObject)(root2))
      throw new Error("Root document is not an object.");
    const encryptionKey = await (0, import_wallet.executeKdf)(password, root2.kdf);
    return this.deserializeWithEncryptionKey(serialization, encryptionKey);
  }
  async getKeyPair(hdPath) {
    const { privkey } = import_crypto3.Slip10.derivePath(
      import_crypto3.Slip10Curve.Secp256k1,
      this.seed,
      hdPath
    );
    const { pubkey } = await import_crypto3.Secp256k1.makeKeypair(privkey);
    return {
      privkey,
      pubkey: import_crypto3.Secp256k1.compressPubkey(pubkey)
    };
  }
  async executeKdf(password, configuration) {
    switch (configuration.algorithm) {
      case "argon2id": {
        const options = configuration.params;
        if (!(0, import_crypto3.isArgon2idOptions)(options))
          throw new Error("Invalid format of argon2id params");
        return import_crypto3.Argon2id.execute(password, import_wallet.cosmjsSalt, options);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(password) {
    const kdfConfiguration = basicPasswordHashingOptions;
    const encryptionKey = await this.executeKdf(password, kdfConfiguration);
    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
    const dataToEncrypt = {
      mnemonic: this.secret,
      accounts: this.accounts.map(({ hdPath, prefix }) => ({
        hdPath: (0, import_crypto3.pathToString)(hdPath),
        prefix
      }))
    };
    const dataToEncryptRaw = (0, import_encoding.toUtf8)(JSON.stringify(dataToEncrypt));
    const encryptionConfiguration = {
      algorithm: import_wallet.supportedAlgorithms.xchacha20poly1305Ietf
    };
    const encryptedData = await (0, import_wallet.encrypt)(
      dataToEncryptRaw,
      encryptionKey,
      encryptionConfiguration
    );
    const out = {
      type: serializationTypeV1,
      kdf: kdfConfiguration,
      encryption: encryptionConfiguration,
      data: (0, import_encoding.toBase64)(encryptedData)
    };
    return JSON.stringify(out);
  }
  async getAccounts() {
    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
    return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
      algo,
      pubkey,
      address
    }));
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(
      this.accounts.map(async ({ hdPath, prefix }) => {
        const { privkey, pubkey } = await this.getKeyPair(hdPath);
        const address = (0, import_encoding.toBech32)(
          prefix,
          (0, import_amino2.rawSecp256k1PubkeyToRawAddress)(pubkey)
        );
        return {
          algo: "secp256k1",
          privkey,
          pubkey,
          address
        };
      })
    );
  }
  async signDirect(signerAddress, signDoc) {
    const accounts = await this.getAccountsWithPrivkeys();
    const account = accounts.find(({ address }) => address === signerAddress);
    if (account === void 0) {
      throw new Error(`Address ${signerAddress} not found in wallet`);
    }
    const { privkey, pubkey } = account;
    const signBytes = (0, import_proto_signing2.makeSignBytes)(signDoc);
    const hashedMessage = (0, import_crypto3.sha256)(signBytes);
    const signature = await import_crypto3.Secp256k1.createSignature(hashedMessage, privkey);
    const signatureBytes = new Uint8Array([
      ...signature.r(32),
      ...signature.s(32)
    ]);
    const stdSignature = (0, import_amino2.encodeSecp256k1Signature)(pubkey, signatureBytes);
    return {
      signed: signDoc,
      signature: stdSignature
    };
  }
};
var AbstraxionAuth = class {
  /**
   * Creates an instance of the AbstraxionAuth class.
   */
  constructor() {
    // Config
    __publicField(this, "rpcUrl");
    __publicField(this, "restUrl");
    __publicField(this, "grantContracts");
    __publicField(this, "stake");
    __publicField(this, "bank");
    __publicField(this, "callbackUrl");
    __publicField(this, "treasury");
    // Signer
    __publicField(this, "client");
    // Accounts
    __publicField(this, "abstractAccount");
    // State
    __publicField(this, "isLoginInProgress", false);
    __publicField(this, "isLoggedIn", false);
    __publicField(this, "authStateChangeSubscribers", []);
  }
  /**
   * Updates AbstraxionAuth instance with user config
   *
   * @param {string} rpc - The RPC URL used for communication with the blockchain.
   * @param {string} [restUrl] - The REST URL used for additional communication.
   * @param {ContractGrantDescription[]} [grantContracts] - Contracts for granting permissions.
   * @param {boolean} [stake] - Indicates whether staking is enabled.
   * @param {SpendLimit[]} [bank] - The spend limits for the user.
   * @param {string} callbackUrl - preferred callback url to override default
   * @param {string} treasury - treasury contract instance address
   */
  configureAbstraxionInstance(rpc, restUrl, grantContracts, stake, bank, callbackUrl, treasury) {
    this.rpcUrl = rpc;
    this.restUrl = restUrl;
    this.grantContracts = grantContracts;
    this.stake = stake;
    this.bank = bank;
    this.callbackUrl = callbackUrl;
    this.treasury = treasury;
  }
  /**
   * Subscribes to changes in authentication state.
   * When the authentication state changes, the provided callback function is invoked
   * with the new authentication state (isLoggedIn).
   * Returns an unsubscribe function that can be called to remove the subscription.
   *
   * @param {function} callback - A function to be invoked when the authentication state changes.
   *                             Receives a single parameter, isLoggedIn, indicating whether the user is logged in.
   *                             The callback should accept a boolean parameter.
   * @returns {function} - A function that, when called, removes the subscription to authentication state changes.
   *                      This function should be invoked to clean up the subscription when no longer needed.
   */
  subscribeToAuthStateChange(callback) {
    this.authStateChangeSubscribers.push(callback);
    return () => {
      const index2 = this.authStateChangeSubscribers.indexOf(callback);
      if (index2 !== -1) {
        this.authStateChangeSubscribers.splice(index2, 1);
      }
    };
  }
  /**
   * Triggers a change in authentication state and notifies all subscribers.
   *
   * @param {boolean} isLoggedIn - The new authentication state, indicating whether the user is logged in.
   */
  triggerAuthStateChange(isLoggedIn) {
    this.isLoggedIn = isLoggedIn;
    this.authStateChangeSubscribers.forEach((callback) => callback(isLoggedIn));
  }
  /**
   * Get the account address of the granter from persisted state.
   *
   * @returns {string} The account address of the granter wallet (XION Meta Account).
   */
  getGranter() {
    const granterAddress = localStorage.getItem("xion-authz-granter-account");
    if (!granterAddress || granterAddress === void 0 || granterAddress === "undefined") {
      return "";
    }
    return granterAddress;
  }
  /**
   * Remove persisted instance of granter account.
   */
  removeGranterAddress() {
    localStorage.removeItem("xion-authz-granter-account");
  }
  /**
   * Set a persisted instance for granter account.
   *
   * @param {string} address - account address of the granter wallet (XION Meta Account).
   */
  setGranter(address) {
    localStorage.setItem("xion-authz-granter-account", address);
  }
  /**
   * Get temp keypair from persisted state.
   */
  async getLocalKeypair() {
    const localKeypair = localStorage.getItem("xion-authz-temp-account");
    if (!localKeypair) {
      return void 0;
    }
    return await SignArbSecp256k1HdWallet.deserialize(
      localKeypair,
      "abstraxion"
    );
  }
  /**
   * Generate a new temp keypair and store in persisted state.
   */
  async generateAndStoreTempAccount() {
    const keypair = await SignArbSecp256k1HdWallet.generate(12, {
      prefix: "xion"
    });
    const serializedKeypair = await keypair.serialize("abstraxion");
    localStorage.setItem("xion-authz-temp-account", serializedKeypair);
    this.removeGranterAddress();
    return keypair;
  }
  /**
   * Get keypair account address.
   */
  async getKeypairAddress() {
    const keypair = await this.getLocalKeypair();
    if (!keypair)
      return "";
    const accounts = await keypair.getAccounts();
    const address = accounts[0].address;
    return address;
  }
  /**
   * Get GranteeSignerClient for the temp keypair.
   */
  async getSigner() {
    try {
      if (this.client) {
        return this.client;
      }
      if (!this.rpcUrl) {
        throw new Error("Configuration not initialized");
      }
      if (!this.abstractAccount) {
        throw new Error("No account found.");
      }
      const granterAddress = this.getGranter();
      if (!granterAddress) {
        throw new Error("No granter found.");
      }
      const granteeAddress = await this.abstractAccount.getAccounts().then((accounts) => {
        if (accounts.length === 0) {
          throw new Error("No account found.");
        }
        return accounts[0].address;
      });
      const directClient = await GranteeSignerClient.connectWithSigner(
        this.rpcUrl,
        this.abstractAccount,
        {
          gasPrice: import_stargate3.GasPrice.fromString("0uxion"),
          granterAddress,
          granteeAddress,
          treasuryAddress: this.treasury
        }
      );
      this.client = directClient;
      return directClient;
    } catch (error) {
      console.warn("Something went wrong getting signer: ", error);
      this.client = void 0;
      throw error;
    }
  }
  /**
   * Get dashboard url and redirect in order to issue claim with XION meta account for local keypair.
   */
  async redirectToDashboard() {
    try {
      if (!this.rpcUrl) {
        throw new Error("AbstraxionAuth needs to be configured.");
      }
      const userAddress = await this.getKeypairAddress();
      const { dashboardUrl } = await fetchConfig(this.rpcUrl);
      this.configureUrlAndRedirect(dashboardUrl, userAddress);
    } catch (error) {
      console.warn(
        "Something went wrong trying to redirect to XION dashboard: ",
        error
      );
    }
  }
  /**
   * Configure URL and redirect page
   */
  configureUrlAndRedirect(dashboardUrl, userAddress) {
    if (typeof window !== "undefined") {
      const currentUrl = this.callbackUrl || window.location.href;
      const urlParams = new URLSearchParams();
      if (this.treasury) {
        urlParams.set("treasury", this.treasury);
      }
      if (this.bank) {
        urlParams.set("bank", JSON.stringify(this.bank));
      }
      if (this.stake) {
        urlParams.set("stake", "true");
      }
      if (this.grantContracts) {
        urlParams.set("contracts", JSON.stringify(this.grantContracts));
      }
      urlParams.set("grantee", userAddress);
      urlParams.set("redirect_uri", currentUrl);
      const queryString = urlParams.toString();
      window.location.href = `${dashboardUrl}?${queryString}`;
    } else {
      console.warn("Window not defined. Cannot redirect to dashboard");
    }
  }
  /**
   * Poll for grants issued to a grantee from a granter.
   *
   * @param {string} grantee - The address of the grantee.
   * @param {string | null} granter - The address of the granter, or null if not available.
   * @returns {Promise<boolean>} A Promise that resolves to true if grants are found, otherwise false.
   * @throws {Error} If the grantee or granter address is invalid, or if maximum retries are exceeded.
   */
  async pollForGrants(grantee, granter) {
    if (!this.rpcUrl) {
      throw new Error("AbstraxionAuth needs to be configured.");
    }
    if (!grantee) {
      throw new Error("No keypair address");
    }
    if (!granter) {
      throw new Error("No granter address");
    }
    const pollBaseUrl = this.restUrl || (await fetchConfig(this.rpcUrl)).restUrl;
    const maxRetries = 5;
    let retries = 0;
    while (retries < maxRetries) {
      try {
        const baseUrl = `${pollBaseUrl}/cosmos/authz/v1beta1/grants`;
        const url = new URL(baseUrl);
        const params = new URLSearchParams({
          grantee,
          granter
        });
        url.search = params.toString();
        const res = await fetch(url, {
          cache: "no-store"
        });
        const data = await res.json();
        if (data.grants.length === 0) {
          console.warn("No grants found.");
          return false;
        }
        const currentTime = (/* @__PURE__ */ new Date()).toISOString();
        const validGrant = data.grants.some((grant) => {
          const { expiration } = grant;
          return !expiration || expiration > currentTime;
        });
        return validGrant;
      } catch (error) {
        console.warn("Error fetching grants: ", error);
        const delay = Math.pow(2, retries) * 1e3;
        await new Promise((resolve) => setTimeout(resolve, delay));
        retries++;
      }
    }
    console.error("Max retries exceeded, giving up.");
    return false;
  }
  /**
   * Wipe persisted state and instance variables.
   */
  logout() {
    localStorage.removeItem("xion-authz-temp-account");
    localStorage.removeItem("xion-authz-granter-account");
    this.abstractAccount = void 0;
    this.triggerAuthStateChange(false);
  }
  /**
   * Authenticates the user based on the presence of a local keypair and a granter address.
   * Also checks if the grant is still valid by verifying the expiration.
   * If valid, sets the abstract account and triggers authentication state change.
   * If expired, clears local state and prompts reauthorization.
   *
   * @returns {Promise<void>} - Resolves if authentication is successful or logs out the user otherwise.
   */
  async authenticate() {
    try {
      const keypair = await this.getLocalKeypair();
      const granter = this.getGranter();
      if (!keypair || !granter) {
        console.warn("Missing keypair or granter, cannot authenticate.");
        return;
      }
      const accounts = await keypair.getAccounts();
      const keypairAddress = accounts[0].address;
      const isGrantValid = await this.pollForGrants(keypairAddress, granter);
      if (isGrantValid) {
        this.abstractAccount = keypair;
        this.triggerAuthStateChange(true);
      } else {
        throw new Error("Grant expired or not found. Logging out.");
      }
    } catch (error) {
      console.error("Error during authentication:", error);
      this.logout();
    }
  }
  /**
   * Initiates the login process for the user.
   * Checks if a local keypair and granter address exist, either from URL parameters or localStorage.
   * If both exist, polls for grants and updates the authentication state if successful.
   * If not, generates a new keypair and redirects to the dashboard for grant issuance.
   *
   * @returns {Promise<void>} - A Promise that resolves once the login process is complete.
   * @throws {Error} - If the login process encounters an error.
   */
  async login() {
    try {
      if (this.isLoginInProgress) {
        console.warn("Login is already in progress.");
        return;
      }
      this.isLoginInProgress = true;
      const keypair = await this.getLocalKeypair();
      const searchParams = new URLSearchParams(window.location.search);
      const granter = this.getGranter() || searchParams.get("granter");
      if (keypair && granter) {
        const accounts = await keypair.getAccounts();
        const keypairAddress = accounts[0].address;
        const pollSuccess = await this.pollForGrants(keypairAddress, granter);
        if (!pollSuccess) {
          throw new Error("Poll was unsuccessful. Please try again");
        }
        this.setGranter(granter);
        this.abstractAccount = keypair;
        this.triggerAuthStateChange(true);
        if (typeof window !== void 0) {
          const currentUrl = new URL(window.location.href);
          currentUrl.searchParams.delete("granted");
          currentUrl.searchParams.delete("granter");
          history.pushState({}, "", currentUrl.href);
        }
      } else {
        await this.newKeypairFlow();
      }
      return;
    } catch (error) {
      console.warn("Something went wrong: ", error);
      throw error;
    } finally {
      this.isLoginInProgress = false;
    }
  }
  /**
   * Initiates the flow to generate a new keypair and redirect to the dashboard for grant issuance.
   */
  async newKeypairFlow() {
    try {
      await this.generateAndStoreTempAccount();
      await this.redirectToDashboard();
    } catch (error) {
      console.warn("Something went wrong: ", error);
      throw error;
    }
  }
};

// node_modules/@burnt-labs/abstraxion/dist/index.mjs
var import_cosmwasm_stargate3 = __toESM(require_build9(), 1);
var AbstraxionContext = (0, import_react8.createContext)(
  {}
);
function AbstraxionContextProvider({
  children,
  contracts,
  rpcUrl = testnetChainInfo.rpc,
  restUrl = testnetChainInfo.rest,
  stake = false,
  bank,
  callbackUrl,
  treasury,
  gasPrice
}) {
  const [abstraxionError, setAbstraxionError] = (0, import_react8.useState)("");
  const [isConnected, setIsConnected] = (0, import_react8.useState)(false);
  const [isConnecting, setIsConnecting] = (0, import_react8.useState)(false);
  const [showModal, setShowModal] = (0, import_react8.useState)(false);
  const [abstraxionAccount, setAbstraxionAccount] = (0, import_react8.useState)(void 0);
  const [granterAddress, setGranterAddress] = (0, import_react8.useState)("");
  const [dashboardUrl, setDashboardUrl] = (0, import_react8.useState)("");
  let gasPriceDefault;
  const { gasPrice: gasPriceConstant } = xionGasValues;
  if (rpcUrl.includes("mainnet")) {
    gasPriceDefault = import_stargate4.GasPrice.fromString(gasPriceConstant);
  } else {
    gasPriceDefault = import_stargate4.GasPrice.fromString("0.001uxion");
  }
  const configureInstance = (0, import_react8.useCallback)(() => {
    abstraxionAuth.configureAbstraxionInstance(
      rpcUrl,
      restUrl || "",
      contracts,
      stake,
      bank,
      callbackUrl,
      treasury
    );
  }, [rpcUrl, restUrl, contracts, stake, bank, callbackUrl, treasury]);
  (0, import_react8.useEffect)(() => {
    configureInstance();
  }, [configureInstance]);
  (0, import_react8.useEffect)(() => {
    const searchParams = new URLSearchParams(window.location.search);
    if (searchParams.get("granted") === "true") {
      setShowModal(true);
    }
  }, []);
  (0, import_react8.useEffect)(() => {
    const unsubscribe = abstraxionAuth.subscribeToAuthStateChange(
      async (newState) => {
        if (newState !== isConnected) {
          setIsConnected(newState);
          if (newState) {
            const account = await abstraxionAuth.getLocalKeypair();
            const granterAddress2 = abstraxionAuth.getGranter();
            setAbstraxionAccount(account);
            setGranterAddress(granterAddress2);
          }
        }
      }
    );
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, [isConnected, abstraxionAuth]);
  const persistAuthenticateState = (0, import_react8.useCallback)(async () => {
    await abstraxionAuth.authenticate();
  }, [abstraxionAuth]);
  (0, import_react8.useEffect)(() => {
    if (!isConnecting && !abstraxionAccount && !granterAddress) {
      persistAuthenticateState();
    }
  }, [
    isConnecting,
    abstraxionAccount,
    granterAddress,
    persistAuthenticateState
  ]);
  const logout = (0, import_react8.useCallback)(() => {
    setIsConnected(false);
    setAbstraxionAccount(void 0);
    setGranterAddress("");
    abstraxionAuth == null ? void 0 : abstraxionAuth.logout();
  }, [abstraxionAuth]);
  return (0, import_jsx_runtime30.jsx)(
    AbstraxionContext.Provider,
    {
      value: {
        isConnected,
        setIsConnected,
        isConnecting,
        setIsConnecting,
        abstraxionError,
        setAbstraxionError,
        abstraxionAccount,
        setAbstraxionAccount,
        granterAddress,
        showModal,
        setShowModal,
        setGranterAddress,
        contracts,
        dashboardUrl,
        setDashboardUrl,
        rpcUrl,
        restUrl,
        stake,
        bank,
        treasury,
        logout,
        gasPrice: gasPrice ? import_stargate4.GasPrice.fromString(gasPrice) : gasPriceDefault
      },
      children
    }
  );
}
function ErrorDisplay() {
  return (0, import_jsx_runtime30.jsxs)("div", { className: "ui-flex ui-h-full ui-w-full ui-flex-col ui-items-start ui-justify-center ui-gap-4 ui-p-8 ui-text-center", children: [
    (0, import_jsx_runtime30.jsx)("h1", { className: "ui-text-3xl ui-font-bold ui-uppercase ui-tracking-tighter ui-text-white", children: "Oops! Something went wrong..." }),
    (0, import_jsx_runtime30.jsx)("h2", { className: "ui-tracking-tight ui-text-neutral-500", children: "Please try refreshing the page. If the problem continues, check your internet connection or try again later." }),
    (0, import_jsx_runtime30.jsx)(
      Button,
      {
        structure: "naked",
        fullWidth: true,
        onClick: () => {
          const currentUrl = new URL(window.location.href);
          currentUrl.searchParams.delete("granted");
          currentUrl.searchParams.delete("granter");
          history.pushState({}, "", currentUrl.href);
          window.location.reload();
        },
        children: "Refresh the page"
      }
    )
  ] });
}
var Loading = () => {
  return (0, import_jsx_runtime30.jsxs)(ModalSection, { children: [
    (0, import_jsx_runtime30.jsxs)("div", { className: "ui-flex ui-flex-col ui-w-full ui-text-center", children: [
      (0, import_jsx_runtime30.jsx)("h1", { className: "ui-w-full ui-tracking-tighter ui-text-3xl ui-font-bold ui-text-white ui-uppercase ui-mb-3", children: "Connecting..." }),
      (0, import_jsx_runtime30.jsx)("h2", { className: "ui-w-full ui-tracking-tighter ui-text-sm ui-mb-4 ui-text-neutral-500", children: "Signing you in... Don’t close the window." })
    ] }),
    (0, import_jsx_runtime30.jsx)("div", { className: "ui-flex ui-h-full ui-w-full ui-items-center ui-justify-center ui-text-white", children: (0, import_jsx_runtime30.jsx)(Spinner, {}) })
  ] });
};
function AbstraxionSignin() {
  const { isConnecting, setShowModal, setIsConnecting, setAbstraxionError } = (0, import_react8.useContext)(AbstraxionContext);
  const isMounted = (0, import_react8.useRef)(false);
  const retryRedirect = async () => {
    abstraxionAuth.redirectToDashboard();
  };
  (0, import_react8.useEffect)(() => {
    async function onStartup() {
      try {
        if (!abstraxionAuth) {
          throw new Error("abstraxion-core not initialized");
        }
        setIsConnecting(true);
        await abstraxionAuth.login();
      } catch (error) {
        console.warn("Something went wrong: ", error);
        setAbstraxionError(error.message);
      } finally {
        setIsConnecting(false);
        setShowModal(false);
      }
    }
    if (!isMounted.current) {
      onStartup();
    }
    isMounted.current = true;
  }, []);
  if (isConnecting) {
    return (0, import_jsx_runtime30.jsx)(Loading, {});
  }
  return (0, import_jsx_runtime30.jsxs)(ModalSection, { className: "ui-items-center", children: [
    (0, import_jsx_runtime30.jsxs)("div", { className: "ui-flex ui-flex-col ui-w-full ui-text-center", children: [
      (0, import_jsx_runtime30.jsx)("h1", { className: "ui-w-full ui-tracking-tighter ui-text-3xl ui-font-bold ui-text-white ui-uppercase ui-mb-3", children: "Secure account creation" }),
      (0, import_jsx_runtime30.jsx)("h2", { className: "ui-w-full ui-tracking-tighter ui-text-sm ui-mb-4 ui-text-neutral-500", children: "Please switch to the newly opened tab and enter your credentials to securely complete your account creation" })
    ] }),
    (0, import_jsx_runtime30.jsx)(BrowserIcon, {}),
    (0, import_jsx_runtime30.jsx)(Button, { onClick: retryRedirect, structure: "naked", children: "Have a Problem? Try Again" })
  ] });
}
function Connected({ onClose }) {
  const { logout } = (0, import_react8.useContext)(AbstraxionContext);
  function handleLogout() {
    logout();
    onClose();
  }
  return (0, import_jsx_runtime30.jsx)(ModalSection, { children: (0, import_jsx_runtime30.jsxs)("div", { className: "ui-flex ui-flex-col ui-h-full ui-w-full ui-items-center ui-justify-center ui-text-white", children: [
    (0, import_jsx_runtime30.jsx)("h1", { className: "ui-tracking-tighter ui-text-3xl ui-font-bold ui-text-white ui-uppercase ui-mb-3", children: "Connected" }),
    (0, import_jsx_runtime30.jsx)("div", { className: "ui-my-4 ui-w-full", children: (0, import_jsx_runtime30.jsx)(Button, { fullWidth: true, onClick: onClose, children: "Close" }) }),
    (0, import_jsx_runtime30.jsx)(Button, { fullWidth: true, onClick: handleLogout, structure: "destructive", children: "Logout" })
  ] }) });
}
var abstraxionAuth = new AbstraxionAuth();
function Abstraxion({ onClose }) {
  const {
    abstraxionAccount,
    abstraxionError,
    isConnected,
    showModal,
    setShowModal
  } = (0, import_react8.useContext)(AbstraxionContext);
  const closeOnEscKey = (0, import_react8.useCallback)(
    (e) => {
      if (e.key === "Escape") {
        onClose();
        setShowModal(false);
      }
    },
    [onClose, setShowModal]
  );
  (0, import_react8.useEffect)(() => {
    document.addEventListener("keydown", closeOnEscKey);
    return () => {
      document.removeEventListener("keydown", closeOnEscKey);
    };
  }, [closeOnEscKey]);
  if (!showModal)
    return null;
  return (0, import_jsx_runtime30.jsx)(Dialog2, { onOpenChange: onClose, open: showModal, children: (0, import_jsx_runtime30.jsx)(DialogContent2, { children: abstraxionError ? (0, import_jsx_runtime30.jsx)(ErrorDisplay, {}) : abstraxionAccount || isConnected ? (0, import_jsx_runtime30.jsx)(Connected, { onClose }) : !abstraxionAccount ? (0, import_jsx_runtime30.jsx)(AbstraxionSignin, {}) : null }) });
}
function AbstraxionProvider({
  children,
  config
}) {
  return (0, import_jsx_runtime30.jsx)(
    AbstraxionContextProvider,
    {
      contracts: config.contracts,
      rpcUrl: config.rpcUrl,
      restUrl: config.restUrl,
      stake: config.stake,
      bank: config.bank,
      callbackUrl: config.callbackUrl,
      treasury: config.treasury,
      gasPrice: config.gasPrice,
      children
    }
  );
}
var useAbstraxionAccount = () => {
  const { isConnected, granterAddress, isConnecting } = (0, import_react8.useContext)(AbstraxionContext);
  return {
    data: {
      bech32Address: granterAddress
    },
    isConnected,
    isConnecting
  };
};
var useAbstraxionSigningClient = () => {
  const {
    isConnected,
    abstraxionAccount,
    granterAddress,
    rpcUrl,
    logout,
    gasPrice,
    treasury
  } = (0, import_react8.useContext)(AbstraxionContext);
  const [signArbWallet, setSignArbWallet] = (0, import_react8.useState)(void 0);
  const [abstractClient, setAbstractClient] = (0, import_react8.useState)(void 0);
  (0, import_react8.useEffect)(() => {
    async function getSigner() {
      try {
        if (!abstraxionAccount) {
          throw new Error("No account found.");
        }
        if (!granterAddress) {
          throw new Error("No granter found.");
        }
        const granteeAddress = await abstraxionAccount.getAccounts().then((accounts) => {
          if (accounts.length === 0) {
            throw new Error("No account found.");
          }
          return accounts[0].address;
        });
        const directClient = await GranteeSignerClient.connectWithSigner(
          // Should be set in the context but defaulting here just in case
          rpcUrl || testnetChainInfo.rpc,
          abstraxionAccount,
          {
            gasPrice,
            granterAddress,
            granteeAddress,
            treasuryAddress: treasury
          }
        );
        const wallet2 = await abstraxionAuth.getLocalKeypair();
        if (wallet2) {
          setSignArbWallet(wallet2);
        }
        setAbstractClient(directClient);
      } catch (error) {
        setAbstractClient(void 0);
      }
    }
    getSigner();
  }, [isConnected, abstraxionAccount, granterAddress, abstraxionAuth]);
  return {
    client: abstractClient,
    signArb: signArbWallet == null ? void 0 : signArbWallet.signArb,
    logout
  };
};
var useAbstraxionClient = () => {
  const { rpcUrl } = (0, import_react8.useContext)(AbstraxionContext);
  const [abstractClient, setAbstractClient] = (0, import_react8.useState)(void 0);
  (0, import_react8.useEffect)(() => {
    async function getClient() {
      try {
        const client = await import_cosmwasm_stargate3.CosmWasmClient.connect(
          // Should be set in the context but defaulting here just in case
          rpcUrl || testnetChainInfo.rpc
        );
        setAbstractClient(client);
      } catch (error) {
        setAbstractClient(void 0);
      }
    }
    getClient();
  }, [rpcUrl]);
  return {
    client: abstractClient
  };
};
var useModal = () => {
  const { showModal, setShowModal } = (0, import_react8.useContext)(AbstraxionContext);
  return [showModal, setShowModal];
};

export {
  Abstraxion,
  AbstraxionProvider,
  useAbstraxionAccount,
  useAbstraxionSigningClient,
  useAbstraxionClient,
  useModal
};
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/poseidon.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/poseidon.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)

tough-cookie/lib/pubsuffix-psl.js:
  (*!
   * Copyright (c) 2018, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/store.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/permuteDomain.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/pathMatch.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/memstore.js:
  (*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

tough-cookie/lib/cookie.js:
  (*!
   * Copyright (c) 2015-2020, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   *)

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

@burnt-labs/signers/dist/index.mjs:
  (*! Bundled license information:
  
  long/index.js:
    (**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     *)
  *)
*/
//# sourceMappingURL=chunk-XP2G3VFJ.js.map
