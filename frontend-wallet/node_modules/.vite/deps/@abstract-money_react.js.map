{
  "version": 3,
  "sources": ["../../use-sync-external-store/cjs/use-sync-external-store-shim.production.js", "../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js", "../../@abstract-money/react/dist/index.js", "../../@abstract-money/react/dist/chunk-2MJQ2BBI.js", "../../@abstract-money/react/node_modules/@tanstack/react-query/build/lib/index.mjs", "../../@abstract-money/react/node_modules/@tanstack/query-core/build/lib/index.mjs", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/subscribable.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/utils.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/focusManager.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/onlineManager.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/retryer.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/logger.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/notifyManager.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/mutation.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/queryObserver.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/mutationObserver.ts", "../../@abstract-money/react/node_modules/@tanstack/query-core/src/hydration.ts", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/reactBatchedUpdates.ts", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/setBatchUpdatesFn.ts", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/useSyncExternalStore.ts", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/QueryClientProvider.tsx", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/isRestoring.tsx", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/QueryErrorResetBoundary.tsx", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/utils.ts", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/errorBoundaryUtils.ts", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/suspense.ts", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/useBaseQuery.ts", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/useQuery.ts", "../../@abstract-money/react/node_modules/@tanstack/react-query/src/useMutation.ts"],
  "sourcesContent": ["/**\n * @license React\n * use-sync-external-store-shim.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useState = React.useState,\n  useEffect = React.useEffect,\n  useLayoutEffect = React.useLayoutEffect,\n  useDebugValue = React.useDebugValue;\nfunction useSyncExternalStore$2(subscribe, getSnapshot) {\n  var value = getSnapshot(),\n    _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }),\n    inst = _useState[0].inst,\n    forceUpdate = _useState[1];\n  useLayoutEffect(\n    function () {\n      inst.value = value;\n      inst.getSnapshot = getSnapshot;\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n    },\n    [subscribe, value, getSnapshot]\n  );\n  useEffect(\n    function () {\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      return subscribe(function () {\n        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      });\n    },\n    [subscribe]\n  );\n  useDebugValue(value);\n  return value;\n}\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  inst = inst.value;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(inst, nextValue);\n  } catch (error) {\n    return !0;\n  }\n}\nfunction useSyncExternalStore$1(subscribe, getSnapshot) {\n  return getSnapshot();\n}\nvar shim =\n  \"undefined\" === typeof window ||\n  \"undefined\" === typeof window.document ||\n  \"undefined\" === typeof window.document.createElement\n    ? useSyncExternalStore$1\n    : useSyncExternalStore$2;\nexports.useSyncExternalStore =\n  void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n", "/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "\"use client\";\nimport {\n  AbstractProvider,\n  useAbstractModuleVersion,\n  useAccountAddress,\n  useAccountAddressFromApi,\n  useAccountBalancesFromApi,\n  useAccountSettings,\n  useAccounts,\n  useAccountsAddressesFromApi,\n  useAnsTokenFromApi,\n  useClaimNamespace,\n  useConfig,\n  useCosmWasmClient,\n  useCreateAccount,\n  useCreateAccountMonarchy,\n  useCreateRemoteAccount,\n  useCreateSubAccount,\n  useDeposit,\n  useEnableIbc,\n  useExecute,\n  useExecuteOnRemote,\n  useExecuteOnRemoteModule,\n  useExecuteRemote,\n  useInstallModules,\n  useModuleInstantiate2Address,\n  useModuleInstantiate2AddressFromApi,\n  useModules,\n  useModulesFromApi,\n  usePredictAccountAddress,\n  usePredictModuleAddress,\n  useQuery,\n  useRemoteAccountIds,\n  useRemoteAccounts,\n  useRemoteHosts,\n  useRequestRemoteFunds,\n  useSendFunds,\n  useSendFundsToRemote,\n  useSenderAddress,\n  useSignAndBroadcast,\n  useSigningCosmWasmClient,\n  useSimulateExecuteRemoteAccount,\n  useSimulateRemoteMsg,\n  useSmartQuery,\n  useSubAccountIdsByModuleIdFromApi,\n  useSubAccountIdsFromApi,\n  useUpdateInfo,\n  useUpdateSettings,\n  useUpdateStatus,\n  useUpgradeModule,\n  useUpgradeModules,\n  useUseSendFundsToRemote,\n  useWithdraw\n} from \"./chunk-2MJQ2BBI.js\";\n\n// src/utils/use-abstract-module-client.ts\nimport * as React from \"react\";\nasync function getAbstractModuleClient({\n  accountPublicClient,\n  accountWalletClient,\n  moduleId,\n  Module\n}) {\n  return new Module({\n    accountPublicClient,\n    accountWalletClient,\n    moduleId\n  });\n}\nfunction useAbstractModuleClient({\n  accountId,\n  moduleId,\n  chainName,\n  Module,\n  query = {},\n  sender: _sender\n}) {\n  const { useAccountWalletClient, useAccountPublicClient } = useConfig();\n  const accountPublicClient = useAccountPublicClient({\n    accountId,\n    chainName\n  });\n  const accountWalletClient = useAccountWalletClient({\n    accountId,\n    chainName\n  });\n  const queryKey = React.useMemo(\n    () => [\"module-mutation-client\", moduleId, accountId, Module],\n    [moduleId, accountId, Module]\n  );\n  const queryFn = React.useCallback(() => {\n    if (!accountPublicClient)\n      throw new Error(\"accountPublicClient is not defined\");\n    if (!accountWalletClient)\n      throw new Error(\"accountWalletClient is not defined\");\n    return getAbstractModuleClient({\n      accountPublicClient,\n      accountWalletClient,\n      moduleId,\n      Module\n    });\n  }, [accountPublicClient, accountWalletClient, moduleId, Module]);\n  const enabled = Boolean(accountWalletClient && (query.enabled ?? true));\n  const {\n    data,\n    isLoading: isAbstractModuleClientLoading,\n    isError: isAbstractModuleClientError,\n    error: abstractModuleClientError\n  } = useQuery({ queryKey, queryFn, ...query, enabled });\n  if (!enabled)\n    return {\n      data: void 0,\n      isLoading: true,\n      isError: false,\n      isSuccess: false,\n      error: void 0\n    };\n  if (isAbstractModuleClientError)\n    return {\n      data: void 0,\n      isLoading: false,\n      isError: true,\n      isSuccess: false,\n      error: abstractModuleClientError\n    };\n  if (isAbstractModuleClientLoading)\n    return {\n      data: void 0,\n      isLoading: true,\n      isError: false,\n      isSuccess: false\n    };\n  return {\n    data,\n    isLoading: false,\n    isError: false,\n    isSuccess: true\n  };\n}\n\n// src/utils/use-abstract-module-query-client.ts\nimport * as React2 from \"react\";\nasync function getAbstractModuleQueryClient({\n  accountPublicClient,\n  moduleId,\n  Module\n}) {\n  return new Module({\n    accountPublicClient,\n    moduleId\n  });\n}\nfunction useAbstractModuleQueryClient({\n  accountId,\n  chainName,\n  moduleId,\n  Module,\n  query = {}\n}) {\n  const { apiUrl, useAccountPublicClient } = useConfig();\n  const accountPublicClient = useAccountPublicClient({\n    accountId,\n    chainName\n  });\n  const queryKey = React2.useMemo(\n    () => [\"module-query-client\", moduleId, Module, accountPublicClient],\n    [moduleId, accountId, accountPublicClient]\n  );\n  const queryFn = React2.useCallback(() => {\n    if (!accountPublicClient)\n      throw new Error(\"client is not defined\");\n    return getAbstractModuleQueryClient({\n      accountPublicClient,\n      overrideApiUrl: apiUrl,\n      moduleId,\n      Module\n    });\n  }, [accountPublicClient, apiUrl, accountId, moduleId, Module]);\n  const enabled = Boolean(\n    accountPublicClient && accountId && (query.enabled ?? true)\n  );\n  const {\n    data,\n    isLoading: isAbstractModuleQueryClientLoading,\n    isError: isAbstractModuleQueryClientError,\n    error: abstractModuleQueryClientError\n  } = useQuery({ queryKey, queryFn, ...query, enabled });\n  if (!enabled)\n    return {\n      data: void 0,\n      isLoading: true,\n      isError: false,\n      isSuccess: false,\n      error: void 0\n    };\n  if (isAbstractModuleQueryClientError)\n    return {\n      data: void 0,\n      isLoading: false,\n      isError: true,\n      isSuccess: false,\n      error: abstractModuleQueryClientError\n    };\n  if (isAbstractModuleQueryClientLoading)\n    return {\n      data: void 0,\n      isLoading: true,\n      isError: false,\n      isSuccess: false\n    };\n  return {\n    data,\n    isLoading: false,\n    isError: false,\n    isSuccess: true\n  };\n}\n\n// src/utils/use-module-client.ts\nimport * as React3 from \"react\";\nfunction useModuleClient(parameters) {\n  const { contractAddress, Module, chainName, sender: sender_ } = parameters;\n  const {\n    data: client,\n    isLoading: isSigningCosmWasmClientLoading,\n    isError: isSigningCosmWasmClientError,\n    error: signingCosmWasmClientError\n  } = useSigningCosmWasmClient({ chainName });\n  const {\n    data: sender,\n    isLoading: isSenderAddressLoading,\n    isError: isSenderAddressError,\n    error: senderAddressError\n  } = useSenderAddress({ chainName });\n  const data = React3.useMemo(() => {\n    if (!client || !contractAddress)\n      return void 0;\n    if (!sender_ && !sender || !sender)\n      return void 0;\n    return new Module(\n      client,\n      sender_ ?? sender,\n      contractAddress\n    );\n  }, [client, contractAddress]);\n  if (isSigningCosmWasmClientError)\n    return {\n      data: void 0,\n      isLoading: false,\n      isError: true,\n      isSuccess: false,\n      error: signingCosmWasmClientError\n    };\n  if (isSenderAddressError)\n    return {\n      data: void 0,\n      isLoading: false,\n      isError: true,\n      isSuccess: false,\n      error: senderAddressError\n    };\n  if (isSigningCosmWasmClientLoading || isSenderAddressLoading)\n    return {\n      data: void 0,\n      isLoading: true,\n      isError: false,\n      isSuccess: false\n    };\n  return {\n    data,\n    isLoading: false,\n    isError: false,\n    isSuccess: true\n  };\n}\n\n// src/utils/use-module-query-client.ts\nimport * as React4 from \"react\";\nfunction useModuleQueryClient(parameters) {\n  const { contractAddress, Module, chainName } = parameters;\n  const { data: client, ...rest } = useCosmWasmClient({ chainName });\n  const queryClient = React4.useMemo(() => {\n    if (!client || !contractAddress)\n      return void 0;\n    return new Module(client, contractAddress);\n  }, [client, contractAddress]);\n  return { data: queryClient, ...rest };\n}\n\n// src/create-config.ts\nimport {\n  ABSTRACT_API_URL,\n  createAccountPublicClient,\n  createAccountWalletClient,\n  createApiClient,\n  createPublicClient,\n  createWalletClient\n} from \"@abstract-money/core\";\nimport { useMemo as useMemo5 } from \"react\";\nfunction createConfig(parameters) {\n  const { apiUrl = ABSTRACT_API_URL, provider } = parameters;\n  function useApiClient() {\n    return useMemo5(\n      () => createApiClient({\n        apiUrl\n      }),\n      [apiUrl]\n    );\n  }\n  function usePublicClient(...args) {\n    const cosmWasmClient = provider.useCosmWasmClient(...args);\n    return useMemo5(() => {\n      if (!cosmWasmClient) {\n        console.debug(\"usePublicClient: no cosmWasmClient\");\n        return void 0;\n      }\n      return createPublicClient({\n        apiUrl,\n        cosmWasmClient\n      });\n    }, [apiUrl, cosmWasmClient]);\n  }\n  function useWalletClient(...args) {\n    const signingCosmWasmClient = provider.useSigningCosmWasmClient(...args);\n    const sender = provider.useSenderAddress(...args);\n    return useMemo5(() => {\n      if (!signingCosmWasmClient || !sender) {\n        console.debug(\"useWalletClient: no signingCosmWasmClient or sender\", {\n          signingCosmWasmClient,\n          sender\n        });\n        return void 0;\n      }\n      return createWalletClient({\n        apiUrl,\n        sender,\n        signingCosmWasmClient\n      });\n    }, [apiUrl, signingCosmWasmClient, sender]);\n  }\n  function useAccountPublicClient({\n    accountId,\n    ...rest\n  }) {\n    const cosmWasmClient = provider.useCosmWasmClient(rest);\n    return useMemo5(() => {\n      if (!cosmWasmClient || !accountId) {\n        console.debug(\n          \"useAccountPublicClient: no cosmWasmClient or accountId\",\n          {\n            cosmWasmClient,\n            accountId\n          }\n        );\n        return void 0;\n      }\n      return createAccountPublicClient({\n        apiUrl,\n        cosmWasmClient,\n        accountId\n      });\n    }, [apiUrl, cosmWasmClient, accountId]);\n  }\n  function useAccountWalletClient({\n    accountId,\n    ...rest\n  }) {\n    const signingCosmWasmClient = provider.useSigningCosmWasmClient(rest);\n    const sender = provider.useSenderAddress(rest);\n    return useMemo5(() => {\n      if (!signingCosmWasmClient || !sender || !accountId) {\n        console.debug(\n          \"useAccountWalletClient: no signingCosmWasmClient, sender, or accountId\",\n          {\n            signingCosmWasmClient,\n            sender,\n            accountId\n          }\n        );\n        return void 0;\n      }\n      return createAccountWalletClient({\n        apiUrl,\n        sender,\n        signingCosmWasmClient,\n        accountId\n      });\n    }, [apiUrl, signingCosmWasmClient, sender, accountId]);\n  }\n  return {\n    apiUrl,\n    provider,\n    useApiClient,\n    usePublicClient,\n    useWalletClient,\n    useAccountPublicClient,\n    useAccountWalletClient\n  };\n}\nexport {\n  AbstractProvider,\n  createConfig,\n  useAbstractModuleClient,\n  useAbstractModuleQueryClient,\n  useAbstractModuleVersion,\n  useAccountAddress,\n  useAccountAddressFromApi,\n  useAccountBalancesFromApi,\n  useAccountSettings,\n  useAccounts,\n  useAccountsAddressesFromApi,\n  useAnsTokenFromApi,\n  useClaimNamespace,\n  useConfig,\n  useCosmWasmClient,\n  useCreateAccount,\n  useCreateAccountMonarchy,\n  useCreateRemoteAccount,\n  useCreateSubAccount,\n  useDeposit,\n  useEnableIbc,\n  useExecute,\n  useExecuteOnRemote,\n  useExecuteOnRemoteModule,\n  useExecuteRemote,\n  useInstallModules,\n  useModuleClient,\n  useModuleInstantiate2Address,\n  useModuleInstantiate2AddressFromApi,\n  useModuleQueryClient,\n  useModules,\n  useModulesFromApi,\n  usePredictAccountAddress,\n  usePredictModuleAddress,\n  useRemoteAccountIds,\n  useRemoteAccounts,\n  useRemoteHosts,\n  useRequestRemoteFunds,\n  useSendFunds,\n  useSendFundsToRemote,\n  useSenderAddress,\n  useSignAndBroadcast,\n  useSigningCosmWasmClient,\n  useSimulateExecuteRemoteAccount,\n  useSimulateRemoteMsg,\n  useSmartQuery,\n  useSubAccountIdsByModuleIdFromApi,\n  useSubAccountIdsFromApi,\n  useUpdateInfo,\n  useUpdateSettings,\n  useUpdateStatus,\n  useUpgradeModule,\n  useUpgradeModules,\n  useUseSendFundsToRemote,\n  useWithdraw\n};\n", "\"use client\";\n\n// src/hooks/account/wallet/use-claim-namespace.ts\nimport { useMutation } from \"@tanstack/react-query\";\n\n// src/contexts/provider.ts\nimport * as React2 from \"react\";\n\n// src/contexts/config.ts\nimport * as React from \"react\";\nvar ConfigContext = React.createContext(void 0);\nfunction AbstractConfigContext({\n  children,\n  config\n}) {\n  return React.createElement(ConfigContext.Provider, {\n    children,\n    value: config\n  });\n}\nfunction useConfig() {\n  const config = React.useContext(ConfigContext);\n  if (!config)\n    throw new Error(\"`useConfig` must be used within `AbstractConfigContext`.\");\n  return config;\n}\n\n// src/contexts/provider.ts\nfunction AbstractProvider({\n  children,\n  config\n}) {\n  return React2.createElement(React2.Fragment, {\n    // biome-ignore lint/correctness/noChildrenProp: <explanation>\n    children: React2.createElement(AbstractConfigContext, {\n      config,\n      children\n    })\n  });\n}\n\n// src/hooks/account/wallet/use-claim-namespace.ts\nfunction useClaimNamespace({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation(\n    [\"claimNamespace\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"client is not defined\");\n      return accountClient.claimNamespace({ ...cosmWasmSignOptions, ...args });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-create-remote-account.ts\nimport { useMutation as useMutation2 } from \"@tanstack/react-query\";\nfunction useCreateRemoteAccount({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation2(\n    [\"createRemoteAccount\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.createRemoteAccount({\n        ...cosmWasmSignOptions,\n        ...args\n      });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-create-sub-account.ts\nimport { useMutation as useMutation3 } from \"@tanstack/react-query\";\nfunction useCreateSubAccount({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation3(\n    [\"createSubAccount\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.createSubAccount({ ...cosmWasmSignOptions, ...args });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-deposit.ts\nimport { useMutation as useMutation4 } from \"@tanstack/react-query\";\nfunction useDeposit({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    accountId,\n    chainName\n  });\n  return useMutation4(\n    [\"deposit\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"client is not defined\");\n      return accountClient.deposit({ ...args, ...cosmWasmSignOptions });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-enable-ibc.ts\nimport { useMutation as useMutation5 } from \"@tanstack/react-query\";\nfunction useEnableIbc({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation5(\n    [\"enableIbc\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      if (!args.ibcEnabled) {\n        throw new Error(\"no action\");\n      }\n      return accountClient.enableIbc({ ...cosmWasmSignOptions, ...args });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-execute.ts\nimport { useMutation as useMutation6 } from \"@tanstack/react-query\";\nfunction useExecute({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation6(\n    [\"execute\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"client is not defined\");\n      return accountClient.execute({ ...cosmWasmSignOptions, ...args });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-execute-on-remote.ts\nimport { useMutation as useMutation7 } from \"@tanstack/react-query\";\nfunction useExecuteOnRemote({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    accountId,\n    chainName\n  });\n  return useMutation7(\n    [\"executeOnRemote\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.executeOnRemote({ ...cosmWasmSignOptions, ...args });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-execute-on-remote-module.ts\nimport { useMutation as useMutation8 } from \"@tanstack/react-query\";\nfunction useExecuteOnRemoteModule({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    accountId,\n    chainName\n  });\n  return useMutation8(\n    [\"executeOnRemoteModule\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.executeOnRemoteModule({\n        ...cosmWasmSignOptions,\n        ...args\n      });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-execute-remote.ts\nimport { useMutation as useMutation9 } from \"@tanstack/react-query\";\nfunction useExecuteRemote({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    accountId,\n    chainName\n  });\n  return useMutation9(\n    [\"executeRemote\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.executeRemote({ ...cosmWasmSignOptions, ...args });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-install-modules.ts\nimport { useMutation as useMutation10 } from \"@tanstack/react-query\";\nfunction useInstallModules({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation10(\n    [\"installModules\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"client is not defined\");\n      return accountClient.installModules({ ...cosmWasmSignOptions, ...args });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-request-remote-funds.ts\nimport { useMutation as useMutation11 } from \"@tanstack/react-query\";\nfunction useRequestRemoteFunds({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation11(\n    [\"requestRemoteFunds\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.requestFundsFromRemote({\n        ...cosmWasmSignOptions,\n        ...args\n      });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-send-funds-to-remote.ts\nimport { useMutation as useMutation12 } from \"@tanstack/react-query\";\nfunction useSendFundsToRemote({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation12(\n    [\"sendFundsToRemote\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.sendFundsToRemote({\n        ...cosmWasmSignOptions,\n        ...args\n      });\n    },\n    mutation\n  );\n}\nvar useUseSendFundsToRemote = useSendFundsToRemote;\n\n// src/hooks/account/wallet/use-update-info.ts\nimport { useMutation as useMutation13 } from \"@tanstack/react-query\";\nfunction useUpdateInfo({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation13(\n    [\"updateInfo\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.updateInfo({ ...cosmWasmSignOptions, ...args });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-update-settings.ts\nimport { useMutation as useMutation14 } from \"@tanstack/react-query\";\nfunction useUpdateSettings({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const { mutateAsync } = useEnableIbc({\n    accountId,\n    chainName,\n    mutation\n  });\n  return useMutation14(\n    [\"updateSettings\", chainName, accountId],\n    async ({ args, ...cosmWasmSignOptions }) => {\n      return await mutateAsync({ ...cosmWasmSignOptions, args });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-update-status.ts\nimport { useMutation as useMutation15 } from \"@tanstack/react-query\";\nfunction useUpdateStatus({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation15(\n    [\"updateStatus\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.updateStatus({ ...cosmWasmSignOptions, ...args });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/wallet/use-upgrade-modules.ts\nimport { useMutation as useMutation16 } from \"@tanstack/react-query\";\nfunction useUpgradeModules({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation16(\n    [\"upgradeModules\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.upgradeModules({ ...cosmWasmSignOptions, ...args });\n    },\n    mutation\n  );\n}\nvar useUpgradeModule = useUpgradeModules;\n\n// src/hooks/account/wallet/use-withdraw.ts\nimport { useMutation as useMutation17 } from \"@tanstack/react-query\";\nfunction useSendFunds({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountWalletClient({\n    chainName,\n    accountId\n  });\n  return useMutation17(\n    [\"sendFunds\", chainName, accountId],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.sendFunds({ ...args, ...cosmWasmSignOptions });\n    },\n    mutation\n  );\n}\nvar useWithdraw = useSendFunds;\n\n// src/hooks/account/public/use-account-address-from-api.ts\nimport React3 from \"react\";\n\n// src/types/queries.ts\nimport {\n  useInfiniteQuery as tanstack_useInfiniteQuery,\n  useQuery as tanstack_useQuery\n} from \"@tanstack/react-query\";\nfunction useQuery(parameters) {\n  const result = tanstack_useQuery({\n    ...parameters\n    // queryKeyHashFn: hashFn, // for bigint support\n  });\n  result.queryKey = parameters.queryKey;\n  return result;\n}\n\n// src/hooks/account/public/use-account-address-from-api.ts\nfunction useAccountAddressFromApi({\n  accountId,\n  chainName,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const accountPublicClient = config.useAccountPublicClient({\n    accountId,\n    chainName\n  });\n  const queryKey = React3.useMemo(\n    () => [\"accountAddress\", accountPublicClient, extra],\n    [accountPublicClient, extra]\n  );\n  const enabled = Boolean(accountPublicClient && (query.enabled ?? true));\n  const queryFn = React3.useCallback(\n    ({ queryKey: [_, accountPublicClient2, extra2] }) => {\n      if (!accountPublicClient2)\n        throw new Error(\"No client\");\n      return accountPublicClient2.getAccountAddress(\n        extra2 ? { extra: extra2 } : void 0\n      );\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\nvar useAccountAddress = useAccountAddressFromApi;\n\n// src/hooks/account/public/use-account-settings.ts\nimport React4 from \"react\";\nfunction useAccountSettings({\n  accountId,\n  extra,\n  chainName,\n  query = {}\n}) {\n  const config = useConfig();\n  const accountPublicClient = config.useAccountPublicClient({\n    accountId,\n    chainName\n  });\n  const queryKey = React4.useMemo(\n    () => [\"accountSettings\", accountPublicClient, extra],\n    [accountPublicClient, extra]\n  );\n  const enabled = Boolean(accountPublicClient && (query.enabled ?? true));\n  const queryFn = React4.useCallback(\n    ({ queryKey: [_, accountPublicClient2, extra2] }) => {\n      if (!accountPublicClient2)\n        throw new Error(\"No client\");\n      return accountPublicClient2.getAccountSettings(\n        extra2 ? { extra: extra2 } : void 0\n      );\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/account/public/use-predict-module-address.ts\nimport React5 from \"react\";\nfunction usePredictModuleAddress({\n  args,\n  accountId,\n  chainName,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const accountPublicClient = config.useAccountPublicClient({\n    accountId,\n    chainName\n  });\n  const queryKey = React5.useMemo(\n    () => [\"predictModuleAddress\", accountPublicClient, args, extra],\n    [accountPublicClient, args, extra]\n  );\n  const enabled = Boolean(\n    accountPublicClient && args && (query.enabled ?? true)\n  );\n  const queryFn = React5.useCallback(\n    ({ queryKey: [_, accountPublicClient2, args2, extra2] }) => {\n      if (!accountPublicClient2)\n        throw new Error(\"No client\");\n      if (!args2)\n        throw new Error(\"No args\");\n      return accountPublicClient2.predictModuleAddress({\n        ...args2,\n        ...extra2\n      });\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\nvar useModuleInstantiate2AddressFromApi = usePredictModuleAddress;\nvar useModuleInstantiate2Address = usePredictModuleAddress;\n\n// src/hooks/account/public/use-modules.ts\nimport React6 from \"react\";\nfunction useModules({\n  accountId,\n  chainName,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const accountPublicClient = config.useAccountPublicClient({\n    accountId,\n    chainName\n  });\n  const queryKey = React6.useMemo(\n    () => [\"modules\", accountPublicClient, extra],\n    [accountPublicClient, extra]\n  );\n  const enabled = Boolean(accountPublicClient && (query.enabled ?? true));\n  const queryFn = React6.useCallback(\n    ({ queryKey: [_, accountPublicClient2, extra2] }) => {\n      if (!accountPublicClient2)\n        throw new Error(\"No client\");\n      return accountPublicClient2.getModules(extra2 ? { extra: extra2 } : void 0);\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/account/public/use-remote-account-ids.ts\nimport {\n  useQuery as useQuery2\n} from \"@tanstack/react-query\";\nimport React7 from \"react\";\nfunction useRemoteAccountIds({\n  accountId,\n  extra,\n  chainName,\n  query = {}\n}) {\n  const config = useConfig();\n  const accountPublicClient = config.useAccountPublicClient({\n    accountId,\n    chainName\n  });\n  const queryKey = React7.useMemo(\n    () => [\"getRemoteAccountIds\", accountPublicClient, extra],\n    [accountPublicClient, extra]\n  );\n  const enabled = React7.useMemo(\n    () => Boolean(\n      accountPublicClient && (query.enabled ?? true)\n    ),\n    [query.enabled, accountPublicClient]\n  );\n  const queryFn = React7.useCallback(\n    ({ queryKey: [_, accountPublicClient2, extra2] }) => {\n      if (!accountPublicClient2)\n        throw new Error(\"No client\");\n      return accountPublicClient2.getRemoteAccountIds(\n        extra2 ? {\n          extra: extra2\n        } : void 0\n      );\n    },\n    []\n  );\n  return useQuery2({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/account/public/use-remote-accounts.ts\nimport {\n  useQuery as useQuery3\n} from \"@tanstack/react-query\";\nimport React8 from \"react\";\nfunction useRemoteAccounts({\n  accountId,\n  extra,\n  chainName,\n  query = {}\n}) {\n  const config = useConfig();\n  const accountPublicClient = config.useAccountPublicClient({\n    accountId,\n    chainName\n  });\n  const queryKey = React8.useMemo(\n    () => [\"getRemoteAccounts\", accountPublicClient, extra],\n    [accountPublicClient, extra]\n  );\n  const enabled = React8.useMemo(\n    () => Boolean(accountPublicClient && (query.enabled ?? true)),\n    [query.enabled, accountPublicClient]\n  );\n  const queryFn = React8.useCallback(\n    ({ queryKey: [_, accountPublicClient2, extra2] }) => {\n      if (!accountPublicClient2)\n        throw new Error(\"No client\");\n      return accountPublicClient2.getRemoteAccounts(\n        extra2 ? {\n          extra: extra2\n        } : void 0\n      );\n    },\n    []\n  );\n  return useQuery3({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/account/public/use-simulate-execute-remote-account.ts\nimport { useMutation as useMutation18 } from \"@tanstack/react-query\";\nfunction useSimulateExecuteRemoteAccount({\n  accountId,\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.useAccountPublicClient({\n    chainName,\n    accountId\n  });\n  return useMutation18(\n    [\"simulateExecuteRemoteAccount\", chainName, accountId],\n    ({ ...params }) => {\n      if (!accountClient)\n        throw new Error(\"client is not defined\");\n      return accountClient.simulateExecuteRemoteAccount({ ...params });\n    },\n    mutation\n  );\n}\n\n// src/hooks/account/public/use-sub-accounts-ids-from-api.ts\nimport React9 from \"react\";\nfunction useSubAccountIdsFromApi({\n  accountId,\n  chainName,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const accountPublicClient = config.useAccountPublicClient({\n    accountId,\n    chainName\n  });\n  const queryKey = React9.useMemo(\n    () => [\"getSubAccountIdsFromApi\", accountPublicClient, extra],\n    [accountPublicClient, extra]\n  );\n  const enabled = Boolean(accountPublicClient && (query.enabled ?? true));\n  const queryFn = React9.useCallback(\n    ({ queryKey: [_, accountPublicClient2, extra2] }) => {\n      if (!accountPublicClient2)\n        throw new Error(\"No client\");\n      return accountPublicClient2.getSubAccountIds(extra2 ? { extra: extra2 } : void 0);\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/public/use-cosm-wasm-client.ts\nimport React10 from \"react\";\nfunction useCosmWasmClient({\n  chainName,\n  query = {}\n}) {\n  const config = useConfig();\n  const publicClient = config.usePublicClient({ chainName });\n  const queryKey = React10.useMemo(\n    () => [\"cosmWasmClient\", chainName, publicClient],\n    [chainName, publicClient]\n  );\n  const queryFn = React10.useCallback(\n    ({ queryKey: [_, chainName2, publicClient2] }) => {\n      if (!publicClient2)\n        throw new Error(`client is not defined for ${chainName2}`);\n      return publicClient2.getCosmWasmClient();\n    },\n    []\n  );\n  const enabled = Boolean(publicClient && (query.enabled ?? true));\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/public/use-smart-query.ts\nimport React11 from \"react\";\nfunction useSmartQuery({\n  chainName,\n  query = {},\n  address,\n  queryMsg\n}) {\n  const { data: cosmWasmClient, isSuccess } = useCosmWasmClient({ chainName });\n  const queryKey = React11.useMemo(\n    () => [\"smartQuery\", chainName, cosmWasmClient, address, queryMsg],\n    [cosmWasmClient, chainName, address, queryMsg]\n  );\n  const queryFn = React11.useCallback(\n    async ({ queryKey: [_, _chainName, cosmWasmClient2] }) => {\n      if (!cosmWasmClient2) {\n        throw new Error(`client is not defined for ${chainName}`);\n      }\n      return cosmWasmClient2.queryContractSmart(address, queryMsg);\n    },\n    []\n  );\n  const enabled = Boolean(isSuccess && (query.enabled ?? true));\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/public/use-abstract-module-version.ts\nimport React12 from \"react\";\nfunction useAbstractModuleVersion({\n  args,\n  extra,\n  chainName,\n  query = {}\n}) {\n  const config = useConfig();\n  const publicClient = config.usePublicClient({\n    chainName\n  });\n  const queryKey = React12.useMemo(\n    () => [\"abstractModuleVersion\", chainName, publicClient, args, extra],\n    [publicClient, chainName, args, extra]\n  );\n  const enabled = Boolean(publicClient && args && (query.enabled ?? true));\n  const queryFn = React12.useCallback(\n    ({ queryKey: [_, _chainName, publicClient2, args2, extra2] }) => {\n      if (!publicClient2)\n        throw new Error(\"No client\");\n      if (!args2)\n        throw new Error(\"No args\");\n      return publicClient2.getAbstractModuleVersion({ ...args2, extra: extra2 });\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/public/use-accounts-addresses-from-api.ts\nimport React13 from \"react\";\nfunction useAccountsAddressesFromApi({\n  chainName,\n  args,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const accountPublicClient = config.usePublicClient({\n    chainName\n  });\n  const queryKey = React13.useMemo(\n    () => [\"accountAddress\", chainName, accountPublicClient, args, extra],\n    [accountPublicClient, chainName, args, extra]\n  );\n  const enabled = Boolean(\n    accountPublicClient && args && (query.enabled ?? true)\n  );\n  const queryFn = React13.useCallback(\n    ({ queryKey: [_, _chainName, accountPublicClient2, args2, extra2] }) => {\n      if (!accountPublicClient2 || !args2)\n        throw new Error(\"No client or args\");\n      return accountPublicClient2.getAccountsAddresses({ extra: extra2, ...args2 });\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/public/use-remote-hosts.ts\nimport React14 from \"react\";\nfunction useRemoteHosts({\n  chainName,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const publicClient = config.usePublicClient({\n    chainName\n  });\n  const queryKey = React14.useMemo(\n    () => [\"getRemoteHosts\", chainName, publicClient, extra],\n    [chainName, publicClient, extra]\n  );\n  const enabled = Boolean(publicClient && (query.enabled ?? true));\n  const queryFn = React14.useCallback(\n    ({ queryKey: [_, _chainName, publicClient2, extra2] }) => {\n      if (!publicClient2)\n        throw new Error(\"No client\");\n      return publicClient2.getRemoteHosts(extra2 ? { extra: extra2 } : void 0);\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/public/use-simulate-remote-msg.ts\nimport { useMutation as useMutation19 } from \"@tanstack/react-query\";\nfunction useSimulateRemoteMsg({\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const accountClient = config.usePublicClient({\n    chainName\n  });\n  return useMutation19(\n    [\"simulateRemoteCosmosMsg\", chainName],\n    ({ ...params }) => {\n      if (!accountClient)\n        throw new Error(\"accountClient is not defined\");\n      return accountClient.simulateRemoteCosmosMsg({\n        ...params\n      });\n    },\n    mutation\n  );\n}\n\n// src/hooks/public/use-predict-account-address.ts\nimport React15 from \"react\";\nfunction usePredictAccountAddress({\n  chainName,\n  args,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const publicClient = config.usePublicClient({\n    chainName\n  });\n  const queryKey = React15.useMemo(\n    () => [\"predictAccountAddress\", publicClient, args, extra],\n    [publicClient, extra]\n  );\n  const enabled = Boolean(publicClient && (query.enabled ?? true));\n  const queryFn = React15.useCallback(\n    ({ queryKey: [_, publicClient2, args2, extra2] }) => {\n      if (!publicClient2)\n        throw new Error(\"No client\");\n      if (!args2)\n        throw new Error(\"No args\");\n      return publicClient2.predictAccountAddress({ extra: extra2, ...args2 });\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/wallet/use-signing-cosm-wasm-client.ts\nimport React16 from \"react\";\nfunction useSigningCosmWasmClient(parameters) {\n  const { chainName, query = {} } = parameters ?? {};\n  const config = useConfig();\n  const walletClient = config.useWalletClient({ chainName });\n  const queryKey = React16.useMemo(\n    () => [\"signing-cosm-wasm-client\", walletClient],\n    [walletClient]\n  );\n  const queryFn = React16.useCallback(() => {\n    if (!walletClient)\n      throw new Error(\"client is not defined\");\n    return walletClient.getSigningCosmWasmClient();\n  }, [walletClient]);\n  const enabled = Boolean(walletClient && (query.enabled ?? true));\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/wallet/use-create-account.ts\nimport { useMutation as useMutation20 } from \"@tanstack/react-query\";\nfunction useCreateAccount({ chainName, mutation }) {\n  const config = useConfig();\n  const walletClient = config.useWalletClient({ chainName });\n  return useMutation20(\n    [\"createAccount\", chainName],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!walletClient)\n        throw new Error(\"walletClient is not defined\");\n      return walletClient.createAccount({ ...args, ...cosmWasmSignOptions });\n    },\n    mutation\n  );\n}\n\n// src/hooks/wallet/use-create-account-monarchy.ts\nimport { useMutation as useMutation21 } from \"@tanstack/react-query\";\nfunction useCreateAccountMonarchy({\n  chainName,\n  mutation\n}) {\n  const config = useConfig();\n  const walletClient = config.useWalletClient({ chainName });\n  return useMutation21(\n    [\"createAccountMonarchy\", chainName],\n    ({ args, ...cosmWasmSignOptions }) => {\n      if (!walletClient)\n        throw new Error(\"walletClient is not defined\");\n      return walletClient.createAccountMonarchy({\n        ...args,\n        ...cosmWasmSignOptions\n      });\n    },\n    mutation\n  );\n}\n\n// src/hooks/wallet/use-sender-address.ts\nimport React17 from \"react\";\nfunction useSenderAddress(parameters) {\n  const { query = {}, chainName } = parameters ?? {};\n  const config = useConfig();\n  const walletClient = config.useWalletClient({ chainName });\n  const queryKey = React17.useMemo(\n    () => [\"sender-address\", walletClient],\n    [walletClient]\n  );\n  const queryFn = React17.useCallback(() => {\n    if (!walletClient)\n      throw new Error(\"client is not defined\");\n    return walletClient.getSenderAddress();\n  }, [walletClient]);\n  const enabled = Boolean(walletClient && (query.enabled ?? true));\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/wallet/utils/use-sign-and-broadcast.ts\nimport { useMutation as useMutation22 } from \"@tanstack/react-query\";\nfunction useSignAndBroadcast({ args: { chainName } }, options) {\n  const { data: signingCosmWasmClient } = useSigningCosmWasmClient({\n    chainName\n  });\n  const { data: senderAddress } = useSenderAddress({ chainName });\n  return useMutation22(\n    [\"signAndBroadcast\", chainName, senderAddress],\n    ({ args, fee, memo }) => {\n      if (!signingCosmWasmClient || !senderAddress)\n        throw new Error(\n          \"signingCosmWasmClient or senderAddress are not defined\"\n        );\n      return signingCosmWasmClient?.signAndBroadcast(\n        senderAddress,\n        args.messages,\n        fee,\n        memo\n      );\n    },\n    options\n  );\n}\n\n// src/hooks/use-accounts.ts\nimport React18 from \"react\";\nfunction useAccounts({\n  args,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const client = config.useApiClient();\n  const queryKey = React18.useMemo(\n    () => [\"accountsOf\", client, args, extra],\n    [client, args, extra]\n  );\n  const enabled = Boolean(client && args && (query.enabled ?? true));\n  const queryFn = React18.useCallback(\n    ({ queryKey: [_, client2, args2, extra2] }) => {\n      if (!client2 || !args2)\n        throw new Error(\"No client or owner or chain\");\n      return client2.getAccountsByOwnerFromApi({\n        ...args2,\n        ...extra2\n      });\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/use-ans-token-from-api.ts\nimport React19 from \"react\";\nfunction useAnsTokenFromApi({\n  args,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const client = config.useApiClient();\n  const queryKey = React19.useMemo(\n    () => [\"ansTokenFromApi\", client, args, extra],\n    [args, client, extra]\n  );\n  const enabled = Boolean(client && args && (query.enabled ?? true));\n  const queryFn = React19.useCallback(\n    ({ queryKey: [_, client2, args2, extra2] }) => {\n      if (!client2 || !args2)\n        throw new Error(\"No client or owner or chain\");\n      return client2.getAnsTokenFromApi({ ...args2, ...extra2 });\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/use-account-balance-from-api.ts\nimport React20 from \"react\";\nfunction useAccountBalancesFromApi({\n  args,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const client = config.useApiClient();\n  const queryKey = React20.useMemo(\n    () => [\"accountBalancesFromApi\", client, args, extra],\n    [args, client, extra]\n  );\n  const enabled = Boolean(client && args && (query.enabled ?? true));\n  const queryFn = React20.useCallback(\n    ({ queryKey: [_, client2, args2, extra2] }) => {\n      if (!client2 || !args2)\n        throw new Error(\"No client or accountid\");\n      return client2.getAccountBalancesFromApi({ ...args2, ...extra2 });\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/use-modules-from-api.ts\nimport React21 from \"react\";\nfunction useModulesFromApi({\n  args,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const client = config.useApiClient();\n  const queryKey = React21.useMemo(\n    () => [\"modulesFromApi\", client, args, extra],\n    [args, client, extra]\n  );\n  const enabled = Boolean(client && args && (query.enabled ?? true));\n  const queryFn = React21.useCallback(() => {\n    if (!client || !args)\n      throw new Error(\"No client or owner or chain\");\n    return client.getModulesFromApi({\n      ...args,\n      ...extra\n    });\n  }, []);\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\n// src/hooks/use-sub-account-ids-by-module-from-api.ts\nimport React22 from \"react\";\nfunction useSubAccountIdsByModuleIdFromApi({\n  args,\n  extra,\n  query = {}\n}) {\n  const config = useConfig();\n  const client = config.useApiClient();\n  const queryKey = React22.useMemo(\n    () => [\"subAccountIdsByModuleIdFromApi\", client, args, extra],\n    [args, client, extra]\n  );\n  const enabled = Boolean(client && args && (query.enabled ?? true));\n  const queryFn = React22.useCallback(\n    ({ queryKey: [_, client2, args2, extra2] }) => {\n      if (!client2 || !args2)\n        throw new Error(\"No client or accountid\");\n      return client2.getSubAccountIdsByModuleIdFromApi({\n        ...args2,\n        ...extra2\n      });\n    },\n    []\n  );\n  return useQuery({ queryKey, queryFn, ...query, enabled });\n}\n\nexport {\n  useConfig,\n  AbstractProvider,\n  useClaimNamespace,\n  useCreateRemoteAccount,\n  useCreateSubAccount,\n  useDeposit,\n  useEnableIbc,\n  useExecute,\n  useExecuteOnRemote,\n  useExecuteOnRemoteModule,\n  useExecuteRemote,\n  useInstallModules,\n  useRequestRemoteFunds,\n  useSendFundsToRemote,\n  useUseSendFundsToRemote,\n  useUpdateInfo,\n  useUpdateSettings,\n  useUpdateStatus,\n  useUpgradeModules,\n  useUpgradeModule,\n  useSendFunds,\n  useWithdraw,\n  useQuery,\n  useAccountAddressFromApi,\n  useAccountAddress,\n  useAccountSettings,\n  usePredictModuleAddress,\n  useModuleInstantiate2AddressFromApi,\n  useModuleInstantiate2Address,\n  useModules,\n  useRemoteAccountIds,\n  useRemoteAccounts,\n  useSimulateExecuteRemoteAccount,\n  useSubAccountIdsFromApi,\n  useCosmWasmClient,\n  useSmartQuery,\n  useAbstractModuleVersion,\n  useAccountsAddressesFromApi,\n  useRemoteHosts,\n  useSimulateRemoteMsg,\n  usePredictAccountAddress,\n  useSigningCosmWasmClient,\n  useCreateAccount,\n  useCreateAccountMonarchy,\n  useSenderAddress,\n  useSignAndBroadcast,\n  useAccounts,\n  useAnsTokenFromApi,\n  useAccountBalancesFromApi,\n  useModulesFromApi,\n  useSubAccountIdsByModuleIdFromApi\n};\n", "import './setBatchUpdatesFn.mjs';\nexport * from '@tanstack/query-core';\nexport { useQueries } from './useQueries.mjs';\nexport { useQuery } from './useQuery.mjs';\nexport { QueryClientProvider, defaultContext, useQueryClient } from './QueryClientProvider.mjs';\nexport { Hydrate, useHydrate } from './Hydrate.mjs';\nexport { QueryErrorResetBoundary, useQueryErrorResetBoundary } from './QueryErrorResetBoundary.mjs';\nexport { useIsFetching } from './useIsFetching.mjs';\nexport { useIsMutating } from './useIsMutating.mjs';\nexport { useMutation } from './useMutation.mjs';\nexport { useInfiniteQuery } from './useInfiniteQuery.mjs';\nexport { IsRestoringProvider, useIsRestoring } from './isRestoring.mjs';\n//# sourceMappingURL=index.mjs.map\n", "export { CancelledError, isCancelledError } from './retryer.mjs';\nexport { QueryCache } from './queryCache.mjs';\nexport { QueryClient } from './queryClient.mjs';\nexport { QueryObserver } from './queryObserver.mjs';\nexport { QueriesObserver } from './queriesObserver.mjs';\nexport { InfiniteQueryObserver } from './infiniteQueryObserver.mjs';\nexport { MutationCache } from './mutationCache.mjs';\nexport { MutationObserver } from './mutationObserver.mjs';\nexport { notifyManager } from './notifyManager.mjs';\nexport { focusManager } from './focusManager.mjs';\nexport { onlineManager } from './onlineManager.mjs';\nexport { hashQueryKey, isError, isServer, matchQuery, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, replaceEqualDeep } from './utils.mjs';\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate } from './hydration.mjs';\nexport { Query } from './query.mjs';\n//# sourceMappingURL=index.mjs.map\n", "type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: Set<{ listener: TListener }>\n\n  constructor() {\n    this.listeners = new Set()\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    const identity = { listener }\n    this.listeners.add(identity)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(identity)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n", "import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationFunction,\n  MutationKey,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Include or exclude fetching mutations\n   */\n  fetching?: boolean\n}\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function difference<T>(array1: T[], array2: T[]): T[] {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nexport function replaceAt<T>(array: T[], index: number, value: T): T[] {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function parseQueryArgs<\n  TOptions extends QueryOptions<any, any, any, TQueryKey>,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | TOptions,\n  arg2?: QueryFunction<any, TQueryKey> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (!isQueryKey(arg1)) {\n    return arg1 as TOptions\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3, queryKey: arg1, queryFn: arg2 } as TOptions\n  }\n\n  return { ...arg2, queryKey: arg1 } as TOptions\n}\n\nexport function parseMutationArgs<\n  TOptions extends MutationOptions<any, any, any, any>,\n>(\n  arg1: MutationKey | MutationFunction<any, any> | TOptions,\n  arg2?: MutationFunction<any, any> | TOptions,\n  arg3?: TOptions,\n): TOptions {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3, mutationKey: arg1, mutationFn: arg2 } as TOptions\n    }\n    return { ...arg2, mutationKey: arg1 } as TOptions\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2, mutationFn: arg1 } as TOptions\n  }\n\n  return { ...arg1 } as TOptions\n}\n\nexport function parseFilterArgs<\n  TFilters extends QueryFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1) ? [{ ...arg2, queryKey: arg1 }, arg3] : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function parseMutationFilterArgs<\n  TFilters extends MutationFilters,\n  TOptions = unknown,\n>(\n  arg1?: QueryKey | TFilters,\n  arg2?: TFilters | TOptions,\n  arg3?: TOptions,\n): [TFilters, TOptions | undefined] {\n  return (\n    isQueryKey(arg1)\n      ? [{ ...arg2, mutationKey: arg1 }, arg3]\n      : [arg1 || {}, arg2]\n  ) as [TFilters, TOptions]\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, fetching, predicate, mutationKey } = filters\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (\n        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)\n      ) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (\n    typeof fetching === 'boolean' &&\n    (mutation.state.status === 'loading') !== fetching\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashQueryKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashQueryKey(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nexport function scheduleMicrotask(callback: () => void) {\n  sleep(0).then(callback)\n}\n\nexport function getAbortController(): AbortController | undefined {\n  if (typeof AbortController === 'function') {\n    return new AbortController()\n  }\n  return\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual?.(prevData, data)) {\n    return prevData as TData\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  private focused?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibillitychange and focus\n        window.addEventListener('visibilitychange', listener, false)\n        window.addEventListener('focus', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n          window.removeEventListener('focus', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.focused !== focused\n    if (changed) {\n      this.focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.focused === 'boolean') {\n      return this.focused\n    }\n\n    // document global can be unavailable in react native\n    if (typeof document === 'undefined') {\n      return true\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(\n      document.visibilityState,\n    )\n  }\n}\n\nexport const focusManager = new FocusManager()\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setOnline: (online?: boolean) => void,\n) => (() => void) | undefined\n\nconst onlineEvents = ['online', 'offline'] as const\n\nexport class OnlineManager extends Subscribable {\n  private online?: boolean\n  private cleanup?: () => void\n\n  private setup: SetupFn\n\n  constructor() {\n    super()\n    this.setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline()\n        // Listen to online\n        onlineEvents.forEach((event) => {\n          window.addEventListener(event, listener, false)\n        })\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach((event) => {\n            window.removeEventListener(event, listener)\n          })\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.cleanup?.()\n      this.cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.setup = setup\n    this.cleanup?.()\n    this.cleanup = setup((online?: boolean) => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online)\n      } else {\n        this.onOnline()\n      }\n    })\n  }\n\n  setOnline(online?: boolean): void {\n    const changed = this.online !== online\n\n    if (changed) {\n      this.online = online\n      this.onOnline()\n    }\n  }\n\n  onOnline(): void {\n    this.listeners.forEach(({ listener }) => {\n      listener()\n    })\n  }\n\n  isOnline(): boolean {\n    if (typeof this.online === 'boolean') {\n      return this.online\n    }\n\n    if (\n      typeof navigator === 'undefined' ||\n      typeof navigator.onLine === 'undefined'\n    ) {\n      return true\n    }\n\n    return navigator.onLine\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n", "import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { sleep } from './utils'\nimport type { CancelOptions, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = unknown> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = unknown> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = unknown>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? 3\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n", "export interface Logger {\n  log: LogFunction\n  warn: LogFunction\n  error: LogFunction\n}\n\ntype LogFunction = (...args: any[]) => void\n\nexport const defaultLogger: Logger = console\n", "import { scheduleMicrotask } from './utils'\n\n// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends unknown[]> = (...args: T) => void\n\nexport function createNotifyManager() {\n  let queue: NotifyCallback[] = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends unknown[]>(\n    callback: BatchCallsCallback<T>,\n  ): BatchCallsCallback<T> => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n", "import { defaultLogger } from './logger'\nimport { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { canFetch, createRetryer } from './retryer'\nimport type { MutationMeta, MutationOptions, MutationStatus } from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Logger } from './logger'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  logger?: Logger\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n  meta?: MutationMeta\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface LoadingAction<TVariables, TContext> {\n  type: 'loading'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError, TVariables, TContext> {\n  type: 'setState'\n  state: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | LoadingAction<TVariables, TContext>\n  | PauseAction\n  | SetStateAction<TData, TError, TVariables, TContext>\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  mutationId: number\n\n  private observers: MutationObserver<TData, TError, TVariables, TContext>[]\n  private defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  private mutationCache: MutationCache\n  private logger: Logger\n  private retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.defaultOptions = config.defaultOptions\n    this.mutationId = config.mutationId\n    this.mutationCache = config.mutationCache\n    this.logger = config.logger || defaultLogger\n    this.observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options?: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = { ...this.defaultOptions, ...options }\n\n    this.updateCacheTime(this.options.cacheTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  setState(state: MutationState<TData, TError, TVariables, TContext>): void {\n    this.dispatch({ type: 'setState', state })\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.observers = this.observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc()\n      } else {\n        this.mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return this.retryer?.continue() ?? this.execute()\n  }\n\n  async execute(): Promise<TData> {\n    const executeMutation = () => {\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found')\n          }\n          return this.options.mutationFn(this.state.variables!)\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({ type: 'failed', failureCount, error })\n        },\n        onPause: () => {\n          this.dispatch({ type: 'pause' })\n        },\n        onContinue: () => {\n          this.dispatch({ type: 'continue' })\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode,\n      })\n\n      return this.retryer.promise\n    }\n\n    const restored = this.state.status === 'loading'\n    try {\n      if (!restored) {\n        this.dispatch({ type: 'loading', variables: this.options.variables! })\n        // Notify cache callback\n        await this.mutationCache.config.onMutate?.(\n          this.state.variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(this.state.variables!)\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables,\n          })\n        }\n      }\n      const data = await executeMutation()\n\n      // Notify cache callback\n      await this.mutationCache.config.onSuccess?.(\n        data,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(\n        data,\n        this.state.variables!,\n        this.state.context!,\n      )\n\n      // Notify cache callback\n      await this.mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(\n        data,\n        null,\n        this.state.variables!,\n        this.state.context,\n      )\n\n      this.dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.mutationCache.config.onError?.(\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error)\n        }\n\n        await this.options.onError?.(\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.mutationCache.config.onSettled?.(\n          undefined,\n          error,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          this.state.variables!,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.dispatch({ type: 'error', error: error as TError })\n      }\n    }\n  }\n\n  private dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'loading':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n  }\n}\n", "import type { QueryBehavior } from './query'\n\nimport type {\n  InfiniteData,\n  QueryFunctionContext,\n  QueryOptions,\n  RefetchQueryFilters,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData,\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = () => {\n        const refetchPage: RefetchQueryFilters['refetchPage'] | undefined =\n          context.fetchOptions?.meta?.refetchPage\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal?.aborted) {\n                cancelled = true\n              } else {\n                context.signal?.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn ||\n          (() =>\n            Promise.reject(\n              `Missing queryFn for queryKey '${context.options.queryHash}'`,\n            ))\n\n        const buildNewPages = (\n          pages: unknown[],\n          param: unknown,\n          page: unknown,\n          previous?: boolean,\n        ) => {\n          newPageParams = previous\n            ? [param, ...newPageParams]\n            : [...newPageParams, param]\n          return previous ? [page, ...pages] : [...pages, page]\n        }\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean,\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then((page) =>\n            buildNewPages(pages, param, page, previous),\n          )\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          const shouldFetchFirstPage =\n            refetchPage && oldPages[0]\n              ? refetchPage(oldPages[0], 0, oldPages)\n              : true\n\n          // Fetch first page\n          promise = shouldFetchFirstPage\n            ? fetchPage([], manual, oldPageParams[0])\n            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then((pages) => {\n              const shouldFetchNextPage =\n                refetchPage && oldPages[i]\n                  ? refetchPage(oldPages[i], i, oldPages)\n                  : true\n\n              if (shouldFetchNextPage) {\n                const param = manual\n                  ? oldPageParams[i]\n                  : getNextPageParam(context.options, pages)\n                return fetchPage(pages, manual, param)\n              }\n              return Promise.resolve(\n                buildNewPages(pages, oldPageParams[i], oldPages[i]),\n              )\n            })\n          }\n        }\n\n        const finalPromise = promise.then((pages) => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n  return\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n  return\n}\n", "import {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch, isCancelledError } from './retryer'\nimport type {\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\nimport type { Action, FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { DefaultedQueryObserverOptions, RefetchPageFilters } from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  private currentQueryInitialState!: QueryState<TQueryData, TError>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private selectError: TError | null\n  private selectFn?: (data: TQueryData) => TData\n  private selectResult?: TData\n  private staleTimeoutId?: ReturnType<typeof setTimeout>\n  private refetchIntervalId?: ReturnType<typeof setInterval>\n  private currentRefetchInterval?: number | false\n  private trackedProps!: Set<keyof QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = new Set()\n    this.selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryOptions(options)\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      typeof options?.isDataEqual !== 'undefined'\n    ) {\n      this.client\n        .getLogger()\n        .error(\n          `The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option`,\n        )\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.currentRefetchInterval)\n    ) {\n      this.updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.client.getQueryCache().build(this.client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result\n      this.currentResultOptions = this.options\n      this.currentResultState = this.currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch<TPageData>({\n    refetchPage,\n    ...options\n  }: RefetchOptions & RefetchPageFilters<TPageData> = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: { refetchPage },\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.client.defaultQueryOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(this.client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  private computeRefetchInterval() {\n    return typeof this.options.refetchInterval === 'function'\n      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)\n      : this.options.refetchInterval ?? false\n  }\n\n  private updateRefetchInterval(nextInterval: number | false): void {\n    this.clearRefetchInterval()\n\n    this.currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.currentRefetchInterval) ||\n      this.currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.currentRefetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval(this.computeRefetchInterval())\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.currentQuery\n    const prevOptions = this.options\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.currentResultState\n    const prevResultOptions = this.currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.currentQueryInitialState\n    const prevQueryResult = queryChange\n      ? this.currentResult\n      : this.previousQueryResult\n\n    const { state } = query\n    let { dataUpdatedAt, error, errorUpdatedAt, fetchStatus, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!dataUpdatedAt) {\n          status = 'loading'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      options.keepPreviousData &&\n      !state.dataUpdatedAt &&\n      prevQueryResult?.isSuccess &&\n      status !== 'error'\n    ) {\n      data = prevQueryResult.data\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt\n      status = prevQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.selectFn\n      ) {\n        data = this.selectResult\n      } else {\n        try {\n          this.selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.selectResult = data\n          this.selectError = null\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError)\n          }\n          this.selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (options.placeholderData as PlaceholderDataFunction<TQueryData>)()\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.selectError = null\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError)\n            }\n            this.selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(prevResult?.data, placeholderData, options) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError as any\n      data = this.selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isLoading = status === 'loading'\n    const isError = status === 'error'\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.currentQuery, this.options)\n    this.currentResultState = this.currentQuery.state\n    this.currentResultOptions = this.options\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = { cache: true }\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.trackedProps,\n      )\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  private updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true\n    }\n\n    this.updateResult(notifyOptions)\n\n    if (this.hasListeners()) {\n      this.updateTimers()\n    }\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({ listener }) => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated',\n        })\n      }\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: typeof options['refetchOnMount'] &\n    typeof options['refetchOnWindowFocus'] &\n    typeof options['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false\n  }\n\n  // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData\n  }\n\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n", "import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  MutateOptions,\n  MutationObserverBaseResult,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options\n    this.options = this.client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this,\n      })\n    }\n    this.currentMutation?.setOptions(this.options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    const result: MutationObserverBaseResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    > = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n\n    this.currentResult = result as MutationObserverResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!,\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach(({ listener }) => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n", "import type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type {\n  MutationKey,\n  MutationOptions,\n  QueryKey,\n  QueryOptions,\n} from './types'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  dehydrateMutations?: boolean\n  dehydrateQueries?: boolean\n  shouldDehydrateMutation?: ShouldDehydrateMutationFunction\n  shouldDehydrateQuery?: ShouldDehydrateQueryFunction\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport interface DehydratedState {\n  mutations: DehydratedMutation[]\n  queries: DehydratedQuery[]\n}\n\nexport type ShouldDehydrateQueryFunction = (query: Query) => boolean\n\nexport type ShouldDehydrateMutationFunction = (mutation: Mutation) => boolean\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n  }\n}\n\nexport function defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nexport function defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {},\n): DehydratedState {\n  const mutations: DehydratedMutation[] = []\n  const queries: DehydratedQuery[] = []\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation =\n      options.shouldDehydrateMutation || defaultShouldDehydrateMutation\n\n    client\n      .getMutationCache()\n      .getAll()\n      .forEach((mutation) => {\n        if (shouldDehydrateMutation(mutation)) {\n          mutations.push(dehydrateMutation(mutation))\n        }\n      })\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery =\n      options.shouldDehydrateQuery || defaultShouldDehydrateQuery\n\n    client\n      .getQueryCache()\n      .getAll()\n      .forEach((query) => {\n        if (shouldDehydrateQuery(query)) {\n          queries.push(dehydrateQuery(query))\n        }\n      })\n  }\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions,\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach((dehydratedMutation) => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n      },\n      dehydratedMutation.state,\n    )\n  })\n\n  queries.forEach(({ queryKey, state, queryHash }) => {\n    const query = queryCache.get(queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < state.dataUpdatedAt) {\n        // omit fetchStatus from dehydrated state\n        // so that query stays in its current fetchStatus\n        const { fetchStatus: _ignored, ...dehydratedQueryState } = state\n        query.setState(dehydratedQueryState)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey,\n        queryHash,\n      },\n      // Reset fetch status to idle to avoid\n      // query being stuck in fetching state upon hydration\n      {\n        ...state,\n        fetchStatus: 'idle',\n      },\n    )\n  })\n}\n", "'use client'\nimport * as ReactDOM from 'react-dom'\n\nexport const unstable_batchedUpdates = ReactDOM.unstable_batchedUpdates\n", "import { notifyManager } from '@tanstack/query-core'\nimport { unstable_batchedUpdates } from './reactBatchedUpdates'\n\nnotifyManager.setBatchNotifyFunction(unstable_batchedUpdates)\n", "'use client'\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n", "'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client\n      .getLogger()\n      .error(\n        `The contextSharing option has been deprecated and will be removed in the next major version`,\n      )\n  }\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n", "'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n", "'use client'\nimport * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n", "export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n", "'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  UseErrorBoundary,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  useErrorBoundary: UseErrorBoundary<\n    TQueryFnData,\n    TError,\n    TQueryData,\n    TQueryKey\n  >\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(useErrorBoundary, [result.error, query])\n  )\n}\n", "import type { DefaultedQueryObserverOptions } from '@tanstack/query-core'\nimport type { QueryObserver } from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport type { QueryObserverResult } from '@tanstack/query-core'\nimport type { QueryKey } from '@tanstack/query-core'\n\nexport const ensureStaleTime = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer\n    .fetchOptimistic(defaultedOptions)\n    .then(({ data }) => {\n      defaultedOptions.onSuccess?.(data as TData)\n      defaultedOptions.onSettled?.(data, null)\n    })\n    .catch((error) => {\n      errorResetBoundary.clearReset()\n      defaultedOptions.onError?.(error)\n      defaultedOptions.onSettled?.(undefined, error)\n    })\n", "'use client'\nimport * as React from 'react'\n\nimport { notifyManager } from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend } from './suspense'\nimport type { QueryKey, QueryObserver } from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange))\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      useErrorBoundary: defaultedOptions.useErrorBoundary,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n", "'use client'\nimport { QueryObserver, parseQueryArgs } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type { QueryFunction, QueryKey } from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n", "'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  notifyManager,\n  parseMutationArgs,\n} from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport { shouldThrowError } from './utils'\nimport type { MutationFunction, MutationKey } from '@tanstack/query-core'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n"],
  "mappings": "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",
  "names": ["import_dist", "React", "useState", "useEffect", "useSyncExternalStore$1", "import_dist", "React", "useState", "useEffect", "useSyncExternalStore$1", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "Subscribable", "constructor", "listeners", "Set", "subscribe", "bind", "listener", "identity", "add", "onSubscribe", "delete", "onUnsubscribe", "hasListeners", "size", "import_dist", "isServer", "window", "noop", "undefined", "isValidTimeout", "value", "Infinity", "timeUntilStale", "updatedAt", "staleTime", "Math", "max", "Date", "now", "parseQueryArgs", "arg1", "arg2", "arg3", "isQueryKey", "queryKey", "queryFn", "parseMutationArgs", "mutationKey", "mutationFn", "replaceEqualDeep", "a", "b", "array", "isPlainArray", "isPlainObject", "aSize", "length", "Object", "keys", "bItems", "bSize", "copy", "equalItems", "i", "key", "shallowEqualObjects", "value", "Array", "isArray", "o", "hasObjectPrototype", "ctor", "constructor", "prot", "prototype", "hasOwnProperty", "toString", "call", "isQueryKey", "sleep", "timeout", "Promise", "resolve", "setTimeout", "scheduleMicrotask", "callback", "then", "replaceData", "prevData", "data", "options", "isDataEqual", "structuralSharing", "replaceEqualDeep", "FocusManager", "Subscribable", "constructor", "setup", "onFocus", "isServer", "window", "addEventListener", "listener", "removeEventListener", "onSubscribe", "cleanup", "setEventListener", "onUnsubscribe", "hasListeners", "undefined", "focused", "setFocused", "changed", "listeners", "forEach", "isFocused", "document", "includes", "visibilityState", "focusManager", "onlineEvents", "OnlineManager", "Subscribable", "constructor", "setup", "onOnline", "isServer", "window", "addEventListener", "listener", "forEach", "event", "removeEventListener", "onSubscribe", "cleanup", "setEventListener", "onUnsubscribe", "hasListeners", "undefined", "online", "setOnline", "changed", "listeners", "isOnline", "navigator", "onLine", "onlineManager", "canFetch", "networkMode", "onlineManager", "isOnline", "CancelledError", "constructor", "options", "revert", "silent", "isCancelledError", "value", "import_dist", "createNotifyManager", "queue", "transactions", "notifyFn", "callback", "batchNotifyFn", "batch", "result", "flush", "schedule", "push", "scheduleMicrotask", "batchCalls", "args", "originalQueue", "length", "forEach", "setNotifyFunction", "fn", "setBatchNotifyFunction", "notifyManager", "getDefaultState", "context", "undefined", "data", "error", "failureCount", "failureReason", "isPaused", "status", "variables", "import_dist", "QueryObserver", "Subscribable", "constructor", "client", "options", "trackedProps", "Set", "selectError", "bindMethods", "setOptions", "remove", "bind", "refetch", "onSubscribe", "listeners", "size", "currentQuery", "addObserver", "shouldFetchOnMount", "executeFetch", "updateTimers", "onUnsubscribe", "hasListeners", "destroy", "shouldFetchOnReconnect", "shouldFetchOn", "refetchOnReconnect", "shouldFetchOnWindowFocus", "refetchOnWindowFocus", "clearStaleTimeout", "clearRefetchInterval", "removeObserver", "notifyOptions", "prevOptions", "prevQuery", "defaultQueryOptions", "process", "env", "NODE_ENV", "isDataEqual", "getLogger", "error", "shallowEqualObjects", "getQueryCache", "notify", "type", "query", "observer", "enabled", "Error", "queryKey", "updateQuery", "mounted", "shouldFetchOptionally", "updateResult", "staleTime", "updateStaleTimeout", "nextRefetchInterval", "computeRefetchInterval", "currentRefetchInterval", "updateRefetchInterval", "getOptimisticResult", "build", "result", "createResult", "shouldAssignObserverCurrentProperties", "currentResult", "currentResultOptions", "currentResultState", "state", "getCurrentResult", "trackResult", "trackedResult", "Object", "keys", "forEach", "key", "defineProperty", "configurable", "enumerable", "get", "add", "getCurrentQuery", "refetchPage", "fetch", "meta", "fetchOptimistic", "defaultedOptions", "isFetchingOptimistic", "then", "fetchOptions", "cancelRefetch", "promise", "throwOnError", "catch", "noop", "isServer", "isStale", "isValidTimeout", "time", "timeUntilStale", "dataUpdatedAt", "timeout", "staleTimeoutId", "setTimeout", "refetchInterval", "data", "nextInterval", "refetchIntervalId", "setInterval", "refetchIntervalInBackground", "focusManager", "isFocused", "clearTimeout", "undefined", "clearInterval", "prevResult", "prevResultState", "prevResultOptions", "queryChange", "queryInitialState", "currentQueryInitialState", "prevQueryResult", "previousQueryResult", "errorUpdatedAt", "fetchStatus", "status", "isPreviousData", "isPlaceholderData", "_optimisticResults", "fetchOnMount", "fetchOptionally", "canFetch", "networkMode", "keepPreviousData", "isSuccess", "select", "selectFn", "selectResult", "replaceData", "placeholderData", "Date", "now", "isFetching", "isLoading", "isError", "isInitialLoading", "failureCount", "fetchFailureCount", "failureReason", "fetchFailureReason", "errorUpdateCount", "isFetched", "dataUpdateCount", "isFetchedAfterMount", "isRefetching", "isLoadingError", "isPaused", "isRefetchError", "nextResult", "defaultNotifyOptions", "cache", "shouldNotifyListeners", "notifyOnChangeProps", "notifyOnChangePropsValue", "includedProps", "useErrorBoundary", "some", "typedKey", "changed", "has", "onQueryUpdate", "action", "onSuccess", "manual", "isCancelledError", "onError", "notifyManager", "batch", "onSettled", "listener", "shouldLoadOnMount", "retryOnMount", "refetchOnMount", "field", "value", "suspense", "isStaleByTime", "optimisticResult", "MutationObserver", "Subscribable", "constructor", "client", "options", "setOptions", "bindMethods", "updateResult", "mutate", "bind", "reset", "prevOptions", "defaultMutationOptions", "shallowEqualObjects", "getMutationCache", "notify", "type", "mutation", "currentMutation", "observer", "onUnsubscribe", "hasListeners", "removeObserver", "onMutationUpdate", "action", "notifyOptions", "listeners", "onSuccess", "onError", "getCurrentResult", "currentResult", "undefined", "variables", "mutateOptions", "build", "addObserver", "execute", "state", "getDefaultState", "result", "isLoading", "status", "isSuccess", "isError", "isIdle", "notifyManager", "batch", "data", "context", "onSettled", "error", "forEach", "listener", "import_dist", "unstable_batchedUpdates", "notifyManager", "setBatchNotifyFunction", "unstable_batchedUpdates", "useSyncExternalStore$1", "context", "IsRestoringProvider", "clearReset", "isReset", "reset", "import_dist", "shouldThrowError", "_useErrorBoundary", "params", "useClearResetErrorBoundary", "errorResetBoundary", "query", "ensureStaleTime", "defaultedOptions", "suspense", "staleTime", "willFetch", "result", "isRestoring", "isLoading", "isFetching", "shouldSuspend", "fetchOptimistic", "observer", "errorResetBoundary", "then", "data", "onSuccess", "onSettled", "catch", "error", "clearReset", "onError", "undefined", "ensurePreventErrorBoundaryRetry", "useSyncExternalStore", "observer", "listeners", "noop", "React2", "React", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "useQuery", "React3", "React4", "React5", "React6", "React7", "React8", "React9", "React10", "React11", "React12", "React13", "React14", "React15", "React16", "React17", "React18", "React19", "React20", "React21", "React22", "React", "React2", "React3", "React4", "import_react", "useQuery", "useMemo5"]
}
