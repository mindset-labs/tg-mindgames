import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_build,
  require_build2,
  require_build3,
  require_build4,
  require_build5,
  require_build6,
  require_ripemd160,
  require_sha256,
  require_sha512
} from "./chunk-BIG3E5R2.js";
import {
  require_bank,
  require_binary,
  require_coin,
  require_helpers,
  require_pagination,
  require_query
} from "./chunk-JH3AK2MQ.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-DJIQL57M.js";

// node_modules/cosmjs-types/google/protobuf/any.js
var require_any = __commonJS({
  "node_modules/cosmjs-types/google/protobuf/any.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Any = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "google.protobuf";
    function createBaseAny() {
      return {
        typeUrl: "",
        value: new Uint8Array()
      };
    }
    exports2.Any = {
      typeUrl: "/google.protobuf.Any",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.typeUrl !== "") {
          writer.uint32(10).string(message.typeUrl);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAny();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.typeUrl = reader.string();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAny();
        if ((0, helpers_1.isSet)(object.typeUrl))
          obj.typeUrl = String(object.typeUrl);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAny();
        message.typeUrl = object.typeUrl ?? "";
        message.value = object.value ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js
var require_multisig = __commonJS({
  "node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompactBitArray = exports2.MultiSignature = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.crypto.multisig.v1beta1";
    function createBaseMultiSignature() {
      return {
        signatures: []
      };
    }
    exports2.MultiSignature = {
      typeUrl: "/cosmos.crypto.multisig.v1beta1.MultiSignature",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signatures) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiSignature();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMultiSignature();
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMultiSignature();
        message.signatures = ((_a = object.signatures) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseCompactBitArray() {
      return {
        extraBitsStored: 0,
        elems: new Uint8Array()
      };
    }
    exports2.CompactBitArray = {
      typeUrl: "/cosmos.crypto.multisig.v1beta1.CompactBitArray",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.extraBitsStored !== 0) {
          writer.uint32(8).uint32(message.extraBitsStored);
        }
        if (message.elems.length !== 0) {
          writer.uint32(18).bytes(message.elems);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompactBitArray();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.extraBitsStored = reader.uint32();
              break;
            case 2:
              message.elems = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompactBitArray();
        if ((0, helpers_1.isSet)(object.extraBitsStored))
          obj.extraBitsStored = Number(object.extraBitsStored);
        if ((0, helpers_1.isSet)(object.elems))
          obj.elems = (0, helpers_1.bytesFromBase64)(object.elems);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.extraBitsStored !== void 0 && (obj.extraBitsStored = Math.round(message.extraBitsStored));
        message.elems !== void 0 && (obj.elems = (0, helpers_1.base64FromBytes)(message.elems !== void 0 ? message.elems : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompactBitArray();
        message.extraBitsStored = object.extraBitsStored ?? 0;
        message.elems = object.elems ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js
var require_signing = __commonJS({
  "node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignatureDescriptor_Data_Multi = exports2.SignatureDescriptor_Data_Single = exports2.SignatureDescriptor_Data = exports2.SignatureDescriptor = exports2.SignatureDescriptors = exports2.signModeToJSON = exports2.signModeFromJSON = exports2.SignMode = exports2.protobufPackage = void 0;
    var multisig_1 = require_multisig();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.tx.signing.v1beta1";
    var SignMode;
    (function(SignMode2) {
      SignMode2[SignMode2["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
      SignMode2[SignMode2["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
      SignMode2[SignMode2["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
      SignMode2[SignMode2["SIGN_MODE_DIRECT_AUX"] = 3] = "SIGN_MODE_DIRECT_AUX";
      SignMode2[SignMode2["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
      SignMode2[SignMode2["SIGN_MODE_EIP_191"] = 191] = "SIGN_MODE_EIP_191";
      SignMode2[SignMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignMode || (exports2.SignMode = SignMode = {}));
    function signModeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGN_MODE_UNSPECIFIED":
          return SignMode.SIGN_MODE_UNSPECIFIED;
        case 1:
        case "SIGN_MODE_DIRECT":
          return SignMode.SIGN_MODE_DIRECT;
        case 2:
        case "SIGN_MODE_TEXTUAL":
          return SignMode.SIGN_MODE_TEXTUAL;
        case 3:
        case "SIGN_MODE_DIRECT_AUX":
          return SignMode.SIGN_MODE_DIRECT_AUX;
        case 127:
        case "SIGN_MODE_LEGACY_AMINO_JSON":
          return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        case 191:
        case "SIGN_MODE_EIP_191":
          return SignMode.SIGN_MODE_EIP_191;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignMode.UNRECOGNIZED;
      }
    }
    exports2.signModeFromJSON = signModeFromJSON;
    function signModeToJSON(object) {
      switch (object) {
        case SignMode.SIGN_MODE_UNSPECIFIED:
          return "SIGN_MODE_UNSPECIFIED";
        case SignMode.SIGN_MODE_DIRECT:
          return "SIGN_MODE_DIRECT";
        case SignMode.SIGN_MODE_TEXTUAL:
          return "SIGN_MODE_TEXTUAL";
        case SignMode.SIGN_MODE_DIRECT_AUX:
          return "SIGN_MODE_DIRECT_AUX";
        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:
          return "SIGN_MODE_LEGACY_AMINO_JSON";
        case SignMode.SIGN_MODE_EIP_191:
          return "SIGN_MODE_EIP_191";
        case SignMode.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.signModeToJSON = signModeToJSON;
    function createBaseSignatureDescriptors() {
      return {
        signatures: []
      };
    }
    exports2.SignatureDescriptors = {
      typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptors",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signatures) {
          exports2.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptors();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(exports2.SignatureDescriptor.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptors();
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => exports2.SignatureDescriptor.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports2.SignatureDescriptor.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseSignatureDescriptors();
        message.signatures = ((_a = object.signatures) == null ? void 0 : _a.map((e) => exports2.SignatureDescriptor.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSignatureDescriptor() {
      return {
        publicKey: void 0,
        data: void 0,
        sequence: BigInt(0)
      };
    }
    exports2.SignatureDescriptor = {
      typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptor",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          exports2.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = exports2.SignatureDescriptor_Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor();
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = exports2.SignatureDescriptor_Data.fromJSON(object.data);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.data !== void 0 && (obj.data = message.data ? exports2.SignatureDescriptor_Data.toJSON(message.data) : void 0);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        if (object.data !== void 0 && object.data !== null) {
          message.data = exports2.SignatureDescriptor_Data.fromPartial(object.data);
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data() {
      return {
        single: void 0,
        multi: void 0
      };
    }
    exports2.SignatureDescriptor_Data = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Data",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.single !== void 0) {
          exports2.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports2.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports2.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports2.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data();
        if ((0, helpers_1.isSet)(object.single))
          obj.single = exports2.SignatureDescriptor_Data_Single.fromJSON(object.single);
        if ((0, helpers_1.isSet)(object.multi))
          obj.multi = exports2.SignatureDescriptor_Data_Multi.fromJSON(object.multi);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports2.SignatureDescriptor_Data_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports2.SignatureDescriptor_Data_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data();
        if (object.single !== void 0 && object.single !== null) {
          message.single = exports2.SignatureDescriptor_Data_Single.fromPartial(object.single);
        }
        if (object.multi !== void 0 && object.multi !== null) {
          message.multi = exports2.SignatureDescriptor_Data_Multi.fromPartial(object.multi);
        }
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Single() {
      return {
        mode: 0,
        signature: new Uint8Array()
      };
    }
    exports2.SignatureDescriptor_Data_Single = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Single",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        if (message.signature.length !== 0) {
          writer.uint32(18).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            case 2:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data_Single();
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = signModeFromJSON(object.mode);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = signModeToJSON(message.mode));
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data_Single();
        message.mode = object.mode ?? 0;
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Multi() {
      return {
        bitarray: void 0,
        signatures: []
      };
    }
    exports2.SignatureDescriptor_Data_Multi = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Multi",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports2.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.signatures.push(exports2.SignatureDescriptor_Data.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data_Multi();
        if ((0, helpers_1.isSet)(object.bitarray))
          obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => exports2.SignatureDescriptor_Data.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports2.SignatureDescriptor_Data.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseSignatureDescriptor_Data_Multi();
        if (object.bitarray !== void 0 && object.bitarray !== null) {
          message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);
        }
        message.signatures = ((_a = object.signatures) == null ? void 0 : _a.map((e) => exports2.SignatureDescriptor_Data.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js
var require_tx = __commonJS({
  "node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuxSignerData = exports2.Tip = exports2.Fee = exports2.ModeInfo_Multi = exports2.ModeInfo_Single = exports2.ModeInfo = exports2.SignerInfo = exports2.AuthInfo = exports2.TxBody = exports2.SignDocDirectAux = exports2.SignDoc = exports2.TxRaw = exports2.Tx = exports2.protobufPackage = void 0;
    var any_1 = require_any();
    var signing_1 = require_signing();
    var multisig_1 = require_multisig();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.tx.v1beta1";
    function createBaseTx() {
      return {
        body: void 0,
        authInfo: void 0,
        signatures: []
      };
    }
    exports2.Tx = {
      typeUrl: "/cosmos.tx.v1beta1.Tx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.body !== void 0) {
          exports2.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();
        }
        if (message.authInfo !== void 0) {
          exports2.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.body = exports2.TxBody.decode(reader, reader.uint32());
              break;
            case 2:
              message.authInfo = exports2.AuthInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTx();
        if ((0, helpers_1.isSet)(object.body))
          obj.body = exports2.TxBody.fromJSON(object.body);
        if ((0, helpers_1.isSet)(object.authInfo))
          obj.authInfo = exports2.AuthInfo.fromJSON(object.authInfo);
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.body !== void 0 && (obj.body = message.body ? exports2.TxBody.toJSON(message.body) : void 0);
        message.authInfo !== void 0 && (obj.authInfo = message.authInfo ? exports2.AuthInfo.toJSON(message.authInfo) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseTx();
        if (object.body !== void 0 && object.body !== null) {
          message.body = exports2.TxBody.fromPartial(object.body);
        }
        if (object.authInfo !== void 0 && object.authInfo !== null) {
          message.authInfo = exports2.AuthInfo.fromPartial(object.authInfo);
        }
        message.signatures = ((_a = object.signatures) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseTxRaw() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        signatures: []
      };
    }
    exports2.TxRaw = {
      typeUrl: "/cosmos.tx.v1beta1.TxRaw",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        for (const v of message.signatures) {
          writer.uint32(26).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxRaw();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxRaw();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.authInfoBytes))
          obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseTxRaw();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
        message.signatures = ((_a = object.signatures) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseSignDoc() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        chainId: "",
        accountNumber: BigInt(0)
      };
    }
    exports2.SignDoc = {
      typeUrl: "/cosmos.tx.v1beta1.SignDoc",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(32).uint64(message.accountNumber);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDoc();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignDoc();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.authInfoBytes))
          obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignDoc();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
        message.chainId = object.chainId ?? "";
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        return message;
      }
    };
    function createBaseSignDocDirectAux() {
      return {
        bodyBytes: new Uint8Array(),
        publicKey: void 0,
        chainId: "",
        accountNumber: BigInt(0),
        sequence: BigInt(0),
        tip: void 0
      };
    }
    exports2.SignDocDirectAux = {
      typeUrl: "/cosmos.tx.v1beta1.SignDocDirectAux",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(32).uint64(message.accountNumber);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(40).uint64(message.sequence);
        }
        if (message.tip !== void 0) {
          exports2.Tip.encode(message.tip, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDocDirectAux();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = reader.uint64();
              break;
            case 5:
              message.sequence = reader.uint64();
              break;
            case 6:
              message.tip = exports2.Tip.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignDocDirectAux();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.tip))
          obj.tip = exports2.Tip.fromJSON(object.tip);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.tip !== void 0 && (obj.tip = message.tip ? exports2.Tip.toJSON(message.tip) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignDocDirectAux();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        message.chainId = object.chainId ?? "";
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        if (object.tip !== void 0 && object.tip !== null) {
          message.tip = exports2.Tip.fromPartial(object.tip);
        }
        return message;
      }
    };
    function createBaseTxBody() {
      return {
        messages: [],
        memo: "",
        timeoutHeight: BigInt(0),
        extensionOptions: [],
        nonCriticalExtensionOptions: []
      };
    }
    exports2.TxBody = {
      typeUrl: "/cosmos.tx.v1beta1.TxBody",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.memo !== "") {
          writer.uint32(18).string(message.memo);
        }
        if (message.timeoutHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.timeoutHeight);
        }
        for (const v of message.extensionOptions) {
          any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();
        }
        for (const v of message.nonCriticalExtensionOptions) {
          any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxBody();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.memo = reader.string();
              break;
            case 3:
              message.timeoutHeight = reader.uint64();
              break;
            case 1023:
              message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2047:
              message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxBody();
        if (Array.isArray(object == null ? void 0 : object.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.memo))
          obj.memo = String(object.memo);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = BigInt(object.timeoutHeight.toString());
        if (Array.isArray(object == null ? void 0 : object.extensionOptions))
          obj.extensionOptions = object.extensionOptions.map((e) => any_1.Any.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.nonCriticalExtensionOptions))
          obj.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.memo !== void 0 && (obj.memo = message.memo);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = (message.timeoutHeight || BigInt(0)).toString());
        if (message.extensionOptions) {
          obj.extensionOptions = message.extensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.extensionOptions = [];
        }
        if (message.nonCriticalExtensionOptions) {
          obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.nonCriticalExtensionOptions = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseTxBody();
        message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];
        message.memo = object.memo ?? "";
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = BigInt(object.timeoutHeight.toString());
        }
        message.extensionOptions = ((_b = object.extensionOptions) == null ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        message.nonCriticalExtensionOptions = ((_c = object.nonCriticalExtensionOptions) == null ? void 0 : _c.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseAuthInfo() {
      return {
        signerInfos: [],
        fee: void 0,
        tip: void 0
      };
    }
    exports2.AuthInfo = {
      typeUrl: "/cosmos.tx.v1beta1.AuthInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.signerInfos) {
          exports2.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.fee !== void 0) {
          exports2.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
        }
        if (message.tip !== void 0) {
          exports2.Tip.encode(message.tip, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuthInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signerInfos.push(exports2.SignerInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.fee = exports2.Fee.decode(reader, reader.uint32());
              break;
            case 3:
              message.tip = exports2.Tip.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAuthInfo();
        if (Array.isArray(object == null ? void 0 : object.signerInfos))
          obj.signerInfos = object.signerInfos.map((e) => exports2.SignerInfo.fromJSON(e));
        if ((0, helpers_1.isSet)(object.fee))
          obj.fee = exports2.Fee.fromJSON(object.fee);
        if ((0, helpers_1.isSet)(object.tip))
          obj.tip = exports2.Tip.fromJSON(object.tip);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signerInfos) {
          obj.signerInfos = message.signerInfos.map((e) => e ? exports2.SignerInfo.toJSON(e) : void 0);
        } else {
          obj.signerInfos = [];
        }
        message.fee !== void 0 && (obj.fee = message.fee ? exports2.Fee.toJSON(message.fee) : void 0);
        message.tip !== void 0 && (obj.tip = message.tip ? exports2.Tip.toJSON(message.tip) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseAuthInfo();
        message.signerInfos = ((_a = object.signerInfos) == null ? void 0 : _a.map((e) => exports2.SignerInfo.fromPartial(e))) || [];
        if (object.fee !== void 0 && object.fee !== null) {
          message.fee = exports2.Fee.fromPartial(object.fee);
        }
        if (object.tip !== void 0 && object.tip !== null) {
          message.tip = exports2.Tip.fromPartial(object.tip);
        }
        return message;
      }
    };
    function createBaseSignerInfo() {
      return {
        publicKey: void 0,
        modeInfo: void 0,
        sequence: BigInt(0)
      };
    }
    exports2.SignerInfo = {
      typeUrl: "/cosmos.tx.v1beta1.SignerInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.modeInfo !== void 0) {
          exports2.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignerInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfo = exports2.ModeInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignerInfo();
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.modeInfo))
          obj.modeInfo = exports2.ModeInfo.fromJSON(object.modeInfo);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.modeInfo !== void 0 && (obj.modeInfo = message.modeInfo ? exports2.ModeInfo.toJSON(message.modeInfo) : void 0);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignerInfo();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        if (object.modeInfo !== void 0 && object.modeInfo !== null) {
          message.modeInfo = exports2.ModeInfo.fromPartial(object.modeInfo);
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseModeInfo() {
      return {
        single: void 0,
        multi: void 0
      };
    }
    exports2.ModeInfo = {
      typeUrl: "/cosmos.tx.v1beta1.ModeInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.single !== void 0) {
          exports2.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports2.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports2.ModeInfo_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports2.ModeInfo_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo();
        if ((0, helpers_1.isSet)(object.single))
          obj.single = exports2.ModeInfo_Single.fromJSON(object.single);
        if ((0, helpers_1.isSet)(object.multi))
          obj.multi = exports2.ModeInfo_Multi.fromJSON(object.multi);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports2.ModeInfo_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports2.ModeInfo_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo();
        if (object.single !== void 0 && object.single !== null) {
          message.single = exports2.ModeInfo_Single.fromPartial(object.single);
        }
        if (object.multi !== void 0 && object.multi !== null) {
          message.multi = exports2.ModeInfo_Multi.fromPartial(object.multi);
        }
        return message;
      }
    };
    function createBaseModeInfo_Single() {
      return {
        mode: 0
      };
    }
    exports2.ModeInfo_Single = {
      typeUrl: "/cosmos.tx.v1beta1.Single",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo_Single();
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = (0, signing_1.signModeFromJSON)(object.mode);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo_Single();
        message.mode = object.mode ?? 0;
        return message;
      }
    };
    function createBaseModeInfo_Multi() {
      return {
        bitarray: void 0,
        modeInfos: []
      };
    }
    exports2.ModeInfo_Multi = {
      typeUrl: "/cosmos.tx.v1beta1.Multi",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.modeInfos) {
          exports2.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfos.push(exports2.ModeInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo_Multi();
        if ((0, helpers_1.isSet)(object.bitarray))
          obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);
        if (Array.isArray(object == null ? void 0 : object.modeInfos))
          obj.modeInfos = object.modeInfos.map((e) => exports2.ModeInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.modeInfos) {
          obj.modeInfos = message.modeInfos.map((e) => e ? exports2.ModeInfo.toJSON(e) : void 0);
        } else {
          obj.modeInfos = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseModeInfo_Multi();
        if (object.bitarray !== void 0 && object.bitarray !== null) {
          message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);
        }
        message.modeInfos = ((_a = object.modeInfos) == null ? void 0 : _a.map((e) => exports2.ModeInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseFee() {
      return {
        amount: [],
        gasLimit: BigInt(0),
        payer: "",
        granter: ""
      };
    }
    exports2.Fee = {
      typeUrl: "/cosmos.tx.v1beta1.Fee",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.gasLimit !== BigInt(0)) {
          writer.uint32(16).uint64(message.gasLimit);
        }
        if (message.payer !== "") {
          writer.uint32(26).string(message.payer);
        }
        if (message.granter !== "") {
          writer.uint32(34).string(message.granter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.gasLimit = reader.uint64();
              break;
            case 3:
              message.payer = reader.string();
              break;
            case 4:
              message.granter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFee();
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.gasLimit))
          obj.gasLimit = BigInt(object.gasLimit.toString());
        if ((0, helpers_1.isSet)(object.payer))
          obj.payer = String(object.payer);
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.gasLimit !== void 0 && (obj.gasLimit = (message.gasLimit || BigInt(0)).toString());
        message.payer !== void 0 && (obj.payer = message.payer);
        message.granter !== void 0 && (obj.granter = message.granter);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseFee();
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.gasLimit !== void 0 && object.gasLimit !== null) {
          message.gasLimit = BigInt(object.gasLimit.toString());
        }
        message.payer = object.payer ?? "";
        message.granter = object.granter ?? "";
        return message;
      }
    };
    function createBaseTip() {
      return {
        amount: [],
        tipper: ""
      };
    }
    exports2.Tip = {
      typeUrl: "/cosmos.tx.v1beta1.Tip",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.tipper !== "") {
          writer.uint32(18).string(message.tipper);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTip();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.tipper = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTip();
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.tipper))
          obj.tipper = String(object.tipper);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.tipper !== void 0 && (obj.tipper = message.tipper);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseTip();
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.tipper = object.tipper ?? "";
        return message;
      }
    };
    function createBaseAuxSignerData() {
      return {
        address: "",
        signDoc: void 0,
        mode: 0,
        sig: new Uint8Array()
      };
    }
    exports2.AuxSignerData = {
      typeUrl: "/cosmos.tx.v1beta1.AuxSignerData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.signDoc !== void 0) {
          exports2.SignDocDirectAux.encode(message.signDoc, writer.uint32(18).fork()).ldelim();
        }
        if (message.mode !== 0) {
          writer.uint32(24).int32(message.mode);
        }
        if (message.sig.length !== 0) {
          writer.uint32(34).bytes(message.sig);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuxSignerData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.signDoc = exports2.SignDocDirectAux.decode(reader, reader.uint32());
              break;
            case 3:
              message.mode = reader.int32();
              break;
            case 4:
              message.sig = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAuxSignerData();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.signDoc))
          obj.signDoc = exports2.SignDocDirectAux.fromJSON(object.signDoc);
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = (0, signing_1.signModeFromJSON)(object.mode);
        if ((0, helpers_1.isSet)(object.sig))
          obj.sig = (0, helpers_1.bytesFromBase64)(object.sig);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.signDoc !== void 0 && (obj.signDoc = message.signDoc ? exports2.SignDocDirectAux.toJSON(message.signDoc) : void 0);
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        message.sig !== void 0 && (obj.sig = (0, helpers_1.base64FromBytes)(message.sig !== void 0 ? message.sig : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAuxSignerData();
        message.address = object.address ?? "";
        if (object.signDoc !== void 0 && object.signDoc !== null) {
          message.signDoc = exports2.SignDocDirectAux.fromPartial(object.signDoc);
        }
        message.mode = object.mode ?? 0;
        message.sig = object.sig ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/@cosmjs/proto-signing/build/decode.js
var require_decode = __commonJS({
  "node_modules/@cosmjs/proto-signing/build/decode.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeTxRaw = void 0;
    var tx_1 = require_tx();
    function decodeTxRaw(tx) {
      const txRaw = tx_1.TxRaw.decode(tx);
      return {
        authInfo: tx_1.AuthInfo.decode(txRaw.authInfoBytes),
        body: tx_1.TxBody.decode(txRaw.bodyBytes),
        signatures: txRaw.signatures
      };
    }
    exports2.decodeTxRaw = decodeTxRaw;
  }
});

// node_modules/@cosmjs/amino/build/pubkeys.js
var require_pubkeys = __commonJS({
  "node_modules/@cosmjs/amino/build/pubkeys.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMultisigThresholdPubkey = exports2.isSinglePubkey = exports2.pubkeyType = exports2.isSecp256k1Pubkey = exports2.isEd25519Pubkey = void 0;
    function isEd25519Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyEd25519";
    }
    exports2.isEd25519Pubkey = isEd25519Pubkey;
    function isSecp256k1Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeySecp256k1";
    }
    exports2.isSecp256k1Pubkey = isSecp256k1Pubkey;
    exports2.pubkeyType = {
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
      secp256k1: "tendermint/PubKeySecp256k1",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
      ed25519: "tendermint/PubKeyEd25519",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
      sr25519: "tendermint/PubKeySr25519",
      multisigThreshold: "tendermint/PubKeyMultisigThreshold"
    };
    function isSinglePubkey(pubkey) {
      const singPubkeyTypes = [exports2.pubkeyType.ed25519, exports2.pubkeyType.secp256k1, exports2.pubkeyType.sr25519];
      return singPubkeyTypes.includes(pubkey.type);
    }
    exports2.isSinglePubkey = isSinglePubkey;
    function isMultisigThresholdPubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyMultisigThreshold";
    }
    exports2.isMultisigThresholdPubkey = isMultisigThresholdPubkey;
  }
});

// node_modules/@cosmjs/amino/build/encoding.js
var require_encoding = __commonJS({
  "node_modules/@cosmjs/amino/build/encoding.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeBech32Pubkey = exports2.encodeAminoPubkey = exports2.decodeBech32Pubkey = exports2.decodeAminoPubkey = exports2.encodeEd25519Pubkey = exports2.encodeSecp256k1Pubkey = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var utils_1 = require_build3();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Pubkey(pubkey) {
      if (pubkey.length !== 33 || pubkey[0] !== 2 && pubkey[0] !== 3) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
      }
      return {
        type: pubkeys_1.pubkeyType.secp256k1,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    exports2.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
    function encodeEd25519Pubkey(pubkey) {
      if (pubkey.length !== 32) {
        throw new Error("Ed25519 public key must be 32 bytes long");
      }
      return {
        type: pubkeys_1.pubkeyType.ed25519,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    exports2.encodeEd25519Pubkey = encodeEd25519Pubkey;
    var pubkeyAminoPrefixSecp256k1 = (0, encoding_1.fromHex)(
      "eb5ae98721"
      /* fixed length */
    );
    var pubkeyAminoPrefixEd25519 = (0, encoding_1.fromHex)(
      "1624de6420"
      /* fixed length */
    );
    var pubkeyAminoPrefixSr25519 = (0, encoding_1.fromHex)(
      "0dfb100520"
      /* fixed length */
    );
    var pubkeyAminoPrefixMultisigThreshold = (0, encoding_1.fromHex)(
      "22c1f7e2"
      /* variable length not included */
    );
    function decodeAminoPubkey(data) {
      if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSecp256k1)) {
        const rest = data.slice(pubkeyAminoPrefixSecp256k1.length);
        if (rest.length !== 33) {
          throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.secp256k1,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixEd25519)) {
        const rest = data.slice(pubkeyAminoPrefixEd25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.ed25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSr25519)) {
        const rest = data.slice(pubkeyAminoPrefixSr25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.sr25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data, pubkeyAminoPrefixMultisigThreshold)) {
        return decodeMultisigPubkey(data);
      } else {
        throw new Error("Unsupported public key type. Amino data starts with: " + (0, encoding_1.toHex)(data.slice(0, 5)));
      }
    }
    exports2.decodeAminoPubkey = decodeAminoPubkey;
    function decodeBech32Pubkey(bechEncoded) {
      const { data } = (0, encoding_1.fromBech32)(bechEncoded);
      return decodeAminoPubkey(data);
    }
    exports2.decodeBech32Pubkey = decodeBech32Pubkey;
    function decodeUvarint(reader) {
      if (reader.length < 1) {
        throw new Error("Can't decode varint. EOF");
      }
      if (reader[0] > 127) {
        throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
      }
      return [reader[0], 1];
    }
    function decodeMultisigPubkey(data) {
      const reader = Array.from(data);
      const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);
      if (!(0, utils_1.arrayContentStartsWith)(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {
        throw new Error("Invalid multisig prefix.");
      }
      if (reader.shift() != 8) {
        throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
      }
      const [threshold, thresholdBytesLength] = decodeUvarint(reader);
      reader.splice(0, thresholdBytesLength);
      const pubkeys = [];
      while (reader.length > 0) {
        if (reader.shift() != 18) {
          throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
        }
        const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);
        reader.splice(0, pubkeyLengthBytesSize);
        if (reader.length < pubkeyLength) {
          throw new Error("Invalid multisig data length.");
        }
        const encodedPubkey = reader.splice(0, pubkeyLength);
        const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));
        pubkeys.push(pubkey);
      }
      return {
        type: pubkeys_1.pubkeyType.multisigThreshold,
        value: {
          threshold: threshold.toString(),
          pubkeys
        }
      };
    }
    function encodeUvarint(value) {
      const checked = math_1.Uint53.fromString(value.toString()).toNumber();
      if (checked > 127) {
        throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
      }
      return [checked];
    }
    function encodeAminoPubkey(pubkey) {
      if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const out = Array.from(pubkeyAminoPrefixMultisigThreshold);
        out.push(8);
        out.push(...encodeUvarint(pubkey.value.threshold));
        for (const pubkeyData of pubkey.value.pubkeys.map((p) => encodeAminoPubkey(p))) {
          out.push(18);
          out.push(...encodeUvarint(pubkeyData.length));
          out.push(...pubkeyData);
        }
        return new Uint8Array(out);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixEd25519, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixSecp256k1, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else {
        throw new Error("Unsupported pubkey type");
      }
    }
    exports2.encodeAminoPubkey = encodeAminoPubkey;
    function encodeBech32Pubkey(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, encodeAminoPubkey(pubkey));
    }
    exports2.encodeBech32Pubkey = encodeBech32Pubkey;
  }
});

// node_modules/@cosmjs/amino/build/addresses.js
var require_addresses = __commonJS({
  "node_modules/@cosmjs/amino/build/addresses.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pubkeyToAddress = exports2.pubkeyToRawAddress = exports2.rawSecp256k1PubkeyToRawAddress = exports2.rawEd25519PubkeyToRawAddress = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    exports2.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    exports2.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    function pubkeyToRawAddress(pubkey) {
      if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawSecp256k1PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawEd25519PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);
        return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
      } else {
        throw new Error("Unsupported public key type");
      }
    }
    exports2.pubkeyToRawAddress = pubkeyToRawAddress;
    function pubkeyToAddress(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));
    }
    exports2.pubkeyToAddress = pubkeyToAddress;
  }
});

// node_modules/@cosmjs/amino/build/coins.js
var require_coins = __commonJS({
  "node_modules/@cosmjs/amino/build/coins.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addCoins = exports2.parseCoins = exports2.coins = exports2.coin = void 0;
    var math_1 = require_build2();
    function coin(amount, denom) {
      let outAmount;
      if (typeof amount === "number") {
        try {
          outAmount = new math_1.Uint53(amount).toString();
        } catch (_err) {
          throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
        }
      } else {
        if (!amount.match(/^[0-9]+$/)) {
          throw new Error("Invalid unsigned integer string format");
        }
        outAmount = amount.replace(/^0*/, "") || "0";
      }
      return {
        amount: outAmount,
        denom
      };
    }
    exports2.coin = coin;
    function coins(amount, denom) {
      return [coin(amount, denom)];
    }
    exports2.coins = coins;
    function parseCoins(input) {
      return input.replace(/\s/g, "").split(",").filter(Boolean).map((part) => {
        const match = part.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
        if (!match)
          throw new Error("Got an invalid coin string");
        return {
          amount: match[1].replace(/^0+/, "") || "0",
          denom: match[2]
        };
      });
    }
    exports2.parseCoins = parseCoins;
    function addCoins(lhs, rhs) {
      if (lhs.denom !== rhs.denom)
        throw new Error("Trying to add two coins with different denoms");
      return {
        amount: math_1.Decimal.fromAtomics(lhs.amount, 0).plus(math_1.Decimal.fromAtomics(rhs.amount, 0)).atomics,
        denom: lhs.denom
      };
    }
    exports2.addCoins = addCoins;
  }
});

// node_modules/@cosmjs/amino/build/multisig.js
var require_multisig2 = __commonJS({
  "node_modules/@cosmjs/amino/build/multisig.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMultisigThresholdPubkey = exports2.compareArrays = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var addresses_1 = require_addresses();
    function compareArrays(a, b) {
      const aHex = (0, encoding_1.toHex)(a);
      const bHex = (0, encoding_1.toHex)(b);
      return aHex === bHex ? 0 : aHex < bHex ? -1 : 1;
    }
    exports2.compareArrays = compareArrays;
    function createMultisigThresholdPubkey(pubkeys, threshold, nosort = false) {
      const uintThreshold = new math_1.Uint53(threshold);
      if (uintThreshold.toNumber() > pubkeys.length) {
        throw new Error(`Threshold k = ${uintThreshold.toNumber()} exceeds number of keys n = ${pubkeys.length}`);
      }
      const outPubkeys = nosort ? pubkeys : Array.from(pubkeys).sort((lhs, rhs) => {
        const addressLhs = (0, addresses_1.pubkeyToRawAddress)(lhs);
        const addressRhs = (0, addresses_1.pubkeyToRawAddress)(rhs);
        return compareArrays(addressLhs, addressRhs);
      });
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: uintThreshold.toString(),
          pubkeys: outPubkeys
        }
      };
    }
    exports2.createMultisigThresholdPubkey = createMultisigThresholdPubkey;
  }
});

// node_modules/@cosmjs/amino/build/omitdefault.js
var require_omitdefault = __commonJS({
  "node_modules/@cosmjs/amino/build/omitdefault.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.omitDefault = void 0;
    function omitDefault(input) {
      switch (typeof input) {
        case "string":
          return input === "" ? void 0 : input;
        case "number":
          return input === 0 ? void 0 : input;
        case "bigint":
          return input === BigInt(0) ? void 0 : input;
        case "boolean":
          return !input ? void 0 : input;
        default:
          throw new Error(`Got unsupported type '${typeof input}'`);
      }
    }
    exports2.omitDefault = omitDefault;
  }
});

// node_modules/@cosmjs/amino/build/paths.js
var require_paths = __commonJS({
  "node_modules/@cosmjs/amino/build/paths.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeCosmoshubPath = void 0;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
    exports2.makeCosmoshubPath = makeCosmoshubPath;
  }
});

// node_modules/@cosmjs/amino/build/signature.js
var require_signature = __commonJS({
  "node_modules/@cosmjs/amino/build/signature.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeSignature = exports2.encodeSecp256k1Signature = void 0;
    var encoding_1 = require_build();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Signature(pubkey, signature) {
      if (signature.length !== 64) {
        throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
      }
      return {
        pub_key: (0, encoding_2.encodeSecp256k1Pubkey)(pubkey),
        signature: (0, encoding_1.toBase64)(signature)
      };
    }
    exports2.encodeSecp256k1Signature = encodeSecp256k1Signature;
    function decodeSignature(signature) {
      switch (signature.pub_key.type) {
        case pubkeys_1.pubkeyType.secp256k1:
          return {
            pubkey: (0, encoding_1.fromBase64)(signature.pub_key.value),
            signature: (0, encoding_1.fromBase64)(signature.signature)
          };
        default:
          throw new Error("Unsupported pubkey type");
      }
    }
    exports2.decodeSignature = decodeSignature;
  }
});

// node_modules/@cosmjs/amino/build/signdoc.js
var require_signdoc = __commonJS({
  "node_modules/@cosmjs/amino/build/signdoc.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeSignDoc = exports2.escapeCharacters = exports2.makeSignDoc = exports2.sortedJsonStringify = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    function sortedObject(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(sortedObject);
      }
      const sortedKeys = Object.keys(obj).sort();
      const result = {};
      sortedKeys.forEach((key) => {
        result[key] = sortedObject(obj[key]);
      });
      return result;
    }
    function sortedJsonStringify(obj) {
      return JSON.stringify(sortedObject(obj));
    }
    exports2.sortedJsonStringify = sortedJsonStringify;
    function makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence, timeout_height) {
      return {
        chain_id: chainId,
        account_number: math_1.Uint53.fromString(accountNumber.toString()).toString(),
        sequence: math_1.Uint53.fromString(sequence.toString()).toString(),
        fee,
        msgs,
        memo: memo || "",
        ...timeout_height && { timeout_height: timeout_height.toString() }
      };
    }
    exports2.makeSignDoc = makeSignDoc;
    function escapeCharacters(input) {
      const amp = /&/g;
      const lt = /</g;
      const gt = />/g;
      return input.replace(amp, "\\u0026").replace(lt, "\\u003c").replace(gt, "\\u003e");
    }
    exports2.escapeCharacters = escapeCharacters;
    function serializeSignDoc(signDoc) {
      const serialized = escapeCharacters(sortedJsonStringify(signDoc));
      return (0, encoding_1.toUtf8)(serialized);
    }
    exports2.serializeSignDoc = serializeSignDoc;
  }
});

// node_modules/@cosmjs/amino/build/wallet.js
var require_wallet = __commonJS({
  "node_modules/@cosmjs/amino/build/wallet.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decrypt = exports2.encrypt = exports2.supportedAlgorithms = exports2.executeKdf = exports2.cosmjsSalt = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    exports2.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          return crypto_1.Argon2id.execute(password, exports2.cosmjsSalt, options);
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports2.executeKdf = executeKdf;
    exports2.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports2.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports2.encrypt = encrypt;
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports2.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports2.decrypt = decrypt;
  }
});

// node_modules/@cosmjs/amino/build/secp256k1hdwallet.js
var require_secp256k1hdwallet = __commonJS({
  "node_modules/@cosmjs/amino/build/secp256k1hdwallet.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Secp256k1HdWallet = exports2.extractKdfConfiguration = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var addresses_1 = require_addresses();
    var paths_1 = require_paths();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var wallet_1 = require_wallet();
    var serializationTypeV1 = "secp256k1wallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    exports2.extractKdfConfiguration = extractKdfConfiguration;
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var Secp256k1HdWallet = class _Secp256k1HdWallet {
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _Secp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _Secp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _Secp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      constructor(mnemonic, options) {
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        const prefix = options.prefix ?? defaultOptions.prefix;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signAmino(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));
        const signature = await crypto_1.Secp256k1.createSignature(message, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports2.Secp256k1HdWallet = Secp256k1HdWallet;
  }
});

// node_modules/@cosmjs/amino/build/secp256k1wallet.js
var require_secp256k1wallet = __commonJS({
  "node_modules/@cosmjs/amino/build/secp256k1wallet.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Secp256k1Wallet = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var addresses_1 = require_addresses();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var Secp256k1Wallet = class _Secp256k1Wallet {
      /**
       * Creates a Secp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _Secp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signAmino(signerAddress, signDoc) {
        if (signerAddress !== this.address) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const message = new crypto_1.Sha256((0, signdoc_1.serializeSignDoc)(signDoc)).digest();
        const signature = await crypto_1.Secp256k1.createSignature(message, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes)
        };
      }
    };
    exports2.Secp256k1Wallet = Secp256k1Wallet;
  }
});

// node_modules/@cosmjs/amino/build/stdtx.js
var require_stdtx = __commonJS({
  "node_modules/@cosmjs/amino/build/stdtx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeStdTx = exports2.isStdTx = void 0;
    function isStdTx(txValue) {
      const { memo, msg, fee, signatures } = txValue;
      return typeof memo === "string" && Array.isArray(msg) && typeof fee === "object" && Array.isArray(signatures);
    }
    exports2.isStdTx = isStdTx;
    function makeStdTx(content, signatures) {
      return {
        msg: content.msgs,
        fee: content.fee,
        memo: content.memo,
        signatures: Array.isArray(signatures) ? signatures : [signatures]
      };
    }
    exports2.makeStdTx = makeStdTx;
  }
});

// node_modules/@cosmjs/amino/build/index.js
var require_build7 = __commonJS({
  "node_modules/@cosmjs/amino/build/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.executeKdf = exports2.makeStdTx = exports2.isStdTx = exports2.serializeSignDoc = exports2.makeSignDoc = exports2.encodeSecp256k1Signature = exports2.decodeSignature = exports2.Secp256k1Wallet = exports2.Secp256k1HdWallet = exports2.extractKdfConfiguration = exports2.pubkeyType = exports2.isSinglePubkey = exports2.isSecp256k1Pubkey = exports2.isMultisigThresholdPubkey = exports2.isEd25519Pubkey = exports2.makeCosmoshubPath = exports2.omitDefault = exports2.createMultisigThresholdPubkey = exports2.encodeSecp256k1Pubkey = exports2.encodeEd25519Pubkey = exports2.encodeBech32Pubkey = exports2.encodeAminoPubkey = exports2.decodeBech32Pubkey = exports2.decodeAminoPubkey = exports2.parseCoins = exports2.coins = exports2.coin = exports2.addCoins = exports2.rawSecp256k1PubkeyToRawAddress = exports2.rawEd25519PubkeyToRawAddress = exports2.pubkeyToRawAddress = exports2.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports2, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports2, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports2, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports2, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var coins_1 = require_coins();
    Object.defineProperty(exports2, "addCoins", { enumerable: true, get: function() {
      return coins_1.addCoins;
    } });
    Object.defineProperty(exports2, "coin", { enumerable: true, get: function() {
      return coins_1.coin;
    } });
    Object.defineProperty(exports2, "coins", { enumerable: true, get: function() {
      return coins_1.coins;
    } });
    Object.defineProperty(exports2, "parseCoins", { enumerable: true, get: function() {
      return coins_1.parseCoins;
    } });
    var encoding_1 = require_encoding();
    Object.defineProperty(exports2, "decodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.decodeAminoPubkey;
    } });
    Object.defineProperty(exports2, "decodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.decodeBech32Pubkey;
    } });
    Object.defineProperty(exports2, "encodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.encodeAminoPubkey;
    } });
    Object.defineProperty(exports2, "encodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeBech32Pubkey;
    } });
    Object.defineProperty(exports2, "encodeEd25519Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeEd25519Pubkey;
    } });
    Object.defineProperty(exports2, "encodeSecp256k1Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeSecp256k1Pubkey;
    } });
    var multisig_1 = require_multisig2();
    Object.defineProperty(exports2, "createMultisigThresholdPubkey", { enumerable: true, get: function() {
      return multisig_1.createMultisigThresholdPubkey;
    } });
    var omitdefault_1 = require_omitdefault();
    Object.defineProperty(exports2, "omitDefault", { enumerable: true, get: function() {
      return omitdefault_1.omitDefault;
    } });
    var paths_1 = require_paths();
    Object.defineProperty(exports2, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkeys_1 = require_pubkeys();
    Object.defineProperty(exports2, "isEd25519Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isEd25519Pubkey;
    } });
    Object.defineProperty(exports2, "isMultisigThresholdPubkey", { enumerable: true, get: function() {
      return pubkeys_1.isMultisigThresholdPubkey;
    } });
    Object.defineProperty(exports2, "isSecp256k1Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSecp256k1Pubkey;
    } });
    Object.defineProperty(exports2, "isSinglePubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSinglePubkey;
    } });
    Object.defineProperty(exports2, "pubkeyType", { enumerable: true, get: function() {
      return pubkeys_1.pubkeyType;
    } });
    var secp256k1hdwallet_1 = require_secp256k1hdwallet();
    Object.defineProperty(exports2, "extractKdfConfiguration", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.extractKdfConfiguration;
    } });
    Object.defineProperty(exports2, "Secp256k1HdWallet", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.Secp256k1HdWallet;
    } });
    var secp256k1wallet_1 = require_secp256k1wallet();
    Object.defineProperty(exports2, "Secp256k1Wallet", { enumerable: true, get: function() {
      return secp256k1wallet_1.Secp256k1Wallet;
    } });
    var signature_1 = require_signature();
    Object.defineProperty(exports2, "decodeSignature", { enumerable: true, get: function() {
      return signature_1.decodeSignature;
    } });
    Object.defineProperty(exports2, "encodeSecp256k1Signature", { enumerable: true, get: function() {
      return signature_1.encodeSecp256k1Signature;
    } });
    var signdoc_1 = require_signdoc();
    Object.defineProperty(exports2, "makeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.makeSignDoc;
    } });
    Object.defineProperty(exports2, "serializeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.serializeSignDoc;
    } });
    var stdtx_1 = require_stdtx();
    Object.defineProperty(exports2, "isStdTx", { enumerable: true, get: function() {
      return stdtx_1.isStdTx;
    } });
    Object.defineProperty(exports2, "makeStdTx", { enumerable: true, get: function() {
      return stdtx_1.makeStdTx;
    } });
    var wallet_1 = require_wallet();
    Object.defineProperty(exports2, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
  }
});

// node_modules/@cosmjs/proto-signing/build/signing.js
var require_signing2 = __commonJS({
  "node_modules/@cosmjs/proto-signing/build/signing.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeSignBytes = exports2.makeSignDoc = exports2.makeAuthInfoBytes = void 0;
    var utils_1 = require_build3();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    function makeSignerInfos(signers, signMode) {
      return signers.map(({ pubkey, sequence }) => ({
        publicKey: pubkey,
        modeInfo: {
          single: { mode: signMode }
        },
        sequence: BigInt(sequence)
      }));
    }
    function makeAuthInfoBytes(signers, feeAmount, gasLimit, feeGranter, feePayer, signMode = signing_1.SignMode.SIGN_MODE_DIRECT) {
      (0, utils_1.assert)(feeGranter === void 0 || typeof feeGranter === "string", "feeGranter must be undefined or string");
      (0, utils_1.assert)(feePayer === void 0 || typeof feePayer === "string", "feePayer must be undefined or string");
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
          amount: [...feeAmount],
          gasLimit: BigInt(gasLimit),
          granter: feeGranter,
          payer: feePayer
        }
      });
      return tx_1.AuthInfo.encode(authInfo).finish();
    }
    exports2.makeAuthInfoBytes = makeAuthInfoBytes;
    function makeSignDoc(bodyBytes, authInfoBytes, chainId, accountNumber) {
      return {
        bodyBytes,
        authInfoBytes,
        chainId,
        accountNumber: BigInt(accountNumber)
      };
    }
    exports2.makeSignDoc = makeSignDoc;
    function makeSignBytes({ accountNumber, authInfoBytes, bodyBytes, chainId }) {
      const signDoc = tx_1.SignDoc.fromPartial({
        accountNumber,
        authInfoBytes,
        bodyBytes,
        chainId
      });
      return tx_1.SignDoc.encode(signDoc).finish();
    }
    exports2.makeSignBytes = makeSignBytes;
  }
});

// node_modules/@cosmjs/proto-signing/build/wallet.js
var require_wallet2 = __commonJS({
  "node_modules/@cosmjs/proto-signing/build/wallet.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decrypt = exports2.encrypt = exports2.supportedAlgorithms = exports2.executeKdf = exports2.cosmjsSalt = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    exports2.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          return crypto_1.Argon2id.execute(password, exports2.cosmjsSalt, options);
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports2.executeKdf = executeKdf;
    exports2.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports2.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports2.encrypt = encrypt;
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports2.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    exports2.decrypt = decrypt;
  }
});

// node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js
var require_directsecp256k1hdwallet = __commonJS({
  "node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectSecp256k1HdWallet = exports2.extractKdfConfiguration = void 0;
    var amino_1 = require_build7();
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var utils_1 = require_build3();
    var signing_1 = require_signing2();
    var wallet_1 = require_wallet2();
    var serializationTypeV1 = "directsecp256k1hdwallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    exports2.extractKdfConfiguration = extractKdfConfiguration;
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, amino_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var DirectSecp256k1HdWallet = class _DirectSecp256k1HdWallet {
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _DirectSecp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      constructor(mnemonic, options) {
        const prefix = options.prefix ?? defaultOptions.prefix;
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signDirect(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports2.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;
  }
});

// node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js
var require_directsecp256k1wallet = __commonJS({
  "node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectSecp256k1Wallet = void 0;
    var amino_1 = require_build7();
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    var signing_1 = require_signing2();
    var DirectSecp256k1Wallet = class _DirectSecp256k1Wallet {
      /**
       * Creates a DirectSecp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _DirectSecp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signDirect(address, signDoc) {
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        if (address !== this.address) {
          throw new Error(`Address ${address} not found in wallet`);
        }
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
    };
    exports2.DirectSecp256k1Wallet = DirectSecp256k1Wallet;
  }
});

// node_modules/@cosmjs/proto-signing/build/paths.js
var require_paths2 = __commonJS({
  "node_modules/@cosmjs/proto-signing/build/paths.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeCosmoshubPath = void 0;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a)
      ];
    }
    exports2.makeCosmoshubPath = makeCosmoshubPath;
  }
});

// node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js
var require_keys = __commonJS({
  "node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivKey = exports2.PubKey = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.crypto.ed25519";
    function createBasePubKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports2.PubKey = {
      typeUrl: "/cosmos.crypto.ed25519.PubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePubKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
    function createBasePrivKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports2.PrivKey = {
      typeUrl: "/cosmos.crypto.ed25519.PrivKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePrivKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js
var require_keys2 = __commonJS({
  "node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LegacyAminoPubKey = exports2.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.crypto.multisig";
    function createBaseLegacyAminoPubKey() {
      return {
        threshold: 0,
        publicKeys: []
      };
    }
    exports2.LegacyAminoPubKey = {
      typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.threshold !== 0) {
          writer.uint32(8).uint32(message.threshold);
        }
        for (const v of message.publicKeys) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLegacyAminoPubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.threshold = reader.uint32();
              break;
            case 2:
              message.publicKeys.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLegacyAminoPubKey();
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = Number(object.threshold);
        if (Array.isArray(object == null ? void 0 : object.publicKeys))
          obj.publicKeys = object.publicKeys.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.threshold !== void 0 && (obj.threshold = Math.round(message.threshold));
        if (message.publicKeys) {
          obj.publicKeys = message.publicKeys.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.publicKeys = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseLegacyAminoPubKey();
        message.threshold = object.threshold ?? 0;
        message.publicKeys = ((_a = object.publicKeys) == null ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js
var require_keys3 = __commonJS({
  "node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivKey = exports2.PubKey = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.crypto.secp256k1";
    function createBasePubKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports2.PubKey = {
      typeUrl: "/cosmos.crypto.secp256k1.PubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePubKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
    function createBasePrivKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports2.PrivKey = {
      typeUrl: "/cosmos.crypto.secp256k1.PrivKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePrivKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/@cosmjs/proto-signing/build/pubkey.js
var require_pubkey = __commonJS({
  "node_modules/@cosmjs/proto-signing/build/pubkey.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeOptionalPubkey = exports2.decodePubkey = exports2.anyToSinglePubkey = exports2.encodePubkey = void 0;
    var amino_1 = require_build7();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var keys_1 = require_keys();
    var keys_2 = require_keys2();
    var keys_3 = require_keys3();
    var any_1 = require_any();
    function encodePubkey(pubkey) {
      if ((0, amino_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyProto = keys_3.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.secp256k1.PubKey",
          value: Uint8Array.from(keys_3.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyProto = keys_1.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.ed25519.PubKey",
          value: Uint8Array.from(keys_1.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyProto = keys_2.LegacyAminoPubKey.fromPartial({
          threshold: math_1.Uint53.fromString(pubkey.value.threshold).toNumber(),
          publicKeys: pubkey.value.pubkeys.map(encodePubkey)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
          value: Uint8Array.from(keys_2.LegacyAminoPubKey.encode(pubkeyProto).finish())
        });
      } else {
        throw new Error(`Pubkey type ${pubkey.type} not recognized`);
      }
    }
    exports2.encodePubkey = encodePubkey;
    function anyToSinglePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey": {
          const { key } = keys_3.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeSecp256k1Pubkey)(key);
        }
        case "/cosmos.crypto.ed25519.PubKey": {
          const { key } = keys_1.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeEd25519Pubkey)(key);
        }
        default:
          throw new Error(`Pubkey type_url ${pubkey.typeUrl} not recognized as single public key type`);
      }
    }
    exports2.anyToSinglePubkey = anyToSinglePubkey;
    function decodePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey":
        case "/cosmos.crypto.ed25519.PubKey": {
          return anyToSinglePubkey(pubkey);
        }
        case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
          const { threshold, publicKeys } = keys_2.LegacyAminoPubKey.decode(pubkey.value);
          const out = {
            type: "tendermint/PubKeyMultisigThreshold",
            value: {
              threshold: threshold.toString(),
              pubkeys: publicKeys.map(anyToSinglePubkey)
            }
          };
          return out;
        }
        default:
          throw new Error(`Pubkey type URL '${pubkey.typeUrl}' not recognized`);
      }
    }
    exports2.decodePubkey = decodePubkey;
    function decodeOptionalPubkey(pubkey) {
      if (!pubkey)
        return null;
      if (pubkey.typeUrl) {
        if (pubkey.value.length) {
          return decodePubkey(pubkey);
        } else {
          throw new Error(`Pubkey is an Any with type URL '${pubkey.typeUrl}' but an empty value`);
        }
      } else {
        if (pubkey.value.length) {
          throw new Error(`Pubkey is an Any with an empty type URL but a value set`);
        } else {
          return null;
        }
      }
    }
    exports2.decodeOptionalPubkey = decodeOptionalPubkey;
  }
});

// node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js
var require_tx2 = __commonJS({
  "node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgSetSendEnabledResponse = exports2.MsgSetSendEnabled = exports2.MsgUpdateParamsResponse = exports2.MsgUpdateParams = exports2.MsgMultiSendResponse = exports2.MsgMultiSend = exports2.MsgSendResponse = exports2.MsgSend = exports2.protobufPackage = void 0;
    var coin_1 = require_coin();
    var bank_1 = require_bank();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseMsgSend() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: []
      };
    }
    exports2.MsgSend = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSend();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgSend();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgSendResponse() {
      return {};
    }
    exports2.MsgSendResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSendResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSendResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSendResponse();
        return message;
      }
    };
    function createBaseMsgMultiSend() {
      return {
        inputs: [],
        outputs: []
      };
    }
    exports2.MsgMultiSend = {
      typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.inputs) {
          bank_1.Input.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.outputs) {
          bank_1.Output.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));
              break;
            case 2:
              message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgMultiSend();
        if (Array.isArray(object == null ? void 0 : object.inputs))
          obj.inputs = object.inputs.map((e) => bank_1.Input.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.outputs))
          obj.outputs = object.outputs.map((e) => bank_1.Output.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.inputs) {
          obj.inputs = message.inputs.map((e) => e ? bank_1.Input.toJSON(e) : void 0);
        } else {
          obj.inputs = [];
        }
        if (message.outputs) {
          obj.outputs = message.outputs.map((e) => e ? bank_1.Output.toJSON(e) : void 0);
        } else {
          obj.outputs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgMultiSend();
        message.inputs = ((_a = object.inputs) == null ? void 0 : _a.map((e) => bank_1.Input.fromPartial(e))) || [];
        message.outputs = ((_b = object.outputs) == null ? void 0 : _b.map((e) => bank_1.Output.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgMultiSendResponse() {
      return {};
    }
    exports2.MsgMultiSendResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgMultiSendResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgMultiSendResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgMultiSendResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: bank_1.Params.fromPartial({})
      };
    }
    exports2.MsgUpdateParams = {
      typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          bank_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = bank_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = bank_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = bank_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports2.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgSetSendEnabled() {
      return {
        authority: "",
        sendEnabled: [],
        useDefaultFor: []
      };
    }
    exports2.MsgSetSendEnabled = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        for (const v of message.sendEnabled) {
          bank_1.SendEnabled.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.useDefaultFor) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetSendEnabled();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 3:
              message.useDefaultFor.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSetSendEnabled();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if (Array.isArray(object == null ? void 0 : object.sendEnabled))
          obj.sendEnabled = object.sendEnabled.map((e) => bank_1.SendEnabled.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.useDefaultFor))
          obj.useDefaultFor = object.useDefaultFor.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? bank_1.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        if (message.useDefaultFor) {
          obj.useDefaultFor = message.useDefaultFor.map((e) => e);
        } else {
          obj.useDefaultFor = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSetSendEnabled();
        message.authority = object.authority ?? "";
        message.sendEnabled = ((_a = object.sendEnabled) == null ? void 0 : _a.map((e) => bank_1.SendEnabled.fromPartial(e))) || [];
        message.useDefaultFor = ((_b = object.useDefaultFor) == null ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMsgSetSendEnabledResponse() {
      return {};
    }
    exports2.MsgSetSendEnabledResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabledResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetSendEnabledResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSetSendEnabledResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSetSendEnabledResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Send = this.Send.bind(this);
        this.MultiSend = this.MultiSend.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.SetSendEnabled = this.SetSendEnabled.bind(this);
      }
      Send(request) {
        const data = exports2.MsgSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", data);
        return promise.then((data2) => exports2.MsgSendResponse.decode(new binary_1.BinaryReader(data2)));
      }
      MultiSend(request) {
        const data = exports2.MsgMultiSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", data);
        return promise.then((data2) => exports2.MsgMultiSendResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateParams(request) {
        const data = exports2.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", data);
        return promise.then((data2) => exports2.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      SetSendEnabled(request) {
        const data = exports2.MsgSetSendEnabled.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", data);
        return promise.then((data2) => exports2.MsgSetSendEnabledResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/proto-signing/build/registry.js
var require_registry = __commonJS({
  "node_modules/@cosmjs/proto-signing/build/registry.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Registry = exports2.isTxBodyEncodeObject = exports2.isPbjsGeneratedType = exports2.isTsProtoGeneratedType = exports2.isTelescopeGeneratedType = void 0;
    var tx_1 = require_tx2();
    var coin_1 = require_coin();
    var tx_2 = require_tx();
    var any_1 = require_any();
    function isTelescopeGeneratedType(type) {
      const casted = type;
      return typeof casted.fromPartial === "function" && typeof casted.typeUrl == "string";
    }
    exports2.isTelescopeGeneratedType = isTelescopeGeneratedType;
    function isTsProtoGeneratedType(type) {
      return typeof type.fromPartial === "function";
    }
    exports2.isTsProtoGeneratedType = isTsProtoGeneratedType;
    function isPbjsGeneratedType(type) {
      return !isTsProtoGeneratedType(type);
    }
    exports2.isPbjsGeneratedType = isPbjsGeneratedType;
    var defaultTypeUrls = {
      cosmosCoin: "/cosmos.base.v1beta1.Coin",
      cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
      cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
      googleAny: "/google.protobuf.Any"
    };
    function isTxBodyEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.tx.v1beta1.TxBody";
    }
    exports2.isTxBodyEncodeObject = isTxBodyEncodeObject;
    var Registry = class {
      /**
       * Creates a new Registry for mapping protobuf type identifiers/type URLs to
       * actual implementations. Those implementations are typically generated with ts-proto
       * but we also support protobuf.js as a type generator.
       *
       * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
       * for historic reasons. Those can be overriden by customTypes.
       *
       * There are currently two methods for adding new types:
       * 1. Passing types to the constructor.
       * 2. Using the `register()` method
       */
      constructor(customTypes) {
        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;
        this.types = customTypes ? new Map([...customTypes]) : /* @__PURE__ */ new Map([
          [cosmosCoin, coin_1.Coin],
          [cosmosMsgSend, tx_1.MsgSend]
        ]);
      }
      register(typeUrl, type) {
        this.types.set(typeUrl, type);
      }
      /**
       * Looks up a type that was previously added to the registry.
       *
       * The generator information (ts-proto or pbjs) gets lost along the way.
       * If you need to work with the result type in TypeScript, you can use:
       *
       * ```
       * import { assert } from "@cosmjs/utils";
       *
       * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
       * assert(Coin); // Ensures not unset
       * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
       *
       * // Coin is typed TsProtoGeneratedType now.
       * ```
       */
      lookupType(typeUrl) {
        return this.types.get(typeUrl);
      }
      lookupTypeWithError(typeUrl) {
        const type = this.lookupType(typeUrl);
        if (!type) {
          throw new Error(`Unregistered type url: ${typeUrl}`);
        }
        return type;
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to protobuf if
       * the given type was previously registered.
       *
       * If the value has to be wrapped in an Any, this needs to be done
       * manually after this call. Or use `encodeAsAny` instead.
       */
      encode(encodeObject) {
        const { value, typeUrl } = encodeObject;
        if (isTxBodyEncodeObject(encodeObject)) {
          return this.encodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const instance = isTelescopeGeneratedType(type) || isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);
        return type.encode(instance).finish();
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to an Any if
       * the given type was previously registered.
       */
      encodeAsAny(encodeObject) {
        const binaryValue = this.encode(encodeObject);
        return any_1.Any.fromPartial({
          typeUrl: encodeObject.typeUrl,
          value: binaryValue
        });
      }
      encodeTxBody(txBodyFields) {
        var _a;
        const wrappedMessages = txBodyFields.messages.map((message) => this.encodeAsAny(message));
        const txBody = tx_2.TxBody.fromPartial({
          ...txBodyFields,
          timeoutHeight: BigInt(((_a = txBodyFields.timeoutHeight) == null ? void 0 : _a.toString()) ?? "0"),
          messages: wrappedMessages
        });
        return tx_2.TxBody.encode(txBody).finish();
      }
      decode({ typeUrl, value }) {
        if (typeUrl === defaultTypeUrls.cosmosTxBody) {
          return this.decodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const decoded = type.decode(value);
        Object.entries(decoded).forEach(([key, val]) => {
          if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined" && Buffer.isBuffer(val)) {
            decoded[key] = Uint8Array.from(val);
          }
        });
        return decoded;
      }
      decodeTxBody(txBody) {
        const decodedTxBody = tx_2.TxBody.decode(txBody);
        return {
          ...decodedTxBody,
          messages: decodedTxBody.messages.map(({ typeUrl, value }) => {
            if (!typeUrl) {
              throw new Error("Missing type_url in Any");
            }
            if (!value) {
              throw new Error("Missing value in Any");
            }
            return this.decode({ typeUrl, value });
          })
        };
      }
    };
    exports2.Registry = Registry;
  }
});

// node_modules/@cosmjs/proto-signing/build/signer.js
var require_signer = __commonJS({
  "node_modules/@cosmjs/proto-signing/build/signer.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isOfflineDirectSigner = void 0;
    function isOfflineDirectSigner(signer) {
      return signer.signDirect !== void 0;
    }
    exports2.isOfflineDirectSigner = isOfflineDirectSigner;
  }
});

// node_modules/@cosmjs/proto-signing/build/index.js
var require_build8 = __commonJS({
  "node_modules/@cosmjs/proto-signing/build/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseCoins = exports2.coins = exports2.coin = exports2.executeKdf = exports2.makeSignDoc = exports2.makeSignBytes = exports2.makeAuthInfoBytes = exports2.isOfflineDirectSigner = exports2.Registry = exports2.isTxBodyEncodeObject = exports2.isTsProtoGeneratedType = exports2.isPbjsGeneratedType = exports2.encodePubkey = exports2.decodePubkey = exports2.decodeOptionalPubkey = exports2.anyToSinglePubkey = exports2.makeCosmoshubPath = exports2.DirectSecp256k1Wallet = exports2.extractKdfConfiguration = exports2.DirectSecp256k1HdWallet = exports2.decodeTxRaw = void 0;
    var decode_1 = require_decode();
    Object.defineProperty(exports2, "decodeTxRaw", { enumerable: true, get: function() {
      return decode_1.decodeTxRaw;
    } });
    var directsecp256k1hdwallet_1 = require_directsecp256k1hdwallet();
    Object.defineProperty(exports2, "DirectSecp256k1HdWallet", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.DirectSecp256k1HdWallet;
    } });
    Object.defineProperty(exports2, "extractKdfConfiguration", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.extractKdfConfiguration;
    } });
    var directsecp256k1wallet_1 = require_directsecp256k1wallet();
    Object.defineProperty(exports2, "DirectSecp256k1Wallet", { enumerable: true, get: function() {
      return directsecp256k1wallet_1.DirectSecp256k1Wallet;
    } });
    var paths_1 = require_paths2();
    Object.defineProperty(exports2, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkey_1 = require_pubkey();
    Object.defineProperty(exports2, "anyToSinglePubkey", { enumerable: true, get: function() {
      return pubkey_1.anyToSinglePubkey;
    } });
    Object.defineProperty(exports2, "decodeOptionalPubkey", { enumerable: true, get: function() {
      return pubkey_1.decodeOptionalPubkey;
    } });
    Object.defineProperty(exports2, "decodePubkey", { enumerable: true, get: function() {
      return pubkey_1.decodePubkey;
    } });
    Object.defineProperty(exports2, "encodePubkey", { enumerable: true, get: function() {
      return pubkey_1.encodePubkey;
    } });
    var registry_1 = require_registry();
    Object.defineProperty(exports2, "isPbjsGeneratedType", { enumerable: true, get: function() {
      return registry_1.isPbjsGeneratedType;
    } });
    Object.defineProperty(exports2, "isTsProtoGeneratedType", { enumerable: true, get: function() {
      return registry_1.isTsProtoGeneratedType;
    } });
    Object.defineProperty(exports2, "isTxBodyEncodeObject", { enumerable: true, get: function() {
      return registry_1.isTxBodyEncodeObject;
    } });
    Object.defineProperty(exports2, "Registry", { enumerable: true, get: function() {
      return registry_1.Registry;
    } });
    var signer_1 = require_signer();
    Object.defineProperty(exports2, "isOfflineDirectSigner", { enumerable: true, get: function() {
      return signer_1.isOfflineDirectSigner;
    } });
    var signing_1 = require_signing2();
    Object.defineProperty(exports2, "makeAuthInfoBytes", { enumerable: true, get: function() {
      return signing_1.makeAuthInfoBytes;
    } });
    Object.defineProperty(exports2, "makeSignBytes", { enumerable: true, get: function() {
      return signing_1.makeSignBytes;
    } });
    Object.defineProperty(exports2, "makeSignDoc", { enumerable: true, get: function() {
      return signing_1.makeSignDoc;
    } });
    var wallet_1 = require_wallet2();
    Object.defineProperty(exports2, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
    var amino_1 = require_build7();
    Object.defineProperty(exports2, "coin", { enumerable: true, get: function() {
      return amino_1.coin;
    } });
    Object.defineProperty(exports2, "coins", { enumerable: true, get: function() {
      return amino_1.coins;
    } });
    Object.defineProperty(exports2, "parseCoins", { enumerable: true, get: function() {
      return amino_1.parseCoins;
    } });
  }
});

// node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js
var require_auth = __commonJS({
  "node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.ModuleCredential = exports2.ModuleAccount = exports2.BaseAccount = exports2.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.auth.v1beta1";
    function createBaseBaseAccount() {
      return {
        address: "",
        pubKey: void 0,
        accountNumber: BigInt(0),
        sequence: BigInt(0)
      };
    }
    exports2.BaseAccount = {
      typeUrl: "/cosmos.auth.v1beta1.BaseAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pubKey !== void 0) {
          any_1.Any.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.accountNumber);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(32).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pubKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.accountNumber = reader.uint64();
              break;
            case 4:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBaseAccount();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = any_1.Any.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? any_1.Any.toJSON(message.pubKey) : void 0);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBaseAccount();
        message.address = object.address ?? "";
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = any_1.Any.fromPartial(object.pubKey);
        }
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseModuleAccount() {
      return {
        baseAccount: void 0,
        name: "",
        permissions: []
      };
    }
    exports2.ModuleAccount = {
      typeUrl: "/cosmos.auth.v1beta1.ModuleAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseAccount !== void 0) {
          exports2.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        for (const v of message.permissions) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = exports2.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.permissions.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleAccount();
        if ((0, helpers_1.isSet)(object.baseAccount))
          obj.baseAccount = exports2.BaseAccount.fromJSON(object.baseAccount);
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if (Array.isArray(object == null ? void 0 : object.permissions))
          obj.permissions = object.permissions.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? exports2.BaseAccount.toJSON(message.baseAccount) : void 0);
        message.name !== void 0 && (obj.name = message.name);
        if (message.permissions) {
          obj.permissions = message.permissions.map((e) => e);
        } else {
          obj.permissions = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseModuleAccount();
        if (object.baseAccount !== void 0 && object.baseAccount !== null) {
          message.baseAccount = exports2.BaseAccount.fromPartial(object.baseAccount);
        }
        message.name = object.name ?? "";
        message.permissions = ((_a = object.permissions) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseModuleCredential() {
      return {
        moduleName: "",
        derivationKeys: []
      };
    }
    exports2.ModuleCredential = {
      typeUrl: "/cosmos.auth.v1beta1.ModuleCredential",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.moduleName !== "") {
          writer.uint32(10).string(message.moduleName);
        }
        for (const v of message.derivationKeys) {
          writer.uint32(18).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleCredential();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moduleName = reader.string();
              break;
            case 2:
              message.derivationKeys.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleCredential();
        if ((0, helpers_1.isSet)(object.moduleName))
          obj.moduleName = String(object.moduleName);
        if (Array.isArray(object == null ? void 0 : object.derivationKeys))
          obj.derivationKeys = object.derivationKeys.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.moduleName !== void 0 && (obj.moduleName = message.moduleName);
        if (message.derivationKeys) {
          obj.derivationKeys = message.derivationKeys.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.derivationKeys = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseModuleCredential();
        message.moduleName = object.moduleName ?? "";
        message.derivationKeys = ((_a = object.derivationKeys) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        maxMemoCharacters: BigInt(0),
        txSigLimit: BigInt(0),
        txSizeCostPerByte: BigInt(0),
        sigVerifyCostEd25519: BigInt(0),
        sigVerifyCostSecp256k1: BigInt(0)
      };
    }
    exports2.Params = {
      typeUrl: "/cosmos.auth.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxMemoCharacters !== BigInt(0)) {
          writer.uint32(8).uint64(message.maxMemoCharacters);
        }
        if (message.txSigLimit !== BigInt(0)) {
          writer.uint32(16).uint64(message.txSigLimit);
        }
        if (message.txSizeCostPerByte !== BigInt(0)) {
          writer.uint32(24).uint64(message.txSizeCostPerByte);
        }
        if (message.sigVerifyCostEd25519 !== BigInt(0)) {
          writer.uint32(32).uint64(message.sigVerifyCostEd25519);
        }
        if (message.sigVerifyCostSecp256k1 !== BigInt(0)) {
          writer.uint32(40).uint64(message.sigVerifyCostSecp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxMemoCharacters = reader.uint64();
              break;
            case 2:
              message.txSigLimit = reader.uint64();
              break;
            case 3:
              message.txSizeCostPerByte = reader.uint64();
              break;
            case 4:
              message.sigVerifyCostEd25519 = reader.uint64();
              break;
            case 5:
              message.sigVerifyCostSecp256k1 = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.maxMemoCharacters))
          obj.maxMemoCharacters = BigInt(object.maxMemoCharacters.toString());
        if ((0, helpers_1.isSet)(object.txSigLimit))
          obj.txSigLimit = BigInt(object.txSigLimit.toString());
        if ((0, helpers_1.isSet)(object.txSizeCostPerByte))
          obj.txSizeCostPerByte = BigInt(object.txSizeCostPerByte.toString());
        if ((0, helpers_1.isSet)(object.sigVerifyCostEd25519))
          obj.sigVerifyCostEd25519 = BigInt(object.sigVerifyCostEd25519.toString());
        if ((0, helpers_1.isSet)(object.sigVerifyCostSecp256k1))
          obj.sigVerifyCostSecp256k1 = BigInt(object.sigVerifyCostSecp256k1.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxMemoCharacters !== void 0 && (obj.maxMemoCharacters = (message.maxMemoCharacters || BigInt(0)).toString());
        message.txSigLimit !== void 0 && (obj.txSigLimit = (message.txSigLimit || BigInt(0)).toString());
        message.txSizeCostPerByte !== void 0 && (obj.txSizeCostPerByte = (message.txSizeCostPerByte || BigInt(0)).toString());
        message.sigVerifyCostEd25519 !== void 0 && (obj.sigVerifyCostEd25519 = (message.sigVerifyCostEd25519 || BigInt(0)).toString());
        message.sigVerifyCostSecp256k1 !== void 0 && (obj.sigVerifyCostSecp256k1 = (message.sigVerifyCostSecp256k1 || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.maxMemoCharacters !== void 0 && object.maxMemoCharacters !== null) {
          message.maxMemoCharacters = BigInt(object.maxMemoCharacters.toString());
        }
        if (object.txSigLimit !== void 0 && object.txSigLimit !== null) {
          message.txSigLimit = BigInt(object.txSigLimit.toString());
        }
        if (object.txSizeCostPerByte !== void 0 && object.txSizeCostPerByte !== null) {
          message.txSizeCostPerByte = BigInt(object.txSizeCostPerByte.toString());
        }
        if (object.sigVerifyCostEd25519 !== void 0 && object.sigVerifyCostEd25519 !== null) {
          message.sigVerifyCostEd25519 = BigInt(object.sigVerifyCostEd25519.toString());
        }
        if (object.sigVerifyCostSecp256k1 !== void 0 && object.sigVerifyCostSecp256k1 !== null) {
          message.sigVerifyCostSecp256k1 = BigInt(object.sigVerifyCostSecp256k1.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js
var require_vesting = __commonJS({
  "node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermanentLockedAccount = exports2.PeriodicVestingAccount = exports2.Period = exports2.DelayedVestingAccount = exports2.ContinuousVestingAccount = exports2.BaseVestingAccount = exports2.protobufPackage = void 0;
    var auth_1 = require_auth();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.vesting.v1beta1";
    function createBaseBaseVestingAccount() {
      return {
        baseAccount: void 0,
        originalVesting: [],
        delegatedFree: [],
        delegatedVesting: [],
        endTime: BigInt(0)
      };
    }
    exports2.BaseVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.BaseVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseAccount !== void 0) {
          auth_1.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.originalVesting) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.delegatedFree) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.delegatedVesting) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.endTime !== BigInt(0)) {
          writer.uint32(40).int64(message.endTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = auth_1.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.originalVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.delegatedFree.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.delegatedVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.endTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBaseVestingAccount();
        if ((0, helpers_1.isSet)(object.baseAccount))
          obj.baseAccount = auth_1.BaseAccount.fromJSON(object.baseAccount);
        if (Array.isArray(object == null ? void 0 : object.originalVesting))
          obj.originalVesting = object.originalVesting.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.delegatedFree))
          obj.delegatedFree = object.delegatedFree.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.delegatedVesting))
          obj.delegatedVesting = object.delegatedVesting.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.endTime))
          obj.endTime = BigInt(object.endTime.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? auth_1.BaseAccount.toJSON(message.baseAccount) : void 0);
        if (message.originalVesting) {
          obj.originalVesting = message.originalVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.originalVesting = [];
        }
        if (message.delegatedFree) {
          obj.delegatedFree = message.delegatedFree.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedFree = [];
        }
        if (message.delegatedVesting) {
          obj.delegatedVesting = message.delegatedVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedVesting = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseBaseVestingAccount();
        if (object.baseAccount !== void 0 && object.baseAccount !== null) {
          message.baseAccount = auth_1.BaseAccount.fromPartial(object.baseAccount);
        }
        message.originalVesting = ((_a = object.originalVesting) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.delegatedFree = ((_b = object.delegatedFree) == null ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.delegatedVesting = ((_c = object.delegatedVesting) == null ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.endTime !== void 0 && object.endTime !== null) {
          message.endTime = BigInt(object.endTime.toString());
        }
        return message;
      }
    };
    function createBaseContinuousVestingAccount() {
      return {
        baseVestingAccount: void 0,
        startTime: BigInt(0)
      };
    }
    exports2.ContinuousVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.ContinuousVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports2.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(16).int64(message.startTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContinuousVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports2.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseContinuousVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports2.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports2.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseContinuousVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports2.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        return message;
      }
    };
    function createBaseDelayedVestingAccount() {
      return {
        baseVestingAccount: void 0
      };
    }
    exports2.DelayedVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.DelayedVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports2.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelayedVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports2.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelayedVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports2.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports2.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelayedVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports2.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        return message;
      }
    };
    function createBasePeriod() {
      return {
        length: BigInt(0),
        amount: []
      };
    }
    exports2.Period = {
      typeUrl: "/cosmos.vesting.v1beta1.Period",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.length !== BigInt(0)) {
          writer.uint32(8).int64(message.length);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriod();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.length = reader.int64();
              break;
            case 2:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriod();
        if ((0, helpers_1.isSet)(object.length))
          obj.length = BigInt(object.length.toString());
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.length !== void 0 && (obj.length = (message.length || BigInt(0)).toString());
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBasePeriod();
        if (object.length !== void 0 && object.length !== null) {
          message.length = BigInt(object.length.toString());
        }
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePeriodicVestingAccount() {
      return {
        baseVestingAccount: void 0,
        startTime: BigInt(0),
        vestingPeriods: []
      };
    }
    exports2.PeriodicVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.PeriodicVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports2.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(16).int64(message.startTime);
        }
        for (const v of message.vestingPeriods) {
          exports2.Period.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriodicVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports2.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            case 3:
              message.vestingPeriods.push(exports2.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriodicVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports2.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        if (Array.isArray(object == null ? void 0 : object.vestingPeriods))
          obj.vestingPeriods = object.vestingPeriods.map((e) => exports2.Period.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports2.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        if (message.vestingPeriods) {
          obj.vestingPeriods = message.vestingPeriods.map((e) => e ? exports2.Period.toJSON(e) : void 0);
        } else {
          obj.vestingPeriods = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBasePeriodicVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports2.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        message.vestingPeriods = ((_a = object.vestingPeriods) == null ? void 0 : _a.map((e) => exports2.Period.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePermanentLockedAccount() {
      return {
        baseVestingAccount: void 0
      };
    }
    exports2.PermanentLockedAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.PermanentLockedAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports2.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePermanentLockedAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports2.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePermanentLockedAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports2.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports2.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePermanentLockedAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports2.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        return message;
      }
    };
  }
});

// node_modules/@cosmjs/stargate/build/accounts.js
var require_accounts = __commonJS({
  "node_modules/@cosmjs/stargate/build/accounts.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.accountFromAny = void 0;
    var math_1 = require_build2();
    var proto_signing_1 = require_build8();
    var utils_1 = require_build3();
    var auth_1 = require_auth();
    var vesting_1 = require_vesting();
    function uint64FromProto(input) {
      return math_1.Uint64.fromString(input.toString());
    }
    function accountFromBaseAccount(input) {
      const { address, pubKey, accountNumber, sequence } = input;
      const pubkey = (0, proto_signing_1.decodeOptionalPubkey)(pubKey);
      return {
        address,
        pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber()
      };
    }
    function accountFromAny(input) {
      var _a, _b, _c, _d, _e, _f, _g;
      const { typeUrl, value } = input;
      switch (typeUrl) {
        case "/cosmos.auth.v1beta1.BaseAccount":
          return accountFromBaseAccount(auth_1.BaseAccount.decode(value));
        case "/cosmos.auth.v1beta1.ModuleAccount": {
          const baseAccount = auth_1.ModuleAccount.decode(value).baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
          const baseAccount = (_a = vesting_1.BaseVestingAccount.decode(value)) == null ? void 0 : _a.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
          const baseAccount = (_c = (_b = vesting_1.ContinuousVestingAccount.decode(value)) == null ? void 0 : _b.baseVestingAccount) == null ? void 0 : _c.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
          const baseAccount = (_e = (_d = vesting_1.DelayedVestingAccount.decode(value)) == null ? void 0 : _d.baseVestingAccount) == null ? void 0 : _e.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
          const baseAccount = (_g = (_f = vesting_1.PeriodicVestingAccount.decode(value)) == null ? void 0 : _f.baseVestingAccount) == null ? void 0 : _g.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        default:
          throw new Error(`Unsupported type: '${typeUrl}'`);
      }
    }
    exports2.accountFromAny = accountFromAny;
  }
});

// node_modules/@cosmjs/stargate/build/aminotypes.js
var require_aminotypes = __commonJS({
  "node_modules/@cosmjs/stargate/build/aminotypes.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AminoTypes = void 0;
    var AminoTypes = class {
      constructor(types) {
        this.register = types;
      }
      toAmino({ typeUrl, value }) {
        const converter = this.register[typeUrl];
        if (!converter) {
          throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
        }
        return {
          type: converter.aminoType,
          value: converter.toAmino(value)
        };
      }
      fromAmino({ type, value }) {
        const matches = Object.entries(this.register).filter(([_typeUrl, { aminoType }]) => aminoType === type);
        switch (matches.length) {
          case 0: {
            throw new Error(`Amino type identifier '${type}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
          }
          case 1: {
            const [typeUrl, converter] = matches[0];
            return {
              typeUrl,
              value: converter.fromAmino(value)
            };
          }
          default:
            throw new Error(`Multiple types are registered with Amino type identifier '${type}': '` + matches.map(([key, _value]) => key).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
        }
      }
    };
    exports2.AminoTypes = AminoTypes;
  }
});

// node_modules/@cosmjs/stargate/build/events.js
var require_events = __commonJS({
  "node_modules/@cosmjs/stargate/build/events.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromTendermintEvent = void 0;
    var encoding_1 = require_build();
    function fromTendermintEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes.map((attr) => ({
          key: typeof attr.key == "string" ? attr.key : (0, encoding_1.fromUtf8)(attr.key, true),
          value: typeof attr.value == "string" ? attr.value : (0, encoding_1.fromUtf8)(attr.value, true)
        }))
      };
    }
    exports2.fromTendermintEvent = fromTendermintEvent;
  }
});

// node_modules/@cosmjs/stargate/build/fee.js
var require_fee = __commonJS({
  "node_modules/@cosmjs/stargate/build/fee.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateFee = exports2.GasPrice = void 0;
    var math_1 = require_build2();
    var proto_signing_1 = require_build8();
    function checkDenom(denom) {
      if (denom.length < 3 || denom.length > 128) {
        throw new Error("Denom must be between 3 and 128 characters");
      }
    }
    var GasPrice = class _GasPrice {
      constructor(amount, denom) {
        this.amount = amount;
        this.denom = denom;
      }
      /**
       * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
       *
       * The denom must match the Cosmos SDK 0.42 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/types/coin.go#L599-L601).
       * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
       *
       * Separators are not yet supported.
       */
      static fromString(gasPrice) {
        const matchResult = gasPrice.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
        if (!matchResult) {
          throw new Error("Invalid gas price string");
        }
        const [_, amount, denom] = matchResult;
        checkDenom(denom);
        const fractionalDigits = 18;
        const decimalAmount = math_1.Decimal.fromUserInput(amount, fractionalDigits);
        return new _GasPrice(decimalAmount, denom);
      }
      /**
       * Returns a string representation of this gas price, e.g. "0.025uatom".
       * This can be used as an input to `GasPrice.fromString`.
       */
      toString() {
        return this.amount.toString() + this.denom;
      }
    };
    exports2.GasPrice = GasPrice;
    function calculateFee(gasLimit, gasPrice) {
      const processedGasPrice = typeof gasPrice === "string" ? GasPrice.fromString(gasPrice) : gasPrice;
      const { denom, amount: gasPriceAmount } = processedGasPrice;
      const amount = gasPriceAmount.multiply(new math_1.Uint53(gasLimit)).ceil().toString();
      return {
        amount: (0, proto_signing_1.coins)(amount, denom),
        gas: gasLimit.toString()
      };
    }
    exports2.calculateFee = calculateFee;
  }
});

// node_modules/@cosmjs/stargate/build/logs.js
var require_logs = __commonJS({
  "node_modules/@cosmjs/stargate/build/logs.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findAttribute = exports2.parseRawLog = exports2.parseLogs = exports2.parseLog = exports2.parseEvent = exports2.parseAttribute = void 0;
    var utils_1 = require_build3();
    function parseAttribute(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Attribute must be a non-null object");
      const { key, value } = input;
      if (typeof key !== "string" || !key)
        throw new Error("Attribute's key must be a non-empty string");
      if (typeof value !== "string" && typeof value !== "undefined") {
        throw new Error("Attribute's value must be a string or unset");
      }
      return {
        key,
        value: value || ""
      };
    }
    exports2.parseAttribute = parseAttribute;
    function parseEvent(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Event must be a non-null object");
      const { type, attributes } = input;
      if (typeof type !== "string" || type === "") {
        throw new Error(`Event type must be a non-empty string`);
      }
      if (!Array.isArray(attributes))
        throw new Error("Event's attributes must be an array");
      return {
        type,
        attributes: attributes.map(parseAttribute)
      };
    }
    exports2.parseEvent = parseEvent;
    function parseLog(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Log must be a non-null object");
      const { msg_index, log, events } = input;
      if (typeof msg_index !== "number")
        throw new Error("Log's msg_index must be a number");
      if (typeof log !== "string")
        throw new Error("Log's log must be a string");
      if (!Array.isArray(events))
        throw new Error("Log's events must be an array");
      return {
        msg_index,
        log,
        events: events.map(parseEvent)
      };
    }
    exports2.parseLog = parseLog;
    function parseLogs(input) {
      if (!Array.isArray(input))
        throw new Error("Logs must be an array");
      return input.map(parseLog);
    }
    exports2.parseLogs = parseLogs;
    function parseRawLog(input) {
      if (!input)
        return [];
      const logsToParse = JSON.parse(input).map(({ events }, i) => ({
        msg_index: i,
        events,
        log: ""
      }));
      return parseLogs(logsToParse);
    }
    exports2.parseRawLog = parseRawLog;
    function findAttribute(logs, eventType, attrKey) {
      var _a;
      const firstLogs = logs.find(() => true);
      const out = (_a = firstLogs == null ? void 0 : firstLogs.events.find((event) => event.type === eventType)) == null ? void 0 : _a.attributes.find((attr) => attr.key === attrKey);
      if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
      }
      return out;
    }
    exports2.findAttribute = findAttribute;
  }
});

// node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js
var require_query2 = __commonJS({
  "node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryAccountInfoResponse = exports2.QueryAccountInfoRequest = exports2.QueryAccountAddressByIDResponse = exports2.QueryAccountAddressByIDRequest = exports2.AddressStringToBytesResponse = exports2.AddressStringToBytesRequest = exports2.AddressBytesToStringResponse = exports2.AddressBytesToStringRequest = exports2.Bech32PrefixResponse = exports2.Bech32PrefixRequest = exports2.QueryModuleAccountByNameResponse = exports2.QueryModuleAccountByNameRequest = exports2.QueryModuleAccountsResponse = exports2.QueryModuleAccountsRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.QueryAccountResponse = exports2.QueryAccountRequest = exports2.QueryAccountsResponse = exports2.QueryAccountsRequest = exports2.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    var auth_1 = require_auth();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.auth.v1beta1";
    function createBaseQueryAccountsRequest() {
      return {
        pagination: void 0
      };
    }
    exports2.QueryAccountsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAccountsResponse() {
      return {
        accounts: [],
        pagination: void 0
      };
    }
    exports2.QueryAccountsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.accounts) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountsResponse();
        if (Array.isArray(object == null ? void 0 : object.accounts))
          obj.accounts = object.accounts.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.accounts) {
          obj.accounts = message.accounts.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.accounts = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAccountsResponse();
        message.accounts = ((_a = object.accounts) == null ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAccountRequest() {
      return {
        address: ""
      };
    }
    exports2.QueryAccountRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountRequest();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseQueryAccountResponse() {
      return {
        account: void 0
      };
    }
    exports2.QueryAccountResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.account !== void 0) {
          any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.account = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountResponse();
        if ((0, helpers_1.isSet)(object.account))
          obj.account = any_1.Any.fromJSON(object.account);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.account !== void 0 && (obj.account = message.account ? any_1.Any.toJSON(message.account) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountResponse();
        if (object.account !== void 0 && object.account !== null) {
          message.account = any_1.Any.fromPartial(object.account);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: auth_1.Params.fromPartial({})
      };
    }
    exports2.QueryParamsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          auth_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = auth_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = auth_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? auth_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = auth_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryModuleAccountsRequest() {
      return {};
    }
    exports2.QueryModuleAccountsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryModuleAccountsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryModuleAccountsRequest();
        return message;
      }
    };
    function createBaseQueryModuleAccountsResponse() {
      return {
        accounts: []
      };
    }
    exports2.QueryModuleAccountsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.accounts) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountsResponse();
        if (Array.isArray(object == null ? void 0 : object.accounts))
          obj.accounts = object.accounts.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.accounts) {
          obj.accounts = message.accounts.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.accounts = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryModuleAccountsResponse();
        message.accounts = ((_a = object.accounts) == null ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseQueryModuleAccountByNameRequest() {
      return {
        name: ""
      };
    }
    exports2.QueryModuleAccountByNameRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountByNameRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountByNameRequest();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryModuleAccountByNameRequest();
        message.name = object.name ?? "";
        return message;
      }
    };
    function createBaseQueryModuleAccountByNameResponse() {
      return {
        account: void 0
      };
    }
    exports2.QueryModuleAccountByNameResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.account !== void 0) {
          any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountByNameResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.account = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountByNameResponse();
        if ((0, helpers_1.isSet)(object.account))
          obj.account = any_1.Any.fromJSON(object.account);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.account !== void 0 && (obj.account = message.account ? any_1.Any.toJSON(message.account) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryModuleAccountByNameResponse();
        if (object.account !== void 0 && object.account !== null) {
          message.account = any_1.Any.fromPartial(object.account);
        }
        return message;
      }
    };
    function createBaseBech32PrefixRequest() {
      return {};
    }
    exports2.Bech32PrefixRequest = {
      typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBech32PrefixRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseBech32PrefixRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseBech32PrefixRequest();
        return message;
      }
    };
    function createBaseBech32PrefixResponse() {
      return {
        bech32Prefix: ""
      };
    }
    exports2.Bech32PrefixResponse = {
      typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bech32Prefix !== "") {
          writer.uint32(10).string(message.bech32Prefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBech32PrefixResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bech32Prefix = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBech32PrefixResponse();
        if ((0, helpers_1.isSet)(object.bech32Prefix))
          obj.bech32Prefix = String(object.bech32Prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bech32Prefix !== void 0 && (obj.bech32Prefix = message.bech32Prefix);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBech32PrefixResponse();
        message.bech32Prefix = object.bech32Prefix ?? "";
        return message;
      }
    };
    function createBaseAddressBytesToStringRequest() {
      return {
        addressBytes: new Uint8Array()
      };
    }
    exports2.AddressBytesToStringRequest = {
      typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressBytes.length !== 0) {
          writer.uint32(10).bytes(message.addressBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressBytesToStringRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressBytesToStringRequest();
        if ((0, helpers_1.isSet)(object.addressBytes))
          obj.addressBytes = (0, helpers_1.bytesFromBase64)(object.addressBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressBytes !== void 0 && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== void 0 ? message.addressBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressBytesToStringRequest();
        message.addressBytes = object.addressBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseAddressBytesToStringResponse() {
      return {
        addressString: ""
      };
    }
    exports2.AddressBytesToStringResponse = {
      typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressString !== "") {
          writer.uint32(10).string(message.addressString);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressBytesToStringResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressString = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressBytesToStringResponse();
        if ((0, helpers_1.isSet)(object.addressString))
          obj.addressString = String(object.addressString);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressString !== void 0 && (obj.addressString = message.addressString);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressBytesToStringResponse();
        message.addressString = object.addressString ?? "";
        return message;
      }
    };
    function createBaseAddressStringToBytesRequest() {
      return {
        addressString: ""
      };
    }
    exports2.AddressStringToBytesRequest = {
      typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressString !== "") {
          writer.uint32(10).string(message.addressString);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressStringToBytesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressString = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressStringToBytesRequest();
        if ((0, helpers_1.isSet)(object.addressString))
          obj.addressString = String(object.addressString);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressString !== void 0 && (obj.addressString = message.addressString);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressStringToBytesRequest();
        message.addressString = object.addressString ?? "";
        return message;
      }
    };
    function createBaseAddressStringToBytesResponse() {
      return {
        addressBytes: new Uint8Array()
      };
    }
    exports2.AddressStringToBytesResponse = {
      typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressBytes.length !== 0) {
          writer.uint32(10).bytes(message.addressBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressStringToBytesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressStringToBytesResponse();
        if ((0, helpers_1.isSet)(object.addressBytes))
          obj.addressBytes = (0, helpers_1.bytesFromBase64)(object.addressBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressBytes !== void 0 && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== void 0 ? message.addressBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressStringToBytesResponse();
        message.addressBytes = object.addressBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryAccountAddressByIDRequest() {
      return {
        id: BigInt(0),
        accountId: BigInt(0)
      };
    }
    exports2.QueryAccountAddressByIDRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).int64(message.id);
        }
        if (message.accountId !== BigInt(0)) {
          writer.uint32(16).uint64(message.accountId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountAddressByIDRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.int64();
              break;
            case 2:
              message.accountId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountAddressByIDRequest();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.accountId))
          obj.accountId = BigInt(object.accountId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.accountId !== void 0 && (obj.accountId = (message.accountId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountAddressByIDRequest();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        if (object.accountId !== void 0 && object.accountId !== null) {
          message.accountId = BigInt(object.accountId.toString());
        }
        return message;
      }
    };
    function createBaseQueryAccountAddressByIDResponse() {
      return {
        accountAddress: ""
      };
    }
    exports2.QueryAccountAddressByIDResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.accountAddress !== "") {
          writer.uint32(10).string(message.accountAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountAddressByIDResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accountAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountAddressByIDResponse();
        if ((0, helpers_1.isSet)(object.accountAddress))
          obj.accountAddress = String(object.accountAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.accountAddress !== void 0 && (obj.accountAddress = message.accountAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountAddressByIDResponse();
        message.accountAddress = object.accountAddress ?? "";
        return message;
      }
    };
    function createBaseQueryAccountInfoRequest() {
      return {
        address: ""
      };
    }
    exports2.QueryAccountInfoRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountInfoRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountInfoRequest();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseQueryAccountInfoResponse() {
      return {
        info: void 0
      };
    }
    exports2.QueryAccountInfoResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.info !== void 0) {
          auth_1.BaseAccount.encode(message.info, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.info = auth_1.BaseAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountInfoResponse();
        if ((0, helpers_1.isSet)(object.info))
          obj.info = auth_1.BaseAccount.fromJSON(object.info);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.info !== void 0 && (obj.info = message.info ? auth_1.BaseAccount.toJSON(message.info) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountInfoResponse();
        if (object.info !== void 0 && object.info !== null) {
          message.info = auth_1.BaseAccount.fromPartial(object.info);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Accounts = this.Accounts.bind(this);
        this.Account = this.Account.bind(this);
        this.AccountAddressByID = this.AccountAddressByID.bind(this);
        this.Params = this.Params.bind(this);
        this.ModuleAccounts = this.ModuleAccounts.bind(this);
        this.ModuleAccountByName = this.ModuleAccountByName.bind(this);
        this.Bech32Prefix = this.Bech32Prefix.bind(this);
        this.AddressBytesToString = this.AddressBytesToString.bind(this);
        this.AddressStringToBytes = this.AddressStringToBytes.bind(this);
        this.AccountInfo = this.AccountInfo.bind(this);
      }
      Accounts(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data = exports2.QueryAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data);
        return promise.then((data2) => exports2.QueryAccountsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Account(request) {
        const data = exports2.QueryAccountRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Account", data);
        return promise.then((data2) => exports2.QueryAccountResponse.decode(new binary_1.BinaryReader(data2)));
      }
      AccountAddressByID(request) {
        const data = exports2.QueryAccountAddressByIDRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", data);
        return promise.then((data2) => exports2.QueryAccountAddressByIDResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Params(request = {}) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ModuleAccounts(request = {}) {
        const data = exports2.QueryModuleAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", data);
        return promise.then((data2) => exports2.QueryModuleAccountsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ModuleAccountByName(request) {
        const data = exports2.QueryModuleAccountByNameRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", data);
        return promise.then((data2) => exports2.QueryModuleAccountByNameResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Bech32Prefix(request = {}) {
        const data = exports2.Bech32PrefixRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Bech32Prefix", data);
        return promise.then((data2) => exports2.Bech32PrefixResponse.decode(new binary_1.BinaryReader(data2)));
      }
      AddressBytesToString(request) {
        const data = exports2.AddressBytesToStringRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AddressBytesToString", data);
        return promise.then((data2) => exports2.AddressBytesToStringResponse.decode(new binary_1.BinaryReader(data2)));
      }
      AddressStringToBytes(request) {
        const data = exports2.AddressStringToBytesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AddressStringToBytes", data);
        return promise.then((data2) => exports2.AddressStringToBytesResponse.decode(new binary_1.BinaryReader(data2)));
      }
      AccountInfo(request) {
        const data = exports2.QueryAccountInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", data);
        return promise.then((data2) => exports2.QueryAccountInfoResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module2.exports = require_index_minimal();
  }
});

// node_modules/@confio/ics23/build/generated/codecimpl.js
var require_codecimpl = __commonJS({
  "node_modules/@confio/ics23/build/generated/codecimpl.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.ics23 = function() {
      var ics23 = {};
      ics23.HashOp = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_HASH"] = 0;
        values[valuesById[1] = "SHA256"] = 1;
        values[valuesById[2] = "SHA512"] = 2;
        values[valuesById[3] = "KECCAK"] = 3;
        values[valuesById[4] = "RIPEMD160"] = 4;
        values[valuesById[5] = "BITCOIN"] = 5;
        values[valuesById[6] = "SHA512_256"] = 6;
        return values;
      }();
      ics23.LengthOp = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_PREFIX"] = 0;
        values[valuesById[1] = "VAR_PROTO"] = 1;
        values[valuesById[2] = "VAR_RLP"] = 2;
        values[valuesById[3] = "FIXED32_BIG"] = 3;
        values[valuesById[4] = "FIXED32_LITTLE"] = 4;
        values[valuesById[5] = "FIXED64_BIG"] = 5;
        values[valuesById[6] = "FIXED64_LITTLE"] = 6;
        values[valuesById[7] = "REQUIRE_32_BYTES"] = 7;
        values[valuesById[8] = "REQUIRE_64_BYTES"] = 8;
        return values;
      }();
      ics23.ExistenceProof = function() {
        function ExistenceProof(properties) {
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ExistenceProof.prototype.key = $util.newBuffer([]);
        ExistenceProof.prototype.value = $util.newBuffer([]);
        ExistenceProof.prototype.leaf = null;
        ExistenceProof.prototype.path = $util.emptyArray;
        ExistenceProof.create = function create(properties) {
          return new ExistenceProof(properties);
        };
        ExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.value);
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            $root.ics23.LeafOp.encode(message.leaf, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.path != null && message.path.length)
            for (var i = 0; i < message.path.length; ++i)
              $root.ics23.InnerOp.encode(message.path[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
          return writer;
        };
        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.path && message.path.length))
                  message.path = [];
                message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
              return "value: buffer expected";
          }
          if (message.leaf != null && message.hasOwnProperty("leaf")) {
            var error = $root.ics23.LeafOp.verify(message.leaf);
            if (error)
              return "leaf." + error;
          }
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (var i = 0; i < message.path.length; ++i) {
              var error = $root.ics23.InnerOp.verify(message.path[i]);
              if (error)
                return "path." + error;
            }
          }
          return null;
        };
        ExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.ExistenceProof)
            return object;
          var message = new $root.ics23.ExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.value != null) {
            if (typeof object.value === "string")
              $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
              message.value = object.value;
          }
          if (object.leaf != null) {
            if (typeof object.leaf !== "object")
              throw TypeError(".ics23.ExistenceProof.leaf: object expected");
            message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);
          }
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".ics23.ExistenceProof.path: array expected");
            message.path = [];
            for (var i = 0; i < object.path.length; ++i) {
              if (typeof object.path[i] !== "object")
                throw TypeError(".ics23.ExistenceProof.path: object expected");
              message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);
            }
          }
          return message;
        };
        ExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String)
              object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array)
                object.value = $util.newBuffer(object.value);
            }
            object.leaf = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);
          if (message.path && message.path.length) {
            object.path = [];
            for (var j = 0; j < message.path.length; ++j)
              object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);
          }
          return object;
        };
        ExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ExistenceProof;
      }();
      ics23.NonExistenceProof = function() {
        function NonExistenceProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        NonExistenceProof.prototype.key = $util.newBuffer([]);
        NonExistenceProof.prototype.left = null;
        NonExistenceProof.prototype.right = null;
        NonExistenceProof.create = function create(properties) {
          return new NonExistenceProof(properties);
        };
        NonExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.left != null && message.hasOwnProperty("left"))
            $root.ics23.ExistenceProof.encode(message.left, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.right != null && message.hasOwnProperty("right"))
            $root.ics23.ExistenceProof.encode(message.right, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          return writer;
        };
        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        NonExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        NonExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.left != null && message.hasOwnProperty("left")) {
            var error = $root.ics23.ExistenceProof.verify(message.left);
            if (error)
              return "left." + error;
          }
          if (message.right != null && message.hasOwnProperty("right")) {
            var error = $root.ics23.ExistenceProof.verify(message.right);
            if (error)
              return "right." + error;
          }
          return null;
        };
        NonExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.NonExistenceProof)
            return object;
          var message = new $root.ics23.NonExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.left != null) {
            if (typeof object.left !== "object")
              throw TypeError(".ics23.NonExistenceProof.left: object expected");
            message.left = $root.ics23.ExistenceProof.fromObject(object.left);
          }
          if (object.right != null) {
            if (typeof object.right !== "object")
              throw TypeError(".ics23.NonExistenceProof.right: object expected");
            message.right = $root.ics23.ExistenceProof.fromObject(object.right);
          }
          return message;
        };
        NonExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            object.left = null;
            object.right = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.left != null && message.hasOwnProperty("left"))
            object.left = $root.ics23.ExistenceProof.toObject(message.left, options);
          if (message.right != null && message.hasOwnProperty("right"))
            object.right = $root.ics23.ExistenceProof.toObject(message.right, options);
          return object;
        };
        NonExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return NonExistenceProof;
      }();
      ics23.CommitmentProof = function() {
        function CommitmentProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CommitmentProof.prototype.exist = null;
        CommitmentProof.prototype.nonexist = null;
        CommitmentProof.prototype.batch = null;
        CommitmentProof.prototype.compressed = null;
        var $oneOfFields;
        Object.defineProperty(CommitmentProof.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist", "batch", "compressed"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        CommitmentProof.create = function create(properties) {
          return new CommitmentProof(properties);
        };
        CommitmentProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.batch != null && message.hasOwnProperty("batch"))
            $root.ics23.BatchProof.encode(message.batch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.compressed != null && message.hasOwnProperty("compressed"))
            $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          return writer;
        };
        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CommitmentProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());
                break;
              case 4:
                message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CommitmentProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.ExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.NonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          if (message.batch != null && message.hasOwnProperty("batch")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.BatchProof.verify(message.batch);
              if (error)
                return "batch." + error;
            }
          }
          if (message.compressed != null && message.hasOwnProperty("compressed")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedBatchProof.verify(message.compressed);
              if (error)
                return "compressed." + error;
            }
          }
          return null;
        };
        CommitmentProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CommitmentProof)
            return object;
          var message = new $root.ics23.CommitmentProof();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.CommitmentProof.exist: object expected");
            message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.CommitmentProof.nonexist: object expected");
            message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);
          }
          if (object.batch != null) {
            if (typeof object.batch !== "object")
              throw TypeError(".ics23.CommitmentProof.batch: object expected");
            message.batch = $root.ics23.BatchProof.fromObject(object.batch);
          }
          if (object.compressed != null) {
            if (typeof object.compressed !== "object")
              throw TypeError(".ics23.CommitmentProof.compressed: object expected");
            message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);
          }
          return message;
        };
        CommitmentProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          if (message.batch != null && message.hasOwnProperty("batch")) {
            object.batch = $root.ics23.BatchProof.toObject(message.batch, options);
            if (options.oneofs)
              object.proof = "batch";
          }
          if (message.compressed != null && message.hasOwnProperty("compressed")) {
            object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);
            if (options.oneofs)
              object.proof = "compressed";
          }
          return object;
        };
        CommitmentProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CommitmentProof;
      }();
      ics23.LeafOp = function() {
        function LeafOp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        LeafOp.prototype.hash = 0;
        LeafOp.prototype.prehashKey = 0;
        LeafOp.prototype.prehashValue = 0;
        LeafOp.prototype.length = 0;
        LeafOp.prototype.prefix = $util.newBuffer([]);
        LeafOp.create = function create(properties) {
          return new LeafOp(properties);
        };
        LeafOp.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.hash);
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.prehashKey);
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.prehashValue);
          if (message.length != null && message.hasOwnProperty("length"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.length);
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(message.prefix);
          return writer;
        };
        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        LeafOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.int32();
                break;
              case 2:
                message.prehashKey = reader.int32();
                break;
              case 3:
                message.prehashValue = reader.int32();
                break;
              case 4:
                message.length = reader.int32();
                break;
              case 5:
                message.prefix = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        LeafOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        LeafOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            switch (message.prehashKey) {
              default:
                return "prehashKey: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            switch (message.prehashValue) {
              default:
                return "prehashValue: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.length != null && message.hasOwnProperty("length"))
            switch (message.length) {
              default:
                return "length: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
                break;
            }
          if (message.prefix != null && message.hasOwnProperty("prefix")) {
            if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
              return "prefix: buffer expected";
          }
          return null;
        };
        LeafOp.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.LeafOp)
            return object;
          var message = new $root.ics23.LeafOp();
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          switch (object.prehashKey) {
            case "NO_HASH":
            case 0:
              message.prehashKey = 0;
              break;
            case "SHA256":
            case 1:
              message.prehashKey = 1;
              break;
            case "SHA512":
            case 2:
              message.prehashKey = 2;
              break;
            case "KECCAK":
            case 3:
              message.prehashKey = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.prehashKey = 4;
              break;
            case "BITCOIN":
            case 5:
              message.prehashKey = 5;
              break;
            case "SHA512_256":
            case 6:
              message.prehashKey = 6;
              break;
          }
          switch (object.prehashValue) {
            case "NO_HASH":
            case 0:
              message.prehashValue = 0;
              break;
            case "SHA256":
            case 1:
              message.prehashValue = 1;
              break;
            case "SHA512":
            case 2:
              message.prehashValue = 2;
              break;
            case "KECCAK":
            case 3:
              message.prehashValue = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.prehashValue = 4;
              break;
            case "BITCOIN":
            case 5:
              message.prehashValue = 5;
              break;
            case "SHA512_256":
            case 6:
              message.prehashValue = 6;
              break;
          }
          switch (object.length) {
            case "NO_PREFIX":
            case 0:
              message.length = 0;
              break;
            case "VAR_PROTO":
            case 1:
              message.length = 1;
              break;
            case "VAR_RLP":
            case 2:
              message.length = 2;
              break;
            case "FIXED32_BIG":
            case 3:
              message.length = 3;
              break;
            case "FIXED32_LITTLE":
            case 4:
              message.length = 4;
              break;
            case "FIXED64_BIG":
            case 5:
              message.length = 5;
              break;
            case "FIXED64_LITTLE":
            case 6:
              message.length = 6;
              break;
            case "REQUIRE_32_BYTES":
            case 7:
              message.length = 7;
              break;
            case "REQUIRE_64_BYTES":
            case 8:
              message.length = 8;
              break;
          }
          if (object.prefix != null) {
            if (typeof object.prefix === "string")
              $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
            else if (object.prefix.length)
              message.prefix = object.prefix;
          }
          return message;
        };
        LeafOp.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.hash = options.enums === String ? "NO_HASH" : 0;
            object.prehashKey = options.enums === String ? "NO_HASH" : 0;
            object.prehashValue = options.enums === String ? "NO_HASH" : 0;
            object.length = options.enums === String ? "NO_PREFIX" : 0;
            if (options.bytes === String)
              object.prefix = "";
            else {
              object.prefix = [];
              if (options.bytes !== Array)
                object.prefix = $util.newBuffer(object.prefix);
            }
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;
          if (message.length != null && message.hasOwnProperty("length"))
            object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
          return object;
        };
        LeafOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return LeafOp;
      }();
      ics23.InnerOp = function() {
        function InnerOp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InnerOp.prototype.hash = 0;
        InnerOp.prototype.prefix = $util.newBuffer([]);
        InnerOp.prototype.suffix = $util.newBuffer([]);
        InnerOp.create = function create(properties) {
          return new InnerOp(properties);
        };
        InnerOp.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.hash);
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.prefix);
          if (message.suffix != null && message.hasOwnProperty("suffix"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).bytes(message.suffix);
          return writer;
        };
        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InnerOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.int32();
                break;
              case 2:
                message.prefix = reader.bytes();
                break;
              case 3:
                message.suffix = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InnerOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InnerOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prefix != null && message.hasOwnProperty("prefix")) {
            if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
              return "prefix: buffer expected";
          }
          if (message.suffix != null && message.hasOwnProperty("suffix")) {
            if (!(message.suffix && typeof message.suffix.length === "number" || $util.isString(message.suffix)))
              return "suffix: buffer expected";
          }
          return null;
        };
        InnerOp.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.InnerOp)
            return object;
          var message = new $root.ics23.InnerOp();
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          if (object.prefix != null) {
            if (typeof object.prefix === "string")
              $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
            else if (object.prefix.length)
              message.prefix = object.prefix;
          }
          if (object.suffix != null) {
            if (typeof object.suffix === "string")
              $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);
            else if (object.suffix.length)
              message.suffix = object.suffix;
          }
          return message;
        };
        InnerOp.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.hash = options.enums === String ? "NO_HASH" : 0;
            if (options.bytes === String)
              object.prefix = "";
            else {
              object.prefix = [];
              if (options.bytes !== Array)
                object.prefix = $util.newBuffer(object.prefix);
            }
            if (options.bytes === String)
              object.suffix = "";
            else {
              object.suffix = [];
              if (options.bytes !== Array)
                object.suffix = $util.newBuffer(object.suffix);
            }
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
          if (message.suffix != null && message.hasOwnProperty("suffix"))
            object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;
          return object;
        };
        InnerOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InnerOp;
      }();
      ics23.ProofSpec = function() {
        function ProofSpec(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ProofSpec.prototype.leafSpec = null;
        ProofSpec.prototype.innerSpec = null;
        ProofSpec.prototype.maxDepth = 0;
        ProofSpec.prototype.minDepth = 0;
        ProofSpec.create = function create(properties) {
          return new ProofSpec(properties);
        };
        ProofSpec.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec"))
            $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec"))
            $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.maxDepth);
          if (message.minDepth != null && message.hasOwnProperty("minDepth"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.minDepth);
          return writer;
        };
        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ProofSpec.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 2:
                message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());
                break;
              case 3:
                message.maxDepth = reader.int32();
                break;
              case 4:
                message.minDepth = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ProofSpec.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ProofSpec.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec")) {
            var error = $root.ics23.LeafOp.verify(message.leafSpec);
            if (error)
              return "leafSpec." + error;
          }
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec")) {
            var error = $root.ics23.InnerSpec.verify(message.innerSpec);
            if (error)
              return "innerSpec." + error;
          }
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth")) {
            if (!$util.isInteger(message.maxDepth))
              return "maxDepth: integer expected";
          }
          if (message.minDepth != null && message.hasOwnProperty("minDepth")) {
            if (!$util.isInteger(message.minDepth))
              return "minDepth: integer expected";
          }
          return null;
        };
        ProofSpec.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.ProofSpec)
            return object;
          var message = new $root.ics23.ProofSpec();
          if (object.leafSpec != null) {
            if (typeof object.leafSpec !== "object")
              throw TypeError(".ics23.ProofSpec.leafSpec: object expected");
            message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);
          }
          if (object.innerSpec != null) {
            if (typeof object.innerSpec !== "object")
              throw TypeError(".ics23.ProofSpec.innerSpec: object expected");
            message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);
          }
          if (object.maxDepth != null)
            message.maxDepth = object.maxDepth | 0;
          if (object.minDepth != null)
            message.minDepth = object.minDepth | 0;
          return message;
        };
        ProofSpec.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.leafSpec = null;
            object.innerSpec = null;
            object.maxDepth = 0;
            object.minDepth = 0;
          }
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec"))
            object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec"))
            object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth"))
            object.maxDepth = message.maxDepth;
          if (message.minDepth != null && message.hasOwnProperty("minDepth"))
            object.minDepth = message.minDepth;
          return object;
        };
        ProofSpec.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ProofSpec;
      }();
      ics23.InnerSpec = function() {
        function InnerSpec(properties) {
          this.childOrder = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InnerSpec.prototype.childOrder = $util.emptyArray;
        InnerSpec.prototype.childSize = 0;
        InnerSpec.prototype.minPrefixLength = 0;
        InnerSpec.prototype.maxPrefixLength = 0;
        InnerSpec.prototype.emptyChild = $util.newBuffer([]);
        InnerSpec.prototype.hash = 0;
        InnerSpec.create = function create(properties) {
          return new InnerSpec(properties);
        };
        InnerSpec.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.childOrder != null && message.childOrder.length) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork();
            for (var i = 0; i < message.childOrder.length; ++i)
              writer.int32(message.childOrder[i]);
            writer.ldelim();
          }
          if (message.childSize != null && message.hasOwnProperty("childSize"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.childSize);
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.minPrefixLength);
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.maxPrefixLength);
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).bytes(message.emptyChild);
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).int32(message.hash);
          return writer;
        };
        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InnerSpec.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.childOrder && message.childOrder.length))
                  message.childOrder = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.childOrder.push(reader.int32());
                } else
                  message.childOrder.push(reader.int32());
                break;
              case 2:
                message.childSize = reader.int32();
                break;
              case 3:
                message.minPrefixLength = reader.int32();
                break;
              case 4:
                message.maxPrefixLength = reader.int32();
                break;
              case 5:
                message.emptyChild = reader.bytes();
                break;
              case 6:
                message.hash = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InnerSpec.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InnerSpec.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.childOrder != null && message.hasOwnProperty("childOrder")) {
            if (!Array.isArray(message.childOrder))
              return "childOrder: array expected";
            for (var i = 0; i < message.childOrder.length; ++i)
              if (!$util.isInteger(message.childOrder[i]))
                return "childOrder: integer[] expected";
          }
          if (message.childSize != null && message.hasOwnProperty("childSize")) {
            if (!$util.isInteger(message.childSize))
              return "childSize: integer expected";
          }
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength")) {
            if (!$util.isInteger(message.minPrefixLength))
              return "minPrefixLength: integer expected";
          }
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength")) {
            if (!$util.isInteger(message.maxPrefixLength))
              return "maxPrefixLength: integer expected";
          }
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild")) {
            if (!(message.emptyChild && typeof message.emptyChild.length === "number" || $util.isString(message.emptyChild)))
              return "emptyChild: buffer expected";
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          return null;
        };
        InnerSpec.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.InnerSpec)
            return object;
          var message = new $root.ics23.InnerSpec();
          if (object.childOrder) {
            if (!Array.isArray(object.childOrder))
              throw TypeError(".ics23.InnerSpec.childOrder: array expected");
            message.childOrder = [];
            for (var i = 0; i < object.childOrder.length; ++i)
              message.childOrder[i] = object.childOrder[i] | 0;
          }
          if (object.childSize != null)
            message.childSize = object.childSize | 0;
          if (object.minPrefixLength != null)
            message.minPrefixLength = object.minPrefixLength | 0;
          if (object.maxPrefixLength != null)
            message.maxPrefixLength = object.maxPrefixLength | 0;
          if (object.emptyChild != null) {
            if (typeof object.emptyChild === "string")
              $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);
            else if (object.emptyChild.length)
              message.emptyChild = object.emptyChild;
          }
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          return message;
        };
        InnerSpec.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.childOrder = [];
          if (options.defaults) {
            object.childSize = 0;
            object.minPrefixLength = 0;
            object.maxPrefixLength = 0;
            if (options.bytes === String)
              object.emptyChild = "";
            else {
              object.emptyChild = [];
              if (options.bytes !== Array)
                object.emptyChild = $util.newBuffer(object.emptyChild);
            }
            object.hash = options.enums === String ? "NO_HASH" : 0;
          }
          if (message.childOrder && message.childOrder.length) {
            object.childOrder = [];
            for (var j = 0; j < message.childOrder.length; ++j)
              object.childOrder[j] = message.childOrder[j];
          }
          if (message.childSize != null && message.hasOwnProperty("childSize"))
            object.childSize = message.childSize;
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength"))
            object.minPrefixLength = message.minPrefixLength;
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength"))
            object.maxPrefixLength = message.maxPrefixLength;
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild"))
            object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          return object;
        };
        InnerSpec.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InnerSpec;
      }();
      ics23.BatchProof = function() {
        function BatchProof(properties) {
          this.entries = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        BatchProof.prototype.entries = $util.emptyArray;
        BatchProof.create = function create(properties) {
          return new BatchProof(properties);
        };
        BatchProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.entries != null && message.entries.length)
            for (var i = 0; i < message.entries.length; ++i)
              $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          return writer;
        };
        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        BatchProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.entries && message.entries.length))
                  message.entries = [];
                message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        BatchProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        BatchProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.entries != null && message.hasOwnProperty("entries")) {
            if (!Array.isArray(message.entries))
              return "entries: array expected";
            for (var i = 0; i < message.entries.length; ++i) {
              var error = $root.ics23.BatchEntry.verify(message.entries[i]);
              if (error)
                return "entries." + error;
            }
          }
          return null;
        };
        BatchProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.BatchProof)
            return object;
          var message = new $root.ics23.BatchProof();
          if (object.entries) {
            if (!Array.isArray(object.entries))
              throw TypeError(".ics23.BatchProof.entries: array expected");
            message.entries = [];
            for (var i = 0; i < object.entries.length; ++i) {
              if (typeof object.entries[i] !== "object")
                throw TypeError(".ics23.BatchProof.entries: object expected");
              message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);
            }
          }
          return message;
        };
        BatchProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.entries = [];
          if (message.entries && message.entries.length) {
            object.entries = [];
            for (var j = 0; j < message.entries.length; ++j)
              object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);
          }
          return object;
        };
        BatchProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BatchProof;
      }();
      ics23.BatchEntry = function() {
        function BatchEntry(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        BatchEntry.prototype.exist = null;
        BatchEntry.prototype.nonexist = null;
        var $oneOfFields;
        Object.defineProperty(BatchEntry.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        BatchEntry.create = function create(properties) {
          return new BatchEntry(properties);
        };
        BatchEntry.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        BatchEntry.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        BatchEntry.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        BatchEntry.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.ExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.NonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          return null;
        };
        BatchEntry.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.BatchEntry)
            return object;
          var message = new $root.ics23.BatchEntry();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.BatchEntry.exist: object expected");
            message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.BatchEntry.nonexist: object expected");
            message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);
          }
          return message;
        };
        BatchEntry.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          return object;
        };
        BatchEntry.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BatchEntry;
      }();
      ics23.CompressedBatchProof = function() {
        function CompressedBatchProof(properties) {
          this.entries = [];
          this.lookupInners = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedBatchProof.prototype.entries = $util.emptyArray;
        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;
        CompressedBatchProof.create = function create(properties) {
          return new CompressedBatchProof(properties);
        };
        CompressedBatchProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.entries != null && message.entries.length)
            for (var i = 0; i < message.entries.length; ++i)
              $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          if (message.lookupInners != null && message.lookupInners.length)
            for (var i = 0; i < message.lookupInners.length; ++i)
              $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          return writer;
        };
        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedBatchProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.entries && message.entries.length))
                  message.entries = [];
                message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));
                break;
              case 2:
                if (!(message.lookupInners && message.lookupInners.length))
                  message.lookupInners = [];
                message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedBatchProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.entries != null && message.hasOwnProperty("entries")) {
            if (!Array.isArray(message.entries))
              return "entries: array expected";
            for (var i = 0; i < message.entries.length; ++i) {
              var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);
              if (error)
                return "entries." + error;
            }
          }
          if (message.lookupInners != null && message.hasOwnProperty("lookupInners")) {
            if (!Array.isArray(message.lookupInners))
              return "lookupInners: array expected";
            for (var i = 0; i < message.lookupInners.length; ++i) {
              var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);
              if (error)
                return "lookupInners." + error;
            }
          }
          return null;
        };
        CompressedBatchProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedBatchProof)
            return object;
          var message = new $root.ics23.CompressedBatchProof();
          if (object.entries) {
            if (!Array.isArray(object.entries))
              throw TypeError(".ics23.CompressedBatchProof.entries: array expected");
            message.entries = [];
            for (var i = 0; i < object.entries.length; ++i) {
              if (typeof object.entries[i] !== "object")
                throw TypeError(".ics23.CompressedBatchProof.entries: object expected");
              message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);
            }
          }
          if (object.lookupInners) {
            if (!Array.isArray(object.lookupInners))
              throw TypeError(".ics23.CompressedBatchProof.lookupInners: array expected");
            message.lookupInners = [];
            for (var i = 0; i < object.lookupInners.length; ++i) {
              if (typeof object.lookupInners[i] !== "object")
                throw TypeError(".ics23.CompressedBatchProof.lookupInners: object expected");
              message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);
            }
          }
          return message;
        };
        CompressedBatchProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.entries = [];
            object.lookupInners = [];
          }
          if (message.entries && message.entries.length) {
            object.entries = [];
            for (var j = 0; j < message.entries.length; ++j)
              object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);
          }
          if (message.lookupInners && message.lookupInners.length) {
            object.lookupInners = [];
            for (var j = 0; j < message.lookupInners.length; ++j)
              object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);
          }
          return object;
        };
        CompressedBatchProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedBatchProof;
      }();
      ics23.CompressedBatchEntry = function() {
        function CompressedBatchEntry(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedBatchEntry.prototype.exist = null;
        CompressedBatchEntry.prototype.nonexist = null;
        var $oneOfFields;
        Object.defineProperty(CompressedBatchEntry.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        CompressedBatchEntry.create = function create(properties) {
          return new CompressedBatchEntry(properties);
        };
        CompressedBatchEntry.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          return writer;
        };
        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedBatchEntry.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedBatchEntry.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          return null;
        };
        CompressedBatchEntry.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedBatchEntry)
            return object;
          var message = new $root.ics23.CompressedBatchEntry();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.CompressedBatchEntry.exist: object expected");
            message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.CompressedBatchEntry.nonexist: object expected");
            message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);
          }
          return message;
        };
        CompressedBatchEntry.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          return object;
        };
        CompressedBatchEntry.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedBatchEntry;
      }();
      ics23.CompressedExistenceProof = function() {
        function CompressedExistenceProof(properties) {
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedExistenceProof.prototype.key = $util.newBuffer([]);
        CompressedExistenceProof.prototype.value = $util.newBuffer([]);
        CompressedExistenceProof.prototype.leaf = null;
        CompressedExistenceProof.prototype.path = $util.emptyArray;
        CompressedExistenceProof.create = function create(properties) {
          return new CompressedExistenceProof(properties);
        };
        CompressedExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).bytes(message.value);
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            $root.ics23.LeafOp.encode(message.leaf, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.path != null && message.path.length) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork();
            for (var i = 0; i < message.path.length; ++i)
              writer.int32(message.path[i]);
            writer.ldelim();
          }
          return writer;
        };
        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.path && message.path.length))
                  message.path = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.path.push(reader.int32());
                } else
                  message.path.push(reader.int32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
              return "value: buffer expected";
          }
          if (message.leaf != null && message.hasOwnProperty("leaf")) {
            var error = $root.ics23.LeafOp.verify(message.leaf);
            if (error)
              return "leaf." + error;
          }
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (var i = 0; i < message.path.length; ++i)
              if (!$util.isInteger(message.path[i]))
                return "path: integer[] expected";
          }
          return null;
        };
        CompressedExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedExistenceProof)
            return object;
          var message = new $root.ics23.CompressedExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.value != null) {
            if (typeof object.value === "string")
              $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
              message.value = object.value;
          }
          if (object.leaf != null) {
            if (typeof object.leaf !== "object")
              throw TypeError(".ics23.CompressedExistenceProof.leaf: object expected");
            message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);
          }
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".ics23.CompressedExistenceProof.path: array expected");
            message.path = [];
            for (var i = 0; i < object.path.length; ++i)
              message.path[i] = object.path[i] | 0;
          }
          return message;
        };
        CompressedExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String)
              object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array)
                object.value = $util.newBuffer(object.value);
            }
            object.leaf = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);
          if (message.path && message.path.length) {
            object.path = [];
            for (var j = 0; j < message.path.length; ++j)
              object.path[j] = message.path[j];
          }
          return object;
        };
        CompressedExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedExistenceProof;
      }();
      ics23.CompressedNonExistenceProof = function() {
        function CompressedNonExistenceProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);
        CompressedNonExistenceProof.prototype.left = null;
        CompressedNonExistenceProof.prototype.right = null;
        CompressedNonExistenceProof.create = function create(properties) {
          return new CompressedNonExistenceProof(properties);
        };
        CompressedNonExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).bytes(message.key);
          if (message.left != null && message.hasOwnProperty("left"))
            $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.right != null && message.hasOwnProperty("right"))
            $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          return writer;
        };
        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedNonExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedNonExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.left != null && message.hasOwnProperty("left")) {
            var error = $root.ics23.CompressedExistenceProof.verify(message.left);
            if (error)
              return "left." + error;
          }
          if (message.right != null && message.hasOwnProperty("right")) {
            var error = $root.ics23.CompressedExistenceProof.verify(message.right);
            if (error)
              return "right." + error;
          }
          return null;
        };
        CompressedNonExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedNonExistenceProof)
            return object;
          var message = new $root.ics23.CompressedNonExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.left != null) {
            if (typeof object.left !== "object")
              throw TypeError(".ics23.CompressedNonExistenceProof.left: object expected");
            message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);
          }
          if (object.right != null) {
            if (typeof object.right !== "object")
              throw TypeError(".ics23.CompressedNonExistenceProof.right: object expected");
            message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);
          }
          return message;
        };
        CompressedNonExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            object.left = null;
            object.right = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.left != null && message.hasOwnProperty("left"))
            object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);
          if (message.right != null && message.hasOwnProperty("right"))
            object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);
          return object;
        };
        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedNonExistenceProof;
      }();
      return ics23;
    }();
    module2.exports = $root;
  }
});

// node_modules/@confio/ics23/build/compress.js
var require_compress = __commonJS({
  "node_modules/@confio/ics23/build/compress.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decompress = exports2.compress = void 0;
    var codecimpl_1 = require_codecimpl();
    function compress(proof) {
      if (!proof.batch) {
        return proof;
      }
      return { compressed: compressBatch(proof.batch) };
    }
    exports2.compress = compress;
    function decompress(proof) {
      if (!proof.compressed) {
        return proof;
      }
      return { batch: decompressBatch(proof.compressed) };
    }
    exports2.decompress = decompress;
    function compressBatch(proof) {
      const centries = [];
      const lookup = [];
      const registry = /* @__PURE__ */ new Map();
      for (const entry of proof.entries) {
        if (entry.exist) {
          const centry = { exist: compressExist(entry.exist, lookup, registry) };
          centries.push(centry);
        } else if (entry.nonexist) {
          const non = entry.nonexist;
          const centry = {
            nonexist: {
              key: non.key,
              left: compressExist(non.left, lookup, registry),
              right: compressExist(non.right, lookup, registry)
            }
          };
          centries.push(centry);
        } else {
          throw new Error("Unexpected batch entry during compress");
        }
      }
      return {
        entries: centries,
        lookupInners: lookup
      };
    }
    function compressExist(exist, lookup, registry) {
      if (!exist) {
        return void 0;
      }
      const path = exist.path.map((inner) => {
        const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();
        let idx = registry.get(sig);
        if (idx === void 0) {
          idx = lookup.length;
          lookup.push(inner);
          registry.set(sig, idx);
        }
        return idx;
      });
      return {
        key: exist.key,
        value: exist.value,
        leaf: exist.leaf,
        path
      };
    }
    function decompressBatch(proof) {
      const lookup = proof.lookupInners;
      const entries = proof.entries.map((comp) => {
        if (comp.exist) {
          return { exist: decompressExist(comp.exist, lookup) };
        } else if (comp.nonexist) {
          const non = comp.nonexist;
          return {
            nonexist: {
              key: non.key,
              left: decompressExist(non.left, lookup),
              right: decompressExist(non.right, lookup)
            }
          };
        } else {
          throw new Error("Unexpected batch entry during compress");
        }
      });
      return {
        entries
      };
    }
    function decompressExist(exist, lookup) {
      if (!exist) {
        return void 0;
      }
      const { key, value, leaf, path } = exist;
      const newPath = (path || []).map((idx) => lookup[idx]);
      return { key, value, leaf, path: newPath };
    }
  }
});

// node_modules/@confio/ics23/build/ops.js
var require_ops = __commonJS({
  "node_modules/@confio/ics23/build/ops.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.doHash = exports2.applyInner = exports2.applyLeaf = void 0;
    var ripemd160_1 = require_ripemd160();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var codecimpl_1 = require_codecimpl();
    function applyLeaf(leaf, key, value) {
      if (key.length === 0) {
        throw new Error("Missing key");
      }
      if (value.length === 0) {
        throw new Error("Missing value");
      }
      const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);
      const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);
      const data = new Uint8Array([
        ...ensureBytes(leaf.prefix),
        ...pkey,
        ...pvalue
      ]);
      return doHash(ensureHash(leaf.hash), data);
    }
    exports2.applyLeaf = applyLeaf;
    function applyInner(inner, child) {
      if (child.length === 0) {
        throw new Error("Inner op needs child value");
      }
      const preimage = new Uint8Array([
        ...ensureBytes(inner.prefix),
        ...child,
        ...ensureBytes(inner.suffix)
      ]);
      return doHash(ensureHash(inner.hash), preimage);
    }
    exports2.applyInner = applyInner;
    function ensure(maybe, value) {
      return maybe === void 0 || maybe === null ? value : maybe;
    }
    var ensureHash = (h) => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);
    var ensureLength = (l) => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);
    var ensureBytes = (b) => ensure(b, new Uint8Array([]));
    function prepareLeafData(hashOp, lengthOp, data) {
      const h = doHashOrNoop(hashOp, data);
      return doLengthOp(lengthOp, h);
    }
    function doHashOrNoop(hashOp, preimage) {
      if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {
        return preimage;
      }
      return doHash(hashOp, preimage);
    }
    function doHash(hashOp, preimage) {
      switch (hashOp) {
        case codecimpl_1.ics23.HashOp.SHA256:
          return (0, sha256_1.sha256)(preimage);
        case codecimpl_1.ics23.HashOp.SHA512:
          return (0, sha512_1.sha512)(preimage);
        case codecimpl_1.ics23.HashOp.RIPEMD160:
          return (0, ripemd160_1.ripemd160)(preimage);
        case codecimpl_1.ics23.HashOp.BITCOIN:
          return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));
        case codecimpl_1.ics23.HashOp.SHA512_256:
          return (0, sha512_1.sha512_256)(preimage);
      }
      throw new Error(`Unsupported hashop: ${hashOp}`);
    }
    exports2.doHash = doHash;
    function doLengthOp(lengthOp, data) {
      switch (lengthOp) {
        case codecimpl_1.ics23.LengthOp.NO_PREFIX:
          return data;
        case codecimpl_1.ics23.LengthOp.VAR_PROTO:
          return new Uint8Array([...encodeVarintProto(data.length), ...data]);
        case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:
          if (data.length !== 32) {
            throw new Error(`Length is ${data.length}, not 32 bytes`);
          }
          return data;
        case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:
          if (data.length !== 64) {
            throw new Error(`Length is ${data.length}, not 64 bytes`);
          }
          return data;
        case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:
          return new Uint8Array([...encodeFixed32Le(data.length), ...data]);
      }
      throw new Error(`Unsupported lengthop: ${lengthOp}`);
    }
    function encodeVarintProto(n) {
      let enc = [];
      let l = n;
      while (l >= 128) {
        const b = l % 128 + 128;
        enc = [...enc, b];
        l = l / 128;
      }
      enc = [...enc, l];
      return new Uint8Array(enc);
    }
    function encodeFixed32Le(n) {
      const enc = new Uint8Array(4);
      let l = n;
      for (let i = enc.length; i > 0; i--) {
        enc[Math.abs(i - enc.length)] = l % 256;
        l = Math.floor(l / 256);
      }
      return enc;
    }
  }
});

// node_modules/@confio/ics23/build/specs.js
var require_specs = __commonJS({
  "node_modules/@confio/ics23/build/specs.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bytesBefore = exports2.ensureBytesBefore = exports2.bytesEqual = exports2.ensureBytesEqual = exports2.ensureInner = exports2.ensureLeaf = void 0;
    function ensureLeaf(leaf, spec) {
      if (leaf.hash !== spec.hash) {
        throw new Error(`Unexpected hashOp: ${leaf.hash}`);
      }
      if (leaf.prehashKey !== spec.prehashKey) {
        throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);
      }
      if (leaf.prehashValue !== spec.prehashValue) {
        throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);
      }
      if (leaf.length !== spec.length) {
        throw new Error(`Unexpected length op: ${leaf.length}`);
      }
      ensurePrefix(leaf.prefix, spec.prefix);
    }
    exports2.ensureLeaf = ensureLeaf;
    function ensureInner(inner, prefix, spec) {
      if (inner.hash !== spec.hash) {
        throw new Error(`Unexpected hashOp: ${inner.hash}`);
      }
      if (!inner.prefix) {
        throw new Error("No prefix set for inner node");
      }
      if (hasPrefix(inner.prefix, prefix)) {
        throw new Error(`Inner node has leaf prefix`);
      }
      if (inner.prefix.length < (spec.minPrefixLength || 0)) {
        throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);
      }
      const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;
      if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {
        throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);
      }
    }
    exports2.ensureInner = ensureInner;
    function ensurePrefix(check, prefix) {
      if (!prefix || prefix.length === 0) {
        return;
      }
      if (!check) {
        throw new Error(`Target bytes missing`);
      }
      ensureBytesEqual(prefix, check.slice(0, prefix.length));
    }
    function ensureBytesEqual(a, b) {
      if (a.length !== b.length) {
        throw new Error(`Different lengths ${a.length} vs ${b.length}`);
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);
        }
      }
    }
    exports2.ensureBytesEqual = ensureBytesEqual;
    function bytesEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports2.bytesEqual = bytesEqual;
    function hasPrefix(check, prefix) {
      if (!prefix || prefix.length === 0) {
        return false;
      }
      if (!check) {
        return false;
      }
      if (check.length <= prefix.length) {
        return false;
      }
      for (let i = 0; i < prefix.length; i++) {
        if (check[i] !== prefix[i]) {
          return false;
        }
      }
      throw true;
    }
    function ensureBytesBefore(first, last) {
      if (!bytesBefore(first, last)) {
        throw new Error("first is after last");
      }
    }
    exports2.ensureBytesBefore = ensureBytesBefore;
    function bytesBefore(first, last) {
      const min = first.length < last.length ? first.length : last.length;
      for (let i = 0; i < min; i++) {
        if (first[i] < last[i]) {
          return true;
        }
        if (first[i] > last[i]) {
          return false;
        }
      }
      return first.length < last.length;
    }
    exports2.bytesBefore = bytesBefore;
  }
});

// node_modules/@confio/ics23/build/proofs.js
var require_proofs = __commonJS({
  "node_modules/@confio/ics23/build/proofs.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureLeftNeighbor = exports2.ensureSpec = exports2.calculateExistenceRoot = exports2.verifyNonExistence = exports2.verifyExistence = exports2.smtSpec = exports2.tendermintSpec = exports2.iavlSpec = void 0;
    var codecimpl_1 = require_codecimpl();
    var ops_1 = require_ops();
    var specs_1 = require_specs();
    exports2.iavlSpec = {
      leafSpec: {
        prefix: Uint8Array.from([0]),
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        length: codecimpl_1.ics23.LengthOp.VAR_PROTO
      },
      innerSpec: {
        childOrder: [0, 1],
        minPrefixLength: 4,
        maxPrefixLength: 12,
        childSize: 33,
        hash: codecimpl_1.ics23.HashOp.SHA256
      }
    };
    exports2.tendermintSpec = {
      leafSpec: {
        prefix: Uint8Array.from([0]),
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        length: codecimpl_1.ics23.LengthOp.VAR_PROTO
      },
      innerSpec: {
        childOrder: [0, 1],
        minPrefixLength: 1,
        maxPrefixLength: 1,
        childSize: 32,
        hash: codecimpl_1.ics23.HashOp.SHA256
      }
    };
    exports2.smtSpec = {
      leafSpec: {
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        length: codecimpl_1.ics23.LengthOp.NO_PREFIX,
        prefix: Uint8Array.from([0])
      },
      innerSpec: {
        childOrder: [0, 1],
        childSize: 32,
        minPrefixLength: 1,
        maxPrefixLength: 1,
        emptyChild: new Uint8Array(32),
        hash: codecimpl_1.ics23.HashOp.SHA256
      },
      maxDepth: 256
    };
    function verifyExistence(proof, spec, root, key, value) {
      ensureSpec(proof, spec);
      const calc = calculateExistenceRoot(proof);
      (0, specs_1.ensureBytesEqual)(calc, root);
      (0, specs_1.ensureBytesEqual)(key, proof.key);
      (0, specs_1.ensureBytesEqual)(value, proof.value);
    }
    exports2.verifyExistence = verifyExistence;
    function verifyNonExistence(proof, spec, root, key) {
      let leftKey;
      let rightKey;
      if (proof.left) {
        verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);
        leftKey = proof.left.key;
      }
      if (proof.right) {
        verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);
        rightKey = proof.right.key;
      }
      if (!leftKey && !rightKey) {
        throw new Error("neither left nor right proof defined");
      }
      if (leftKey) {
        (0, specs_1.ensureBytesBefore)(leftKey, key);
      }
      if (rightKey) {
        (0, specs_1.ensureBytesBefore)(key, rightKey);
      }
      if (!spec.innerSpec) {
        throw new Error("no inner spec");
      }
      if (!leftKey) {
        ensureLeftMost(spec.innerSpec, proof.right.path);
      } else if (!rightKey) {
        ensureRightMost(spec.innerSpec, proof.left.path);
      } else {
        ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);
      }
      return;
    }
    exports2.verifyNonExistence = verifyNonExistence;
    function calculateExistenceRoot(proof) {
      if (!proof.key || !proof.value) {
        throw new Error("Existence proof needs key and value set");
      }
      if (!proof.leaf) {
        throw new Error("Existence proof must start with a leaf operation");
      }
      const path = proof.path || [];
      let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);
      for (const inner of path) {
        res = (0, ops_1.applyInner)(inner, res);
      }
      return res;
    }
    exports2.calculateExistenceRoot = calculateExistenceRoot;
    function ensureSpec(proof, spec) {
      if (!proof.leaf) {
        throw new Error("Existence proof must start with a leaf operation");
      }
      if (!spec.leafSpec) {
        throw new Error("Spec must include leafSpec");
      }
      if (!spec.innerSpec) {
        throw new Error("Spec must include innerSpec");
      }
      (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);
      const path = proof.path || [];
      if (spec.minDepth && path.length < spec.minDepth) {
        throw new Error(`Too few inner nodes ${path.length}`);
      }
      if (spec.maxDepth && path.length > spec.maxDepth) {
        throw new Error(`Too many inner nodes ${path.length}`);
      }
      for (const inner of path) {
        (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);
      }
    }
    exports2.ensureSpec = ensureSpec;
    function ensureLeftMost(spec, path) {
      const { minPrefix, maxPrefix, suffix } = getPadding(spec, 0);
      for (const step of path) {
        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {
          throw new Error("Step not leftmost");
        }
      }
    }
    function ensureRightMost(spec, path) {
      const len = spec.childOrder.length - 1;
      const { minPrefix, maxPrefix, suffix } = getPadding(spec, len);
      for (const step of path) {
        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {
          throw new Error("Step not leftmost");
        }
      }
    }
    function ensureLeftNeighbor(spec, left, right) {
      const mutleft = [...left];
      const mutright = [...right];
      let topleft = mutleft.pop();
      let topright = mutright.pop();
      while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) && (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {
        topleft = mutleft.pop();
        topright = mutright.pop();
      }
      if (!isLeftStep(spec, topleft, topright)) {
        throw new Error(`Not left neightbor at first divergent step`);
      }
      ensureRightMost(spec, mutleft);
      ensureLeftMost(spec, mutright);
    }
    exports2.ensureLeftNeighbor = ensureLeftNeighbor;
    function isLeftStep(spec, left, right) {
      const leftidx = orderFromPadding(spec, left);
      const rightidx = orderFromPadding(spec, right);
      return rightidx === leftidx + 1;
    }
    function orderFromPadding(spec, inner) {
      for (let branch = 0; branch < spec.childOrder.length; branch++) {
        const { minPrefix, maxPrefix, suffix } = getPadding(spec, branch);
        if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {
          return branch;
        }
      }
      throw new Error(`Cannot find any valid spacing for this node`);
    }
    function hasPadding(op, minPrefix, maxPrefix, suffix) {
      if ((op.prefix || []).length < minPrefix) {
        return false;
      }
      if ((op.prefix || []).length > maxPrefix) {
        return false;
      }
      return (op.suffix || []).length === suffix;
    }
    function getPadding(spec, branch) {
      const idx = getPosition(spec.childOrder, branch);
      const prefix = idx * spec.childSize;
      const minPrefix = prefix + spec.minPrefixLength;
      const maxPrefix = prefix + spec.maxPrefixLength;
      const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;
      return { minPrefix, maxPrefix, suffix };
    }
    function getPosition(order, branch) {
      if (branch < 0 || branch >= order.length) {
        throw new Error(`Invalid branch: ${branch}`);
      }
      return order.findIndex((val) => val === branch);
    }
  }
});

// node_modules/@confio/ics23/build/ics23.js
var require_ics23 = __commonJS({
  "node_modules/@confio/ics23/build/ics23.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.batchVerifyNonMembership = exports2.batchVerifyMembership = exports2.verifyNonMembership = exports2.verifyMembership = void 0;
    var compress_1 = require_compress();
    var proofs_1 = require_proofs();
    var specs_1 = require_specs();
    function verifyMembership(proof, spec, root, key, value) {
      const norm = (0, compress_1.decompress)(proof);
      const exist = getExistForKey(norm, key);
      if (!exist) {
        return false;
      }
      try {
        (0, proofs_1.verifyExistence)(exist, spec, root, key, value);
        return true;
      } catch (_a) {
        return false;
      }
    }
    exports2.verifyMembership = verifyMembership;
    function verifyNonMembership(proof, spec, root, key) {
      const norm = (0, compress_1.decompress)(proof);
      const nonexist = getNonExistForKey(norm, key);
      if (!nonexist) {
        return false;
      }
      try {
        (0, proofs_1.verifyNonExistence)(nonexist, spec, root, key);
        return true;
      } catch (_a) {
        return false;
      }
    }
    exports2.verifyNonMembership = verifyNonMembership;
    function batchVerifyMembership(proof, spec, root, items) {
      const norm = (0, compress_1.decompress)(proof);
      for (const [key, value] of items.entries()) {
        if (!verifyMembership(norm, spec, root, key, value)) {
          return false;
        }
      }
      return true;
    }
    exports2.batchVerifyMembership = batchVerifyMembership;
    function batchVerifyNonMembership(proof, spec, root, keys) {
      const norm = (0, compress_1.decompress)(proof);
      for (const key of keys) {
        if (!verifyNonMembership(norm, spec, root, key)) {
          return false;
        }
      }
      return true;
    }
    exports2.batchVerifyNonMembership = batchVerifyNonMembership;
    function getExistForKey(proof, key) {
      const match = (p) => !!p && (0, specs_1.bytesEqual)(key, p.key);
      if (match(proof.exist)) {
        return proof.exist;
      } else if (proof.batch) {
        return proof.batch.entries.map((x) => x.exist || null).find(match);
      }
      return void 0;
    }
    function getNonExistForKey(proof, key) {
      const match = (p) => {
        return !!p && (!p.left || (0, specs_1.bytesBefore)(p.left.key, key)) && (!p.right || (0, specs_1.bytesBefore)(key, p.right.key));
      };
      if (match(proof.nonexist)) {
        return proof.nonexist;
      } else if (proof.batch) {
        return proof.batch.entries.map((x) => x.nonexist || null).find(match);
      }
      return void 0;
    }
  }
});

// node_modules/@confio/ics23/build/index.js
var require_build9 = __commonJS({
  "node_modules/@confio/ics23/build/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyNonExistence = exports2.verifyExistence = exports2.tendermintSpec = exports2.iavlSpec = exports2.calculateExistenceRoot = exports2.verifyNonMembership = exports2.verifyMembership = exports2.ics23 = void 0;
    var codecimpl_1 = require_codecimpl();
    Object.defineProperty(exports2, "ics23", { enumerable: true, get: function() {
      return codecimpl_1.ics23;
    } });
    var ics23_1 = require_ics23();
    Object.defineProperty(exports2, "verifyMembership", { enumerable: true, get: function() {
      return ics23_1.verifyMembership;
    } });
    Object.defineProperty(exports2, "verifyNonMembership", { enumerable: true, get: function() {
      return ics23_1.verifyNonMembership;
    } });
    var proofs_1 = require_proofs();
    Object.defineProperty(exports2, "calculateExistenceRoot", { enumerable: true, get: function() {
      return proofs_1.calculateExistenceRoot;
    } });
    Object.defineProperty(exports2, "iavlSpec", { enumerable: true, get: function() {
      return proofs_1.iavlSpec;
    } });
    Object.defineProperty(exports2, "tendermintSpec", { enumerable: true, get: function() {
      return proofs_1.tendermintSpec;
    } });
    Object.defineProperty(exports2, "verifyExistence", { enumerable: true, get: function() {
      return proofs_1.verifyExistence;
    } });
    Object.defineProperty(exports2, "verifyNonExistence", { enumerable: true, get: function() {
      return proofs_1.verifyNonExistence;
    } });
  }
});

// node_modules/@cosmjs/stargate/build/queryclient/queryclient.js
var require_queryclient = __commonJS({
  "node_modules/@cosmjs/stargate/build/queryclient/queryclient.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClient = void 0;
    var ics23_1 = require_build9();
    var encoding_1 = require_build();
    var stream_1 = require_build5();
    var utils_1 = require_build3();
    function checkAndParseOp(op, kind, key) {
      if (op.type !== kind) {
        throw new Error(`Op expected to be ${kind}, got "${op.type}`);
      }
      if (!(0, utils_1.arrayContentEquals)(key, op.key)) {
        throw new Error(`Proven key different than queried key.
Query: ${(0, encoding_1.toHex)(key)}
Proven: ${(0, encoding_1.toHex)(op.key)}`);
      }
      return ics23_1.ics23.CommitmentProof.decode(op.data);
    }
    var QueryClient = class _QueryClient {
      static withExtensions(cometClient, ...extensionSetups) {
        const client = new _QueryClient(cometClient);
        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));
        for (const extension of extensions) {
          (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);
          for (const [moduleKey, moduleValue] of Object.entries(extension)) {
            (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module "${moduleKey}".`);
            const current = client[moduleKey] || {};
            client[moduleKey] = {
              ...current,
              ...moduleValue
            };
          }
        }
        return client;
      }
      constructor(cometClient) {
        this.cometClient = cometClient;
      }
      /**
       * Queries the database store with a proof, which is then verified.
       *
       * Please note: the current implementation trusts block headers it gets from the PRC endpoint.
       */
      async queryStoreVerified(store, queryKey, desiredHeight) {
        const { height, proof, key, value } = await this.queryRawProof(store, queryKey, desiredHeight);
        const subProof = checkAndParseOp(proof.ops[0], "ics23:iavl", queryKey);
        const storeProof = checkAndParseOp(proof.ops[1], "ics23:simple", (0, encoding_1.toAscii)(store));
        (0, utils_1.assert)(storeProof.exist);
        (0, utils_1.assert)(storeProof.exist.value);
        if (!value || value.length === 0) {
          (0, utils_1.assert)(subProof.nonexist);
          (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, queryKey);
        } else {
          (0, utils_1.assert)(subProof.exist);
          (0, utils_1.assert)(subProof.exist.value);
          (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, queryKey, value);
        }
        const header = await this.getNextHeader(height);
        (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);
        return { key, value, height };
      }
      async queryRawProof(store, queryKey, desiredHeight) {
        const { key, value, height, proof, code, log } = await this.cometClient.abciQuery({
          // we need the StoreKey for the module, not the module name
          // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12
          path: `/store/${store}/key`,
          data: queryKey,
          prove: true,
          height: desiredHeight
        });
        if (code) {
          throw new Error(`Query failed with (${code}): ${log}`);
        }
        if (!(0, utils_1.arrayContentEquals)(queryKey, key)) {
          throw new Error(`Response key ${(0, encoding_1.toHex)(key)} doesn't match query key ${(0, encoding_1.toHex)(queryKey)}`);
        }
        if (!height) {
          throw new Error("No query height returned");
        }
        if (!proof || proof.ops.length !== 2) {
          throw new Error(`Expected 2 proof ops, got ${(proof == null ? void 0 : proof.ops.length) ?? 0}. Are you using stargate?`);
        }
        checkAndParseOp(proof.ops[0], "ics23:iavl", key);
        checkAndParseOp(proof.ops[1], "ics23:simple", (0, encoding_1.toAscii)(store));
        return {
          key,
          value,
          height,
          // need to clone this: readonly input / writeable output
          proof: {
            ops: [...proof.ops]
          }
        };
      }
      /**
       * Performs an ABCI query to Tendermint without requesting a proof.
       *
       * If the `desiredHeight` is set, a particular height is requested. Otherwise
       * the latest height is requested. The response contains the actual height of
       * the query.
       */
      async queryAbci(path, request, desiredHeight) {
        const response = await this.cometClient.abciQuery({
          path,
          data: request,
          prove: false,
          height: desiredHeight
        });
        if (response.code) {
          throw new Error(`Query failed with (${response.code}): ${response.log}`);
        }
        if (!response.height) {
          throw new Error("No query height returned");
        }
        return {
          value: response.value,
          height: response.height
        };
      }
      // this must return the header for height+1
      // throws an error if height is 0 or undefined
      async getNextHeader(height) {
        (0, utils_1.assertDefined)(height);
        if (height === 0) {
          throw new Error("Query returned height 0, cannot prove it");
        }
        const searchHeight = height + 1;
        let nextHeader;
        let headersSubscription;
        try {
          headersSubscription = this.cometClient.subscribeNewBlockHeader();
        } catch {
        }
        if (headersSubscription) {
          const firstHeader = await (0, stream_1.firstEvent)(headersSubscription);
          if (firstHeader.height === searchHeight) {
            nextHeader = firstHeader;
          }
        }
        while (!nextHeader) {
          const correctHeader = (await this.cometClient.blockchain(height, searchHeight)).blockMetas.map((meta) => meta.header).find((h) => h.height === searchHeight);
          if (correctHeader) {
            nextHeader = correctHeader;
          } else {
            await (0, utils_1.sleep)(1e3);
          }
        }
        (0, utils_1.assert)(nextHeader.height === searchHeight, "Got wrong header. This is a bug in the logic above.");
        return nextHeader;
      }
    };
    exports2.QueryClient = QueryClient;
  }
});

// node_modules/@cosmjs/stargate/build/queryclient/utils.js
var require_utils = __commonJS({
  "node_modules/@cosmjs/stargate/build/queryclient/utils.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeCosmosSdkDecFromProto = exports2.longify = exports2.createProtobufRpcClient = exports2.createPagination = exports2.toAccAddress = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var pagination_1 = require_pagination();
    function toAccAddress(address) {
      return (0, encoding_1.fromBech32)(address).data;
    }
    exports2.toAccAddress = toAccAddress;
    function createPagination(paginationKey) {
      return paginationKey ? pagination_1.PageRequest.fromPartial({ key: paginationKey }) : pagination_1.PageRequest.fromPartial({});
    }
    exports2.createPagination = createPagination;
    function createProtobufRpcClient(base) {
      return {
        request: async (service, method, data) => {
          const path = `/${service}/${method}`;
          const response = await base.queryAbci(path, data, void 0);
          return response.value;
        }
      };
    }
    exports2.createProtobufRpcClient = createProtobufRpcClient;
    function longify(value) {
      const checkedValue = math_1.Uint64.fromString(value.toString());
      return BigInt(checkedValue.toString());
    }
    exports2.longify = longify;
    function decodeCosmosSdkDecFromProto(input) {
      const asString = typeof input === "string" ? input : (0, encoding_1.fromAscii)(input);
      return math_1.Decimal.fromAtomics(asString, 18);
    }
    exports2.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;
  }
});

// node_modules/@cosmjs/stargate/build/queryclient/index.js
var require_queryclient2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/queryclient/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.longify = exports2.decodeCosmosSdkDecFromProto = exports2.createProtobufRpcClient = exports2.createPagination = exports2.QueryClient = void 0;
    var queryclient_1 = require_queryclient();
    Object.defineProperty(exports2, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports2, "createPagination", { enumerable: true, get: function() {
      return utils_1.createPagination;
    } });
    Object.defineProperty(exports2, "createProtobufRpcClient", { enumerable: true, get: function() {
      return utils_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports2, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return utils_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports2, "longify", { enumerable: true, get: function() {
      return utils_1.longify;
    } });
  }
});

// node_modules/@cosmjs/stargate/build/modules/auth/queries.js
var require_queries = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/auth/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupAuthExtension = void 0;
    var query_1 = require_query2();
    var queryclient_1 = require_queryclient2();
    function setupAuthExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        auth: {
          account: async (address) => {
            const { account } = await queryService.Account({ address });
            return account ?? null;
          }
        }
      };
    }
    exports2.setupAuthExtension = setupAuthExtension;
  }
});

// node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js
var require_aminomessages = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAuthzAminoConverters = void 0;
    function createAuthzAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.authz.v1beta1.MsgGrant": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgExec": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgRevoke": IMPLEMENT ME,
      };
    }
    exports2.createAuthzAminoConverters = createAuthzAminoConverters;
  }
});

// node_modules/cosmjs-types/google/protobuf/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/cosmjs-types/google/protobuf/timestamp.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timestamp = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "google.protobuf";
    function createBaseTimestamp() {
      return {
        seconds: BigInt(0),
        nanos: 0
      };
    }
    exports2.Timestamp = {
      typeUrl: "/google.protobuf.Timestamp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.seconds !== BigInt(0)) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTimestamp();
        if ((0, helpers_1.isSet)(object.seconds))
          obj.seconds = BigInt(object.seconds.toString());
        if ((0, helpers_1.isSet)(object.nanos))
          obj.nanos = Number(object.nanos);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || BigInt(0)).toString());
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTimestamp();
        if (object.seconds !== void 0 && object.seconds !== null) {
          message.seconds = BigInt(object.seconds.toString());
        }
        message.nanos = object.nanos ?? 0;
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/authz/v1beta1/authz.js
var require_authz = __commonJS({
  "node_modules/cosmjs-types/cosmos/authz/v1beta1/authz.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GrantQueueItem = exports2.GrantAuthorization = exports2.Grant = exports2.GenericAuthorization = exports2.protobufPackage = void 0;
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseGenericAuthorization() {
      return {
        msg: ""
      };
    }
    exports2.GenericAuthorization = {
      typeUrl: "/cosmos.authz.v1beta1.GenericAuthorization",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msg !== "") {
          writer.uint32(10).string(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGenericAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msg = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGenericAuthorization();
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = String(object.msg);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msg !== void 0 && (obj.msg = message.msg);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGenericAuthorization();
        message.msg = object.msg ?? "";
        return message;
      }
    };
    function createBaseGrant() {
      return {
        authorization: void 0,
        expiration: void 0
      };
    }
    exports2.Grant = {
      typeUrl: "/cosmos.authz.v1beta1.Grant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrant();
        if ((0, helpers_1.isSet)(object.authorization))
          obj.authorization = any_1.Any.fromJSON(object.authorization);
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrant();
        if (object.authorization !== void 0 && object.authorization !== null) {
          message.authorization = any_1.Any.fromPartial(object.authorization);
        }
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBaseGrantAuthorization() {
      return {
        granter: "",
        grantee: "",
        authorization: void 0,
        expiration: void 0
      };
    }
    exports2.GrantAuthorization = {
      typeUrl: "/cosmos.authz.v1beta1.GrantAuthorization",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(26).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrantAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrantAuthorization();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.authorization))
          obj.authorization = any_1.Any.fromJSON(object.authorization);
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrantAuthorization();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.authorization !== void 0 && object.authorization !== null) {
          message.authorization = any_1.Any.fromPartial(object.authorization);
        }
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBaseGrantQueueItem() {
      return {
        msgTypeUrls: []
      };
    }
    exports2.GrantQueueItem = {
      typeUrl: "/cosmos.authz.v1beta1.GrantQueueItem",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.msgTypeUrls) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrantQueueItem();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgTypeUrls.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrantQueueItem();
        if (Array.isArray(object == null ? void 0 : object.msgTypeUrls))
          obj.msgTypeUrls = object.msgTypeUrls.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.msgTypeUrls) {
          obj.msgTypeUrls = message.msgTypeUrls.map((e) => e);
        } else {
          obj.msgTypeUrls = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseGrantQueueItem();
        message.msgTypeUrls = ((_a = object.msgTypeUrls) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js
var require_tx3 = __commonJS({
  "node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgRevokeResponse = exports2.MsgRevoke = exports2.MsgGrantResponse = exports2.MsgExec = exports2.MsgExecResponse = exports2.MsgGrant = exports2.protobufPackage = void 0;
    var authz_1 = require_authz();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseMsgGrant() {
      return {
        granter: "",
        grantee: "",
        grant: authz_1.Grant.fromPartial({})
      };
    }
    exports2.MsgGrant = {
      typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.grant !== void 0) {
          authz_1.Grant.encode(message.grant, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.grant = authz_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgGrant();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.grant))
          obj.grant = authz_1.Grant.fromJSON(object.grant);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.grant !== void 0 && (obj.grant = message.grant ? authz_1.Grant.toJSON(message.grant) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgGrant();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.grant !== void 0 && object.grant !== null) {
          message.grant = authz_1.Grant.fromPartial(object.grant);
        }
        return message;
      }
    };
    function createBaseMsgExecResponse() {
      return {
        results: []
      };
    }
    exports2.MsgExecResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgExecResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.results) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.results.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecResponse();
        if (Array.isArray(object == null ? void 0 : object.results))
          obj.results = object.results.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.results) {
          obj.results = message.results.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.results = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgExecResponse();
        message.results = ((_a = object.results) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMsgExec() {
      return {
        grantee: "",
        msgs: []
      };
    }
    exports2.MsgExec = {
      typeUrl: "/cosmos.authz.v1beta1.MsgExec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        for (const v of message.msgs) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.msgs.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExec();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if (Array.isArray(object == null ? void 0 : object.msgs))
          obj.msgs = object.msgs.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        if (message.msgs) {
          obj.msgs = message.msgs.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgExec();
        message.grantee = object.grantee ?? "";
        message.msgs = ((_a = object.msgs) == null ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgGrantResponse() {
      return {};
    }
    exports2.MsgGrantResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgGrantResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgGrantResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgGrantResponse();
        return message;
      }
    };
    function createBaseMsgRevoke() {
      return {
        granter: "",
        grantee: "",
        msgTypeUrl: ""
      };
    }
    exports2.MsgRevoke = {
      typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevoke();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRevoke();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.msgTypeUrl))
          obj.msgTypeUrl = String(object.msgTypeUrl);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRevoke();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        message.msgTypeUrl = object.msgTypeUrl ?? "";
        return message;
      }
    };
    function createBaseMsgRevokeResponse() {
      return {};
    }
    exports2.MsgRevokeResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgRevokeResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgRevokeResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRevokeResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Grant = this.Grant.bind(this);
        this.Exec = this.Exec.bind(this);
        this.Revoke = this.Revoke.bind(this);
      }
      Grant(request) {
        const data = exports2.MsgGrant.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", data);
        return promise.then((data2) => exports2.MsgGrantResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Exec(request) {
        const data = exports2.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", data);
        return promise.then((data2) => exports2.MsgExecResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Revoke(request) {
        const data = exports2.MsgRevoke.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", data);
        return promise.then((data2) => exports2.MsgRevokeResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/authz/messages.js
var require_messages = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/authz/messages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.authzTypes = void 0;
    var tx_1 = require_tx3();
    exports2.authzTypes = [
      ["/cosmos.authz.v1beta1.MsgExec", tx_1.MsgExec],
      ["/cosmos.authz.v1beta1.MsgGrant", tx_1.MsgGrant],
      ["/cosmos.authz.v1beta1.MsgRevoke", tx_1.MsgRevoke]
    ];
  }
});

// node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js
var require_query3 = __commonJS({
  "node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryGranteeGrantsResponse = exports2.QueryGranteeGrantsRequest = exports2.QueryGranterGrantsResponse = exports2.QueryGranterGrantsRequest = exports2.QueryGrantsResponse = exports2.QueryGrantsRequest = exports2.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var authz_1 = require_authz();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseQueryGrantsRequest() {
      return {
        granter: "",
        grantee: "",
        msgTypeUrl: "",
        pagination: void 0
      };
    }
    exports2.QueryGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGrantsRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.msgTypeUrl))
          obj.msgTypeUrl = String(object.msgTypeUrl);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGrantsRequest();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        message.msgTypeUrl = object.msgTypeUrl ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGrantsResponse() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports2.QueryGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants) {
          authz_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGrantsResponse();
        if (Array.isArray(object == null ? void 0 : object.grants))
          obj.grants = object.grants.map((e) => authz_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.Grant.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryGrantsResponse();
        message.grants = ((_a = object.grants) == null ? void 0 : _a.map((e) => authz_1.Grant.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranterGrantsRequest() {
      return {
        granter: "",
        pagination: void 0
      };
    }
    exports2.QueryGranterGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranterGrantsRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranterGrantsRequest();
        message.granter = object.granter ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranterGrantsResponse() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports2.QueryGranterGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants) {
          authz_1.GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranterGrantsResponse();
        if (Array.isArray(object == null ? void 0 : object.grants))
          obj.grants = object.grants.map((e) => authz_1.GrantAuthorization.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.GrantAuthorization.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryGranterGrantsResponse();
        message.grants = ((_a = object.grants) == null ? void 0 : _a.map((e) => authz_1.GrantAuthorization.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranteeGrantsRequest() {
      return {
        grantee: "",
        pagination: void 0
      };
    }
    exports2.QueryGranteeGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranteeGrantsRequest();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranteeGrantsRequest();
        message.grantee = object.grantee ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranteeGrantsResponse() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports2.QueryGranteeGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.grants) {
          authz_1.GrantAuthorization.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranteeGrantsResponse();
        if (Array.isArray(object == null ? void 0 : object.grants))
          obj.grants = object.grants.map((e) => authz_1.GrantAuthorization.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.GrantAuthorization.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryGranteeGrantsResponse();
        message.grants = ((_a = object.grants) == null ? void 0 : _a.map((e) => authz_1.GrantAuthorization.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Grants = this.Grants.bind(this);
        this.GranterGrants = this.GranterGrants.bind(this);
        this.GranteeGrants = this.GranteeGrants.bind(this);
      }
      Grants(request) {
        const data = exports2.QueryGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", data);
        return promise.then((data2) => exports2.QueryGrantsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      GranterGrants(request) {
        const data = exports2.QueryGranterGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", data);
        return promise.then((data2) => exports2.QueryGranterGrantsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      GranteeGrants(request) {
        const data = exports2.QueryGranteeGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", data);
        return promise.then((data2) => exports2.QueryGranteeGrantsResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/authz/queries.js
var require_queries2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/authz/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupAuthzExtension = void 0;
    var query_1 = require_query3();
    var queryclient_1 = require_queryclient2();
    function setupAuthzExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        authz: {
          grants: async (granter, grantee, msgTypeUrl, paginationKey) => {
            return await queryService.Grants({
              granter,
              grantee,
              msgTypeUrl,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granteeGrants: async (grantee, paginationKey) => {
            return await queryService.GranteeGrants({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granterGrants: async (granter, paginationKey) => {
            return await queryService.GranterGrants({
              granter,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          }
        }
      };
    }
    exports2.setupAuthzExtension = setupAuthzExtension;
  }
});

// node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js
var require_aminomessages2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBankAminoConverters = exports2.isAminoMsgMultiSend = exports2.isAminoMsgSend = void 0;
    function isAminoMsgSend(msg) {
      return msg.type === "cosmos-sdk/MsgSend";
    }
    exports2.isAminoMsgSend = isAminoMsgSend;
    function isAminoMsgMultiSend(msg) {
      return msg.type === "cosmos-sdk/MsgMultiSend";
    }
    exports2.isAminoMsgMultiSend = isAminoMsgMultiSend;
    function createBankAminoConverters() {
      return {
        "/cosmos.bank.v1beta1.MsgSend": {
          aminoType: "cosmos-sdk/MsgSend",
          toAmino: ({ fromAddress, toAddress, amount }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount]
          }),
          fromAmino: ({ from_address, to_address, amount }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount]
          })
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
          aminoType: "cosmos-sdk/MsgMultiSend",
          toAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          }),
          fromAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          })
        }
      };
    }
    exports2.createBankAminoConverters = createBankAminoConverters;
  }
});

// node_modules/@cosmjs/stargate/build/modules/bank/messages.js
var require_messages2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/bank/messages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgSendEncodeObject = exports2.bankTypes = void 0;
    var tx_1 = require_tx2();
    exports2.bankTypes = [
      ["/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend],
      ["/cosmos.bank.v1beta1.MsgSend", tx_1.MsgSend]
    ];
    function isMsgSendEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
    }
    exports2.isMsgSendEncodeObject = isMsgSendEncodeObject;
  }
});

// node_modules/@cosmjs/stargate/build/modules/bank/queries.js
var require_queries3 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/bank/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupBankExtension = void 0;
    var utils_1 = require_build3();
    var query_1 = require_query();
    var queryclient_1 = require_queryclient2();
    function setupBankExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        bank: {
          balance: async (address, denom) => {
            const { balance } = await queryService.Balance({ address, denom });
            (0, utils_1.assert)(balance);
            return balance;
          },
          allBalances: async (address) => {
            const { balances } = await queryService.AllBalances(query_1.QueryAllBalancesRequest.fromPartial({ address }));
            return balances;
          },
          totalSupply: async (paginationKey) => {
            const response = await queryService.TotalSupply({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          supplyOf: async (denom) => {
            const { amount } = await queryService.SupplyOf({ denom });
            (0, utils_1.assert)(amount);
            return amount;
          },
          denomMetadata: async (denom) => {
            const { metadata } = await queryService.DenomMetadata({ denom });
            (0, utils_1.assert)(metadata);
            return metadata;
          },
          denomsMetadata: async () => {
            const { metadatas } = await queryService.DenomsMetadata(query_1.QueryDenomsMetadataRequest.fromPartial({
              pagination: void 0
              // Not implemented
            }));
            return metadatas;
          }
        }
      };
    }
    exports2.setupBankExtension = setupBankExtension;
  }
});

// node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js
var require_aminomessages3 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createCrysisAminoConverters = exports2.isAminoMsgVerifyInvariant = void 0;
    function isAminoMsgVerifyInvariant(msg) {
      return msg.type === "cosmos-sdk/MsgVerifyInvariant";
    }
    exports2.isAminoMsgVerifyInvariant = isAminoMsgVerifyInvariant;
    function createCrysisAminoConverters() {
      throw new Error("Not implemented");
    }
    exports2.createCrysisAminoConverters = createCrysisAminoConverters;
  }
});

// node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js
var require_aminomessages4 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDistributionAminoConverters = exports2.isAminoMsgFundCommunityPool = exports2.isAminoMsgWithdrawValidatorCommission = exports2.isAminoMsgWithdrawDelegatorReward = exports2.isAminoMsgSetWithdrawAddress = void 0;
    function isAminoMsgSetWithdrawAddress(msg) {
      return msg.type === "cosmos-sdk/MsgModifyWithdrawAddress";
    }
    exports2.isAminoMsgSetWithdrawAddress = isAminoMsgSetWithdrawAddress;
    function isAminoMsgWithdrawDelegatorReward(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawDelegationReward";
    }
    exports2.isAminoMsgWithdrawDelegatorReward = isAminoMsgWithdrawDelegatorReward;
    function isAminoMsgWithdrawValidatorCommission(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
    }
    exports2.isAminoMsgWithdrawValidatorCommission = isAminoMsgWithdrawValidatorCommission;
    function isAminoMsgFundCommunityPool(msg) {
      return msg.type === "cosmos-sdk/MsgFundCommunityPool";
    }
    exports2.isAminoMsgFundCommunityPool = isAminoMsgFundCommunityPool;
    function createDistributionAminoConverters() {
      return {
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
          aminoType: "cosmos-sdk/MsgFundCommunityPool",
          toAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          }),
          fromAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          })
        },
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
          aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
          toAmino: ({ delegatorAddress, withdrawAddress }) => ({
            delegator_address: delegatorAddress,
            withdraw_address: withdrawAddress
          }),
          fromAmino: ({ delegator_address, withdraw_address }) => ({
            delegatorAddress: delegator_address,
            withdrawAddress: withdraw_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
          aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
          toAmino: ({ delegatorAddress, validatorAddress }) => ({
            delegator_address: delegatorAddress,
            validator_address: validatorAddress
          }),
          fromAmino: ({ delegator_address, validator_address }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
          aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
          toAmino: ({ validatorAddress }) => ({
            validator_address: validatorAddress
          }),
          fromAmino: ({ validator_address }) => ({
            validatorAddress: validator_address
          })
        }
      };
    }
    exports2.createDistributionAminoConverters = createDistributionAminoConverters;
  }
});

// node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js
var require_distribution = __commonJS({
  "node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommunityPoolSpendProposalWithDeposit = exports2.DelegationDelegatorReward = exports2.DelegatorStartingInfo = exports2.CommunityPoolSpendProposal = exports2.FeePool = exports2.ValidatorSlashEvents = exports2.ValidatorSlashEvent = exports2.ValidatorOutstandingRewards = exports2.ValidatorAccumulatedCommission = exports2.ValidatorCurrentRewards = exports2.ValidatorHistoricalRewards = exports2.Params = exports2.protobufPackage = void 0;
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseParams() {
      return {
        communityTax: "",
        baseProposerReward: "",
        bonusProposerReward: "",
        withdrawAddrEnabled: false
      };
    }
    exports2.Params = {
      typeUrl: "/cosmos.distribution.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.communityTax !== "") {
          writer.uint32(10).string(message.communityTax);
        }
        if (message.baseProposerReward !== "") {
          writer.uint32(18).string(message.baseProposerReward);
        }
        if (message.bonusProposerReward !== "") {
          writer.uint32(26).string(message.bonusProposerReward);
        }
        if (message.withdrawAddrEnabled === true) {
          writer.uint32(32).bool(message.withdrawAddrEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityTax = reader.string();
              break;
            case 2:
              message.baseProposerReward = reader.string();
              break;
            case 3:
              message.bonusProposerReward = reader.string();
              break;
            case 4:
              message.withdrawAddrEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.communityTax))
          obj.communityTax = String(object.communityTax);
        if ((0, helpers_1.isSet)(object.baseProposerReward))
          obj.baseProposerReward = String(object.baseProposerReward);
        if ((0, helpers_1.isSet)(object.bonusProposerReward))
          obj.bonusProposerReward = String(object.bonusProposerReward);
        if ((0, helpers_1.isSet)(object.withdrawAddrEnabled))
          obj.withdrawAddrEnabled = Boolean(object.withdrawAddrEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.communityTax !== void 0 && (obj.communityTax = message.communityTax);
        message.baseProposerReward !== void 0 && (obj.baseProposerReward = message.baseProposerReward);
        message.bonusProposerReward !== void 0 && (obj.bonusProposerReward = message.bonusProposerReward);
        message.withdrawAddrEnabled !== void 0 && (obj.withdrawAddrEnabled = message.withdrawAddrEnabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.communityTax = object.communityTax ?? "";
        message.baseProposerReward = object.baseProposerReward ?? "";
        message.bonusProposerReward = object.bonusProposerReward ?? "";
        message.withdrawAddrEnabled = object.withdrawAddrEnabled ?? false;
        return message;
      }
    };
    function createBaseValidatorHistoricalRewards() {
      return {
        cumulativeRewardRatio: [],
        referenceCount: 0
      };
    }
    exports2.ValidatorHistoricalRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.cumulativeRewardRatio) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.referenceCount !== 0) {
          writer.uint32(16).uint32(message.referenceCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorHistoricalRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cumulativeRewardRatio.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.referenceCount = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorHistoricalRewards();
        if (Array.isArray(object == null ? void 0 : object.cumulativeRewardRatio))
          obj.cumulativeRewardRatio = object.cumulativeRewardRatio.map((e) => coin_1.DecCoin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.referenceCount))
          obj.referenceCount = Number(object.referenceCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.cumulativeRewardRatio) {
          obj.cumulativeRewardRatio = message.cumulativeRewardRatio.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.cumulativeRewardRatio = [];
        }
        message.referenceCount !== void 0 && (obj.referenceCount = Math.round(message.referenceCount));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorHistoricalRewards();
        message.cumulativeRewardRatio = ((_a = object.cumulativeRewardRatio) == null ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        message.referenceCount = object.referenceCount ?? 0;
        return message;
      }
    };
    function createBaseValidatorCurrentRewards() {
      return {
        rewards: [],
        period: BigInt(0)
      };
    }
    exports2.ValidatorCurrentRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== BigInt(0)) {
          writer.uint32(16).uint64(message.period);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorCurrentRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.period = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorCurrentRewards();
        if (Array.isArray(object == null ? void 0 : object.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.period))
          obj.period = BigInt(object.period.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        message.period !== void 0 && (obj.period = (message.period || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorCurrentRewards();
        message.rewards = ((_a = object.rewards) == null ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        if (object.period !== void 0 && object.period !== null) {
          message.period = BigInt(object.period.toString());
        }
        return message;
      }
    };
    function createBaseValidatorAccumulatedCommission() {
      return {
        commission: []
      };
    }
    exports2.ValidatorAccumulatedCommission = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.commission) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorAccumulatedCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorAccumulatedCommission();
        if (Array.isArray(object == null ? void 0 : object.commission))
          obj.commission = object.commission.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.commission) {
          obj.commission = message.commission.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.commission = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorAccumulatedCommission();
        message.commission = ((_a = object.commission) == null ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseValidatorOutstandingRewards() {
      return {
        rewards: []
      };
    }
    exports2.ValidatorOutstandingRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorOutstandingRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorOutstandingRewards();
        if (Array.isArray(object == null ? void 0 : object.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorOutstandingRewards();
        message.rewards = ((_a = object.rewards) == null ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseValidatorSlashEvent() {
      return {
        validatorPeriod: BigInt(0),
        fraction: ""
      };
    }
    exports2.ValidatorSlashEvent = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorPeriod !== BigInt(0)) {
          writer.uint32(8).uint64(message.validatorPeriod);
        }
        if (message.fraction !== "") {
          writer.uint32(18).string(message.fraction);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorPeriod = reader.uint64();
              break;
            case 2:
              message.fraction = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSlashEvent();
        if ((0, helpers_1.isSet)(object.validatorPeriod))
          obj.validatorPeriod = BigInt(object.validatorPeriod.toString());
        if ((0, helpers_1.isSet)(object.fraction))
          obj.fraction = String(object.fraction);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorPeriod !== void 0 && (obj.validatorPeriod = (message.validatorPeriod || BigInt(0)).toString());
        message.fraction !== void 0 && (obj.fraction = message.fraction);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSlashEvent();
        if (object.validatorPeriod !== void 0 && object.validatorPeriod !== null) {
          message.validatorPeriod = BigInt(object.validatorPeriod.toString());
        }
        message.fraction = object.fraction ?? "";
        return message;
      }
    };
    function createBaseValidatorSlashEvents() {
      return {
        validatorSlashEvents: []
      };
    }
    exports2.ValidatorSlashEvents = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvents",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validatorSlashEvents) {
          exports2.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvents();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorSlashEvents.push(exports2.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSlashEvents();
        if (Array.isArray(object == null ? void 0 : object.validatorSlashEvents))
          obj.validatorSlashEvents = object.validatorSlashEvents.map((e) => exports2.ValidatorSlashEvent.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validatorSlashEvents) {
          obj.validatorSlashEvents = message.validatorSlashEvents.map((e) => e ? exports2.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.validatorSlashEvents = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorSlashEvents();
        message.validatorSlashEvents = ((_a = object.validatorSlashEvents) == null ? void 0 : _a.map((e) => exports2.ValidatorSlashEvent.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseFeePool() {
      return {
        communityPool: []
      };
    }
    exports2.FeePool = {
      typeUrl: "/cosmos.distribution.v1beta1.FeePool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.communityPool) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFeePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityPool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFeePool();
        if (Array.isArray(object == null ? void 0 : object.communityPool))
          obj.communityPool = object.communityPool.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.communityPool) {
          obj.communityPool = message.communityPool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.communityPool = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseFeePool();
        message.communityPool = ((_a = object.communityPool) == null ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommunityPoolSpendProposal() {
      return {
        title: "",
        description: "",
        recipient: "",
        amount: []
      };
    }
    exports2.CommunityPoolSpendProposal = {
      typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommunityPoolSpendProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseCommunityPoolSpendProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDelegatorStartingInfo() {
      return {
        previousPeriod: BigInt(0),
        stake: "",
        height: BigInt(0)
      };
    }
    exports2.DelegatorStartingInfo = {
      typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.previousPeriod !== BigInt(0)) {
          writer.uint32(8).uint64(message.previousPeriod);
        }
        if (message.stake !== "") {
          writer.uint32(18).string(message.stake);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).uint64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegatorStartingInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.previousPeriod = reader.uint64();
              break;
            case 2:
              message.stake = reader.string();
              break;
            case 3:
              message.height = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegatorStartingInfo();
        if ((0, helpers_1.isSet)(object.previousPeriod))
          obj.previousPeriod = BigInt(object.previousPeriod.toString());
        if ((0, helpers_1.isSet)(object.stake))
          obj.stake = String(object.stake);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.previousPeriod !== void 0 && (obj.previousPeriod = (message.previousPeriod || BigInt(0)).toString());
        message.stake !== void 0 && (obj.stake = message.stake);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegatorStartingInfo();
        if (object.previousPeriod !== void 0 && object.previousPeriod !== null) {
          message.previousPeriod = BigInt(object.previousPeriod.toString());
        }
        message.stake = object.stake ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        return message;
      }
    };
    function createBaseDelegationDelegatorReward() {
      return {
        validatorAddress: "",
        reward: []
      };
    }
    exports2.DelegationDelegatorReward = {
      typeUrl: "/cosmos.distribution.v1beta1.DelegationDelegatorReward",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        for (const v of message.reward) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationDelegatorReward();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.reward.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegationDelegatorReward();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object == null ? void 0 : object.reward))
          obj.reward = object.reward.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.reward) {
          obj.reward = message.reward.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.reward = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDelegationDelegatorReward();
        message.validatorAddress = object.validatorAddress ?? "";
        message.reward = ((_a = object.reward) == null ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommunityPoolSpendProposalWithDeposit() {
      return {
        title: "",
        description: "",
        recipient: "",
        amount: "",
        deposit: ""
      };
    }
    exports2.CommunityPoolSpendProposalWithDeposit = {
      typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        if (message.amount !== "") {
          writer.uint32(34).string(message.amount);
        }
        if (message.deposit !== "") {
          writer.uint32(42).string(message.deposit);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            case 5:
              message.deposit = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommunityPoolSpendProposalWithDeposit();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = String(object.amount);
        if ((0, helpers_1.isSet)(object.deposit))
          obj.deposit = String(object.deposit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        message.amount !== void 0 && (obj.amount = message.amount);
        message.deposit !== void 0 && (obj.deposit = message.deposit);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount ?? "";
        message.deposit = object.deposit ?? "";
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js
var require_tx4 = __commonJS({
  "node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgCommunityPoolSpendResponse = exports2.MsgCommunityPoolSpend = exports2.MsgUpdateParamsResponse = exports2.MsgUpdateParams = exports2.MsgFundCommunityPoolResponse = exports2.MsgFundCommunityPool = exports2.MsgWithdrawValidatorCommissionResponse = exports2.MsgWithdrawValidatorCommission = exports2.MsgWithdrawDelegatorRewardResponse = exports2.MsgWithdrawDelegatorReward = exports2.MsgSetWithdrawAddressResponse = exports2.MsgSetWithdrawAddress = exports2.protobufPackage = void 0;
    var coin_1 = require_coin();
    var distribution_1 = require_distribution();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseMsgSetWithdrawAddress() {
      return {
        delegatorAddress: "",
        withdrawAddress: ""
      };
    }
    exports2.MsgSetWithdrawAddress = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.withdrawAddress !== "") {
          writer.uint32(18).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddress();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSetWithdrawAddress();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.withdrawAddress))
          obj.withdrawAddress = String(object.withdrawAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSetWithdrawAddress();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
      }
    };
    function createBaseMsgSetWithdrawAddressResponse() {
      return {};
    }
    exports2.MsgSetWithdrawAddressResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSetWithdrawAddressResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSetWithdrawAddressResponse();
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorReward() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports2.MsgWithdrawDelegatorReward = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorReward();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawDelegatorReward();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawDelegatorReward();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorRewardResponse() {
      return {
        amount: []
      };
    }
    exports2.MsgWithdrawDelegatorRewardResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawDelegatorRewardResponse();
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommission() {
      return {
        validatorAddress: ""
      };
    }
    exports2.MsgWithdrawValidatorCommission = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawValidatorCommission();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawValidatorCommission();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommissionResponse() {
      return {
        amount: []
      };
    }
    exports2.MsgWithdrawValidatorCommissionResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawValidatorCommissionResponse();
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgFundCommunityPool() {
      return {
        amount: [],
        depositor: ""
      };
    }
    exports2.MsgFundCommunityPool = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgFundCommunityPool();
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgFundCommunityPool();
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.depositor = object.depositor ?? "";
        return message;
      }
    };
    function createBaseMsgFundCommunityPoolResponse() {
      return {};
    }
    exports2.MsgFundCommunityPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgFundCommunityPoolResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgFundCommunityPoolResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: distribution_1.Params.fromPartial({})
      };
    }
    exports2.MsgUpdateParams = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          distribution_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = distribution_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = distribution_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = distribution_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports2.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgCommunityPoolSpend() {
      return {
        authority: "",
        recipient: "",
        amount: []
      };
    }
    exports2.MsgCommunityPoolSpend = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.recipient !== "") {
          writer.uint32(18).string(message.recipient);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCommunityPoolSpend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.recipient = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCommunityPoolSpend();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgCommunityPoolSpend();
        message.authority = object.authority ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgCommunityPoolSpendResponse() {
      return {};
    }
    exports2.MsgCommunityPoolSpendResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCommunityPoolSpendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCommunityPoolSpendResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCommunityPoolSpendResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this);
        this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this);
        this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this);
        this.FundCommunityPool = this.FundCommunityPool.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this);
      }
      SetWithdrawAddress(request) {
        const data = exports2.MsgSetWithdrawAddress.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", data);
        return promise.then((data2) => exports2.MsgSetWithdrawAddressResponse.decode(new binary_1.BinaryReader(data2)));
      }
      WithdrawDelegatorReward(request) {
        const data = exports2.MsgWithdrawDelegatorReward.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", data);
        return promise.then((data2) => exports2.MsgWithdrawDelegatorRewardResponse.decode(new binary_1.BinaryReader(data2)));
      }
      WithdrawValidatorCommission(request) {
        const data = exports2.MsgWithdrawValidatorCommission.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", data);
        return promise.then((data2) => exports2.MsgWithdrawValidatorCommissionResponse.decode(new binary_1.BinaryReader(data2)));
      }
      FundCommunityPool(request) {
        const data = exports2.MsgFundCommunityPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", data);
        return promise.then((data2) => exports2.MsgFundCommunityPoolResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateParams(request) {
        const data = exports2.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", data);
        return promise.then((data2) => exports2.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      CommunityPoolSpend(request) {
        const data = exports2.MsgCommunityPoolSpend.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", data);
        return promise.then((data2) => exports2.MsgCommunityPoolSpendResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/distribution/messages.js
var require_messages3 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/distribution/messages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgWithdrawDelegatorRewardEncodeObject = exports2.distributionTypes = void 0;
    var tx_1 = require_tx4();
    exports2.distributionTypes = [
      ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", tx_1.MsgFundCommunityPool],
      ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_1.MsgSetWithdrawAddress],
      ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_1.MsgWithdrawDelegatorReward],
      ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", tx_1.MsgWithdrawValidatorCommission]
    ];
    function isMsgWithdrawDelegatorRewardEncodeObject(object) {
      return object.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
    }
    exports2.isMsgWithdrawDelegatorRewardEncodeObject = isMsgWithdrawDelegatorRewardEncodeObject;
  }
});

// node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js
var require_query4 = __commonJS({
  "node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryCommunityPoolResponse = exports2.QueryCommunityPoolRequest = exports2.QueryDelegatorWithdrawAddressResponse = exports2.QueryDelegatorWithdrawAddressRequest = exports2.QueryDelegatorValidatorsResponse = exports2.QueryDelegatorValidatorsRequest = exports2.QueryDelegationTotalRewardsResponse = exports2.QueryDelegationTotalRewardsRequest = exports2.QueryDelegationRewardsResponse = exports2.QueryDelegationRewardsRequest = exports2.QueryValidatorSlashesResponse = exports2.QueryValidatorSlashesRequest = exports2.QueryValidatorCommissionResponse = exports2.QueryValidatorCommissionRequest = exports2.QueryValidatorOutstandingRewardsResponse = exports2.QueryValidatorOutstandingRewardsRequest = exports2.QueryValidatorDistributionInfoResponse = exports2.QueryValidatorDistributionInfoRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var distribution_1 = require_distribution();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: distribution_1.Params.fromPartial({})
      };
    }
    exports2.QueryParamsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          distribution_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = distribution_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = distribution_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = distribution_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDistributionInfoRequest() {
      return {
        validatorAddress: ""
      };
    }
    exports2.QueryValidatorDistributionInfoRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDistributionInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDistributionInfoRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDistributionInfoRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorDistributionInfoResponse() {
      return {
        operatorAddress: "",
        selfBondRewards: [],
        commission: []
      };
    }
    exports2.QueryValidatorDistributionInfoResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        for (const v of message.selfBondRewards) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.commission) {
          coin_1.DecCoin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDistributionInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.selfBondRewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDistributionInfoResponse();
        if ((0, helpers_1.isSet)(object.operatorAddress))
          obj.operatorAddress = String(object.operatorAddress);
        if (Array.isArray(object == null ? void 0 : object.selfBondRewards))
          obj.selfBondRewards = object.selfBondRewards.map((e) => coin_1.DecCoin.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.commission))
          obj.commission = object.commission.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        if (message.selfBondRewards) {
          obj.selfBondRewards = message.selfBondRewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.selfBondRewards = [];
        }
        if (message.commission) {
          obj.commission = message.commission.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.commission = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryValidatorDistributionInfoResponse();
        message.operatorAddress = object.operatorAddress ?? "";
        message.selfBondRewards = ((_a = object.selfBondRewards) == null ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        message.commission = ((_b = object.commission) == null ? void 0 : _b.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseQueryValidatorOutstandingRewardsRequest() {
      return {
        validatorAddress: ""
      };
    }
    exports2.QueryValidatorOutstandingRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorOutstandingRewardsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorOutstandingRewardsResponse() {
      return {
        rewards: distribution_1.ValidatorOutstandingRewards.fromPartial({})
      };
    }
    exports2.QueryValidatorOutstandingRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rewards !== void 0) {
          distribution_1.ValidatorOutstandingRewards.encode(message.rewards, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards = distribution_1.ValidatorOutstandingRewards.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorOutstandingRewardsResponse();
        if ((0, helpers_1.isSet)(object.rewards))
          obj.rewards = distribution_1.ValidatorOutstandingRewards.fromJSON(object.rewards);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rewards !== void 0 && (obj.rewards = message.rewards ? distribution_1.ValidatorOutstandingRewards.toJSON(message.rewards) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        if (object.rewards !== void 0 && object.rewards !== null) {
          message.rewards = distribution_1.ValidatorOutstandingRewards.fromPartial(object.rewards);
        }
        return message;
      }
    };
    function createBaseQueryValidatorCommissionRequest() {
      return {
        validatorAddress: ""
      };
    }
    exports2.QueryValidatorCommissionRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorCommissionRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorCommissionRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorCommissionResponse() {
      return {
        commission: distribution_1.ValidatorAccumulatedCommission.fromPartial({})
      };
    }
    exports2.QueryValidatorCommissionResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commission !== void 0) {
          distribution_1.ValidatorAccumulatedCommission.encode(message.commission, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission = distribution_1.ValidatorAccumulatedCommission.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorCommissionResponse();
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = distribution_1.ValidatorAccumulatedCommission.fromJSON(object.commission);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commission !== void 0 && (obj.commission = message.commission ? distribution_1.ValidatorAccumulatedCommission.toJSON(message.commission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorCommissionResponse();
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = distribution_1.ValidatorAccumulatedCommission.fromPartial(object.commission);
        }
        return message;
      }
    };
    function createBaseQueryValidatorSlashesRequest() {
      return {
        validatorAddress: "",
        startingHeight: BigInt(0),
        endingHeight: BigInt(0),
        pagination: void 0
      };
    }
    exports2.QueryValidatorSlashesRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        if (message.startingHeight !== BigInt(0)) {
          writer.uint32(16).uint64(message.startingHeight);
        }
        if (message.endingHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.endingHeight);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.startingHeight = reader.uint64();
              break;
            case 3:
              message.endingHeight = reader.uint64();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorSlashesRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.startingHeight))
          obj.startingHeight = BigInt(object.startingHeight.toString());
        if ((0, helpers_1.isSet)(object.endingHeight))
          obj.endingHeight = BigInt(object.endingHeight.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.startingHeight !== void 0 && (obj.startingHeight = (message.startingHeight || BigInt(0)).toString());
        message.endingHeight !== void 0 && (obj.endingHeight = (message.endingHeight || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorSlashesRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.startingHeight !== void 0 && object.startingHeight !== null) {
          message.startingHeight = BigInt(object.startingHeight.toString());
        }
        if (object.endingHeight !== void 0 && object.endingHeight !== null) {
          message.endingHeight = BigInt(object.endingHeight.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorSlashesResponse() {
      return {
        slashes: [],
        pagination: void 0
      };
    }
    exports2.QueryValidatorSlashesResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.slashes) {
          distribution_1.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.slashes.push(distribution_1.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorSlashesResponse();
        if (Array.isArray(object == null ? void 0 : object.slashes))
          obj.slashes = object.slashes.map((e) => distribution_1.ValidatorSlashEvent.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.slashes) {
          obj.slashes = message.slashes.map((e) => e ? distribution_1.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.slashes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorSlashesResponse();
        message.slashes = ((_a = object.slashes) == null ? void 0 : _a.map((e) => distribution_1.ValidatorSlashEvent.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegationRewardsRequest() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports2.QueryDelegationRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRewardsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationRewardsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationRewardsResponse() {
      return {
        rewards: []
      };
    }
    exports2.QueryDelegationRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRewardsResponse();
        if (Array.isArray(object == null ? void 0 : object.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegationRewardsResponse();
        message.rewards = ((_a = object.rewards) == null ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseQueryDelegationTotalRewardsRequest() {
      return {
        delegatorAddress: ""
      };
    }
    exports2.QueryDelegationTotalRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationTotalRewardsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationTotalRewardsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationTotalRewardsResponse() {
      return {
        rewards: [],
        total: []
      };
    }
    exports2.QueryDelegationTotalRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.rewards) {
          distribution_1.DelegationDelegatorReward.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.total) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(distribution_1.DelegationDelegatorReward.decode(reader, reader.uint32()));
              break;
            case 2:
              message.total.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationTotalRewardsResponse();
        if (Array.isArray(object == null ? void 0 : object.rewards))
          obj.rewards = object.rewards.map((e) => distribution_1.DelegationDelegatorReward.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.total))
          obj.total = object.total.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? distribution_1.DelegationDelegatorReward.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseQueryDelegationTotalRewardsResponse();
        message.rewards = ((_a = object.rewards) == null ? void 0 : _a.map((e) => distribution_1.DelegationDelegatorReward.fromPartial(e))) || [];
        message.total = ((_b = object.total) == null ? void 0 : _b.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsRequest() {
      return {
        delegatorAddress: ""
      };
    }
    exports2.QueryDelegatorValidatorsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsResponse() {
      return {
        validators: []
      };
    }
    exports2.QueryDelegatorValidatorsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsResponse();
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e);
        } else {
          obj.validators = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = ((_a = object.validators) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseQueryDelegatorWithdrawAddressRequest() {
      return {
        delegatorAddress: ""
      };
    }
    exports2.QueryDelegatorWithdrawAddressRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorWithdrawAddressRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorWithdrawAddressResponse() {
      return {
        withdrawAddress: ""
      };
    }
    exports2.QueryDelegatorWithdrawAddressResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.withdrawAddress !== "") {
          writer.uint32(10).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorWithdrawAddressResponse();
        if ((0, helpers_1.isSet)(object.withdrawAddress))
          obj.withdrawAddress = String(object.withdrawAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
      }
    };
    function createBaseQueryCommunityPoolRequest() {
      return {};
    }
    exports2.QueryCommunityPoolRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryCommunityPoolRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryCommunityPoolRequest();
        return message;
      }
    };
    function createBaseQueryCommunityPoolResponse() {
      return {
        pool: []
      };
    }
    exports2.QueryCommunityPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pool) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryCommunityPoolResponse();
        if (Array.isArray(object == null ? void 0 : object.pool))
          obj.pool = object.pool.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pool) {
          obj.pool = message.pool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.pool = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryCommunityPoolResponse();
        message.pool = ((_a = object.pool) == null ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.ValidatorDistributionInfo = this.ValidatorDistributionInfo.bind(this);
        this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this);
        this.ValidatorCommission = this.ValidatorCommission.bind(this);
        this.ValidatorSlashes = this.ValidatorSlashes.bind(this);
        this.DelegationRewards = this.DelegationRewards.bind(this);
        this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this);
        this.CommunityPool = this.CommunityPool.bind(this);
      }
      Params(request = {}) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ValidatorDistributionInfo(request) {
        const data = exports2.QueryValidatorDistributionInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorDistributionInfo", data);
        return promise.then((data2) => exports2.QueryValidatorDistributionInfoResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ValidatorOutstandingRewards(request) {
        const data = exports2.QueryValidatorOutstandingRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", data);
        return promise.then((data2) => exports2.QueryValidatorOutstandingRewardsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ValidatorCommission(request) {
        const data = exports2.QueryValidatorCommissionRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", data);
        return promise.then((data2) => exports2.QueryValidatorCommissionResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ValidatorSlashes(request) {
        const data = exports2.QueryValidatorSlashesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", data);
        return promise.then((data2) => exports2.QueryValidatorSlashesResponse.decode(new binary_1.BinaryReader(data2)));
      }
      DelegationRewards(request) {
        const data = exports2.QueryDelegationRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", data);
        return promise.then((data2) => exports2.QueryDelegationRewardsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      DelegationTotalRewards(request) {
        const data = exports2.QueryDelegationTotalRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", data);
        return promise.then((data2) => exports2.QueryDelegationTotalRewardsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      DelegatorValidators(request) {
        const data = exports2.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", data);
        return promise.then((data2) => exports2.QueryDelegatorValidatorsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      DelegatorWithdrawAddress(request) {
        const data = exports2.QueryDelegatorWithdrawAddressRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", data);
        return promise.then((data2) => exports2.QueryDelegatorWithdrawAddressResponse.decode(new binary_1.BinaryReader(data2)));
      }
      CommunityPool(request = {}) {
        const data = exports2.QueryCommunityPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", data);
        return promise.then((data2) => exports2.QueryCommunityPoolResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/distribution/queries.js
var require_queries4 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/distribution/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupDistributionExtension = void 0;
    var query_1 = require_query4();
    var queryclient_1 = require_queryclient2();
    function setupDistributionExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        distribution: {
          communityPool: async () => {
            const response = await queryService.CommunityPool({});
            return response;
          },
          delegationRewards: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegationRewards({
              delegatorAddress,
              validatorAddress
            });
            return response;
          },
          delegationTotalRewards: async (delegatorAddress) => {
            const response = await queryService.DelegationTotalRewards({
              delegatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddress
            });
            return response;
          },
          delegatorWithdrawAddress: async (delegatorAddress) => {
            const response = await queryService.DelegatorWithdrawAddress({
              delegatorAddress
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          validatorCommission: async (validatorAddress) => {
            const response = await queryService.ValidatorCommission({
              validatorAddress
            });
            return response;
          },
          validatorOutstandingRewards: async (validatorAddress) => {
            const response = await queryService.ValidatorOutstandingRewards({
              validatorAddress
            });
            return response;
          },
          validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey) => {
            const response = await queryService.ValidatorSlashes({
              validatorAddress,
              startingHeight: BigInt(startingHeight),
              endingHeight: BigInt(endingHeight),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports2.setupDistributionExtension = setupDistributionExtension;
  }
});

// node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js
var require_aminomessages5 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createEvidenceAminoConverters = exports2.isAminoMsgSubmitEvidence = void 0;
    function isAminoMsgSubmitEvidence(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitEvidence";
    }
    exports2.isAminoMsgSubmitEvidence = isAminoMsgSubmitEvidence;
    function createEvidenceAminoConverters() {
      throw new Error("Not implemented");
    }
    exports2.createEvidenceAminoConverters = createEvidenceAminoConverters;
  }
});

// node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js
var require_aminomessages6 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFeegrantAminoConverters = void 0;
    function createFeegrantAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.feegrant.v1beta1.MsgGrantAllowance": IMPLEMENT_ME,
        // "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": IMPLEMENT_ME,
      };
    }
    exports2.createFeegrantAminoConverters = createFeegrantAminoConverters;
  }
});

// node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js
var require_tx5 = __commonJS({
  "node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgRevokeAllowanceResponse = exports2.MsgRevokeAllowance = exports2.MsgGrantAllowanceResponse = exports2.MsgGrantAllowance = exports2.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseMsgGrantAllowance() {
      return {
        granter: "",
        grantee: "",
        allowance: void 0
      };
    }
    exports2.MsgGrantAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgGrantAllowance();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgGrantAllowance();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        return message;
      }
    };
    function createBaseMsgGrantAllowanceResponse() {
      return {};
    }
    exports2.MsgGrantAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowanceResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgGrantAllowanceResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgGrantAllowanceResponse();
        return message;
      }
    };
    function createBaseMsgRevokeAllowance() {
      return {
        granter: "",
        grantee: ""
      };
    }
    exports2.MsgRevokeAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRevokeAllowance();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRevokeAllowance();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        return message;
      }
    };
    function createBaseMsgRevokeAllowanceResponse() {
      return {};
    }
    exports2.MsgRevokeAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowanceResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgRevokeAllowanceResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgRevokeAllowanceResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.GrantAllowance = this.GrantAllowance.bind(this);
        this.RevokeAllowance = this.RevokeAllowance.bind(this);
      }
      GrantAllowance(request) {
        const data = exports2.MsgGrantAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", data);
        return promise.then((data2) => exports2.MsgGrantAllowanceResponse.decode(new binary_1.BinaryReader(data2)));
      }
      RevokeAllowance(request) {
        const data = exports2.MsgRevokeAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", data);
        return promise.then((data2) => exports2.MsgRevokeAllowanceResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js
var require_messages4 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.feegrantTypes = void 0;
    var tx_1 = require_tx5();
    exports2.feegrantTypes = [
      ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", tx_1.MsgGrantAllowance],
      ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", tx_1.MsgRevokeAllowance]
    ];
  }
});

// node_modules/cosmjs-types/google/protobuf/duration.js
var require_duration = __commonJS({
  "node_modules/cosmjs-types/google/protobuf/duration.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Duration = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "google.protobuf";
    function createBaseDuration() {
      return {
        seconds: BigInt(0),
        nanos: 0
      };
    }
    exports2.Duration = {
      typeUrl: "/google.protobuf.Duration",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.seconds !== BigInt(0)) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuration();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDuration();
        if ((0, helpers_1.isSet)(object.seconds))
          obj.seconds = BigInt(object.seconds.toString());
        if ((0, helpers_1.isSet)(object.nanos))
          obj.nanos = Number(object.nanos);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || BigInt(0)).toString());
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDuration();
        if (object.seconds !== void 0 && object.seconds !== null) {
          message.seconds = BigInt(object.seconds.toString());
        }
        message.nanos = object.nanos ?? 0;
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/feegrant/v1beta1/feegrant.js
var require_feegrant = __commonJS({
  "node_modules/cosmjs-types/cosmos/feegrant/v1beta1/feegrant.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Grant = exports2.AllowedMsgAllowance = exports2.PeriodicAllowance = exports2.BasicAllowance = exports2.protobufPackage = void 0;
    var coin_1 = require_coin();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseBasicAllowance() {
      return {
        spendLimit: [],
        expiration: void 0
      };
    }
    exports2.BasicAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.BasicAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.spendLimit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBasicAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.spendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBasicAllowance();
        if (Array.isArray(object == null ? void 0 : object.spendLimit))
          obj.spendLimit = object.spendLimit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.spendLimit) {
          obj.spendLimit = message.spendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.spendLimit = [];
        }
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseBasicAllowance();
        message.spendLimit = ((_a = object.spendLimit) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBasePeriodicAllowance() {
      return {
        basic: exports2.BasicAllowance.fromPartial({}),
        period: duration_1.Duration.fromPartial({}),
        periodSpendLimit: [],
        periodCanSpend: [],
        periodReset: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.PeriodicAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.PeriodicAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.basic !== void 0) {
          exports2.BasicAllowance.encode(message.basic, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== void 0) {
          duration_1.Duration.encode(message.period, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.periodSpendLimit) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.periodCanSpend) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.periodReset !== void 0) {
          timestamp_1.Timestamp.encode(message.periodReset, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriodicAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.basic = exports2.BasicAllowance.decode(reader, reader.uint32());
              break;
            case 2:
              message.period = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.periodSpendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.periodCanSpend.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.periodReset = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriodicAllowance();
        if ((0, helpers_1.isSet)(object.basic))
          obj.basic = exports2.BasicAllowance.fromJSON(object.basic);
        if ((0, helpers_1.isSet)(object.period))
          obj.period = duration_1.Duration.fromJSON(object.period);
        if (Array.isArray(object == null ? void 0 : object.periodSpendLimit))
          obj.periodSpendLimit = object.periodSpendLimit.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.periodCanSpend))
          obj.periodCanSpend = object.periodCanSpend.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.periodReset))
          obj.periodReset = (0, helpers_1.fromJsonTimestamp)(object.periodReset);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.basic !== void 0 && (obj.basic = message.basic ? exports2.BasicAllowance.toJSON(message.basic) : void 0);
        message.period !== void 0 && (obj.period = message.period ? duration_1.Duration.toJSON(message.period) : void 0);
        if (message.periodSpendLimit) {
          obj.periodSpendLimit = message.periodSpendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.periodSpendLimit = [];
        }
        if (message.periodCanSpend) {
          obj.periodCanSpend = message.periodCanSpend.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.periodCanSpend = [];
        }
        message.periodReset !== void 0 && (obj.periodReset = (0, helpers_1.fromTimestamp)(message.periodReset).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBasePeriodicAllowance();
        if (object.basic !== void 0 && object.basic !== null) {
          message.basic = exports2.BasicAllowance.fromPartial(object.basic);
        }
        if (object.period !== void 0 && object.period !== null) {
          message.period = duration_1.Duration.fromPartial(object.period);
        }
        message.periodSpendLimit = ((_a = object.periodSpendLimit) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.periodCanSpend = ((_b = object.periodCanSpend) == null ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.periodReset !== void 0 && object.periodReset !== null) {
          message.periodReset = timestamp_1.Timestamp.fromPartial(object.periodReset);
        }
        return message;
      }
    };
    function createBaseAllowedMsgAllowance() {
      return {
        allowance: void 0,
        allowedMessages: []
      };
    }
    exports2.AllowedMsgAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.AllowedMsgAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.allowedMessages) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAllowedMsgAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.allowedMessages.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAllowedMsgAllowance();
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        if (Array.isArray(object == null ? void 0 : object.allowedMessages))
          obj.allowedMessages = object.allowedMessages.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        if (message.allowedMessages) {
          obj.allowedMessages = message.allowedMessages.map((e) => e);
        } else {
          obj.allowedMessages = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseAllowedMsgAllowance();
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        message.allowedMessages = ((_a = object.allowedMessages) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseGrant() {
      return {
        granter: "",
        grantee: "",
        allowance: void 0
      };
    }
    exports2.Grant = {
      typeUrl: "/cosmos.feegrant.v1beta1.Grant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrant();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrant();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js
var require_query5 = __commonJS({
  "node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryAllowancesByGranterResponse = exports2.QueryAllowancesByGranterRequest = exports2.QueryAllowancesResponse = exports2.QueryAllowancesRequest = exports2.QueryAllowanceResponse = exports2.QueryAllowanceRequest = exports2.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var feegrant_1 = require_feegrant();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseQueryAllowanceRequest() {
      return {
        granter: "",
        grantee: ""
      };
    }
    exports2.QueryAllowanceRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowanceRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowanceRequest();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        return message;
      }
    };
    function createBaseQueryAllowanceResponse() {
      return {
        allowance: void 0
      };
    }
    exports2.QueryAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.allowance !== void 0) {
          feegrant_1.Grant.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowance = feegrant_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowanceResponse();
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = feegrant_1.Grant.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.allowance !== void 0 && (obj.allowance = message.allowance ? feegrant_1.Grant.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowanceResponse();
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = feegrant_1.Grant.fromPartial(object.allowance);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesRequest() {
      return {
        grantee: "",
        pagination: void 0
      };
    }
    exports2.QueryAllowancesRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesRequest();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesRequest();
        message.grantee = object.grantee ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesResponse() {
      return {
        allowances: [],
        pagination: void 0
      };
    }
    exports2.QueryAllowancesResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowances) {
          feegrant_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesResponse();
        if (Array.isArray(object == null ? void 0 : object.allowances))
          obj.allowances = object.allowances.map((e) => feegrant_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowances) {
          obj.allowances = message.allowances.map((e) => e ? feegrant_1.Grant.toJSON(e) : void 0);
        } else {
          obj.allowances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllowancesResponse();
        message.allowances = ((_a = object.allowances) == null ? void 0 : _a.map((e) => feegrant_1.Grant.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesByGranterRequest() {
      return {
        granter: "",
        pagination: void 0
      };
    }
    exports2.QueryAllowancesByGranterRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesByGranterRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesByGranterRequest();
        message.granter = object.granter ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesByGranterResponse() {
      return {
        allowances: [],
        pagination: void 0
      };
    }
    exports2.QueryAllowancesByGranterResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowances) {
          feegrant_1.Grant.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesByGranterResponse();
        if (Array.isArray(object == null ? void 0 : object.allowances))
          obj.allowances = object.allowances.map((e) => feegrant_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowances) {
          obj.allowances = message.allowances.map((e) => e ? feegrant_1.Grant.toJSON(e) : void 0);
        } else {
          obj.allowances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryAllowancesByGranterResponse();
        message.allowances = ((_a = object.allowances) == null ? void 0 : _a.map((e) => feegrant_1.Grant.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Allowance = this.Allowance.bind(this);
        this.Allowances = this.Allowances.bind(this);
        this.AllowancesByGranter = this.AllowancesByGranter.bind(this);
      }
      Allowance(request) {
        const data = exports2.QueryAllowanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", data);
        return promise.then((data2) => exports2.QueryAllowanceResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Allowances(request) {
        const data = exports2.QueryAllowancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", data);
        return promise.then((data2) => exports2.QueryAllowancesResponse.decode(new binary_1.BinaryReader(data2)));
      }
      AllowancesByGranter(request) {
        const data = exports2.QueryAllowancesByGranterRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", data);
        return promise.then((data2) => exports2.QueryAllowancesByGranterResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js
var require_queries5 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupFeegrantExtension = void 0;
    var query_1 = require_query5();
    var queryclient_1 = require_queryclient2();
    function setupFeegrantExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        feegrant: {
          allowance: async (granter, grantee) => {
            const response = await queryService.Allowance({
              granter,
              grantee
            });
            return response;
          },
          allowances: async (grantee, paginationKey) => {
            const response = await queryService.Allowances({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports2.setupFeegrantExtension = setupFeegrantExtension;
  }
});

// node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js
var require_gov = __commonJS({
  "node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TallyParams = exports2.VotingParams = exports2.DepositParams = exports2.Vote = exports2.TallyResult = exports2.Proposal = exports2.Deposit = exports2.TextProposal = exports2.WeightedVoteOption = exports2.proposalStatusToJSON = exports2.proposalStatusFromJSON = exports2.ProposalStatus = exports2.voteOptionToJSON = exports2.voteOptionFromJSON = exports2.VoteOption = exports2.protobufPackage = void 0;
    var coin_1 = require_coin();
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.gov.v1beta1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports2.VoteOption = VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports2.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports2.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports2.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.proposalStatusToJSON = proposalStatusToJSON;
    function createBaseWeightedVoteOption() {
      return {
        option: 0,
        weight: ""
      };
    }
    exports2.WeightedVoteOption = {
      typeUrl: "/cosmos.gov.v1beta1.WeightedVoteOption",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseWeightedVoteOption();
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseWeightedVoteOption();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
      }
    };
    function createBaseTextProposal() {
      return {
        title: "",
        description: ""
      };
    }
    exports2.TextProposal = {
      typeUrl: "/cosmos.gov.v1beta1.TextProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTextProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTextProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTextProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
      }
    };
    function createBaseDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports2.Deposit = {
      typeUrl: "/cosmos.gov.v1beta1.Deposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseProposal() {
      return {
        proposalId: BigInt(0),
        content: void 0,
        status: 0,
        finalTallyResult: exports2.TallyResult.fromPartial({}),
        submitTime: timestamp_1.Timestamp.fromPartial({}),
        depositEndTime: timestamp_1.Timestamp.fromPartial({}),
        totalDeposit: [],
        votingStartTime: timestamp_1.Timestamp.fromPartial({}),
        votingEndTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.Proposal = {
      typeUrl: "/cosmos.gov.v1beta1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports2.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.totalDeposit) {
          coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports2.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports2.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.depositEndTime))
          obj.depositEndTime = (0, helpers_1.fromJsonTimestamp)(object.depositEndTime);
        if (Array.isArray(object == null ? void 0 : object.totalDeposit))
          obj.totalDeposit = object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.votingStartTime))
          obj.votingStartTime = (0, helpers_1.fromJsonTimestamp)(object.votingStartTime);
        if ((0, helpers_1.isSet)(object.votingEndTime))
          obj.votingEndTime = (0, helpers_1.fromJsonTimestamp)(object.votingEndTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports2.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = (0, helpers_1.fromTimestamp)(message.depositEndTime).toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = (0, helpers_1.fromTimestamp)(message.votingStartTime).toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = (0, helpers_1.fromTimestamp)(message.votingEndTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseProposal();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports2.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.depositEndTime !== void 0 && object.depositEndTime !== null) {
          message.depositEndTime = timestamp_1.Timestamp.fromPartial(object.depositEndTime);
        }
        message.totalDeposit = ((_a = object.totalDeposit) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.votingStartTime !== void 0 && object.votingStartTime !== null) {
          message.votingStartTime = timestamp_1.Timestamp.fromPartial(object.votingStartTime);
        }
        if (object.votingEndTime !== void 0 && object.votingEndTime !== null) {
          message.votingEndTime = timestamp_1.Timestamp.fromPartial(object.votingEndTime);
        }
        return message;
      }
    };
    function createBaseTallyResult() {
      return {
        yes: "",
        abstain: "",
        no: "",
        noWithVeto: ""
      };
    }
    exports2.TallyResult = {
      typeUrl: "/cosmos.gov.v1beta1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yes !== "") {
          writer.uint32(10).string(message.yes);
        }
        if (message.abstain !== "") {
          writer.uint32(18).string(message.abstain);
        }
        if (message.no !== "") {
          writer.uint32(26).string(message.no);
        }
        if (message.noWithVeto !== "") {
          writer.uint32(34).string(message.noWithVeto);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yes = reader.string();
              break;
            case 2:
              message.abstain = reader.string();
              break;
            case 3:
              message.no = reader.string();
              break;
            case 4:
              message.noWithVeto = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yes))
          obj.yes = String(object.yes);
        if ((0, helpers_1.isSet)(object.abstain))
          obj.abstain = String(object.abstain);
        if ((0, helpers_1.isSet)(object.no))
          obj.no = String(object.no);
        if ((0, helpers_1.isSet)(object.noWithVeto))
          obj.noWithVeto = String(object.noWithVeto);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yes !== void 0 && (obj.yes = message.yes);
        message.abstain !== void 0 && (obj.abstain = message.abstain);
        message.no !== void 0 && (obj.no = message.no);
        message.noWithVeto !== void 0 && (obj.noWithVeto = message.noWithVeto);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult();
        message.yes = object.yes ?? "";
        message.abstain = object.abstain ?? "";
        message.no = object.no ?? "";
        message.noWithVeto = object.noWithVeto ?? "";
        return message;
      }
    };
    function createBaseVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        options: []
      };
    }
    exports2.Vote = {
      typeUrl: "/cosmos.gov.v1beta1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        for (const v of message.options) {
          exports2.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.options.push(exports2.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if (Array.isArray(object == null ? void 0 : object.options))
          obj.options = object.options.map((e) => exports2.WeightedVoteOption.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports2.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.options = ((_a = object.options) == null ? void 0 : _a.map((e) => exports2.WeightedVoteOption.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDepositParams() {
      return {
        minDeposit: [],
        maxDepositPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports2.DepositParams = {
      typeUrl: "/cosmos.gov.v1beta1.DepositParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDepositParams();
        if (Array.isArray(object == null ? void 0 : object.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDepositParams();
        message.minDeposit = ((_a = object.minDeposit) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        return message;
      }
    };
    function createBaseVotingParams() {
      return {
        votingPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports2.VotingParams = {
      typeUrl: "/cosmos.gov.v1beta1.VotingParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVotingParams();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVotingParams();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        return message;
      }
    };
    function createBaseTallyParams() {
      return {
        quorum: new Uint8Array(),
        threshold: new Uint8Array(),
        vetoThreshold: new Uint8Array()
      };
    }
    exports2.TallyParams = {
      typeUrl: "/cosmos.gov.v1beta1.TallyParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.quorum.length !== 0) {
          writer.uint32(10).bytes(message.quorum);
        }
        if (message.threshold.length !== 0) {
          writer.uint32(18).bytes(message.threshold);
        }
        if (message.vetoThreshold.length !== 0) {
          writer.uint32(26).bytes(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.bytes();
              break;
            case 2:
              message.threshold = reader.bytes();
              break;
            case 3:
              message.vetoThreshold = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyParams();
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = (0, helpers_1.bytesFromBase64)(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = (0, helpers_1.bytesFromBase64)(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = (0, helpers_1.bytesFromBase64)(object.vetoThreshold);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = (0, helpers_1.base64FromBytes)(message.quorum !== void 0 ? message.quorum : new Uint8Array()));
        message.threshold !== void 0 && (obj.threshold = (0, helpers_1.base64FromBytes)(message.threshold !== void 0 ? message.threshold : new Uint8Array()));
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = (0, helpers_1.base64FromBytes)(message.vetoThreshold !== void 0 ? message.vetoThreshold : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyParams();
        message.quorum = object.quorum ?? new Uint8Array();
        message.threshold = object.threshold ?? new Uint8Array();
        message.vetoThreshold = object.vetoThreshold ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js
var require_aminomessages7 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createGovAminoConverters = exports2.isAminoMsgDeposit = exports2.isAminoMsgVoteWeighted = exports2.isAminoMsgVote = exports2.isAminoMsgSubmitProposal = void 0;
    var math_1 = require_build2();
    var utils_1 = require_build3();
    var gov_1 = require_gov();
    var any_1 = require_any();
    var queryclient_1 = require_queryclient2();
    function isAminoMsgSubmitProposal(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitProposal";
    }
    exports2.isAminoMsgSubmitProposal = isAminoMsgSubmitProposal;
    function isAminoMsgVote(msg) {
      return msg.type === "cosmos-sdk/MsgVote";
    }
    exports2.isAminoMsgVote = isAminoMsgVote;
    function isAminoMsgVoteWeighted(msg) {
      return msg.type === "cosmos-sdk/MsgVoteWeighted";
    }
    exports2.isAminoMsgVoteWeighted = isAminoMsgVoteWeighted;
    function isAminoMsgDeposit(msg) {
      return msg.type === "cosmos-sdk/MsgDeposit";
    }
    exports2.isAminoMsgDeposit = isAminoMsgDeposit;
    function createGovAminoConverters() {
      return {
        "/cosmos.gov.v1beta1.MsgDeposit": {
          aminoType: "cosmos-sdk/MsgDeposit",
          toAmino: ({ amount, depositor, proposalId }) => {
            return {
              amount,
              depositor,
              proposal_id: proposalId.toString()
            };
          },
          fromAmino: ({ amount, depositor, proposal_id }) => {
            return {
              amount: Array.from(amount),
              depositor,
              proposalId: BigInt(proposal_id)
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVote": {
          aminoType: "cosmos-sdk/MsgVote",
          toAmino: ({ option, proposalId, voter }) => {
            return {
              option,
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ option, proposal_id, voter }) => {
            return {
              option: (0, gov_1.voteOptionFromJSON)(option),
              proposalId: BigInt(proposal_id),
              voter
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVoteWeighted": {
          aminoType: "cosmos-sdk/MsgVoteWeighted",
          toAmino: ({ options, proposalId, voter }) => {
            return {
              options: options.map((o) => ({
                option: o.option,
                // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
                // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
                weight: (0, queryclient_1.decodeCosmosSdkDecFromProto)(o.weight).toString().padEnd(20, "0")
              })),
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ options, proposal_id, voter }) => {
            return {
              proposalId: BigInt(proposal_id),
              voter,
              options: options.map((o) => ({
                option: (0, gov_1.voteOptionFromJSON)(o.option),
                weight: math_1.Decimal.fromUserInput(o.weight, 18).atomics
              }))
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgSubmitProposal": {
          aminoType: "cosmos-sdk/MsgSubmitProposal",
          toAmino: ({ initialDeposit, proposer, content }) => {
            (0, utils_1.assertDefinedAndNotNull)(content);
            let proposal;
            switch (content.typeUrl) {
              case "/cosmos.gov.v1beta1.TextProposal": {
                const textProposal = gov_1.TextProposal.decode(content.value);
                proposal = {
                  type: "cosmos-sdk/TextProposal",
                  value: {
                    description: textProposal.description,
                    title: textProposal.title
                  }
                };
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.typeUrl}'`);
            }
            return {
              initial_deposit: initialDeposit,
              proposer,
              content: proposal
            };
          },
          fromAmino: ({ initial_deposit, proposer, content }) => {
            let any_content;
            switch (content.type) {
              case "cosmos-sdk/TextProposal": {
                const { value } = content;
                (0, utils_1.assert)((0, utils_1.isNonNullObject)(value));
                const { title, description } = value;
                (0, utils_1.assert)(typeof title === "string");
                (0, utils_1.assert)(typeof description === "string");
                any_content = any_1.Any.fromPartial({
                  typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                  value: gov_1.TextProposal.encode(gov_1.TextProposal.fromPartial({
                    title,
                    description
                  })).finish()
                });
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.type}'`);
            }
            return {
              initialDeposit: Array.from(initial_deposit),
              proposer,
              content: any_content
            };
          }
        }
      };
    }
    exports2.createGovAminoConverters = createGovAminoConverters;
  }
});

// node_modules/cosmjs-types/cosmos/gov/v1/gov.js
var require_gov2 = __commonJS({
  "node_modules/cosmjs-types/cosmos/gov/v1/gov.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.TallyParams = exports2.VotingParams = exports2.DepositParams = exports2.Vote = exports2.TallyResult = exports2.Proposal = exports2.Deposit = exports2.WeightedVoteOption = exports2.proposalStatusToJSON = exports2.proposalStatusFromJSON = exports2.ProposalStatus = exports2.voteOptionToJSON = exports2.voteOptionFromJSON = exports2.VoteOption = exports2.protobufPackage = void 0;
    var coin_1 = require_coin();
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.gov.v1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports2.VoteOption = VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports2.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports2.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports2.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.proposalStatusToJSON = proposalStatusToJSON;
    function createBaseWeightedVoteOption() {
      return {
        option: 0,
        weight: ""
      };
    }
    exports2.WeightedVoteOption = {
      typeUrl: "/cosmos.gov.v1.WeightedVoteOption",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseWeightedVoteOption();
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseWeightedVoteOption();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
      }
    };
    function createBaseDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports2.Deposit = {
      typeUrl: "/cosmos.gov.v1.Deposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseProposal() {
      return {
        id: BigInt(0),
        messages: [],
        status: 0,
        finalTallyResult: void 0,
        submitTime: void 0,
        depositEndTime: void 0,
        totalDeposit: [],
        votingStartTime: void 0,
        votingEndTime: void 0,
        metadata: "",
        title: "",
        summary: "",
        proposer: ""
      };
    }
    exports2.Proposal = {
      typeUrl: "/cosmos.gov.v1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports2.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.totalDeposit) {
          coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(82).string(message.metadata);
        }
        if (message.title !== "") {
          writer.uint32(90).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(98).string(message.summary);
        }
        if (message.proposer !== "") {
          writer.uint32(106).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports2.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.metadata = reader.string();
              break;
            case 11:
              message.title = reader.string();
              break;
            case 12:
              message.summary = reader.string();
              break;
            case 13:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if (Array.isArray(object == null ? void 0 : object.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports2.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.depositEndTime))
          obj.depositEndTime = (0, helpers_1.fromJsonTimestamp)(object.depositEndTime);
        if (Array.isArray(object == null ? void 0 : object.totalDeposit))
          obj.totalDeposit = object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.votingStartTime))
          obj.votingStartTime = (0, helpers_1.fromJsonTimestamp)(object.votingStartTime);
        if ((0, helpers_1.isSet)(object.votingEndTime))
          obj.votingEndTime = (0, helpers_1.fromJsonTimestamp)(object.votingEndTime);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports2.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = (0, helpers_1.fromTimestamp)(message.depositEndTime).toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = (0, helpers_1.fromTimestamp)(message.votingStartTime).toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = (0, helpers_1.fromTimestamp)(message.votingEndTime).toISOString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseProposal();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports2.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.depositEndTime !== void 0 && object.depositEndTime !== null) {
          message.depositEndTime = timestamp_1.Timestamp.fromPartial(object.depositEndTime);
        }
        message.totalDeposit = ((_b = object.totalDeposit) == null ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.votingStartTime !== void 0 && object.votingStartTime !== null) {
          message.votingStartTime = timestamp_1.Timestamp.fromPartial(object.votingStartTime);
        }
        if (object.votingEndTime !== void 0 && object.votingEndTime !== null) {
          message.votingEndTime = timestamp_1.Timestamp.fromPartial(object.votingEndTime);
        }
        message.metadata = object.metadata ?? "";
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        message.proposer = object.proposer ?? "";
        return message;
      }
    };
    function createBaseTallyResult() {
      return {
        yesCount: "",
        abstainCount: "",
        noCount: "",
        noWithVetoCount: ""
      };
    }
    exports2.TallyResult = {
      typeUrl: "/cosmos.gov.v1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yesCount !== "") {
          writer.uint32(10).string(message.yesCount);
        }
        if (message.abstainCount !== "") {
          writer.uint32(18).string(message.abstainCount);
        }
        if (message.noCount !== "") {
          writer.uint32(26).string(message.noCount);
        }
        if (message.noWithVetoCount !== "") {
          writer.uint32(34).string(message.noWithVetoCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yesCount = reader.string();
              break;
            case 2:
              message.abstainCount = reader.string();
              break;
            case 3:
              message.noCount = reader.string();
              break;
            case 4:
              message.noWithVetoCount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yesCount))
          obj.yesCount = String(object.yesCount);
        if ((0, helpers_1.isSet)(object.abstainCount))
          obj.abstainCount = String(object.abstainCount);
        if ((0, helpers_1.isSet)(object.noCount))
          obj.noCount = String(object.noCount);
        if ((0, helpers_1.isSet)(object.noWithVetoCount))
          obj.noWithVetoCount = String(object.noWithVetoCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yesCount !== void 0 && (obj.yesCount = message.yesCount);
        message.abstainCount !== void 0 && (obj.abstainCount = message.abstainCount);
        message.noCount !== void 0 && (obj.noCount = message.noCount);
        message.noWithVetoCount !== void 0 && (obj.noWithVetoCount = message.noWithVetoCount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult();
        message.yesCount = object.yesCount ?? "";
        message.abstainCount = object.abstainCount ?? "";
        message.noCount = object.noCount ?? "";
        message.noWithVetoCount = object.noWithVetoCount ?? "";
        return message;
      }
    };
    function createBaseVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: [],
        metadata: ""
      };
    }
    exports2.Vote = {
      typeUrl: "/cosmos.gov.v1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          exports2.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(42).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 4:
              message.options.push(exports2.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            case 5:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object == null ? void 0 : object.options))
          obj.options = object.options.map((e) => exports2.WeightedVoteOption.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports2.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = ((_a = object.options) == null ? void 0 : _a.map((e) => exports2.WeightedVoteOption.fromPartial(e))) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseDepositParams() {
      return {
        minDeposit: [],
        maxDepositPeriod: void 0
      };
    }
    exports2.DepositParams = {
      typeUrl: "/cosmos.gov.v1.DepositParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDepositParams();
        if (Array.isArray(object == null ? void 0 : object.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDepositParams();
        message.minDeposit = ((_a = object.minDeposit) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        return message;
      }
    };
    function createBaseVotingParams() {
      return {
        votingPeriod: void 0
      };
    }
    exports2.VotingParams = {
      typeUrl: "/cosmos.gov.v1.VotingParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVotingParams();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVotingParams();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        return message;
      }
    };
    function createBaseTallyParams() {
      return {
        quorum: "",
        threshold: "",
        vetoThreshold: ""
      };
    }
    exports2.TallyParams = {
      typeUrl: "/cosmos.gov.v1.TallyParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.quorum !== "") {
          writer.uint32(10).string(message.quorum);
        }
        if (message.threshold !== "") {
          writer.uint32(18).string(message.threshold);
        }
        if (message.vetoThreshold !== "") {
          writer.uint32(26).string(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.string();
              break;
            case 2:
              message.threshold = reader.string();
              break;
            case 3:
              message.vetoThreshold = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyParams();
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = String(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = String(object.vetoThreshold);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = message.quorum);
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = message.vetoThreshold);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyParams();
        message.quorum = object.quorum ?? "";
        message.threshold = object.threshold ?? "";
        message.vetoThreshold = object.vetoThreshold ?? "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        minDeposit: [],
        maxDepositPeriod: void 0,
        votingPeriod: void 0,
        quorum: "",
        threshold: "",
        vetoThreshold: "",
        minInitialDepositRatio: "",
        burnVoteQuorum: false,
        burnProposalDepositPrevote: false,
        burnVoteVeto: false
      };
    }
    exports2.Params = {
      typeUrl: "/cosmos.gov.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(26).fork()).ldelim();
        }
        if (message.quorum !== "") {
          writer.uint32(34).string(message.quorum);
        }
        if (message.threshold !== "") {
          writer.uint32(42).string(message.threshold);
        }
        if (message.vetoThreshold !== "") {
          writer.uint32(50).string(message.vetoThreshold);
        }
        if (message.minInitialDepositRatio !== "") {
          writer.uint32(58).string(message.minInitialDepositRatio);
        }
        if (message.burnVoteQuorum === true) {
          writer.uint32(104).bool(message.burnVoteQuorum);
        }
        if (message.burnProposalDepositPrevote === true) {
          writer.uint32(112).bool(message.burnProposalDepositPrevote);
        }
        if (message.burnVoteVeto === true) {
          writer.uint32(120).bool(message.burnVoteVeto);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.quorum = reader.string();
              break;
            case 5:
              message.threshold = reader.string();
              break;
            case 6:
              message.vetoThreshold = reader.string();
              break;
            case 7:
              message.minInitialDepositRatio = reader.string();
              break;
            case 13:
              message.burnVoteQuorum = reader.bool();
              break;
            case 14:
              message.burnProposalDepositPrevote = reader.bool();
              break;
            case 15:
              message.burnVoteVeto = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if (Array.isArray(object == null ? void 0 : object.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = String(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = String(object.vetoThreshold);
        if ((0, helpers_1.isSet)(object.minInitialDepositRatio))
          obj.minInitialDepositRatio = String(object.minInitialDepositRatio);
        if ((0, helpers_1.isSet)(object.burnVoteQuorum))
          obj.burnVoteQuorum = Boolean(object.burnVoteQuorum);
        if ((0, helpers_1.isSet)(object.burnProposalDepositPrevote))
          obj.burnProposalDepositPrevote = Boolean(object.burnProposalDepositPrevote);
        if ((0, helpers_1.isSet)(object.burnVoteVeto))
          obj.burnVoteVeto = Boolean(object.burnVoteVeto);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        message.quorum !== void 0 && (obj.quorum = message.quorum);
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = message.vetoThreshold);
        message.minInitialDepositRatio !== void 0 && (obj.minInitialDepositRatio = message.minInitialDepositRatio);
        message.burnVoteQuorum !== void 0 && (obj.burnVoteQuorum = message.burnVoteQuorum);
        message.burnProposalDepositPrevote !== void 0 && (obj.burnProposalDepositPrevote = message.burnProposalDepositPrevote);
        message.burnVoteVeto !== void 0 && (obj.burnVoteVeto = message.burnVoteVeto);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseParams();
        message.minDeposit = ((_a = object.minDeposit) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        message.quorum = object.quorum ?? "";
        message.threshold = object.threshold ?? "";
        message.vetoThreshold = object.vetoThreshold ?? "";
        message.minInitialDepositRatio = object.minInitialDepositRatio ?? "";
        message.burnVoteQuorum = object.burnVoteQuorum ?? false;
        message.burnProposalDepositPrevote = object.burnProposalDepositPrevote ?? false;
        message.burnVoteVeto = object.burnVoteVeto ?? false;
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/gov/v1/tx.js
var require_tx6 = __commonJS({
  "node_modules/cosmjs-types/cosmos/gov/v1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgUpdateParamsResponse = exports2.MsgUpdateParams = exports2.MsgDepositResponse = exports2.MsgDeposit = exports2.MsgVoteWeightedResponse = exports2.MsgVoteWeighted = exports2.MsgVoteResponse = exports2.MsgVote = exports2.MsgExecLegacyContentResponse = exports2.MsgExecLegacyContent = exports2.MsgSubmitProposalResponse = exports2.MsgSubmitProposal = exports2.protobufPackage = void 0;
    var any_1 = require_any();
    var coin_1 = require_coin();
    var gov_1 = require_gov2();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.gov.v1";
    function createBaseMsgSubmitProposal() {
      return {
        messages: [],
        initialDeposit: [],
        proposer: "",
        metadata: "",
        title: "",
        summary: ""
      };
    }
    exports2.MsgSubmitProposal = {
      typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.initialDeposit) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.title !== "") {
          writer.uint32(42).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(50).string(message.summary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.title = reader.string();
              break;
            case 6:
              message.summary = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal();
        if (Array.isArray(object == null ? void 0 : object.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.initialDeposit))
          obj.initialDeposit = object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSubmitProposal();
        message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];
        message.initialDeposit = ((_b = object.initialDeposit) == null ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.proposer = object.proposer ?? "";
        message.metadata = object.metadata ?? "";
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports2.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.gov.v1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgExecLegacyContent() {
      return {
        content: void 0,
        authority: ""
      };
    }
    exports2.MsgExecLegacyContent = {
      typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        if (message.authority !== "") {
          writer.uint32(18).string(message.authority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecLegacyContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.authority = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecLegacyContent();
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.authority !== void 0 && (obj.authority = message.authority);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecLegacyContent();
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.authority = object.authority ?? "";
        return message;
      }
    };
    function createBaseMsgExecLegacyContentResponse() {
      return {};
    }
    exports2.MsgExecLegacyContentResponse = {
      typeUrl: "/cosmos.gov.v1.MsgExecLegacyContentResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecLegacyContentResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgExecLegacyContentResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgExecLegacyContentResponse();
        return message;
      }
    };
    function createBaseMsgVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: ""
      };
    }
    exports2.MsgVote = {
      typeUrl: "/cosmos.gov.v1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, gov_1.voteOptionFromJSON)(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports2.MsgVoteResponse = {
      typeUrl: "/cosmos.gov.v1.MsgVoteResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgVoteWeighted() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: [],
        metadata: ""
      };
    }
    exports2.MsgVoteWeighted = {
      typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            case 4:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVoteWeighted();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object == null ? void 0 : object.options))
          obj.options = object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgVoteWeighted();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = ((_a = object.options) == null ? void 0 : _a.map((e) => gov_1.WeightedVoteOption.fromPartial(e))) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse() {
      return {};
    }
    exports2.MsgVoteWeightedResponse = {
      typeUrl: "/cosmos.gov.v1.MsgVoteWeightedResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteWeightedResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
      }
    };
    function createBaseMsgDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports2.MsgDeposit = {
      typeUrl: "/cosmos.gov.v1.MsgDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse() {
      return {};
    }
    exports2.MsgDepositResponse = {
      typeUrl: "/cosmos.gov.v1.MsgDepositResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDepositResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDepositResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: gov_1.Params.fromPartial({})
      };
    }
    exports2.MsgUpdateParams = {
      typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          gov_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = gov_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = gov_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? gov_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = gov_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports2.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.gov.v1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.ExecLegacyContent = this.ExecLegacyContent.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
      }
      SubmitProposal(request) {
        const data = exports2.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "SubmitProposal", data);
        return promise.then((data2) => exports2.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ExecLegacyContent(request) {
        const data = exports2.MsgExecLegacyContent.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "ExecLegacyContent", data);
        return promise.then((data2) => exports2.MsgExecLegacyContentResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Vote(request) {
        const data = exports2.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "Vote", data);
        return promise.then((data2) => exports2.MsgVoteResponse.decode(new binary_1.BinaryReader(data2)));
      }
      VoteWeighted(request) {
        const data = exports2.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "VoteWeighted", data);
        return promise.then((data2) => exports2.MsgVoteWeightedResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Deposit(request) {
        const data = exports2.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "Deposit", data);
        return promise.then((data2) => exports2.MsgDepositResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateParams(request) {
        const data = exports2.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "UpdateParams", data);
        return promise.then((data2) => exports2.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js
var require_tx7 = __commonJS({
  "node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgDepositResponse = exports2.MsgDeposit = exports2.MsgVoteWeightedResponse = exports2.MsgVoteWeighted = exports2.MsgVoteResponse = exports2.MsgVote = exports2.MsgSubmitProposalResponse = exports2.MsgSubmitProposal = exports2.protobufPackage = void 0;
    var any_1 = require_any();
    var coin_1 = require_coin();
    var gov_1 = require_gov();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseMsgSubmitProposal() {
      return {
        content: void 0,
        initialDeposit: [],
        proposer: ""
      };
    }
    exports2.MsgSubmitProposal = {
      typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.initialDeposit) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal();
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if (Array.isArray(object == null ? void 0 : object.initialDeposit))
          obj.initialDeposit = object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgSubmitProposal();
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.initialDeposit = ((_a = object.initialDeposit) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.proposer = object.proposer ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports2.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0
      };
    }
    exports2.MsgVote = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, gov_1.voteOptionFromJSON)(object.option);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports2.MsgVoteResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgVoteWeighted() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: []
      };
    }
    exports2.MsgVoteWeighted = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVoteWeighted();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object == null ? void 0 : object.options))
          obj.options = object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgVoteWeighted();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = ((_a = object.options) == null ? void 0 : _a.map((e) => gov_1.WeightedVoteOption.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse() {
      return {};
    }
    exports2.MsgVoteWeightedResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeightedResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteWeightedResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
      }
    };
    function createBaseMsgDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports2.MsgDeposit = {
      typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse() {
      return {};
    }
    exports2.MsgDepositResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgDepositResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDepositResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDepositResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
      }
      SubmitProposal(request) {
        const data = exports2.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", data);
        return promise.then((data2) => exports2.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Vote(request) {
        const data = exports2.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", data);
        return promise.then((data2) => exports2.MsgVoteResponse.decode(new binary_1.BinaryReader(data2)));
      }
      VoteWeighted(request) {
        const data = exports2.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", data);
        return promise.then((data2) => exports2.MsgVoteWeightedResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Deposit(request) {
        const data = exports2.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", data);
        return promise.then((data2) => exports2.MsgDepositResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/gov/messages.js
var require_messages5 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/gov/messages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgVoteWeightedEncodeObject = exports2.isMsgVoteEncodeObject = exports2.isMsgSubmitProposalEncodeObject = exports2.isMsgDepositEncodeObject = exports2.govTypes = void 0;
    var tx_1 = require_tx6();
    var tx_2 = require_tx7();
    exports2.govTypes = [
      ["/cosmos.gov.v1.MsgDeposit", tx_1.MsgDeposit],
      ["/cosmos.gov.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.gov.v1.MsgUpdateParams", tx_1.MsgUpdateParams],
      ["/cosmos.gov.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.gov.v1.MsgVoteWeighted", tx_1.MsgVoteWeighted],
      ["/cosmos.gov.v1beta1.MsgDeposit", tx_2.MsgDeposit],
      ["/cosmos.gov.v1beta1.MsgSubmitProposal", tx_2.MsgSubmitProposal],
      ["/cosmos.gov.v1beta1.MsgVote", tx_2.MsgVote],
      ["/cosmos.gov.v1beta1.MsgVoteWeighted", tx_2.MsgVoteWeighted]
    ];
    function isMsgDepositEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
    }
    exports2.isMsgDepositEncodeObject = isMsgDepositEncodeObject;
    function isMsgSubmitProposalEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
    }
    exports2.isMsgSubmitProposalEncodeObject = isMsgSubmitProposalEncodeObject;
    function isMsgVoteEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
    }
    exports2.isMsgVoteEncodeObject = isMsgVoteEncodeObject;
    function isMsgVoteWeightedEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
    }
    exports2.isMsgVoteWeightedEncodeObject = isMsgVoteWeightedEncodeObject;
  }
});

// node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js
var require_query6 = __commonJS({
  "node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryTallyResultResponse = exports2.QueryTallyResultRequest = exports2.QueryDepositsResponse = exports2.QueryDepositsRequest = exports2.QueryDepositResponse = exports2.QueryDepositRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.QueryVotesResponse = exports2.QueryVotesRequest = exports2.QueryVoteResponse = exports2.QueryVoteRequest = exports2.QueryProposalsResponse = exports2.QueryProposalsRequest = exports2.QueryProposalResponse = exports2.QueryProposalRequest = exports2.protobufPackage = void 0;
    var gov_1 = require_gov();
    var pagination_1 = require_pagination();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseQueryProposalRequest() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports2.QueryProposalRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseQueryProposalResponse() {
      return {
        proposal: gov_1.Proposal.fromPartial({})
      };
    }
    exports2.QueryProposalResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposal !== void 0) {
          gov_1.Proposal.encode(message.proposal, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposal = gov_1.Proposal.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalResponse();
        if ((0, helpers_1.isSet)(object.proposal))
          obj.proposal = gov_1.Proposal.fromJSON(object.proposal);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposal !== void 0 && (obj.proposal = message.proposal ? gov_1.Proposal.toJSON(message.proposal) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalResponse();
        if (object.proposal !== void 0 && object.proposal !== null) {
          message.proposal = gov_1.Proposal.fromPartial(object.proposal);
        }
        return message;
      }
    };
    function createBaseQueryProposalsRequest() {
      return {
        proposalStatus: 0,
        voter: "",
        depositor: "",
        pagination: void 0
      };
    }
    exports2.QueryProposalsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalStatus !== 0) {
          writer.uint32(8).int32(message.proposalStatus);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.depositor !== "") {
          writer.uint32(26).string(message.depositor);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalStatus = reader.int32();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.depositor = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalsRequest();
        if ((0, helpers_1.isSet)(object.proposalStatus))
          obj.proposalStatus = (0, gov_1.proposalStatusFromJSON)(object.proposalStatus);
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalStatus !== void 0 && (obj.proposalStatus = (0, gov_1.proposalStatusToJSON)(message.proposalStatus));
        message.voter !== void 0 && (obj.voter = message.voter);
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalsRequest();
        message.proposalStatus = object.proposalStatus ?? 0;
        message.voter = object.voter ?? "";
        message.depositor = object.depositor ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryProposalsResponse() {
      return {
        proposals: [],
        pagination: void 0
      };
    }
    exports2.QueryProposalsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.proposals) {
          gov_1.Proposal.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposals.push(gov_1.Proposal.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalsResponse();
        if (Array.isArray(object == null ? void 0 : object.proposals))
          obj.proposals = object.proposals.map((e) => gov_1.Proposal.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.proposals) {
          obj.proposals = message.proposals.map((e) => e ? gov_1.Proposal.toJSON(e) : void 0);
        } else {
          obj.proposals = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryProposalsResponse();
        message.proposals = ((_a = object.proposals) == null ? void 0 : _a.map((e) => gov_1.Proposal.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryVoteRequest() {
      return {
        proposalId: BigInt(0),
        voter: ""
      };
    }
    exports2.QueryVoteRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVoteRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVoteRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVoteRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        return message;
      }
    };
    function createBaseQueryVoteResponse() {
      return {
        vote: gov_1.Vote.fromPartial({})
      };
    }
    exports2.QueryVoteResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVoteResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.vote !== void 0) {
          gov_1.Vote.encode(message.vote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vote = gov_1.Vote.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVoteResponse();
        if ((0, helpers_1.isSet)(object.vote))
          obj.vote = gov_1.Vote.fromJSON(object.vote);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.vote !== void 0 && (obj.vote = message.vote ? gov_1.Vote.toJSON(message.vote) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVoteResponse();
        if (object.vote !== void 0 && object.vote !== null) {
          message.vote = gov_1.Vote.fromPartial(object.vote);
        }
        return message;
      }
    };
    function createBaseQueryVotesRequest() {
      return {
        proposalId: BigInt(0),
        pagination: void 0
      };
    }
    exports2.QueryVotesRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVotesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVotesRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVotesRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryVotesResponse() {
      return {
        votes: [],
        pagination: void 0
      };
    }
    exports2.QueryVotesResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVotesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.votes) {
          gov_1.Vote.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votes.push(gov_1.Vote.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVotesResponse();
        if (Array.isArray(object == null ? void 0 : object.votes))
          obj.votes = object.votes.map((e) => gov_1.Vote.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? gov_1.Vote.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryVotesResponse();
        message.votes = ((_a = object.votes) == null ? void 0 : _a.map((e) => gov_1.Vote.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {
        paramsType: ""
      };
    }
    exports2.QueryParamsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryParamsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.paramsType !== "") {
          writer.uint32(10).string(message.paramsType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paramsType = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsRequest();
        if ((0, helpers_1.isSet)(object.paramsType))
          obj.paramsType = String(object.paramsType);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.paramsType !== void 0 && (obj.paramsType = message.paramsType);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsRequest();
        message.paramsType = object.paramsType ?? "";
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        votingParams: gov_1.VotingParams.fromPartial({}),
        depositParams: gov_1.DepositParams.fromPartial({}),
        tallyParams: gov_1.TallyParams.fromPartial({})
      };
    }
    exports2.QueryParamsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingParams !== void 0) {
          gov_1.VotingParams.encode(message.votingParams, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositParams !== void 0) {
          gov_1.DepositParams.encode(message.depositParams, writer.uint32(18).fork()).ldelim();
        }
        if (message.tallyParams !== void 0) {
          gov_1.TallyParams.encode(message.tallyParams, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingParams = gov_1.VotingParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.depositParams = gov_1.DepositParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.tallyParams = gov_1.TallyParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.votingParams))
          obj.votingParams = gov_1.VotingParams.fromJSON(object.votingParams);
        if ((0, helpers_1.isSet)(object.depositParams))
          obj.depositParams = gov_1.DepositParams.fromJSON(object.depositParams);
        if ((0, helpers_1.isSet)(object.tallyParams))
          obj.tallyParams = gov_1.TallyParams.fromJSON(object.tallyParams);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingParams !== void 0 && (obj.votingParams = message.votingParams ? gov_1.VotingParams.toJSON(message.votingParams) : void 0);
        message.depositParams !== void 0 && (obj.depositParams = message.depositParams ? gov_1.DepositParams.toJSON(message.depositParams) : void 0);
        message.tallyParams !== void 0 && (obj.tallyParams = message.tallyParams ? gov_1.TallyParams.toJSON(message.tallyParams) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.votingParams !== void 0 && object.votingParams !== null) {
          message.votingParams = gov_1.VotingParams.fromPartial(object.votingParams);
        }
        if (object.depositParams !== void 0 && object.depositParams !== null) {
          message.depositParams = gov_1.DepositParams.fromPartial(object.depositParams);
        }
        if (object.tallyParams !== void 0 && object.tallyParams !== null) {
          message.tallyParams = gov_1.TallyParams.fromPartial(object.tallyParams);
        }
        return message;
      }
    };
    function createBaseQueryDepositRequest() {
      return {
        proposalId: BigInt(0),
        depositor: ""
      };
    }
    exports2.QueryDepositRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        return message;
      }
    };
    function createBaseQueryDepositResponse() {
      return {
        deposit: gov_1.Deposit.fromPartial({})
      };
    }
    exports2.QueryDepositResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.deposit !== void 0) {
          gov_1.Deposit.encode(message.deposit, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposit = gov_1.Deposit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositResponse();
        if ((0, helpers_1.isSet)(object.deposit))
          obj.deposit = gov_1.Deposit.fromJSON(object.deposit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.deposit !== void 0 && (obj.deposit = message.deposit ? gov_1.Deposit.toJSON(message.deposit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositResponse();
        if (object.deposit !== void 0 && object.deposit !== null) {
          message.deposit = gov_1.Deposit.fromPartial(object.deposit);
        }
        return message;
      }
    };
    function createBaseQueryDepositsRequest() {
      return {
        proposalId: BigInt(0),
        pagination: void 0
      };
    }
    exports2.QueryDepositsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositsRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositsRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDepositsResponse() {
      return {
        deposits: [],
        pagination: void 0
      };
    }
    exports2.QueryDepositsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.deposits) {
          gov_1.Deposit.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposits.push(gov_1.Deposit.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositsResponse();
        if (Array.isArray(object == null ? void 0 : object.deposits))
          obj.deposits = object.deposits.map((e) => gov_1.Deposit.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.deposits) {
          obj.deposits = message.deposits.map((e) => e ? gov_1.Deposit.toJSON(e) : void 0);
        } else {
          obj.deposits = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDepositsResponse();
        message.deposits = ((_a = object.deposits) == null ? void 0 : _a.map((e) => gov_1.Deposit.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryTallyResultRequest() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports2.QueryTallyResultRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTallyResultRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTallyResultRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseQueryTallyResultResponse() {
      return {
        tally: gov_1.TallyResult.fromPartial({})
      };
    }
    exports2.QueryTallyResultResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tally !== void 0) {
          gov_1.TallyResult.encode(message.tally, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tally = gov_1.TallyResult.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTallyResultResponse();
        if ((0, helpers_1.isSet)(object.tally))
          obj.tally = gov_1.TallyResult.fromJSON(object.tally);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tally !== void 0 && (obj.tally = message.tally ? gov_1.TallyResult.toJSON(message.tally) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTallyResultResponse();
        if (object.tally !== void 0 && object.tally !== null) {
          message.tally = gov_1.TallyResult.fromPartial(object.tally);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Proposal = this.Proposal.bind(this);
        this.Proposals = this.Proposals.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Votes = this.Votes.bind(this);
        this.Params = this.Params.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.Deposits = this.Deposits.bind(this);
        this.TallyResult = this.TallyResult.bind(this);
      }
      Proposal(request) {
        const data = exports2.QueryProposalRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", data);
        return promise.then((data2) => exports2.QueryProposalResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Proposals(request) {
        const data = exports2.QueryProposalsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", data);
        return promise.then((data2) => exports2.QueryProposalsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Vote(request) {
        const data = exports2.QueryVoteRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", data);
        return promise.then((data2) => exports2.QueryVoteResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Votes(request) {
        const data = exports2.QueryVotesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", data);
        return promise.then((data2) => exports2.QueryVotesResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Params(request) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Deposit(request) {
        const data = exports2.QueryDepositRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", data);
        return promise.then((data2) => exports2.QueryDepositResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Deposits(request) {
        const data = exports2.QueryDepositsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", data);
        return promise.then((data2) => exports2.QueryDepositsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      TallyResult(request) {
        const data = exports2.QueryTallyResultRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", data);
        return promise.then((data2) => exports2.QueryTallyResultResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/gov/queries.js
var require_queries6 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/gov/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupGovExtension = void 0;
    var query_1 = require_query6();
    var queryclient_1 = require_queryclient2();
    function setupGovExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        gov: {
          params: async (parametersType) => {
            const response = await queryService.Params({ paramsType: parametersType });
            return response;
          },
          proposals: async (proposalStatus, depositorAddress, voterAddress, paginationKey) => {
            const response = await queryService.Proposals({
              proposalStatus,
              depositor: depositorAddress,
              voter: voterAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          proposal: async (proposalId) => {
            const response = await queryService.Proposal({ proposalId: (0, queryclient_1.longify)(proposalId) });
            return response;
          },
          deposits: async (proposalId, paginationKey) => {
            const response = await queryService.Deposits({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          deposit: async (proposalId, depositorAddress) => {
            const response = await queryService.Deposit({
              proposalId: (0, queryclient_1.longify)(proposalId),
              depositor: depositorAddress
            });
            return response;
          },
          tally: async (proposalId) => {
            const response = await queryService.TallyResult({
              proposalId: (0, queryclient_1.longify)(proposalId)
            });
            return response;
          },
          votes: async (proposalId, paginationKey) => {
            const response = await queryService.Votes({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          vote: async (proposalId, voterAddress) => {
            const response = await queryService.Vote({
              proposalId: (0, queryclient_1.longify)(proposalId),
              voter: voterAddress
            });
            return response;
          }
        }
      };
    }
    exports2.setupGovExtension = setupGovExtension;
  }
});

// node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js
var require_aminomessages8 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createGroupAminoConverters = void 0;
    function createGroupAminoConverters() {
      return {};
    }
    exports2.createGroupAminoConverters = createGroupAminoConverters;
  }
});

// node_modules/cosmjs-types/cosmos/group/v1/types.js
var require_types = __commonJS({
  "node_modules/cosmjs-types/cosmos/group/v1/types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Vote = exports2.TallyResult = exports2.Proposal = exports2.GroupPolicyInfo = exports2.GroupMember = exports2.GroupInfo = exports2.DecisionPolicyWindows = exports2.PercentageDecisionPolicy = exports2.ThresholdDecisionPolicy = exports2.MemberRequest = exports2.Member = exports2.proposalExecutorResultToJSON = exports2.proposalExecutorResultFromJSON = exports2.ProposalExecutorResult = exports2.proposalStatusToJSON = exports2.proposalStatusFromJSON = exports2.ProposalStatus = exports2.voteOptionToJSON = exports2.voteOptionFromJSON = exports2.VoteOption = exports2.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.group.v1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports2.VoteOption = VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports2.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_SUBMITTED"] = 1] = "PROPOSAL_STATUS_SUBMITTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_ACCEPTED"] = 2] = "PROPOSAL_STATUS_ACCEPTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 3] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_ABORTED"] = 4] = "PROPOSAL_STATUS_ABORTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_WITHDRAWN"] = 5] = "PROPOSAL_STATUS_WITHDRAWN";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports2.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_SUBMITTED":
          return ProposalStatus.PROPOSAL_STATUS_SUBMITTED;
        case 2:
        case "PROPOSAL_STATUS_ACCEPTED":
          return ProposalStatus.PROPOSAL_STATUS_ACCEPTED;
        case 3:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 4:
        case "PROPOSAL_STATUS_ABORTED":
          return ProposalStatus.PROPOSAL_STATUS_ABORTED;
        case 5:
        case "PROPOSAL_STATUS_WITHDRAWN":
          return ProposalStatus.PROPOSAL_STATUS_WITHDRAWN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports2.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_SUBMITTED:
          return "PROPOSAL_STATUS_SUBMITTED";
        case ProposalStatus.PROPOSAL_STATUS_ACCEPTED:
          return "PROPOSAL_STATUS_ACCEPTED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_ABORTED:
          return "PROPOSAL_STATUS_ABORTED";
        case ProposalStatus.PROPOSAL_STATUS_WITHDRAWN:
          return "PROPOSAL_STATUS_WITHDRAWN";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.proposalStatusToJSON = proposalStatusToJSON;
    var ProposalExecutorResult;
    (function(ProposalExecutorResult2) {
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"] = 0] = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_NOT_RUN"] = 1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_SUCCESS"] = 2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_FAILURE"] = 3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE";
      ProposalExecutorResult2[ProposalExecutorResult2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalExecutorResult || (exports2.ProposalExecutorResult = ProposalExecutorResult = {}));
    function proposalExecutorResultFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED;
        case 1:
        case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_NOT_RUN;
        case 2:
        case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_SUCCESS;
        case 3:
        case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalExecutorResult.UNRECOGNIZED;
      }
    }
    exports2.proposalExecutorResultFromJSON = proposalExecutorResultFromJSON;
    function proposalExecutorResultToJSON(object) {
      switch (object) {
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED:
          return "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_NOT_RUN:
          return "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_SUCCESS:
          return "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_FAILURE:
          return "PROPOSAL_EXECUTOR_RESULT_FAILURE";
        case ProposalExecutorResult.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.proposalExecutorResultToJSON = proposalExecutorResultToJSON;
    function createBaseMember() {
      return {
        address: "",
        weight: "",
        metadata: "",
        addedAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.Member = {
      typeUrl: "/cosmos.group.v1.Member",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.addedAt !== void 0) {
          timestamp_1.Timestamp.encode(message.addedAt, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMember();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.weight = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.addedAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMember();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.addedAt))
          obj.addedAt = (0, helpers_1.fromJsonTimestamp)(object.addedAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.weight !== void 0 && (obj.weight = message.weight);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.addedAt !== void 0 && (obj.addedAt = (0, helpers_1.fromTimestamp)(message.addedAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMember();
        message.address = object.address ?? "";
        message.weight = object.weight ?? "";
        message.metadata = object.metadata ?? "";
        if (object.addedAt !== void 0 && object.addedAt !== null) {
          message.addedAt = timestamp_1.Timestamp.fromPartial(object.addedAt);
        }
        return message;
      }
    };
    function createBaseMemberRequest() {
      return {
        address: "",
        weight: "",
        metadata: ""
      };
    }
    exports2.MemberRequest = {
      typeUrl: "/cosmos.group.v1.MemberRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMemberRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.weight = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMemberRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.weight !== void 0 && (obj.weight = message.weight);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMemberRequest();
        message.address = object.address ?? "";
        message.weight = object.weight ?? "";
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseThresholdDecisionPolicy() {
      return {
        threshold: "",
        windows: void 0
      };
    }
    exports2.ThresholdDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.ThresholdDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.threshold !== "") {
          writer.uint32(10).string(message.threshold);
        }
        if (message.windows !== void 0) {
          exports2.DecisionPolicyWindows.encode(message.windows, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseThresholdDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.threshold = reader.string();
              break;
            case 2:
              message.windows = exports2.DecisionPolicyWindows.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseThresholdDecisionPolicy();
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.windows))
          obj.windows = exports2.DecisionPolicyWindows.fromJSON(object.windows);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.windows !== void 0 && (obj.windows = message.windows ? exports2.DecisionPolicyWindows.toJSON(message.windows) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseThresholdDecisionPolicy();
        message.threshold = object.threshold ?? "";
        if (object.windows !== void 0 && object.windows !== null) {
          message.windows = exports2.DecisionPolicyWindows.fromPartial(object.windows);
        }
        return message;
      }
    };
    function createBasePercentageDecisionPolicy() {
      return {
        percentage: "",
        windows: void 0
      };
    }
    exports2.PercentageDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.PercentageDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.percentage !== "") {
          writer.uint32(10).string(message.percentage);
        }
        if (message.windows !== void 0) {
          exports2.DecisionPolicyWindows.encode(message.windows, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePercentageDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.percentage = reader.string();
              break;
            case 2:
              message.windows = exports2.DecisionPolicyWindows.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePercentageDecisionPolicy();
        if ((0, helpers_1.isSet)(object.percentage))
          obj.percentage = String(object.percentage);
        if ((0, helpers_1.isSet)(object.windows))
          obj.windows = exports2.DecisionPolicyWindows.fromJSON(object.windows);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.percentage !== void 0 && (obj.percentage = message.percentage);
        message.windows !== void 0 && (obj.windows = message.windows ? exports2.DecisionPolicyWindows.toJSON(message.windows) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePercentageDecisionPolicy();
        message.percentage = object.percentage ?? "";
        if (object.windows !== void 0 && object.windows !== null) {
          message.windows = exports2.DecisionPolicyWindows.fromPartial(object.windows);
        }
        return message;
      }
    };
    function createBaseDecisionPolicyWindows() {
      return {
        votingPeriod: duration_1.Duration.fromPartial({}),
        minExecutionPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports2.DecisionPolicyWindows = {
      typeUrl: "/cosmos.group.v1.DecisionPolicyWindows",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        if (message.minExecutionPeriod !== void 0) {
          duration_1.Duration.encode(message.minExecutionPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecisionPolicyWindows();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.minExecutionPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDecisionPolicyWindows();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        if ((0, helpers_1.isSet)(object.minExecutionPeriod))
          obj.minExecutionPeriod = duration_1.Duration.fromJSON(object.minExecutionPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        message.minExecutionPeriod !== void 0 && (obj.minExecutionPeriod = message.minExecutionPeriod ? duration_1.Duration.toJSON(message.minExecutionPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecisionPolicyWindows();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        if (object.minExecutionPeriod !== void 0 && object.minExecutionPeriod !== null) {
          message.minExecutionPeriod = duration_1.Duration.fromPartial(object.minExecutionPeriod);
        }
        return message;
      }
    };
    function createBaseGroupInfo() {
      return {
        id: BigInt(0),
        admin: "",
        metadata: "",
        version: BigInt(0),
        totalWeight: "",
        createdAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.GroupInfo = {
      typeUrl: "/cosmos.group.v1.GroupInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(32).uint64(message.version);
        }
        if (message.totalWeight !== "") {
          writer.uint32(42).string(message.totalWeight);
        }
        if (message.createdAt !== void 0) {
          timestamp_1.Timestamp.encode(message.createdAt, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.version = reader.uint64();
              break;
            case 5:
              message.totalWeight = reader.string();
              break;
            case 6:
              message.createdAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupInfo();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        if ((0, helpers_1.isSet)(object.totalWeight))
          obj.totalWeight = String(object.totalWeight);
        if ((0, helpers_1.isSet)(object.createdAt))
          obj.createdAt = (0, helpers_1.fromJsonTimestamp)(object.createdAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.admin !== void 0 && (obj.admin = message.admin);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        message.totalWeight !== void 0 && (obj.totalWeight = message.totalWeight);
        message.createdAt !== void 0 && (obj.createdAt = (0, helpers_1.fromTimestamp)(message.createdAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupInfo();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.admin = object.admin ?? "";
        message.metadata = object.metadata ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        message.totalWeight = object.totalWeight ?? "";
        if (object.createdAt !== void 0 && object.createdAt !== null) {
          message.createdAt = timestamp_1.Timestamp.fromPartial(object.createdAt);
        }
        return message;
      }
    };
    function createBaseGroupMember() {
      return {
        groupId: BigInt(0),
        member: void 0
      };
    }
    exports2.GroupMember = {
      typeUrl: "/cosmos.group.v1.GroupMember",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        if (message.member !== void 0) {
          exports2.Member.encode(message.member, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupMember();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            case 2:
              message.member = exports2.Member.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupMember();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.member))
          obj.member = exports2.Member.fromJSON(object.member);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.member !== void 0 && (obj.member = message.member ? exports2.Member.toJSON(message.member) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupMember();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        if (object.member !== void 0 && object.member !== null) {
          message.member = exports2.Member.fromPartial(object.member);
        }
        return message;
      }
    };
    function createBaseGroupPolicyInfo() {
      return {
        address: "",
        groupId: BigInt(0),
        admin: "",
        metadata: "",
        version: BigInt(0),
        decisionPolicy: void 0,
        createdAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.GroupPolicyInfo = {
      typeUrl: "/cosmos.group.v1.GroupPolicyInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.admin !== "") {
          writer.uint32(26).string(message.admin);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(40).uint64(message.version);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(50).fork()).ldelim();
        }
        if (message.createdAt !== void 0) {
          timestamp_1.Timestamp.encode(message.createdAt, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupPolicyInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.admin = reader.string();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.version = reader.uint64();
              break;
            case 6:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.createdAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupPolicyInfo();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        if ((0, helpers_1.isSet)(object.createdAt))
          obj.createdAt = (0, helpers_1.fromJsonTimestamp)(object.createdAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.admin !== void 0 && (obj.admin = message.admin);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        message.createdAt !== void 0 && (obj.createdAt = (0, helpers_1.fromTimestamp)(message.createdAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupPolicyInfo();
        message.address = object.address ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.admin = object.admin ?? "";
        message.metadata = object.metadata ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        if (object.createdAt !== void 0 && object.createdAt !== null) {
          message.createdAt = timestamp_1.Timestamp.fromPartial(object.createdAt);
        }
        return message;
      }
    };
    function createBaseProposal() {
      return {
        id: BigInt(0),
        groupPolicyAddress: "",
        metadata: "",
        proposers: [],
        submitTime: timestamp_1.Timestamp.fromPartial({}),
        groupVersion: BigInt(0),
        groupPolicyVersion: BigInt(0),
        status: 0,
        finalTallyResult: exports2.TallyResult.fromPartial({}),
        votingPeriodEnd: timestamp_1.Timestamp.fromPartial({}),
        executorResult: 0,
        messages: [],
        title: "",
        summary: ""
      };
    }
    exports2.Proposal = {
      typeUrl: "/cosmos.group.v1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        for (const v of message.proposers) {
          writer.uint32(34).string(v);
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.groupVersion !== BigInt(0)) {
          writer.uint32(48).uint64(message.groupVersion);
        }
        if (message.groupPolicyVersion !== BigInt(0)) {
          writer.uint32(56).uint64(message.groupPolicyVersion);
        }
        if (message.status !== 0) {
          writer.uint32(64).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports2.TallyResult.encode(message.finalTallyResult, writer.uint32(74).fork()).ldelim();
        }
        if (message.votingPeriodEnd !== void 0) {
          timestamp_1.Timestamp.encode(message.votingPeriodEnd, writer.uint32(82).fork()).ldelim();
        }
        if (message.executorResult !== 0) {
          writer.uint32(88).int32(message.executorResult);
        }
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(98).fork()).ldelim();
        }
        if (message.title !== "") {
          writer.uint32(106).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(114).string(message.summary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.proposers.push(reader.string());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.groupVersion = reader.uint64();
              break;
            case 7:
              message.groupPolicyVersion = reader.uint64();
              break;
            case 8:
              message.status = reader.int32();
              break;
            case 9:
              message.finalTallyResult = exports2.TallyResult.decode(reader, reader.uint32());
              break;
            case 10:
              message.votingPeriodEnd = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.executorResult = reader.int32();
              break;
            case 12:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 13:
              message.title = reader.string();
              break;
            case 14:
              message.summary = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if (Array.isArray(object == null ? void 0 : object.proposers))
          obj.proposers = object.proposers.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.groupVersion))
          obj.groupVersion = BigInt(object.groupVersion.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyVersion))
          obj.groupPolicyVersion = BigInt(object.groupPolicyVersion.toString());
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports2.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.votingPeriodEnd))
          obj.votingPeriodEnd = (0, helpers_1.fromJsonTimestamp)(object.votingPeriodEnd);
        if ((0, helpers_1.isSet)(object.executorResult))
          obj.executorResult = proposalExecutorResultFromJSON(object.executorResult);
        if (Array.isArray(object == null ? void 0 : object.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        if (message.proposers) {
          obj.proposers = message.proposers.map((e) => e);
        } else {
          obj.proposers = [];
        }
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.groupVersion !== void 0 && (obj.groupVersion = (message.groupVersion || BigInt(0)).toString());
        message.groupPolicyVersion !== void 0 && (obj.groupPolicyVersion = (message.groupPolicyVersion || BigInt(0)).toString());
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports2.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.votingPeriodEnd !== void 0 && (obj.votingPeriodEnd = (0, helpers_1.fromTimestamp)(message.votingPeriodEnd).toISOString());
        message.executorResult !== void 0 && (obj.executorResult = proposalExecutorResultToJSON(message.executorResult));
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseProposal();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.metadata = object.metadata ?? "";
        message.proposers = ((_a = object.proposers) == null ? void 0 : _a.map((e) => e)) || [];
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.groupVersion !== void 0 && object.groupVersion !== null) {
          message.groupVersion = BigInt(object.groupVersion.toString());
        }
        if (object.groupPolicyVersion !== void 0 && object.groupPolicyVersion !== null) {
          message.groupPolicyVersion = BigInt(object.groupPolicyVersion.toString());
        }
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports2.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.votingPeriodEnd !== void 0 && object.votingPeriodEnd !== null) {
          message.votingPeriodEnd = timestamp_1.Timestamp.fromPartial(object.votingPeriodEnd);
        }
        message.executorResult = object.executorResult ?? 0;
        message.messages = ((_b = object.messages) == null ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
      }
    };
    function createBaseTallyResult() {
      return {
        yesCount: "",
        abstainCount: "",
        noCount: "",
        noWithVetoCount: ""
      };
    }
    exports2.TallyResult = {
      typeUrl: "/cosmos.group.v1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yesCount !== "") {
          writer.uint32(10).string(message.yesCount);
        }
        if (message.abstainCount !== "") {
          writer.uint32(18).string(message.abstainCount);
        }
        if (message.noCount !== "") {
          writer.uint32(26).string(message.noCount);
        }
        if (message.noWithVetoCount !== "") {
          writer.uint32(34).string(message.noWithVetoCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yesCount = reader.string();
              break;
            case 2:
              message.abstainCount = reader.string();
              break;
            case 3:
              message.noCount = reader.string();
              break;
            case 4:
              message.noWithVetoCount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yesCount))
          obj.yesCount = String(object.yesCount);
        if ((0, helpers_1.isSet)(object.abstainCount))
          obj.abstainCount = String(object.abstainCount);
        if ((0, helpers_1.isSet)(object.noCount))
          obj.noCount = String(object.noCount);
        if ((0, helpers_1.isSet)(object.noWithVetoCount))
          obj.noWithVetoCount = String(object.noWithVetoCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yesCount !== void 0 && (obj.yesCount = message.yesCount);
        message.abstainCount !== void 0 && (obj.abstainCount = message.abstainCount);
        message.noCount !== void 0 && (obj.noCount = message.noCount);
        message.noWithVetoCount !== void 0 && (obj.noWithVetoCount = message.noWithVetoCount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult();
        message.yesCount = object.yesCount ?? "";
        message.abstainCount = object.abstainCount ?? "";
        message.noCount = object.noCount ?? "";
        message.noWithVetoCount = object.noWithVetoCount ?? "";
        return message;
      }
    };
    function createBaseVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: "",
        submitTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.Vote = {
      typeUrl: "/cosmos.group.v1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/group/v1/tx.js
var require_tx8 = __commonJS({
  "node_modules/cosmjs-types/cosmos/group/v1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgLeaveGroupResponse = exports2.MsgLeaveGroup = exports2.MsgExecResponse = exports2.MsgExec = exports2.MsgVoteResponse = exports2.MsgVote = exports2.MsgWithdrawProposalResponse = exports2.MsgWithdrawProposal = exports2.MsgSubmitProposalResponse = exports2.MsgSubmitProposal = exports2.MsgUpdateGroupPolicyMetadataResponse = exports2.MsgUpdateGroupPolicyMetadata = exports2.MsgUpdateGroupPolicyDecisionPolicyResponse = exports2.MsgUpdateGroupPolicyDecisionPolicy = exports2.MsgCreateGroupWithPolicyResponse = exports2.MsgCreateGroupWithPolicy = exports2.MsgUpdateGroupPolicyAdminResponse = exports2.MsgUpdateGroupPolicyAdmin = exports2.MsgCreateGroupPolicyResponse = exports2.MsgCreateGroupPolicy = exports2.MsgUpdateGroupMetadataResponse = exports2.MsgUpdateGroupMetadata = exports2.MsgUpdateGroupAdminResponse = exports2.MsgUpdateGroupAdmin = exports2.MsgUpdateGroupMembersResponse = exports2.MsgUpdateGroupMembers = exports2.MsgCreateGroupResponse = exports2.MsgCreateGroup = exports2.execToJSON = exports2.execFromJSON = exports2.Exec = exports2.protobufPackage = void 0;
    var types_1 = require_types();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.group.v1";
    var Exec;
    (function(Exec2) {
      Exec2[Exec2["EXEC_UNSPECIFIED"] = 0] = "EXEC_UNSPECIFIED";
      Exec2[Exec2["EXEC_TRY"] = 1] = "EXEC_TRY";
      Exec2[Exec2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Exec || (exports2.Exec = Exec = {}));
    function execFromJSON(object) {
      switch (object) {
        case 0:
        case "EXEC_UNSPECIFIED":
          return Exec.EXEC_UNSPECIFIED;
        case 1:
        case "EXEC_TRY":
          return Exec.EXEC_TRY;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Exec.UNRECOGNIZED;
      }
    }
    exports2.execFromJSON = execFromJSON;
    function execToJSON(object) {
      switch (object) {
        case Exec.EXEC_UNSPECIFIED:
          return "EXEC_UNSPECIFIED";
        case Exec.EXEC_TRY:
          return "EXEC_TRY";
        case Exec.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.execToJSON = execToJSON;
    function createBaseMsgCreateGroup() {
      return {
        admin: "",
        members: [],
        metadata: ""
      };
    }
    exports2.MsgCreateGroup = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroup",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        for (const v of message.members) {
          types_1.MemberRequest.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroup();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.members.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroup();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if (Array.isArray(object == null ? void 0 : object.members))
          obj.members = object.members.map((e) => types_1.MemberRequest.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        if (message.members) {
          obj.members = message.members.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.members = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgCreateGroup();
        message.admin = object.admin ?? "";
        message.members = ((_a = object.members) == null ? void 0 : _a.map((e) => types_1.MemberRequest.fromPartial(e))) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgCreateGroupResponse() {
      return {
        groupId: BigInt(0)
      };
    }
    exports2.MsgCreateGroupResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupResponse();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupResponse();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        return message;
      }
    };
    function createBaseMsgUpdateGroupMembers() {
      return {
        admin: "",
        groupId: BigInt(0),
        memberUpdates: []
      };
    }
    exports2.MsgUpdateGroupMembers = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        for (const v of message.memberUpdates) {
          types_1.MemberRequest.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMembers();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.memberUpdates.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupMembers();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if (Array.isArray(object == null ? void 0 : object.memberUpdates))
          obj.memberUpdates = object.memberUpdates.map((e) => types_1.MemberRequest.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        if (message.memberUpdates) {
          obj.memberUpdates = message.memberUpdates.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.memberUpdates = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgUpdateGroupMembers();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.memberUpdates = ((_a = object.memberUpdates) == null ? void 0 : _a.map((e) => types_1.MemberRequest.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgUpdateGroupMembersResponse() {
      return {};
    }
    exports2.MsgUpdateGroupMembersResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembersResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMembersResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupMembersResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupMembersResponse();
        return message;
      }
    };
    function createBaseMsgUpdateGroupAdmin() {
      return {
        admin: "",
        groupId: BigInt(0),
        newAdmin: ""
      };
    }
    exports2.MsgUpdateGroupAdmin = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.newAdmin !== "") {
          writer.uint32(26).string(message.newAdmin);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.newAdmin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupAdmin();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.newAdmin))
          obj.newAdmin = String(object.newAdmin);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupAdmin();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.newAdmin = object.newAdmin ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupAdminResponse() {
      return {};
    }
    exports2.MsgUpdateGroupAdminResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdminResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupAdminResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupAdminResponse();
        return message;
      }
    };
    function createBaseMsgUpdateGroupMetadata() {
      return {
        admin: "",
        groupId: BigInt(0),
        metadata: ""
      };
    }
    exports2.MsgUpdateGroupMetadata = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupMetadata();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupMetadata();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupMetadataResponse() {
      return {};
    }
    exports2.MsgUpdateGroupMetadataResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadataResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupMetadataResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupMetadataResponse();
        return message;
      }
    };
    function createBaseMsgCreateGroupPolicy() {
      return {
        admin: "",
        groupId: BigInt(0),
        metadata: "",
        decisionPolicy: void 0
      };
    }
    exports2.MsgCreateGroupPolicy = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupPolicy();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupPolicy();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.metadata = object.metadata ?? "";
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgCreateGroupPolicyResponse() {
      return {
        address: ""
      };
    }
    exports2.MsgCreateGroupPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupPolicyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupPolicyResponse();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupPolicyResponse();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyAdmin() {
      return {
        admin: "",
        groupPolicyAddress: "",
        newAdmin: ""
      };
    }
    exports2.MsgUpdateGroupPolicyAdmin = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.newAdmin !== "") {
          writer.uint32(26).string(message.newAdmin);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.newAdmin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyAdmin();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.newAdmin))
          obj.newAdmin = String(object.newAdmin);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyAdmin();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.newAdmin = object.newAdmin ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyAdminResponse() {
      return {};
    }
    exports2.MsgUpdateGroupPolicyAdminResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupPolicyAdminResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupPolicyAdminResponse();
        return message;
      }
    };
    function createBaseMsgCreateGroupWithPolicy() {
      return {
        admin: "",
        members: [],
        groupMetadata: "",
        groupPolicyMetadata: "",
        groupPolicyAsAdmin: false,
        decisionPolicy: void 0
      };
    }
    exports2.MsgCreateGroupWithPolicy = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        for (const v of message.members) {
          types_1.MemberRequest.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.groupMetadata !== "") {
          writer.uint32(26).string(message.groupMetadata);
        }
        if (message.groupPolicyMetadata !== "") {
          writer.uint32(34).string(message.groupPolicyMetadata);
        }
        if (message.groupPolicyAsAdmin === true) {
          writer.uint32(40).bool(message.groupPolicyAsAdmin);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupWithPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.members.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            case 3:
              message.groupMetadata = reader.string();
              break;
            case 4:
              message.groupPolicyMetadata = reader.string();
              break;
            case 5:
              message.groupPolicyAsAdmin = reader.bool();
              break;
            case 6:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupWithPolicy();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if (Array.isArray(object == null ? void 0 : object.members))
          obj.members = object.members.map((e) => types_1.MemberRequest.fromJSON(e));
        if ((0, helpers_1.isSet)(object.groupMetadata))
          obj.groupMetadata = String(object.groupMetadata);
        if ((0, helpers_1.isSet)(object.groupPolicyMetadata))
          obj.groupPolicyMetadata = String(object.groupPolicyMetadata);
        if ((0, helpers_1.isSet)(object.groupPolicyAsAdmin))
          obj.groupPolicyAsAdmin = Boolean(object.groupPolicyAsAdmin);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        if (message.members) {
          obj.members = message.members.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.members = [];
        }
        message.groupMetadata !== void 0 && (obj.groupMetadata = message.groupMetadata);
        message.groupPolicyMetadata !== void 0 && (obj.groupPolicyMetadata = message.groupPolicyMetadata);
        message.groupPolicyAsAdmin !== void 0 && (obj.groupPolicyAsAdmin = message.groupPolicyAsAdmin);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgCreateGroupWithPolicy();
        message.admin = object.admin ?? "";
        message.members = ((_a = object.members) == null ? void 0 : _a.map((e) => types_1.MemberRequest.fromPartial(e))) || [];
        message.groupMetadata = object.groupMetadata ?? "";
        message.groupPolicyMetadata = object.groupPolicyMetadata ?? "";
        message.groupPolicyAsAdmin = object.groupPolicyAsAdmin ?? false;
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgCreateGroupWithPolicyResponse() {
      return {
        groupId: BigInt(0),
        groupPolicyAddress: ""
      };
    }
    exports2.MsgCreateGroupWithPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupWithPolicyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupWithPolicyResponse();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupWithPolicyResponse();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyDecisionPolicy() {
      return {
        admin: "",
        groupPolicyAddress: "",
        decisionPolicy: void 0
      };
    }
    exports2.MsgUpdateGroupPolicyDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyDecisionPolicyResponse() {
      return {};
    }
    exports2.MsgUpdateGroupPolicyDecisionPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyMetadata() {
      return {
        admin: "",
        groupPolicyAddress: "",
        metadata: ""
      };
    }
    exports2.MsgUpdateGroupPolicyMetadata = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyMetadata();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyMetadata();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyMetadataResponse() {
      return {};
    }
    exports2.MsgUpdateGroupPolicyMetadataResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateGroupPolicyMetadataResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateGroupPolicyMetadataResponse();
        return message;
      }
    };
    function createBaseMsgSubmitProposal() {
      return {
        groupPolicyAddress: "",
        proposers: [],
        metadata: "",
        messages: [],
        exec: 0,
        title: "",
        summary: ""
      };
    }
    exports2.MsgSubmitProposal = {
      typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupPolicyAddress !== "") {
          writer.uint32(10).string(message.groupPolicyAddress);
        }
        for (const v of message.proposers) {
          writer.uint32(18).string(v);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        for (const v of message.messages) {
          any_1.Any.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.exec !== 0) {
          writer.uint32(40).int32(message.exec);
        }
        if (message.title !== "") {
          writer.uint32(50).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(58).string(message.summary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupPolicyAddress = reader.string();
              break;
            case 2:
              message.proposers.push(reader.string());
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 5:
              message.exec = reader.int32();
              break;
            case 6:
              message.title = reader.string();
              break;
            case 7:
              message.summary = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal();
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if (Array.isArray(object == null ? void 0 : object.proposers))
          obj.proposers = object.proposers.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if (Array.isArray(object == null ? void 0 : object.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.exec))
          obj.exec = execFromJSON(object.exec);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        if (message.proposers) {
          obj.proposers = message.proposers.map((e) => e);
        } else {
          obj.proposers = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.exec !== void 0 && (obj.exec = execToJSON(message.exec));
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSubmitProposal();
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.proposers = ((_a = object.proposers) == null ? void 0 : _a.map((e) => e)) || [];
        message.metadata = object.metadata ?? "";
        message.messages = ((_b = object.messages) == null ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        message.exec = object.exec ?? 0;
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports2.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.group.v1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgWithdrawProposal() {
      return {
        proposalId: BigInt(0),
        address: ""
      };
    }
    exports2.MsgWithdrawProposal = {
      typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.address !== "") {
          writer.uint32(18).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawProposal();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawProposal();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawProposalResponse() {
      return {};
    }
    exports2.MsgWithdrawProposalResponse = {
      typeUrl: "/cosmos.group.v1.MsgWithdrawProposalResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgWithdrawProposalResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgWithdrawProposalResponse();
        return message;
      }
    };
    function createBaseMsgVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: "",
        exec: 0
      };
    }
    exports2.MsgVote = {
      typeUrl: "/cosmos.group.v1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.exec !== 0) {
          writer.uint32(40).int32(message.exec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.exec = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, types_1.voteOptionFromJSON)(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.exec))
          obj.exec = execFromJSON(object.exec);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, types_1.voteOptionToJSON)(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.exec !== void 0 && (obj.exec = execToJSON(message.exec));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        message.exec = object.exec ?? 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports2.MsgVoteResponse = {
      typeUrl: "/cosmos.group.v1.MsgVoteResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgVoteResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgExec() {
      return {
        proposalId: BigInt(0),
        executor: ""
      };
    }
    exports2.MsgExec = {
      typeUrl: "/cosmos.group.v1.MsgExec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.executor !== "") {
          writer.uint32(18).string(message.executor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.executor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExec();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.executor))
          obj.executor = String(object.executor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.executor !== void 0 && (obj.executor = message.executor);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExec();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.executor = object.executor ?? "";
        return message;
      }
    };
    function createBaseMsgExecResponse() {
      return {
        result: 0
      };
    }
    exports2.MsgExecResponse = {
      typeUrl: "/cosmos.group.v1.MsgExecResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(16).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = (0, types_1.proposalExecutorResultFromJSON)(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = (0, types_1.proposalExecutorResultToJSON)(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgLeaveGroup() {
      return {
        address: "",
        groupId: BigInt(0)
      };
    }
    exports2.MsgLeaveGroup = {
      typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLeaveGroup();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgLeaveGroup();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgLeaveGroup();
        message.address = object.address ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        return message;
      }
    };
    function createBaseMsgLeaveGroupResponse() {
      return {};
    }
    exports2.MsgLeaveGroupResponse = {
      typeUrl: "/cosmos.group.v1.MsgLeaveGroupResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLeaveGroupResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgLeaveGroupResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgLeaveGroupResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateGroup = this.CreateGroup.bind(this);
        this.UpdateGroupMembers = this.UpdateGroupMembers.bind(this);
        this.UpdateGroupAdmin = this.UpdateGroupAdmin.bind(this);
        this.UpdateGroupMetadata = this.UpdateGroupMetadata.bind(this);
        this.CreateGroupPolicy = this.CreateGroupPolicy.bind(this);
        this.CreateGroupWithPolicy = this.CreateGroupWithPolicy.bind(this);
        this.UpdateGroupPolicyAdmin = this.UpdateGroupPolicyAdmin.bind(this);
        this.UpdateGroupPolicyDecisionPolicy = this.UpdateGroupPolicyDecisionPolicy.bind(this);
        this.UpdateGroupPolicyMetadata = this.UpdateGroupPolicyMetadata.bind(this);
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.WithdrawProposal = this.WithdrawProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Exec = this.Exec.bind(this);
        this.LeaveGroup = this.LeaveGroup.bind(this);
      }
      CreateGroup(request) {
        const data = exports2.MsgCreateGroup.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroup", data);
        return promise.then((data2) => exports2.MsgCreateGroupResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateGroupMembers(request) {
        const data = exports2.MsgUpdateGroupMembers.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMembers", data);
        return promise.then((data2) => exports2.MsgUpdateGroupMembersResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateGroupAdmin(request) {
        const data = exports2.MsgUpdateGroupAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupAdmin", data);
        return promise.then((data2) => exports2.MsgUpdateGroupAdminResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateGroupMetadata(request) {
        const data = exports2.MsgUpdateGroupMetadata.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMetadata", data);
        return promise.then((data2) => exports2.MsgUpdateGroupMetadataResponse.decode(new binary_1.BinaryReader(data2)));
      }
      CreateGroupPolicy(request) {
        const data = exports2.MsgCreateGroupPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroupPolicy", data);
        return promise.then((data2) => exports2.MsgCreateGroupPolicyResponse.decode(new binary_1.BinaryReader(data2)));
      }
      CreateGroupWithPolicy(request) {
        const data = exports2.MsgCreateGroupWithPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroupWithPolicy", data);
        return promise.then((data2) => exports2.MsgCreateGroupWithPolicyResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateGroupPolicyAdmin(request) {
        const data = exports2.MsgUpdateGroupPolicyAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyAdmin", data);
        return promise.then((data2) => exports2.MsgUpdateGroupPolicyAdminResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateGroupPolicyDecisionPolicy(request) {
        const data = exports2.MsgUpdateGroupPolicyDecisionPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyDecisionPolicy", data);
        return promise.then((data2) => exports2.MsgUpdateGroupPolicyDecisionPolicyResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateGroupPolicyMetadata(request) {
        const data = exports2.MsgUpdateGroupPolicyMetadata.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyMetadata", data);
        return promise.then((data2) => exports2.MsgUpdateGroupPolicyMetadataResponse.decode(new binary_1.BinaryReader(data2)));
      }
      SubmitProposal(request) {
        const data = exports2.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "SubmitProposal", data);
        return promise.then((data2) => exports2.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data2)));
      }
      WithdrawProposal(request) {
        const data = exports2.MsgWithdrawProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "WithdrawProposal", data);
        return promise.then((data2) => exports2.MsgWithdrawProposalResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Vote(request) {
        const data = exports2.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "Vote", data);
        return promise.then((data2) => exports2.MsgVoteResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Exec(request) {
        const data = exports2.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "Exec", data);
        return promise.then((data2) => exports2.MsgExecResponse.decode(new binary_1.BinaryReader(data2)));
      }
      LeaveGroup(request) {
        const data = exports2.MsgLeaveGroup.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "LeaveGroup", data);
        return promise.then((data2) => exports2.MsgLeaveGroupResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/group/messages.js
var require_messages6 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/group/messages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.groupTypes = void 0;
    var tx_1 = require_tx8();
    exports2.groupTypes = [
      ["/cosmos.group.v1.MsgCreateGroup", tx_1.MsgCreateGroup],
      ["/cosmos.group.v1.MsgCreateGroupPolicy", tx_1.MsgCreateGroupPolicy],
      ["/cosmos.group.v1.MsgCreateGroupWithPolicy", tx_1.MsgCreateGroupWithPolicy],
      ["/cosmos.group.v1.MsgExec", tx_1.MsgExec],
      ["/cosmos.group.v1.MsgLeaveGroup", tx_1.MsgLeaveGroup],
      ["/cosmos.group.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.group.v1.MsgUpdateGroupAdmin", tx_1.MsgUpdateGroupAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupMembers", tx_1.MsgUpdateGroupMembers],
      ["/cosmos.group.v1.MsgUpdateGroupMetadata", tx_1.MsgUpdateGroupMetadata],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", tx_1.MsgUpdateGroupPolicyAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", tx_1.MsgUpdateGroupPolicyDecisionPolicy],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", tx_1.MsgUpdateGroupPolicyMetadata],
      ["/cosmos.group.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.group.v1.MsgWithdrawProposal", tx_1.MsgWithdrawProposal]
    ];
  }
});

// node_modules/cosmjs-types/cosmos/upgrade/v1beta1/upgrade.js
var require_upgrade = __commonJS({
  "node_modules/cosmjs-types/cosmos/upgrade/v1beta1/upgrade.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ModuleVersion = exports2.CancelSoftwareUpgradeProposal = exports2.SoftwareUpgradeProposal = exports2.Plan = exports2.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.upgrade.v1beta1";
    function createBasePlan() {
      return {
        name: "",
        time: timestamp_1.Timestamp.fromPartial({}),
        height: BigInt(0),
        info: "",
        upgradedClientState: void 0
      };
    }
    exports2.Plan = {
      typeUrl: "/cosmos.upgrade.v1beta1.Plan",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePlan();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePlan();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.info !== void 0 && (obj.info = message.info);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePlan();
        message.name = object.name ?? "";
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.info = object.info ?? "";
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
    function createBaseSoftwareUpgradeProposal() {
      return {
        title: "",
        description: "",
        plan: exports2.Plan.fromPartial({})
      };
    }
    exports2.SoftwareUpgradeProposal = {
      typeUrl: "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          exports2.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = exports2.Plan.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSoftwareUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = exports2.Plan.fromJSON(object.plan);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? exports2.Plan.toJSON(message.plan) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSoftwareUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = exports2.Plan.fromPartial(object.plan);
        }
        return message;
      }
    };
    function createBaseCancelSoftwareUpgradeProposal() {
      return {
        title: "",
        description: ""
      };
    }
    exports2.CancelSoftwareUpgradeProposal = {
      typeUrl: "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCancelSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCancelSoftwareUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCancelSoftwareUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
      }
    };
    function createBaseModuleVersion() {
      return {
        name: "",
        version: BigInt(0)
      };
    }
    exports2.ModuleVersion = {
      typeUrl: "/cosmos.upgrade.v1beta1.ModuleVersion",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(16).uint64(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.version = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleVersion();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModuleVersion();
        message.name = object.name ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/ibc/core/client/v1/client.js
var require_client = __commonJS({
  "node_modules/cosmjs-types/ibc/core/client/v1/client.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.Height = exports2.UpgradeProposal = exports2.ClientUpdateProposal = exports2.ClientConsensusStates = exports2.ConsensusStateWithHeight = exports2.IdentifiedClientState = exports2.protobufPackage = void 0;
    var any_1 = require_any();
    var upgrade_1 = require_upgrade();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.core.client.v1";
    function createBaseIdentifiedClientState() {
      return {
        clientId: "",
        clientState: void 0
      };
    }
    exports2.IdentifiedClientState = {
      typeUrl: "/ibc.core.client.v1.IdentifiedClientState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedClientState();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIdentifiedClientState();
        message.clientId = object.clientId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        return message;
      }
    };
    function createBaseConsensusStateWithHeight() {
      return {
        height: exports2.Height.fromPartial({}),
        consensusState: void 0
      };
    }
    exports2.ConsensusStateWithHeight = {
      typeUrl: "/ibc.core.client.v1.ConsensusStateWithHeight",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== void 0) {
          exports2.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusStateWithHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = exports2.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusStateWithHeight();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = exports2.Height.fromJSON(object.height);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? exports2.Height.toJSON(message.height) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusStateWithHeight();
        if (object.height !== void 0 && object.height !== null) {
          message.height = exports2.Height.fromPartial(object.height);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        return message;
      }
    };
    function createBaseClientConsensusStates() {
      return {
        clientId: "",
        consensusStates: []
      };
    }
    exports2.ClientConsensusStates = {
      typeUrl: "/ibc.core.client.v1.ClientConsensusStates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.consensusStates) {
          exports2.ConsensusStateWithHeight.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientConsensusStates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.consensusStates.push(exports2.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientConsensusStates();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object == null ? void 0 : object.consensusStates))
          obj.consensusStates = object.consensusStates.map((e) => exports2.ConsensusStateWithHeight.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? exports2.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseClientConsensusStates();
        message.clientId = object.clientId ?? "";
        message.consensusStates = ((_a = object.consensusStates) == null ? void 0 : _a.map((e) => exports2.ConsensusStateWithHeight.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseClientUpdateProposal() {
      return {
        title: "",
        description: "",
        subjectClientId: "",
        substituteClientId: ""
      };
    }
    exports2.ClientUpdateProposal = {
      typeUrl: "/ibc.core.client.v1.ClientUpdateProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.subjectClientId !== "") {
          writer.uint32(26).string(message.subjectClientId);
        }
        if (message.substituteClientId !== "") {
          writer.uint32(34).string(message.substituteClientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientUpdateProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.subjectClientId = reader.string();
              break;
            case 4:
              message.substituteClientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientUpdateProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.subjectClientId))
          obj.subjectClientId = String(object.subjectClientId);
        if ((0, helpers_1.isSet)(object.substituteClientId))
          obj.substituteClientId = String(object.substituteClientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.subjectClientId !== void 0 && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== void 0 && (obj.substituteClientId = message.substituteClientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseClientUpdateProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.subjectClientId = object.subjectClientId ?? "";
        message.substituteClientId = object.substituteClientId ?? "";
        return message;
      }
    };
    function createBaseUpgradeProposal() {
      return {
        title: "",
        description: "",
        plan: upgrade_1.Plan.fromPartial({}),
        upgradedClientState: void 0
      };
    }
    exports2.UpgradeProposal = {
      typeUrl: "/ibc.core.client.v1.UpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
              break;
            case 4:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = upgrade_1.Plan.fromJSON(object.plan);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : void 0);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = upgrade_1.Plan.fromPartial(object.plan);
        }
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
    function createBaseHeight() {
      return {
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports2.Height = {
      typeUrl: "/ibc.core.client.v1.Height",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(8).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.revisionNumber = reader.uint64();
              break;
            case 2:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeight();
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeight();
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseParams() {
      return {
        allowedClients: []
      };
    }
    exports2.Params = {
      typeUrl: "/ibc.core.client.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.allowedClients) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowedClients.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if (Array.isArray(object == null ? void 0 : object.allowedClients))
          obj.allowedClients = object.allowedClients.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowedClients) {
          obj.allowedClients = message.allowedClients.map((e) => e);
        } else {
          obj.allowedClients = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseParams();
        message.allowedClients = ((_a = object.allowedClients) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js
var require_tx9 = __commonJS({
  "node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgTransferResponse = exports2.MsgTransfer = exports2.protobufPackage = void 0;
    var coin_1 = require_coin();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseMsgTransfer() {
      return {
        sourcePort: "",
        sourceChannel: "",
        token: coin_1.Coin.fromPartial({}),
        sender: "",
        receiver: "",
        timeoutHeight: client_1.Height.fromPartial({}),
        timeoutTimestamp: BigInt(0),
        memo: ""
      };
    }
    exports2.MsgTransfer = {
      typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sourcePort !== "") {
          writer.uint32(10).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(18).string(message.sourceChannel);
        }
        if (message.token !== void 0) {
          coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();
        }
        if (message.sender !== "") {
          writer.uint32(34).string(message.sender);
        }
        if (message.receiver !== "") {
          writer.uint32(42).string(message.receiver);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== BigInt(0)) {
          writer.uint32(56).uint64(message.timeoutTimestamp);
        }
        if (message.memo !== "") {
          writer.uint32(66).string(message.memo);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransfer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sourcePort = reader.string();
              break;
            case 2:
              message.sourceChannel = reader.string();
              break;
            case 3:
              message.token = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.sender = reader.string();
              break;
            case 5:
              message.receiver = reader.string();
              break;
            case 6:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.timeoutTimestamp = reader.uint64();
              break;
            case 8:
              message.memo = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTransfer();
        if ((0, helpers_1.isSet)(object.sourcePort))
          obj.sourcePort = String(object.sourcePort);
        if ((0, helpers_1.isSet)(object.sourceChannel))
          obj.sourceChannel = String(object.sourceChannel);
        if ((0, helpers_1.isSet)(object.token))
          obj.token = coin_1.Coin.fromJSON(object.token);
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.receiver))
          obj.receiver = String(object.receiver);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = client_1.Height.fromJSON(object.timeoutHeight);
        if ((0, helpers_1.isSet)(object.timeoutTimestamp))
          obj.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        if ((0, helpers_1.isSet)(object.memo))
          obj.memo = String(object.memo);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.token !== void 0 && (obj.token = message.token ? coin_1.Coin.toJSON(message.token) : void 0);
        message.sender !== void 0 && (obj.sender = message.sender);
        message.receiver !== void 0 && (obj.receiver = message.receiver);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt(0)).toString());
        message.memo !== void 0 && (obj.memo = message.memo);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTransfer();
        message.sourcePort = object.sourcePort ?? "";
        message.sourceChannel = object.sourceChannel ?? "";
        if (object.token !== void 0 && object.token !== null) {
          message.token = coin_1.Coin.fromPartial(object.token);
        }
        message.sender = object.sender ?? "";
        message.receiver = object.receiver ?? "";
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = client_1.Height.fromPartial(object.timeoutHeight);
        }
        if (object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null) {
          message.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        }
        message.memo = object.memo ?? "";
        return message;
      }
    };
    function createBaseMsgTransferResponse() {
      return {
        sequence: BigInt(0)
      };
    }
    exports2.MsgTransferResponse = {
      typeUrl: "/ibc.applications.transfer.v1.MsgTransferResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTransferResponse();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTransferResponse();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Transfer = this.Transfer.bind(this);
      }
      Transfer(request) {
        const data = exports2.MsgTransfer.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", data);
        return promise.then((data2) => exports2.MsgTransferResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js
var require_aminomessages9 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createIbcAminoConverters = exports2.isAminoMsgTransfer = void 0;
    var amino_1 = require_build7();
    var tx_1 = require_tx9();
    function isAminoMsgTransfer(msg) {
      return msg.type === "cosmos-sdk/MsgTransfer";
    }
    exports2.isAminoMsgTransfer = isAminoMsgTransfer;
    function createIbcAminoConverters() {
      return {
        "/ibc.applications.transfer.v1.MsgTransfer": {
          aminoType: "cosmos-sdk/MsgTransfer",
          toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp, memo }) => {
            var _a, _b, _c;
            return {
              source_port: sourcePort,
              source_channel: sourceChannel,
              token,
              sender,
              receiver,
              timeout_height: timeoutHeight ? {
                revision_height: (_a = (0, amino_1.omitDefault)(timeoutHeight.revisionHeight)) == null ? void 0 : _a.toString(),
                revision_number: (_b = (0, amino_1.omitDefault)(timeoutHeight.revisionNumber)) == null ? void 0 : _b.toString()
              } : {},
              timeout_timestamp: (_c = (0, amino_1.omitDefault)(timeoutTimestamp)) == null ? void 0 : _c.toString(),
              memo: (0, amino_1.omitDefault)(memo)
            };
          },
          fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo }) => tx_1.MsgTransfer.fromPartial({
            sourcePort: source_port,
            sourceChannel: source_channel,
            token,
            sender,
            receiver,
            timeoutHeight: timeout_height ? {
              revisionHeight: BigInt(timeout_height.revision_height || "0"),
              revisionNumber: BigInt(timeout_height.revision_number || "0")
            } : void 0,
            timeoutTimestamp: BigInt(timeout_timestamp || "0"),
            memo: memo ?? ""
          })
        }
      };
    }
    exports2.createIbcAminoConverters = createIbcAminoConverters;
  }
});

// node_modules/cosmjs-types/ibc/core/channel/v1/channel.js
var require_channel = __commonJS({
  "node_modules/cosmjs-types/ibc/core/channel/v1/channel.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Acknowledgement = exports2.PacketId = exports2.PacketState = exports2.Packet = exports2.Counterparty = exports2.IdentifiedChannel = exports2.Channel = exports2.orderToJSON = exports2.orderFromJSON = exports2.Order = exports2.stateToJSON = exports2.stateFromJSON = exports2.State = exports2.protobufPackage = void 0;
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.core.channel.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["STATE_CLOSED"] = 4] = "STATE_CLOSED";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State || (exports2.State = State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case 4:
        case "STATE_CLOSED":
          return State.STATE_CLOSED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports2.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        case State.STATE_CLOSED:
          return "STATE_CLOSED";
        case State.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.stateToJSON = stateToJSON;
    var Order;
    (function(Order2) {
      Order2[Order2["ORDER_NONE_UNSPECIFIED"] = 0] = "ORDER_NONE_UNSPECIFIED";
      Order2[Order2["ORDER_UNORDERED"] = 1] = "ORDER_UNORDERED";
      Order2[Order2["ORDER_ORDERED"] = 2] = "ORDER_ORDERED";
      Order2[Order2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Order || (exports2.Order = Order = {}));
    function orderFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_NONE_UNSPECIFIED":
          return Order.ORDER_NONE_UNSPECIFIED;
        case 1:
        case "ORDER_UNORDERED":
          return Order.ORDER_UNORDERED;
        case 2:
        case "ORDER_ORDERED":
          return Order.ORDER_ORDERED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Order.UNRECOGNIZED;
      }
    }
    exports2.orderFromJSON = orderFromJSON;
    function orderToJSON(object) {
      switch (object) {
        case Order.ORDER_NONE_UNSPECIFIED:
          return "ORDER_NONE_UNSPECIFIED";
        case Order.ORDER_UNORDERED:
          return "ORDER_UNORDERED";
        case Order.ORDER_ORDERED:
          return "ORDER_ORDERED";
        case Order.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.orderToJSON = orderToJSON;
    function createBaseChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: exports2.Counterparty.fromPartial({}),
        connectionHops: [],
        version: ""
      };
    }
    exports2.Channel = {
      typeUrl: "/ibc.core.channel.v1.Channel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports2.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports2.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseChannel();
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = orderFromJSON(object.ordering);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports2.Counterparty.fromJSON(object.counterparty);
        if (Array.isArray(object == null ? void 0 : object.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports2.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseChannel();
        message.state = object.state ?? 0;
        message.ordering = object.ordering ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports2.Counterparty.fromPartial(object.counterparty);
        }
        message.connectionHops = ((_a = object.connectionHops) == null ? void 0 : _a.map((e) => e)) || [];
        message.version = object.version ?? "";
        return message;
      }
    };
    function createBaseIdentifiedChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: exports2.Counterparty.fromPartial({}),
        connectionHops: [],
        version: "",
        portId: "",
        channelId: ""
      };
    }
    exports2.IdentifiedChannel = {
      typeUrl: "/ibc.core.channel.v1.IdentifiedChannel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports2.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        if (message.portId !== "") {
          writer.uint32(50).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(58).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports2.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            case 6:
              message.portId = reader.string();
              break;
            case 7:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedChannel();
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = orderFromJSON(object.ordering);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports2.Counterparty.fromJSON(object.counterparty);
        if (Array.isArray(object == null ? void 0 : object.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports2.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseIdentifiedChannel();
        message.state = object.state ?? 0;
        message.ordering = object.ordering ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports2.Counterparty.fromPartial(object.counterparty);
        }
        message.connectionHops = ((_a = object.connectionHops) == null ? void 0 : _a.map((e) => e)) || [];
        message.version = object.version ?? "";
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseCounterparty() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports2.Counterparty = {
      typeUrl: "/ibc.core.channel.v1.Counterparty",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCounterparty();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCounterparty();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBasePacket() {
      return {
        sequence: BigInt(0),
        sourcePort: "",
        sourceChannel: "",
        destinationPort: "",
        destinationChannel: "",
        data: new Uint8Array(),
        timeoutHeight: client_1.Height.fromPartial({}),
        timeoutTimestamp: BigInt(0)
      };
    }
    exports2.Packet = {
      typeUrl: "/ibc.core.channel.v1.Packet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        if (message.sourcePort !== "") {
          writer.uint32(18).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(26).string(message.sourceChannel);
        }
        if (message.destinationPort !== "") {
          writer.uint32(34).string(message.destinationPort);
        }
        if (message.destinationChannel !== "") {
          writer.uint32(42).string(message.destinationChannel);
        }
        if (message.data.length !== 0) {
          writer.uint32(50).bytes(message.data);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== BigInt(0)) {
          writer.uint32(64).uint64(message.timeoutTimestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            case 2:
              message.sourcePort = reader.string();
              break;
            case 3:
              message.sourceChannel = reader.string();
              break;
            case 4:
              message.destinationPort = reader.string();
              break;
            case 5:
              message.destinationChannel = reader.string();
              break;
            case 6:
              message.data = reader.bytes();
              break;
            case 7:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.timeoutTimestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacket();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.sourcePort))
          obj.sourcePort = String(object.sourcePort);
        if ((0, helpers_1.isSet)(object.sourceChannel))
          obj.sourceChannel = String(object.sourceChannel);
        if ((0, helpers_1.isSet)(object.destinationPort))
          obj.destinationPort = String(object.destinationPort);
        if ((0, helpers_1.isSet)(object.destinationChannel))
          obj.destinationChannel = String(object.destinationChannel);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = client_1.Height.fromJSON(object.timeoutHeight);
        if ((0, helpers_1.isSet)(object.timeoutTimestamp))
          obj.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.destinationPort !== void 0 && (obj.destinationPort = message.destinationPort);
        message.destinationChannel !== void 0 && (obj.destinationChannel = message.destinationChannel);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacket();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.sourcePort = object.sourcePort ?? "";
        message.sourceChannel = object.sourceChannel ?? "";
        message.destinationPort = object.destinationPort ?? "";
        message.destinationChannel = object.destinationChannel ?? "";
        message.data = object.data ?? new Uint8Array();
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = client_1.Height.fromPartial(object.timeoutHeight);
        }
        if (object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null) {
          message.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        }
        return message;
      }
    };
    function createBasePacketState() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0),
        data: new Uint8Array()
      };
    }
    exports2.PacketState = {
      typeUrl: "/ibc.core.channel.v1.PacketState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        if (message.data.length !== 0) {
          writer.uint32(34).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            case 4:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacketState();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacketState();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBasePacketId() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports2.PacketId = {
      typeUrl: "/ibc.core.channel.v1.PacketId",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketId();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacketId();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacketId();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseAcknowledgement() {
      return {
        result: void 0,
        error: void 0
      };
    }
    exports2.Acknowledgement = {
      typeUrl: "/ibc.core.channel.v1.Acknowledgement",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== void 0) {
          writer.uint32(170).bytes(message.result);
        }
        if (message.error !== void 0) {
          writer.uint32(178).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 21:
              message.result = reader.bytes();
              break;
            case 22:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAcknowledgement();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = (0, helpers_1.bytesFromBase64)(object.result);
        if ((0, helpers_1.isSet)(object.error))
          obj.error = String(object.error);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = message.result !== void 0 ? (0, helpers_1.base64FromBytes)(message.result) : void 0);
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAcknowledgement();
        message.result = object.result ?? void 0;
        message.error = object.error ?? void 0;
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/ibc/core/channel/v1/tx.js
var require_tx10 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/channel/v1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgAcknowledgementResponse = exports2.MsgAcknowledgement = exports2.MsgTimeoutOnCloseResponse = exports2.MsgTimeoutOnClose = exports2.MsgTimeoutResponse = exports2.MsgTimeout = exports2.MsgRecvPacketResponse = exports2.MsgRecvPacket = exports2.MsgChannelCloseConfirmResponse = exports2.MsgChannelCloseConfirm = exports2.MsgChannelCloseInitResponse = exports2.MsgChannelCloseInit = exports2.MsgChannelOpenConfirmResponse = exports2.MsgChannelOpenConfirm = exports2.MsgChannelOpenAckResponse = exports2.MsgChannelOpenAck = exports2.MsgChannelOpenTryResponse = exports2.MsgChannelOpenTry = exports2.MsgChannelOpenInitResponse = exports2.MsgChannelOpenInit = exports2.responseResultTypeToJSON = exports2.responseResultTypeFromJSON = exports2.ResponseResultType = exports2.protobufPackage = void 0;
    var channel_1 = require_channel();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.core.channel.v1";
    var ResponseResultType;
    (function(ResponseResultType2) {
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_UNSPECIFIED"] = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_NOOP"] = 1] = "RESPONSE_RESULT_TYPE_NOOP";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_SUCCESS"] = 2] = "RESPONSE_RESULT_TYPE_SUCCESS";
      ResponseResultType2[ResponseResultType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseResultType || (exports2.ResponseResultType = ResponseResultType = {}));
    function responseResultTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
          return ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED;
        case 1:
        case "RESPONSE_RESULT_TYPE_NOOP":
          return ResponseResultType.RESPONSE_RESULT_TYPE_NOOP;
        case 2:
        case "RESPONSE_RESULT_TYPE_SUCCESS":
          return ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseResultType.UNRECOGNIZED;
      }
    }
    exports2.responseResultTypeFromJSON = responseResultTypeFromJSON;
    function responseResultTypeToJSON(object) {
      switch (object) {
        case ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED:
          return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
        case ResponseResultType.RESPONSE_RESULT_TYPE_NOOP:
          return "RESPONSE_RESULT_TYPE_NOOP";
        case ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS:
          return "RESPONSE_RESULT_TYPE_SUCCESS";
        case ResponseResultType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.responseResultTypeToJSON = responseResultTypeToJSON;
    function createBaseMsgChannelOpenInit() {
      return {
        portId: "",
        channel: channel_1.Channel.fromPartial({}),
        signer: ""
      };
    }
    exports2.MsgChannelOpenInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenInit();
        message.portId = object.portId ?? "";
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenInitResponse() {
      return {
        channelId: "",
        version: ""
      };
    }
    exports2.MsgChannelOpenInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInitResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.channelId !== "") {
          writer.uint32(10).string(message.channelId);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channelId = reader.string();
              break;
            case 2:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenInitResponse();
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenInitResponse();
        message.channelId = object.channelId ?? "";
        message.version = object.version ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenTry() {
      return {
        portId: "",
        previousChannelId: "",
        channel: channel_1.Channel.fromPartial({}),
        counterpartyVersion: "",
        proofInit: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports2.MsgChannelOpenTry = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.previousChannelId !== "") {
          writer.uint32(18).string(message.previousChannelId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(42).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.previousChannelId = reader.string();
              break;
            case 3:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofInit = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenTry();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.previousChannelId))
          obj.previousChannelId = String(object.previousChannelId);
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.counterpartyVersion))
          obj.counterpartyVersion = String(object.counterpartyVersion);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.previousChannelId !== void 0 && (obj.previousChannelId = message.previousChannelId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenTry();
        message.portId = object.portId ?? "";
        message.previousChannelId = object.previousChannelId ?? "";
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.counterpartyVersion = object.counterpartyVersion ?? "";
        message.proofInit = object.proofInit ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenTryResponse() {
      return {
        version: ""
      };
    }
    exports2.MsgChannelOpenTryResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenTryResponse();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenTryResponse();
        message.version = object.version ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenAck() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelId: "",
        counterpartyVersion: "",
        proofTry: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports2.MsgChannelOpenAck = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelId !== "") {
          writer.uint32(26).string(message.counterpartyChannelId);
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(42).bytes(message.proofTry);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelId = reader.string();
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofTry = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenAck();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelId))
          obj.counterpartyChannelId = String(object.counterpartyChannelId);
        if ((0, helpers_1.isSet)(object.counterpartyVersion))
          obj.counterpartyVersion = String(object.counterpartyVersion);
        if ((0, helpers_1.isSet)(object.proofTry))
          obj.proofTry = (0, helpers_1.bytesFromBase64)(object.proofTry);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelId !== void 0 && (obj.counterpartyChannelId = message.counterpartyChannelId);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofTry !== void 0 && (obj.proofTry = (0, helpers_1.base64FromBytes)(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenAck();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelId = object.counterpartyChannelId ?? "";
        message.counterpartyVersion = object.counterpartyVersion ?? "";
        message.proofTry = object.proofTry ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenAckResponse() {
      return {};
    }
    exports2.MsgChannelOpenAckResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAckResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelOpenAckResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelOpenAckResponse();
        return message;
      }
    };
    function createBaseMsgChannelOpenConfirm() {
      return {
        portId: "",
        channelId: "",
        proofAck: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports2.MsgChannelOpenConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(26).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofAck = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.proofAck))
          obj.proofAck = (0, helpers_1.bytesFromBase64)(object.proofAck);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofAck !== void 0 && (obj.proofAck = (0, helpers_1.base64FromBytes)(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proofAck = object.proofAck ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenConfirmResponse() {
      return {};
    }
    exports2.MsgChannelOpenConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirmResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelOpenConfirmResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelOpenConfirmResponse();
        return message;
      }
    };
    function createBaseMsgChannelCloseInit() {
      return {
        portId: "",
        channelId: "",
        signer: ""
      };
    }
    exports2.MsgChannelCloseInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelCloseInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelCloseInit();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelCloseInitResponse() {
      return {};
    }
    exports2.MsgChannelCloseInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInitResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelCloseInitResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelCloseInitResponse();
        return message;
      }
    };
    function createBaseMsgChannelCloseConfirm() {
      return {
        portId: "",
        channelId: "",
        proofInit: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports2.MsgChannelCloseConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(26).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofInit = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelCloseConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelCloseConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proofInit = object.proofInit ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelCloseConfirmResponse() {
      return {};
    }
    exports2.MsgChannelCloseConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirmResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgChannelCloseConfirmResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgChannelCloseConfirmResponse();
        return message;
      }
    };
    function createBaseMsgRecvPacket() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofCommitment: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports2.MsgRecvPacket = {
      typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofCommitment.length !== 0) {
          writer.uint32(18).bytes(message.proofCommitment);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofCommitment = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecvPacket();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofCommitment))
          obj.proofCommitment = (0, helpers_1.bytesFromBase64)(object.proofCommitment);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofCommitment !== void 0 && (obj.proofCommitment = (0, helpers_1.base64FromBytes)(message.proofCommitment !== void 0 ? message.proofCommitment : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecvPacket();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofCommitment = object.proofCommitment ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgRecvPacketResponse() {
      return {
        result: 0
      };
    }
    exports2.MsgRecvPacketResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgRecvPacketResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacketResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecvPacketResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecvPacketResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgTimeout() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofUnreceived: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        nextSequenceRecv: BigInt(0),
        signer: ""
      };
    }
    exports2.MsgTimeout = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeout",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.nextSequenceRecv !== BigInt(0)) {
          writer.uint32(32).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeout();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofUnreceived))
          obj.proofUnreceived = (0, helpers_1.bytesFromBase64)(object.proofUnreceived);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.nextSequenceRecv))
          obj.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = (0, helpers_1.base64FromBytes)(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeout();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofUnreceived = object.proofUnreceived ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null) {
          message.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgTimeoutResponse() {
      return {
        result: 0
      };
    }
    exports2.MsgTimeoutResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgTimeoutOnClose() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofUnreceived: new Uint8Array(),
        proofClose: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        nextSequenceRecv: BigInt(0),
        signer: ""
      };
    }
    exports2.MsgTimeoutOnClose = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofClose.length !== 0) {
          writer.uint32(26).bytes(message.proofClose);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.nextSequenceRecv !== BigInt(0)) {
          writer.uint32(40).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnClose();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofClose = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutOnClose();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofUnreceived))
          obj.proofUnreceived = (0, helpers_1.bytesFromBase64)(object.proofUnreceived);
        if ((0, helpers_1.isSet)(object.proofClose))
          obj.proofClose = (0, helpers_1.bytesFromBase64)(object.proofClose);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.nextSequenceRecv))
          obj.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = (0, helpers_1.base64FromBytes)(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofClose !== void 0 && (obj.proofClose = (0, helpers_1.base64FromBytes)(message.proofClose !== void 0 ? message.proofClose : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutOnClose();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofUnreceived = object.proofUnreceived ?? new Uint8Array();
        message.proofClose = object.proofClose ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null) {
          message.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgTimeoutOnCloseResponse() {
      return {
        result: 0
      };
    }
    exports2.MsgTimeoutOnCloseResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnCloseResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnCloseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutOnCloseResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutOnCloseResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgAcknowledgement() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        acknowledgement: new Uint8Array(),
        proofAcked: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports2.MsgAcknowledgement = {
      typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.acknowledgement.length !== 0) {
          writer.uint32(18).bytes(message.acknowledgement);
        }
        if (message.proofAcked.length !== 0) {
          writer.uint32(26).bytes(message.proofAcked);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.acknowledgement = reader.bytes();
              break;
            case 3:
              message.proofAcked = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgAcknowledgement();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.acknowledgement))
          obj.acknowledgement = (0, helpers_1.bytesFromBase64)(object.acknowledgement);
        if ((0, helpers_1.isSet)(object.proofAcked))
          obj.proofAcked = (0, helpers_1.bytesFromBase64)(object.proofAcked);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.acknowledgement !== void 0 && (obj.acknowledgement = (0, helpers_1.base64FromBytes)(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proofAcked !== void 0 && (obj.proofAcked = (0, helpers_1.base64FromBytes)(message.proofAcked !== void 0 ? message.proofAcked : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgAcknowledgement();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.acknowledgement = object.acknowledgement ?? new Uint8Array();
        message.proofAcked = object.proofAcked ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgAcknowledgementResponse() {
      return {
        result: 0
      };
    }
    exports2.MsgAcknowledgementResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgAcknowledgementResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgementResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgAcknowledgementResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgAcknowledgementResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ChannelOpenInit = this.ChannelOpenInit.bind(this);
        this.ChannelOpenTry = this.ChannelOpenTry.bind(this);
        this.ChannelOpenAck = this.ChannelOpenAck.bind(this);
        this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this);
        this.ChannelCloseInit = this.ChannelCloseInit.bind(this);
        this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this);
        this.RecvPacket = this.RecvPacket.bind(this);
        this.Timeout = this.Timeout.bind(this);
        this.TimeoutOnClose = this.TimeoutOnClose.bind(this);
        this.Acknowledgement = this.Acknowledgement.bind(this);
      }
      ChannelOpenInit(request) {
        const data = exports2.MsgChannelOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", data);
        return promise.then((data2) => exports2.MsgChannelOpenInitResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ChannelOpenTry(request) {
        const data = exports2.MsgChannelOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", data);
        return promise.then((data2) => exports2.MsgChannelOpenTryResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ChannelOpenAck(request) {
        const data = exports2.MsgChannelOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", data);
        return promise.then((data2) => exports2.MsgChannelOpenAckResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ChannelOpenConfirm(request) {
        const data = exports2.MsgChannelOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", data);
        return promise.then((data2) => exports2.MsgChannelOpenConfirmResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ChannelCloseInit(request) {
        const data = exports2.MsgChannelCloseInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", data);
        return promise.then((data2) => exports2.MsgChannelCloseInitResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ChannelCloseConfirm(request) {
        const data = exports2.MsgChannelCloseConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", data);
        return promise.then((data2) => exports2.MsgChannelCloseConfirmResponse.decode(new binary_1.BinaryReader(data2)));
      }
      RecvPacket(request) {
        const data = exports2.MsgRecvPacket.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", data);
        return promise.then((data2) => exports2.MsgRecvPacketResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Timeout(request) {
        const data = exports2.MsgTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", data);
        return promise.then((data2) => exports2.MsgTimeoutResponse.decode(new binary_1.BinaryReader(data2)));
      }
      TimeoutOnClose(request) {
        const data = exports2.MsgTimeoutOnClose.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", data);
        return promise.then((data2) => exports2.MsgTimeoutOnCloseResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Acknowledgement(request) {
        const data = exports2.MsgAcknowledgement.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", data);
        return promise.then((data2) => exports2.MsgAcknowledgementResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/cosmjs-types/ibc/core/client/v1/tx.js
var require_tx11 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/client/v1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgSubmitMisbehaviourResponse = exports2.MsgSubmitMisbehaviour = exports2.MsgUpgradeClientResponse = exports2.MsgUpgradeClient = exports2.MsgUpdateClientResponse = exports2.MsgUpdateClient = exports2.MsgCreateClientResponse = exports2.MsgCreateClient = exports2.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.core.client.v1";
    function createBaseMsgCreateClient() {
      return {
        clientState: void 0,
        consensusState: void 0,
        signer: ""
      };
    }
    exports2.MsgCreateClient = {
      typeUrl: "/ibc.core.client.v1.MsgCreateClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateClient();
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateClient();
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgCreateClientResponse() {
      return {};
    }
    exports2.MsgCreateClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgCreateClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreateClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateClientResponse();
        return message;
      }
    };
    function createBaseMsgUpdateClient() {
      return {
        clientId: "",
        clientMessage: void 0,
        signer: ""
      };
    }
    exports2.MsgUpdateClient = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientMessage !== void 0) {
          any_1.Any.encode(message.clientMessage, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientMessage = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateClient();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientMessage))
          obj.clientMessage = any_1.Any.fromJSON(object.clientMessage);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientMessage !== void 0 && (obj.clientMessage = message.clientMessage ? any_1.Any.toJSON(message.clientMessage) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateClient();
        message.clientId = object.clientId ?? "";
        if (object.clientMessage !== void 0 && object.clientMessage !== null) {
          message.clientMessage = any_1.Any.fromPartial(object.clientMessage);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateClientResponse() {
      return {};
    }
    exports2.MsgUpdateClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateClientResponse();
        return message;
      }
    };
    function createBaseMsgUpgradeClient() {
      return {
        clientId: "",
        clientState: void 0,
        consensusState: void 0,
        proofUpgradeClient: new Uint8Array(),
        proofUpgradeConsensusState: new Uint8Array(),
        signer: ""
      };
    }
    exports2.MsgUpgradeClient = {
      typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofUpgradeClient.length !== 0) {
          writer.uint32(34).bytes(message.proofUpgradeClient);
        }
        if (message.proofUpgradeConsensusState.length !== 0) {
          writer.uint32(42).bytes(message.proofUpgradeConsensusState);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofUpgradeClient = reader.bytes();
              break;
            case 5:
              message.proofUpgradeConsensusState = reader.bytes();
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpgradeClient();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.proofUpgradeClient))
          obj.proofUpgradeClient = (0, helpers_1.bytesFromBase64)(object.proofUpgradeClient);
        if ((0, helpers_1.isSet)(object.proofUpgradeConsensusState))
          obj.proofUpgradeConsensusState = (0, helpers_1.bytesFromBase64)(object.proofUpgradeConsensusState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proofUpgradeClient !== void 0 && (obj.proofUpgradeClient = (0, helpers_1.base64FromBytes)(message.proofUpgradeClient !== void 0 ? message.proofUpgradeClient : new Uint8Array()));
        message.proofUpgradeConsensusState !== void 0 && (obj.proofUpgradeConsensusState = (0, helpers_1.base64FromBytes)(message.proofUpgradeConsensusState !== void 0 ? message.proofUpgradeConsensusState : new Uint8Array()));
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpgradeClient();
        message.clientId = object.clientId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.proofUpgradeClient = object.proofUpgradeClient ?? new Uint8Array();
        message.proofUpgradeConsensusState = object.proofUpgradeConsensusState ?? new Uint8Array();
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgUpgradeClientResponse() {
      return {};
    }
    exports2.MsgUpgradeClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpgradeClientResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpgradeClientResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpgradeClientResponse();
        return message;
      }
    };
    function createBaseMsgSubmitMisbehaviour() {
      return {
        clientId: "",
        misbehaviour: void 0,
        signer: ""
      };
    }
    exports2.MsgSubmitMisbehaviour = {
      typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.misbehaviour !== void 0) {
          any_1.Any.encode(message.misbehaviour, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviour();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.misbehaviour = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitMisbehaviour();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.misbehaviour))
          obj.misbehaviour = any_1.Any.fromJSON(object.misbehaviour);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.misbehaviour !== void 0 && (obj.misbehaviour = message.misbehaviour ? any_1.Any.toJSON(message.misbehaviour) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitMisbehaviour();
        message.clientId = object.clientId ?? "";
        if (object.misbehaviour !== void 0 && object.misbehaviour !== null) {
          message.misbehaviour = any_1.Any.fromPartial(object.misbehaviour);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitMisbehaviourResponse() {
      return {};
    }
    exports2.MsgSubmitMisbehaviourResponse = {
      typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviourResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviourResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgSubmitMisbehaviourResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgSubmitMisbehaviourResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateClient = this.CreateClient.bind(this);
        this.UpdateClient = this.UpdateClient.bind(this);
        this.UpgradeClient = this.UpgradeClient.bind(this);
        this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
      }
      CreateClient(request) {
        const data = exports2.MsgCreateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", data);
        return promise.then((data2) => exports2.MsgCreateClientResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateClient(request) {
        const data = exports2.MsgUpdateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", data);
        return promise.then((data2) => exports2.MsgUpdateClientResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpgradeClient(request) {
        const data = exports2.MsgUpgradeClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", data);
        return promise.then((data2) => exports2.MsgUpgradeClientResponse.decode(new binary_1.BinaryReader(data2)));
      }
      SubmitMisbehaviour(request) {
        const data = exports2.MsgSubmitMisbehaviour.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", data);
        return promise.then((data2) => exports2.MsgSubmitMisbehaviourResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/cosmjs-types/cosmos/ics23/v1/proofs.js
var require_proofs2 = __commonJS({
  "node_modules/cosmjs-types/cosmos/ics23/v1/proofs.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompressedNonExistenceProof = exports2.CompressedExistenceProof = exports2.CompressedBatchEntry = exports2.CompressedBatchProof = exports2.BatchEntry = exports2.BatchProof = exports2.InnerSpec = exports2.ProofSpec = exports2.InnerOp = exports2.LeafOp = exports2.CommitmentProof = exports2.NonExistenceProof = exports2.ExistenceProof = exports2.lengthOpToJSON = exports2.lengthOpFromJSON = exports2.LengthOp = exports2.hashOpToJSON = exports2.hashOpFromJSON = exports2.HashOp = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.ics23.v1";
    var HashOp;
    (function(HashOp2) {
      HashOp2[HashOp2["NO_HASH"] = 0] = "NO_HASH";
      HashOp2[HashOp2["SHA256"] = 1] = "SHA256";
      HashOp2[HashOp2["SHA512"] = 2] = "SHA512";
      HashOp2[HashOp2["KECCAK"] = 3] = "KECCAK";
      HashOp2[HashOp2["RIPEMD160"] = 4] = "RIPEMD160";
      HashOp2[HashOp2["BITCOIN"] = 5] = "BITCOIN";
      HashOp2[HashOp2["SHA512_256"] = 6] = "SHA512_256";
      HashOp2[HashOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(HashOp || (exports2.HashOp = HashOp = {}));
    function hashOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_HASH":
          return HashOp.NO_HASH;
        case 1:
        case "SHA256":
          return HashOp.SHA256;
        case 2:
        case "SHA512":
          return HashOp.SHA512;
        case 3:
        case "KECCAK":
          return HashOp.KECCAK;
        case 4:
        case "RIPEMD160":
          return HashOp.RIPEMD160;
        case 5:
        case "BITCOIN":
          return HashOp.BITCOIN;
        case 6:
        case "SHA512_256":
          return HashOp.SHA512_256;
        case -1:
        case "UNRECOGNIZED":
        default:
          return HashOp.UNRECOGNIZED;
      }
    }
    exports2.hashOpFromJSON = hashOpFromJSON;
    function hashOpToJSON(object) {
      switch (object) {
        case HashOp.NO_HASH:
          return "NO_HASH";
        case HashOp.SHA256:
          return "SHA256";
        case HashOp.SHA512:
          return "SHA512";
        case HashOp.KECCAK:
          return "KECCAK";
        case HashOp.RIPEMD160:
          return "RIPEMD160";
        case HashOp.BITCOIN:
          return "BITCOIN";
        case HashOp.SHA512_256:
          return "SHA512_256";
        case HashOp.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.hashOpToJSON = hashOpToJSON;
    var LengthOp;
    (function(LengthOp2) {
      LengthOp2[LengthOp2["NO_PREFIX"] = 0] = "NO_PREFIX";
      LengthOp2[LengthOp2["VAR_PROTO"] = 1] = "VAR_PROTO";
      LengthOp2[LengthOp2["VAR_RLP"] = 2] = "VAR_RLP";
      LengthOp2[LengthOp2["FIXED32_BIG"] = 3] = "FIXED32_BIG";
      LengthOp2[LengthOp2["FIXED32_LITTLE"] = 4] = "FIXED32_LITTLE";
      LengthOp2[LengthOp2["FIXED64_BIG"] = 5] = "FIXED64_BIG";
      LengthOp2[LengthOp2["FIXED64_LITTLE"] = 6] = "FIXED64_LITTLE";
      LengthOp2[LengthOp2["REQUIRE_32_BYTES"] = 7] = "REQUIRE_32_BYTES";
      LengthOp2[LengthOp2["REQUIRE_64_BYTES"] = 8] = "REQUIRE_64_BYTES";
      LengthOp2[LengthOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LengthOp || (exports2.LengthOp = LengthOp = {}));
    function lengthOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_PREFIX":
          return LengthOp.NO_PREFIX;
        case 1:
        case "VAR_PROTO":
          return LengthOp.VAR_PROTO;
        case 2:
        case "VAR_RLP":
          return LengthOp.VAR_RLP;
        case 3:
        case "FIXED32_BIG":
          return LengthOp.FIXED32_BIG;
        case 4:
        case "FIXED32_LITTLE":
          return LengthOp.FIXED32_LITTLE;
        case 5:
        case "FIXED64_BIG":
          return LengthOp.FIXED64_BIG;
        case 6:
        case "FIXED64_LITTLE":
          return LengthOp.FIXED64_LITTLE;
        case 7:
        case "REQUIRE_32_BYTES":
          return LengthOp.REQUIRE_32_BYTES;
        case 8:
        case "REQUIRE_64_BYTES":
          return LengthOp.REQUIRE_64_BYTES;
        case -1:
        case "UNRECOGNIZED":
        default:
          return LengthOp.UNRECOGNIZED;
      }
    }
    exports2.lengthOpFromJSON = lengthOpFromJSON;
    function lengthOpToJSON(object) {
      switch (object) {
        case LengthOp.NO_PREFIX:
          return "NO_PREFIX";
        case LengthOp.VAR_PROTO:
          return "VAR_PROTO";
        case LengthOp.VAR_RLP:
          return "VAR_RLP";
        case LengthOp.FIXED32_BIG:
          return "FIXED32_BIG";
        case LengthOp.FIXED32_LITTLE:
          return "FIXED32_LITTLE";
        case LengthOp.FIXED64_BIG:
          return "FIXED64_BIG";
        case LengthOp.FIXED64_LITTLE:
          return "FIXED64_LITTLE";
        case LengthOp.REQUIRE_32_BYTES:
          return "REQUIRE_32_BYTES";
        case LengthOp.REQUIRE_64_BYTES:
          return "REQUIRE_64_BYTES";
        case LengthOp.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.lengthOpToJSON = lengthOpToJSON;
    function createBaseExistenceProof() {
      return {
        key: new Uint8Array(),
        value: new Uint8Array(),
        leaf: void 0,
        path: []
      };
    }
    exports2.ExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.ExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports2.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.path) {
          exports2.InnerOp.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports2.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              message.path.push(exports2.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.leaf))
          obj.leaf = exports2.LeafOp.fromJSON(object.leaf);
        if (Array.isArray(object == null ? void 0 : object.path))
          obj.path = object.path.map((e) => exports2.InnerOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports2.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => e ? exports2.InnerOp.toJSON(e) : void 0);
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseExistenceProof();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.leaf !== void 0 && object.leaf !== null) {
          message.leaf = exports2.LeafOp.fromPartial(object.leaf);
        }
        message.path = ((_a = object.path) == null ? void 0 : _a.map((e) => exports2.InnerOp.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseNonExistenceProof() {
      return {
        key: new Uint8Array(),
        left: void 0,
        right: void 0
      };
    }
    exports2.NonExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.NonExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports2.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports2.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseNonExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports2.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports2.ExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseNonExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.left))
          obj.left = exports2.ExistenceProof.fromJSON(object.left);
        if ((0, helpers_1.isSet)(object.right))
          obj.right = exports2.ExistenceProof.fromJSON(object.right);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports2.ExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports2.ExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseNonExistenceProof();
        message.key = object.key ?? new Uint8Array();
        if (object.left !== void 0 && object.left !== null) {
          message.left = exports2.ExistenceProof.fromPartial(object.left);
        }
        if (object.right !== void 0 && object.right !== null) {
          message.right = exports2.ExistenceProof.fromPartial(object.right);
        }
        return message;
      }
    };
    function createBaseCommitmentProof() {
      return {
        exist: void 0,
        nonexist: void 0,
        batch: void 0,
        compressed: void 0
      };
    }
    exports2.CommitmentProof = {
      typeUrl: "/cosmos.ics23.v1.CommitmentProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports2.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports2.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        if (message.batch !== void 0) {
          exports2.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();
        }
        if (message.compressed !== void 0) {
          exports2.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitmentProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports2.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports2.NonExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.batch = exports2.BatchProof.decode(reader, reader.uint32());
              break;
            case 4:
              message.compressed = exports2.CompressedBatchProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitmentProof();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports2.ExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports2.NonExistenceProof.fromJSON(object.nonexist);
        if ((0, helpers_1.isSet)(object.batch))
          obj.batch = exports2.BatchProof.fromJSON(object.batch);
        if ((0, helpers_1.isSet)(object.compressed))
          obj.compressed = exports2.CompressedBatchProof.fromJSON(object.compressed);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports2.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports2.NonExistenceProof.toJSON(message.nonexist) : void 0);
        message.batch !== void 0 && (obj.batch = message.batch ? exports2.BatchProof.toJSON(message.batch) : void 0);
        message.compressed !== void 0 && (obj.compressed = message.compressed ? exports2.CompressedBatchProof.toJSON(message.compressed) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitmentProof();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports2.ExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports2.NonExistenceProof.fromPartial(object.nonexist);
        }
        if (object.batch !== void 0 && object.batch !== null) {
          message.batch = exports2.BatchProof.fromPartial(object.batch);
        }
        if (object.compressed !== void 0 && object.compressed !== null) {
          message.compressed = exports2.CompressedBatchProof.fromPartial(object.compressed);
        }
        return message;
      }
    };
    function createBaseLeafOp() {
      return {
        hash: 0,
        prehashKey: 0,
        prehashValue: 0,
        length: 0,
        prefix: new Uint8Array()
      };
    }
    exports2.LeafOp = {
      typeUrl: "/cosmos.ics23.v1.LeafOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prehashKey !== 0) {
          writer.uint32(16).int32(message.prehashKey);
        }
        if (message.prehashValue !== 0) {
          writer.uint32(24).int32(message.prehashValue);
        }
        if (message.length !== 0) {
          writer.uint32(32).int32(message.length);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(42).bytes(message.prefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLeafOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prehashKey = reader.int32();
              break;
            case 3:
              message.prehashValue = reader.int32();
              break;
            case 4:
              message.length = reader.int32();
              break;
            case 5:
              message.prefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLeafOp();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        if ((0, helpers_1.isSet)(object.prehashKey))
          obj.prehashKey = hashOpFromJSON(object.prehashKey);
        if ((0, helpers_1.isSet)(object.prehashValue))
          obj.prehashValue = hashOpFromJSON(object.prehashValue);
        if ((0, helpers_1.isSet)(object.length))
          obj.length = lengthOpFromJSON(object.length);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = (0, helpers_1.bytesFromBase64)(object.prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prehashKey !== void 0 && (obj.prehashKey = hashOpToJSON(message.prehashKey));
        message.prehashValue !== void 0 && (obj.prehashValue = hashOpToJSON(message.prehashValue));
        message.length !== void 0 && (obj.length = lengthOpToJSON(message.length));
        message.prefix !== void 0 && (obj.prefix = (0, helpers_1.base64FromBytes)(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLeafOp();
        message.hash = object.hash ?? 0;
        message.prehashKey = object.prehashKey ?? 0;
        message.prehashValue = object.prehashValue ?? 0;
        message.length = object.length ?? 0;
        message.prefix = object.prefix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseInnerOp() {
      return {
        hash: 0,
        prefix: new Uint8Array(),
        suffix: new Uint8Array()
      };
    }
    exports2.InnerOp = {
      typeUrl: "/cosmos.ics23.v1.InnerOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(18).bytes(message.prefix);
        }
        if (message.suffix.length !== 0) {
          writer.uint32(26).bytes(message.suffix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInnerOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prefix = reader.bytes();
              break;
            case 3:
              message.suffix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInnerOp();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = (0, helpers_1.bytesFromBase64)(object.prefix);
        if ((0, helpers_1.isSet)(object.suffix))
          obj.suffix = (0, helpers_1.bytesFromBase64)(object.suffix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prefix !== void 0 && (obj.prefix = (0, helpers_1.base64FromBytes)(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        message.suffix !== void 0 && (obj.suffix = (0, helpers_1.base64FromBytes)(message.suffix !== void 0 ? message.suffix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseInnerOp();
        message.hash = object.hash ?? 0;
        message.prefix = object.prefix ?? new Uint8Array();
        message.suffix = object.suffix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProofSpec() {
      return {
        leafSpec: void 0,
        innerSpec: void 0,
        maxDepth: 0,
        minDepth: 0
      };
    }
    exports2.ProofSpec = {
      typeUrl: "/cosmos.ics23.v1.ProofSpec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.leafSpec !== void 0) {
          exports2.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();
        }
        if (message.innerSpec !== void 0) {
          exports2.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxDepth !== 0) {
          writer.uint32(24).int32(message.maxDepth);
        }
        if (message.minDepth !== 0) {
          writer.uint32(32).int32(message.minDepth);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofSpec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.leafSpec = exports2.LeafOp.decode(reader, reader.uint32());
              break;
            case 2:
              message.innerSpec = exports2.InnerSpec.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxDepth = reader.int32();
              break;
            case 4:
              message.minDepth = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofSpec();
        if ((0, helpers_1.isSet)(object.leafSpec))
          obj.leafSpec = exports2.LeafOp.fromJSON(object.leafSpec);
        if ((0, helpers_1.isSet)(object.innerSpec))
          obj.innerSpec = exports2.InnerSpec.fromJSON(object.innerSpec);
        if ((0, helpers_1.isSet)(object.maxDepth))
          obj.maxDepth = Number(object.maxDepth);
        if ((0, helpers_1.isSet)(object.minDepth))
          obj.minDepth = Number(object.minDepth);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.leafSpec !== void 0 && (obj.leafSpec = message.leafSpec ? exports2.LeafOp.toJSON(message.leafSpec) : void 0);
        message.innerSpec !== void 0 && (obj.innerSpec = message.innerSpec ? exports2.InnerSpec.toJSON(message.innerSpec) : void 0);
        message.maxDepth !== void 0 && (obj.maxDepth = Math.round(message.maxDepth));
        message.minDepth !== void 0 && (obj.minDepth = Math.round(message.minDepth));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProofSpec();
        if (object.leafSpec !== void 0 && object.leafSpec !== null) {
          message.leafSpec = exports2.LeafOp.fromPartial(object.leafSpec);
        }
        if (object.innerSpec !== void 0 && object.innerSpec !== null) {
          message.innerSpec = exports2.InnerSpec.fromPartial(object.innerSpec);
        }
        message.maxDepth = object.maxDepth ?? 0;
        message.minDepth = object.minDepth ?? 0;
        return message;
      }
    };
    function createBaseInnerSpec() {
      return {
        childOrder: [],
        childSize: 0,
        minPrefixLength: 0,
        maxPrefixLength: 0,
        emptyChild: new Uint8Array(),
        hash: 0
      };
    }
    exports2.InnerSpec = {
      typeUrl: "/cosmos.ics23.v1.InnerSpec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.childOrder) {
          writer.int32(v);
        }
        writer.ldelim();
        if (message.childSize !== 0) {
          writer.uint32(16).int32(message.childSize);
        }
        if (message.minPrefixLength !== 0) {
          writer.uint32(24).int32(message.minPrefixLength);
        }
        if (message.maxPrefixLength !== 0) {
          writer.uint32(32).int32(message.maxPrefixLength);
        }
        if (message.emptyChild.length !== 0) {
          writer.uint32(42).bytes(message.emptyChild);
        }
        if (message.hash !== 0) {
          writer.uint32(48).int32(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInnerSpec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.childOrder.push(reader.int32());
                }
              } else {
                message.childOrder.push(reader.int32());
              }
              break;
            case 2:
              message.childSize = reader.int32();
              break;
            case 3:
              message.minPrefixLength = reader.int32();
              break;
            case 4:
              message.maxPrefixLength = reader.int32();
              break;
            case 5:
              message.emptyChild = reader.bytes();
              break;
            case 6:
              message.hash = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInnerSpec();
        if (Array.isArray(object == null ? void 0 : object.childOrder))
          obj.childOrder = object.childOrder.map((e) => Number(e));
        if ((0, helpers_1.isSet)(object.childSize))
          obj.childSize = Number(object.childSize);
        if ((0, helpers_1.isSet)(object.minPrefixLength))
          obj.minPrefixLength = Number(object.minPrefixLength);
        if ((0, helpers_1.isSet)(object.maxPrefixLength))
          obj.maxPrefixLength = Number(object.maxPrefixLength);
        if ((0, helpers_1.isSet)(object.emptyChild))
          obj.emptyChild = (0, helpers_1.bytesFromBase64)(object.emptyChild);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.childOrder) {
          obj.childOrder = message.childOrder.map((e) => Math.round(e));
        } else {
          obj.childOrder = [];
        }
        message.childSize !== void 0 && (obj.childSize = Math.round(message.childSize));
        message.minPrefixLength !== void 0 && (obj.minPrefixLength = Math.round(message.minPrefixLength));
        message.maxPrefixLength !== void 0 && (obj.maxPrefixLength = Math.round(message.maxPrefixLength));
        message.emptyChild !== void 0 && (obj.emptyChild = (0, helpers_1.base64FromBytes)(message.emptyChild !== void 0 ? message.emptyChild : new Uint8Array()));
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseInnerSpec();
        message.childOrder = ((_a = object.childOrder) == null ? void 0 : _a.map((e) => e)) || [];
        message.childSize = object.childSize ?? 0;
        message.minPrefixLength = object.minPrefixLength ?? 0;
        message.maxPrefixLength = object.maxPrefixLength ?? 0;
        message.emptyChild = object.emptyChild ?? new Uint8Array();
        message.hash = object.hash ?? 0;
        return message;
      }
    };
    function createBaseBatchProof() {
      return {
        entries: []
      };
    }
    exports2.BatchProof = {
      typeUrl: "/cosmos.ics23.v1.BatchProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.entries) {
          exports2.BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBatchProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports2.BatchEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBatchProof();
        if (Array.isArray(object == null ? void 0 : object.entries))
          obj.entries = object.entries.map((e) => exports2.BatchEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.BatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseBatchProof();
        message.entries = ((_a = object.entries) == null ? void 0 : _a.map((e) => exports2.BatchEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseBatchEntry() {
      return {
        exist: void 0,
        nonexist: void 0
      };
    }
    exports2.BatchEntry = {
      typeUrl: "/cosmos.ics23.v1.BatchEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports2.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports2.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBatchEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports2.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports2.NonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBatchEntry();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports2.ExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports2.NonExistenceProof.fromJSON(object.nonexist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports2.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports2.NonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBatchEntry();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports2.ExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports2.NonExistenceProof.fromPartial(object.nonexist);
        }
        return message;
      }
    };
    function createBaseCompressedBatchProof() {
      return {
        entries: [],
        lookupInners: []
      };
    }
    exports2.CompressedBatchProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedBatchProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.entries) {
          exports2.CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.lookupInners) {
          exports2.InnerOp.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports2.CompressedBatchEntry.decode(reader, reader.uint32()));
              break;
            case 2:
              message.lookupInners.push(exports2.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedBatchProof();
        if (Array.isArray(object == null ? void 0 : object.entries))
          obj.entries = object.entries.map((e) => exports2.CompressedBatchEntry.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.lookupInners))
          obj.lookupInners = object.lookupInners.map((e) => exports2.InnerOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.CompressedBatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        if (message.lookupInners) {
          obj.lookupInners = message.lookupInners.map((e) => e ? exports2.InnerOp.toJSON(e) : void 0);
        } else {
          obj.lookupInners = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseCompressedBatchProof();
        message.entries = ((_a = object.entries) == null ? void 0 : _a.map((e) => exports2.CompressedBatchEntry.fromPartial(e))) || [];
        message.lookupInners = ((_b = object.lookupInners) == null ? void 0 : _b.map((e) => exports2.InnerOp.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCompressedBatchEntry() {
      return {
        exist: void 0,
        nonexist: void 0
      };
    }
    exports2.CompressedBatchEntry = {
      typeUrl: "/cosmos.ics23.v1.CompressedBatchEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports2.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports2.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports2.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports2.CompressedNonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedBatchEntry();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports2.CompressedExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports2.CompressedNonExistenceProof.fromJSON(object.nonexist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports2.CompressedExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports2.CompressedNonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedBatchEntry();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports2.CompressedExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports2.CompressedNonExistenceProof.fromPartial(object.nonexist);
        }
        return message;
      }
    };
    function createBaseCompressedExistenceProof() {
      return {
        key: new Uint8Array(),
        value: new Uint8Array(),
        leaf: void 0,
        path: []
      };
    }
    exports2.CompressedExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports2.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.path) {
          writer.int32(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports2.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.path.push(reader.int32());
                }
              } else {
                message.path.push(reader.int32());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.leaf))
          obj.leaf = exports2.LeafOp.fromJSON(object.leaf);
        if (Array.isArray(object == null ? void 0 : object.path))
          obj.path = object.path.map((e) => Number(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports2.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => Math.round(e));
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseCompressedExistenceProof();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.leaf !== void 0 && object.leaf !== null) {
          message.leaf = exports2.LeafOp.fromPartial(object.leaf);
        }
        message.path = ((_a = object.path) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseCompressedNonExistenceProof() {
      return {
        key: new Uint8Array(),
        left: void 0,
        right: void 0
      };
    }
    exports2.CompressedNonExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedNonExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports2.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports2.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedNonExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports2.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports2.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedNonExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.left))
          obj.left = exports2.CompressedExistenceProof.fromJSON(object.left);
        if ((0, helpers_1.isSet)(object.right))
          obj.right = exports2.CompressedExistenceProof.fromJSON(object.right);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports2.CompressedExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports2.CompressedExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedNonExistenceProof();
        message.key = object.key ?? new Uint8Array();
        if (object.left !== void 0 && object.left !== null) {
          message.left = exports2.CompressedExistenceProof.fromPartial(object.left);
        }
        if (object.right !== void 0 && object.right !== null) {
          message.right = exports2.CompressedExistenceProof.fromPartial(object.right);
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js
var require_commitment = __commonJS({
  "node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MerkleProof = exports2.MerklePath = exports2.MerklePrefix = exports2.MerkleRoot = exports2.protobufPackage = void 0;
    var proofs_1 = require_proofs2();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.core.commitment.v1";
    function createBaseMerkleRoot() {
      return {
        hash: new Uint8Array()
      };
    }
    exports2.MerkleRoot = {
      typeUrl: "/ibc.core.commitment.v1.MerkleRoot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerkleRoot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerkleRoot();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerkleRoot();
        message.hash = object.hash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMerklePrefix() {
      return {
        keyPrefix: new Uint8Array()
      };
    }
    exports2.MerklePrefix = {
      typeUrl: "/ibc.core.commitment.v1.MerklePrefix",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.keyPrefix.length !== 0) {
          writer.uint32(10).bytes(message.keyPrefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerklePrefix();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPrefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerklePrefix();
        if ((0, helpers_1.isSet)(object.keyPrefix))
          obj.keyPrefix = (0, helpers_1.bytesFromBase64)(object.keyPrefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.keyPrefix !== void 0 && (obj.keyPrefix = (0, helpers_1.base64FromBytes)(message.keyPrefix !== void 0 ? message.keyPrefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerklePrefix();
        message.keyPrefix = object.keyPrefix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMerklePath() {
      return {
        keyPath: []
      };
    }
    exports2.MerklePath = {
      typeUrl: "/ibc.core.commitment.v1.MerklePath",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.keyPath) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerklePath();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPath.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerklePath();
        if (Array.isArray(object == null ? void 0 : object.keyPath))
          obj.keyPath = object.keyPath.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.keyPath) {
          obj.keyPath = message.keyPath.map((e) => e);
        } else {
          obj.keyPath = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMerklePath();
        message.keyPath = ((_a = object.keyPath) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseMerkleProof() {
      return {
        proofs: []
      };
    }
    exports2.MerkleProof = {
      typeUrl: "/ibc.core.commitment.v1.MerkleProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.proofs) {
          proofs_1.CommitmentProof.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerkleProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proofs.push(proofs_1.CommitmentProof.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerkleProof();
        if (Array.isArray(object == null ? void 0 : object.proofs))
          obj.proofs = object.proofs.map((e) => proofs_1.CommitmentProof.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.proofs) {
          obj.proofs = message.proofs.map((e) => e ? proofs_1.CommitmentProof.toJSON(e) : void 0);
        } else {
          obj.proofs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMerkleProof();
        message.proofs = ((_a = object.proofs) == null ? void 0 : _a.map((e) => proofs_1.CommitmentProof.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/ibc/core/connection/v1/connection.js
var require_connection = __commonJS({
  "node_modules/cosmjs-types/ibc/core/connection/v1/connection.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.Version = exports2.ConnectionPaths = exports2.ClientPaths = exports2.Counterparty = exports2.IdentifiedConnection = exports2.ConnectionEnd = exports2.stateToJSON = exports2.stateFromJSON = exports2.State = exports2.protobufPackage = void 0;
    var commitment_1 = require_commitment();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.core.connection.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State || (exports2.State = State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports2.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        case State.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.stateToJSON = stateToJSON;
    function createBaseConnectionEnd() {
      return {
        clientId: "",
        versions: [],
        state: 0,
        counterparty: exports2.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0)
      };
    }
    exports2.ConnectionEnd = {
      typeUrl: "/ibc.core.connection.v1.ConnectionEnd",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.versions) {
          exports2.Version.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(24).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports2.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConnectionEnd();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.versions.push(exports2.Version.decode(reader, reader.uint32()));
              break;
            case 3:
              message.state = reader.int32();
              break;
            case 4:
              message.counterparty = exports2.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConnectionEnd();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object == null ? void 0 : object.versions))
          obj.versions = object.versions.map((e) => exports2.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports2.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports2.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports2.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseConnectionEnd();
        message.clientId = object.clientId ?? "";
        message.versions = ((_a = object.versions) == null ? void 0 : _a.map((e) => exports2.Version.fromPartial(e))) || [];
        message.state = object.state ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports2.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        return message;
      }
    };
    function createBaseIdentifiedConnection() {
      return {
        id: "",
        clientId: "",
        versions: [],
        state: 0,
        counterparty: exports2.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0)
      };
    }
    exports2.IdentifiedConnection = {
      typeUrl: "/ibc.core.connection.v1.IdentifiedConnection",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        for (const v of message.versions) {
          exports2.Version.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(32).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports2.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(48).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedConnection();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.versions.push(exports2.Version.decode(reader, reader.uint32()));
              break;
            case 4:
              message.state = reader.int32();
              break;
            case 5:
              message.counterparty = exports2.Counterparty.decode(reader, reader.uint32());
              break;
            case 6:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedConnection();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = String(object.id);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object == null ? void 0 : object.versions))
          obj.versions = object.versions.map((e) => exports2.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports2.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports2.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports2.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseIdentifiedConnection();
        message.id = object.id ?? "";
        message.clientId = object.clientId ?? "";
        message.versions = ((_a = object.versions) == null ? void 0 : _a.map((e) => exports2.Version.fromPartial(e))) || [];
        message.state = object.state ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports2.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        return message;
      }
    };
    function createBaseCounterparty() {
      return {
        clientId: "",
        connectionId: "",
        prefix: commitment_1.MerklePrefix.fromPartial({})
      };
    }
    exports2.Counterparty = {
      typeUrl: "/ibc.core.connection.v1.Counterparty",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.connectionId !== "") {
          writer.uint32(18).string(message.connectionId);
        }
        if (message.prefix !== void 0) {
          commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.connectionId = reader.string();
              break;
            case 3:
              message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCounterparty();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = commitment_1.MerklePrefix.fromJSON(object.prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.prefix !== void 0 && (obj.prefix = message.prefix ? commitment_1.MerklePrefix.toJSON(message.prefix) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCounterparty();
        message.clientId = object.clientId ?? "";
        message.connectionId = object.connectionId ?? "";
        if (object.prefix !== void 0 && object.prefix !== null) {
          message.prefix = commitment_1.MerklePrefix.fromPartial(object.prefix);
        }
        return message;
      }
    };
    function createBaseClientPaths() {
      return {
        paths: []
      };
    }
    exports2.ClientPaths = {
      typeUrl: "/ibc.core.connection.v1.ClientPaths",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.paths) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientPaths();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientPaths();
        if (Array.isArray(object == null ? void 0 : object.paths))
          obj.paths = object.paths.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseClientPaths();
        message.paths = ((_a = object.paths) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseConnectionPaths() {
      return {
        clientId: "",
        paths: []
      };
    }
    exports2.ConnectionPaths = {
      typeUrl: "/ibc.core.connection.v1.ConnectionPaths",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.paths) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConnectionPaths();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConnectionPaths();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object == null ? void 0 : object.paths))
          obj.paths = object.paths.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseConnectionPaths();
        message.clientId = object.clientId ?? "";
        message.paths = ((_a = object.paths) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseVersion() {
      return {
        identifier: "",
        features: []
      };
    }
    exports2.Version = {
      typeUrl: "/ibc.core.connection.v1.Version",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifier !== "") {
          writer.uint32(10).string(message.identifier);
        }
        for (const v of message.features) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifier = reader.string();
              break;
            case 2:
              message.features.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVersion();
        if ((0, helpers_1.isSet)(object.identifier))
          obj.identifier = String(object.identifier);
        if (Array.isArray(object == null ? void 0 : object.features))
          obj.features = object.features.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifier !== void 0 && (obj.identifier = message.identifier);
        if (message.features) {
          obj.features = message.features.map((e) => e);
        } else {
          obj.features = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseVersion();
        message.identifier = object.identifier ?? "";
        message.features = ((_a = object.features) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        maxExpectedTimePerBlock: BigInt(0)
      };
    }
    exports2.Params = {
      typeUrl: "/ibc.core.connection.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxExpectedTimePerBlock !== BigInt(0)) {
          writer.uint32(8).uint64(message.maxExpectedTimePerBlock);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxExpectedTimePerBlock = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.maxExpectedTimePerBlock))
          obj.maxExpectedTimePerBlock = BigInt(object.maxExpectedTimePerBlock.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxExpectedTimePerBlock !== void 0 && (obj.maxExpectedTimePerBlock = (message.maxExpectedTimePerBlock || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.maxExpectedTimePerBlock !== void 0 && object.maxExpectedTimePerBlock !== null) {
          message.maxExpectedTimePerBlock = BigInt(object.maxExpectedTimePerBlock.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/ibc/core/connection/v1/tx.js
var require_tx12 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/connection/v1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgConnectionOpenConfirmResponse = exports2.MsgConnectionOpenConfirm = exports2.MsgConnectionOpenAckResponse = exports2.MsgConnectionOpenAck = exports2.MsgConnectionOpenTryResponse = exports2.MsgConnectionOpenTry = exports2.MsgConnectionOpenInitResponse = exports2.MsgConnectionOpenInit = exports2.protobufPackage = void 0;
    var connection_1 = require_connection();
    var any_1 = require_any();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.core.connection.v1";
    function createBaseMsgConnectionOpenInit() {
      return {
        clientId: "",
        counterparty: connection_1.Counterparty.fromPartial({}),
        version: void 0,
        delayPeriod: BigInt(0),
        signer: ""
      };
    }
    exports2.MsgConnectionOpenInit = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(32).uint64(message.delayPeriod);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.delayPeriod = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenInit();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = connection_1.Version.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenInit();
        message.clientId = object.clientId ?? "";
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);
        }
        if (object.version !== void 0 && object.version !== null) {
          message.version = connection_1.Version.fromPartial(object.version);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenInitResponse() {
      return {};
    }
    exports2.MsgConnectionOpenInitResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInitResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenInitResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenInitResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenTry() {
      return {
        clientId: "",
        previousConnectionId: "",
        clientState: void 0,
        counterparty: connection_1.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0),
        counterpartyVersions: [],
        proofHeight: client_1.Height.fromPartial({}),
        proofInit: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: client_1.Height.fromPartial({}),
        signer: "",
        hostConsensusStateProof: new Uint8Array()
      };
    }
    exports2.MsgConnectionOpenTry = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.previousConnectionId !== "") {
          writer.uint32(18).string(message.previousConnectionId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        for (const v of message.counterpartyVersions) {
          connection_1.Version.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(66).bytes(message.proofInit);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(74).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(82).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(90).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(98).string(message.signer);
        }
        if (message.hostConsensusStateProof.length !== 0) {
          writer.uint32(106).bytes(message.hostConsensusStateProof);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.previousConnectionId = reader.string();
              break;
            case 3:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            case 6:
              message.counterpartyVersions.push(connection_1.Version.decode(reader, reader.uint32()));
              break;
            case 7:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofInit = reader.bytes();
              break;
            case 9:
              message.proofClient = reader.bytes();
              break;
            case 10:
              message.proofConsensus = reader.bytes();
              break;
            case 11:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 12:
              message.signer = reader.string();
              break;
            case 13:
              message.hostConsensusStateProof = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenTry();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.previousConnectionId))
          obj.previousConnectionId = String(object.previousConnectionId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        if (Array.isArray(object == null ? void 0 : object.counterpartyVersions))
          obj.counterpartyVersions = object.counterpartyVersions.map((e) => connection_1.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofClient))
          obj.proofClient = (0, helpers_1.bytesFromBase64)(object.proofClient);
        if ((0, helpers_1.isSet)(object.proofConsensus))
          obj.proofConsensus = (0, helpers_1.bytesFromBase64)(object.proofConsensus);
        if ((0, helpers_1.isSet)(object.consensusHeight))
          obj.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.hostConsensusStateProof))
          obj.hostConsensusStateProof = (0, helpers_1.bytesFromBase64)(object.hostConsensusStateProof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.previousConnectionId !== void 0 && (obj.previousConnectionId = message.previousConnectionId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        if (message.counterpartyVersions) {
          obj.counterpartyVersions = message.counterpartyVersions.map((e) => e ? connection_1.Version.toJSON(e) : void 0);
        } else {
          obj.counterpartyVersions = [];
        }
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = (0, helpers_1.base64FromBytes)(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = (0, helpers_1.base64FromBytes)(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.hostConsensusStateProof !== void 0 && (obj.hostConsensusStateProof = (0, helpers_1.base64FromBytes)(message.hostConsensusStateProof !== void 0 ? message.hostConsensusStateProof : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgConnectionOpenTry();
        message.clientId = object.clientId ?? "";
        message.previousConnectionId = object.previousConnectionId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        message.counterpartyVersions = ((_a = object.counterpartyVersions) == null ? void 0 : _a.map((e) => connection_1.Version.fromPartial(e))) || [];
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.proofInit = object.proofInit ?? new Uint8Array();
        message.proofClient = object.proofClient ?? new Uint8Array();
        message.proofConsensus = object.proofConsensus ?? new Uint8Array();
        if (object.consensusHeight !== void 0 && object.consensusHeight !== null) {
          message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);
        }
        message.signer = object.signer ?? "";
        message.hostConsensusStateProof = object.hostConsensusStateProof ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgConnectionOpenTryResponse() {
      return {};
    }
    exports2.MsgConnectionOpenTryResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTryResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenTryResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenTryResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenAck() {
      return {
        connectionId: "",
        counterpartyConnectionId: "",
        version: void 0,
        clientState: void 0,
        proofHeight: client_1.Height.fromPartial({}),
        proofTry: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: client_1.Height.fromPartial({}),
        signer: "",
        hostConsensusStateProof: new Uint8Array()
      };
    }
    exports2.MsgConnectionOpenAck = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.counterpartyConnectionId !== "") {
          writer.uint32(18).string(message.counterpartyConnectionId);
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(34).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(50).bytes(message.proofTry);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(58).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(66).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(74).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(82).string(message.signer);
        }
        if (message.hostConsensusStateProof.length !== 0) {
          writer.uint32(90).bytes(message.hostConsensusStateProof);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.counterpartyConnectionId = reader.string();
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.proofTry = reader.bytes();
              break;
            case 7:
              message.proofClient = reader.bytes();
              break;
            case 8:
              message.proofConsensus = reader.bytes();
              break;
            case 9:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 10:
              message.signer = reader.string();
              break;
            case 11:
              message.hostConsensusStateProof = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenAck();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.counterpartyConnectionId))
          obj.counterpartyConnectionId = String(object.counterpartyConnectionId);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = connection_1.Version.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.proofTry))
          obj.proofTry = (0, helpers_1.bytesFromBase64)(object.proofTry);
        if ((0, helpers_1.isSet)(object.proofClient))
          obj.proofClient = (0, helpers_1.bytesFromBase64)(object.proofClient);
        if ((0, helpers_1.isSet)(object.proofConsensus))
          obj.proofConsensus = (0, helpers_1.bytesFromBase64)(object.proofConsensus);
        if ((0, helpers_1.isSet)(object.consensusHeight))
          obj.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.hostConsensusStateProof))
          obj.hostConsensusStateProof = (0, helpers_1.bytesFromBase64)(object.hostConsensusStateProof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.counterpartyConnectionId !== void 0 && (obj.counterpartyConnectionId = message.counterpartyConnectionId);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofTry !== void 0 && (obj.proofTry = (0, helpers_1.base64FromBytes)(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = (0, helpers_1.base64FromBytes)(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = (0, helpers_1.base64FromBytes)(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.hostConsensusStateProof !== void 0 && (obj.hostConsensusStateProof = (0, helpers_1.base64FromBytes)(message.hostConsensusStateProof !== void 0 ? message.hostConsensusStateProof : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenAck();
        message.connectionId = object.connectionId ?? "";
        message.counterpartyConnectionId = object.counterpartyConnectionId ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = connection_1.Version.fromPartial(object.version);
        }
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.proofTry = object.proofTry ?? new Uint8Array();
        message.proofClient = object.proofClient ?? new Uint8Array();
        message.proofConsensus = object.proofConsensus ?? new Uint8Array();
        if (object.consensusHeight !== void 0 && object.consensusHeight !== null) {
          message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);
        }
        message.signer = object.signer ?? "";
        message.hostConsensusStateProof = object.hostConsensusStateProof ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgConnectionOpenAckResponse() {
      return {};
    }
    exports2.MsgConnectionOpenAckResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAckResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenAckResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenAckResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenConfirm() {
      return {
        connectionId: "",
        proofAck: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports2.MsgConnectionOpenConfirm = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(18).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.proofAck = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenConfirm();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.proofAck))
          obj.proofAck = (0, helpers_1.bytesFromBase64)(object.proofAck);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.proofAck !== void 0 && (obj.proofAck = (0, helpers_1.base64FromBytes)(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenConfirm();
        message.connectionId = object.connectionId ?? "";
        message.proofAck = object.proofAck ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenConfirmResponse() {
      return {};
    }
    exports2.MsgConnectionOpenConfirmResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirmResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgConnectionOpenConfirmResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgConnectionOpenConfirmResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this);
        this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this);
        this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this);
        this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
      }
      ConnectionOpenInit(request) {
        const data = exports2.MsgConnectionOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", data);
        return promise.then((data2) => exports2.MsgConnectionOpenInitResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ConnectionOpenTry(request) {
        const data = exports2.MsgConnectionOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", data);
        return promise.then((data2) => exports2.MsgConnectionOpenTryResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ConnectionOpenAck(request) {
        const data = exports2.MsgConnectionOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", data);
        return promise.then((data2) => exports2.MsgConnectionOpenAckResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ConnectionOpenConfirm(request) {
        const data = exports2.MsgConnectionOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", data);
        return promise.then((data2) => exports2.MsgConnectionOpenConfirmResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/ibc/messages.js
var require_messages7 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/ibc/messages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgTransferEncodeObject = exports2.ibcTypes = void 0;
    var tx_1 = require_tx9();
    var tx_2 = require_tx10();
    var tx_3 = require_tx11();
    var tx_4 = require_tx12();
    exports2.ibcTypes = [
      ["/ibc.applications.transfer.v1.MsgTransfer", tx_1.MsgTransfer],
      ["/ibc.core.channel.v1.MsgAcknowledgement", tx_2.MsgAcknowledgement],
      ["/ibc.core.channel.v1.MsgChannelCloseConfirm", tx_2.MsgChannelCloseConfirm],
      ["/ibc.core.channel.v1.MsgChannelCloseInit", tx_2.MsgChannelCloseInit],
      ["/ibc.core.channel.v1.MsgChannelOpenAck", tx_2.MsgChannelOpenAck],
      ["/ibc.core.channel.v1.MsgChannelOpenConfirm", tx_2.MsgChannelOpenConfirm],
      ["/ibc.core.channel.v1.MsgChannelOpenInit", tx_2.MsgChannelOpenInit],
      ["/ibc.core.channel.v1.MsgChannelOpenTry", tx_2.MsgChannelOpenTry],
      ["/ibc.core.channel.v1.MsgRecvPacket", tx_2.MsgRecvPacket],
      ["/ibc.core.channel.v1.MsgTimeout", tx_2.MsgTimeout],
      ["/ibc.core.channel.v1.MsgTimeoutOnClose", tx_2.MsgTimeoutOnClose],
      ["/ibc.core.client.v1.MsgCreateClient", tx_3.MsgCreateClient],
      ["/ibc.core.client.v1.MsgSubmitMisbehaviour", tx_3.MsgSubmitMisbehaviour],
      ["/ibc.core.client.v1.MsgUpdateClient", tx_3.MsgUpdateClient],
      ["/ibc.core.client.v1.MsgUpgradeClient", tx_3.MsgUpgradeClient],
      ["/ibc.core.connection.v1.MsgConnectionOpenAck", tx_4.MsgConnectionOpenAck],
      ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", tx_4.MsgConnectionOpenConfirm],
      ["/ibc.core.connection.v1.MsgConnectionOpenInit", tx_4.MsgConnectionOpenInit],
      ["/ibc.core.connection.v1.MsgConnectionOpenTry", tx_4.MsgConnectionOpenTry]
    ];
    function isMsgTransferEncodeObject(object) {
      return object.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
    }
    exports2.isMsgTransferEncodeObject = isMsgTransferEncodeObject;
  }
});

// node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js
var require_transfer = __commonJS({
  "node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.DenomTrace = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseDenomTrace() {
      return {
        path: "",
        baseDenom: ""
      };
    }
    exports2.DenomTrace = {
      typeUrl: "/ibc.applications.transfer.v1.DenomTrace",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.path !== "") {
          writer.uint32(10).string(message.path);
        }
        if (message.baseDenom !== "") {
          writer.uint32(18).string(message.baseDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomTrace();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.path = reader.string();
              break;
            case 2:
              message.baseDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDenomTrace();
        if ((0, helpers_1.isSet)(object.path))
          obj.path = String(object.path);
        if ((0, helpers_1.isSet)(object.baseDenom))
          obj.baseDenom = String(object.baseDenom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.path !== void 0 && (obj.path = message.path);
        message.baseDenom !== void 0 && (obj.baseDenom = message.baseDenom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDenomTrace();
        message.path = object.path ?? "";
        message.baseDenom = object.baseDenom ?? "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        sendEnabled: false,
        receiveEnabled: false
      };
    }
    exports2.Params = {
      typeUrl: "/ibc.applications.transfer.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sendEnabled === true) {
          writer.uint32(8).bool(message.sendEnabled);
        }
        if (message.receiveEnabled === true) {
          writer.uint32(16).bool(message.receiveEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled = reader.bool();
              break;
            case 2:
              message.receiveEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.sendEnabled))
          obj.sendEnabled = Boolean(object.sendEnabled);
        if ((0, helpers_1.isSet)(object.receiveEnabled))
          obj.receiveEnabled = Boolean(object.receiveEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sendEnabled !== void 0 && (obj.sendEnabled = message.sendEnabled);
        message.receiveEnabled !== void 0 && (obj.receiveEnabled = message.receiveEnabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.sendEnabled = object.sendEnabled ?? false;
        message.receiveEnabled = object.receiveEnabled ?? false;
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js
var require_query7 = __commonJS({
  "node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryEscrowAddressResponse = exports2.QueryEscrowAddressRequest = exports2.QueryDenomHashResponse = exports2.QueryDenomHashRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.QueryDenomTracesResponse = exports2.QueryDenomTracesRequest = exports2.QueryDenomTraceResponse = exports2.QueryDenomTraceRequest = exports2.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var transfer_1 = require_transfer();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseQueryDenomTraceRequest() {
      return {
        hash: ""
      };
    }
    exports2.QueryDenomTraceRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTraceRequest();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTraceRequest();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseQueryDenomTraceResponse() {
      return {
        denomTrace: void 0
      };
    }
    exports2.QueryDenomTraceResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denomTrace !== void 0) {
          transfer_1.DenomTrace.encode(message.denomTrace, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTrace = transfer_1.DenomTrace.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTraceResponse();
        if ((0, helpers_1.isSet)(object.denomTrace))
          obj.denomTrace = transfer_1.DenomTrace.fromJSON(object.denomTrace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denomTrace !== void 0 && (obj.denomTrace = message.denomTrace ? transfer_1.DenomTrace.toJSON(message.denomTrace) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTraceResponse();
        if (object.denomTrace !== void 0 && object.denomTrace !== null) {
          message.denomTrace = transfer_1.DenomTrace.fromPartial(object.denomTrace);
        }
        return message;
      }
    };
    function createBaseQueryDenomTracesRequest() {
      return {
        pagination: void 0
      };
    }
    exports2.QueryDenomTracesRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTracesRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTracesRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomTracesResponse() {
      return {
        denomTraces: [],
        pagination: void 0
      };
    }
    exports2.QueryDenomTracesResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.denomTraces) {
          transfer_1.DenomTrace.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTraces.push(transfer_1.DenomTrace.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTracesResponse();
        if (Array.isArray(object == null ? void 0 : object.denomTraces))
          obj.denomTraces = object.denomTraces.map((e) => transfer_1.DenomTrace.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomTraces) {
          obj.denomTraces = message.denomTraces.map((e) => e ? transfer_1.DenomTrace.toJSON(e) : void 0);
        } else {
          obj.denomTraces = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDenomTracesResponse();
        message.denomTraces = ((_a = object.denomTraces) == null ? void 0 : _a.map((e) => transfer_1.DenomTrace.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: void 0
      };
    }
    exports2.QueryParamsResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          transfer_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = transfer_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = transfer_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? transfer_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = transfer_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryDenomHashRequest() {
      return {
        trace: ""
      };
    }
    exports2.QueryDenomHashRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.trace !== "") {
          writer.uint32(10).string(message.trace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.trace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomHashRequest();
        if ((0, helpers_1.isSet)(object.trace))
          obj.trace = String(object.trace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.trace !== void 0 && (obj.trace = message.trace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomHashRequest();
        message.trace = object.trace ?? "";
        return message;
      }
    };
    function createBaseQueryDenomHashResponse() {
      return {
        hash: ""
      };
    }
    exports2.QueryDenomHashResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomHashResponse();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomHashResponse();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseQueryEscrowAddressRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports2.QueryEscrowAddressRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryEscrowAddressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryEscrowAddressRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryEscrowAddressRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryEscrowAddressResponse() {
      return {
        escrowAddress: ""
      };
    }
    exports2.QueryEscrowAddressResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.escrowAddress !== "") {
          writer.uint32(10).string(message.escrowAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryEscrowAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.escrowAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryEscrowAddressResponse();
        if ((0, helpers_1.isSet)(object.escrowAddress))
          obj.escrowAddress = String(object.escrowAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.escrowAddress !== void 0 && (obj.escrowAddress = message.escrowAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryEscrowAddressResponse();
        message.escrowAddress = object.escrowAddress ?? "";
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.DenomTrace = this.DenomTrace.bind(this);
        this.DenomTraces = this.DenomTraces.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomHash = this.DenomHash.bind(this);
        this.EscrowAddress = this.EscrowAddress.bind(this);
      }
      DenomTrace(request) {
        const data = exports2.QueryDenomTraceRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", data);
        return promise.then((data2) => exports2.QueryDenomTraceResponse.decode(new binary_1.BinaryReader(data2)));
      }
      DenomTraces(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data = exports2.QueryDenomTracesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", data);
        return promise.then((data2) => exports2.QueryDenomTracesResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Params(request = {}) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      DenomHash(request) {
        const data = exports2.QueryDenomHashRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", data);
        return promise.then((data2) => exports2.QueryDenomHashResponse.decode(new binary_1.BinaryReader(data2)));
      }
      EscrowAddress(request) {
        const data = exports2.QueryEscrowAddressRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "EscrowAddress", data);
        return promise.then((data2) => exports2.QueryEscrowAddressResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/cosmjs-types/ibc/core/channel/v1/query.js
var require_query8 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/channel/v1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryNextSequenceReceiveResponse = exports2.QueryNextSequenceReceiveRequest = exports2.QueryUnreceivedAcksResponse = exports2.QueryUnreceivedAcksRequest = exports2.QueryUnreceivedPacketsResponse = exports2.QueryUnreceivedPacketsRequest = exports2.QueryPacketAcknowledgementsResponse = exports2.QueryPacketAcknowledgementsRequest = exports2.QueryPacketAcknowledgementResponse = exports2.QueryPacketAcknowledgementRequest = exports2.QueryPacketReceiptResponse = exports2.QueryPacketReceiptRequest = exports2.QueryPacketCommitmentsResponse = exports2.QueryPacketCommitmentsRequest = exports2.QueryPacketCommitmentResponse = exports2.QueryPacketCommitmentRequest = exports2.QueryChannelConsensusStateResponse = exports2.QueryChannelConsensusStateRequest = exports2.QueryChannelClientStateResponse = exports2.QueryChannelClientStateRequest = exports2.QueryConnectionChannelsResponse = exports2.QueryConnectionChannelsRequest = exports2.QueryChannelsResponse = exports2.QueryChannelsRequest = exports2.QueryChannelResponse = exports2.QueryChannelRequest = exports2.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var channel_1 = require_channel();
    var client_1 = require_client();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.core.channel.v1";
    function createBaseQueryChannelRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports2.QueryChannelRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryChannelResponse() {
      return {
        channel: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryChannelResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelResponse();
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelResponse();
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelsRequest() {
      return {
        pagination: void 0
      };
    }
    exports2.QueryChannelsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryChannelsResponse() {
      return {
        channels: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryChannelsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.channels) {
          channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelsResponse();
        if (Array.isArray(object == null ? void 0 : object.channels))
          obj.channels = object.channels.map((e) => channel_1.IdentifiedChannel.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryChannelsResponse();
        message.channels = ((_a = object.channels) == null ? void 0 : _a.map((e) => channel_1.IdentifiedChannel.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryConnectionChannelsRequest() {
      return {
        connection: "",
        pagination: void 0
      };
    }
    exports2.QueryConnectionChannelsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connection !== "") {
          writer.uint32(10).string(message.connection);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionChannelsRequest();
        if ((0, helpers_1.isSet)(object.connection))
          obj.connection = String(object.connection);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionChannelsRequest();
        message.connection = object.connection ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConnectionChannelsResponse() {
      return {
        channels: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryConnectionChannelsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.channels) {
          channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionChannelsResponse();
        if (Array.isArray(object == null ? void 0 : object.channels))
          obj.channels = object.channels.map((e) => channel_1.IdentifiedChannel.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConnectionChannelsResponse();
        message.channels = ((_a = object.channels) == null ? void 0 : _a.map((e) => channel_1.IdentifiedChannel.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryChannelClientStateRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports2.QueryChannelClientStateRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelClientStateRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelClientStateRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryChannelClientStateResponse() {
      return {
        identifiedClientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryChannelClientStateResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelClientStateResponse();
        if ((0, helpers_1.isSet)(object.identifiedClientState))
          obj.identifiedClientState = client_1.IdentifiedClientState.fromJSON(object.identifiedClientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelClientStateResponse();
        if (object.identifiedClientState !== void 0 && object.identifiedClientState !== null) {
          message.identifiedClientState = client_1.IdentifiedClientState.fromPartial(object.identifiedClientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelConsensusStateRequest() {
      return {
        portId: "",
        channelId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports2.QueryChannelConsensusStateRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(32).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.revisionNumber = reader.uint64();
              break;
            case 4:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelConsensusStateRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseQueryChannelConsensusStateResponse() {
      return {
        consensusState: void 0,
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryChannelConsensusStateResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports2.QueryPacketCommitmentRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentResponse() {
      return {
        commitment: new Uint8Array(),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryPacketCommitmentResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commitment.length !== 0) {
          writer.uint32(10).bytes(message.commitment);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitment = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentResponse();
        if ((0, helpers_1.isSet)(object.commitment))
          obj.commitment = (0, helpers_1.bytesFromBase64)(object.commitment);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commitment !== void 0 && (obj.commitment = (0, helpers_1.base64FromBytes)(message.commitment !== void 0 ? message.commitment : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentResponse();
        message.commitment = object.commitment ?? new Uint8Array();
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentsRequest() {
      return {
        portId: "",
        channelId: "",
        pagination: void 0
      };
    }
    exports2.QueryPacketCommitmentsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentsResponse() {
      return {
        commitments: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryPacketCommitmentsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.commitments) {
          channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitments.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentsResponse();
        if (Array.isArray(object == null ? void 0 : object.commitments))
          obj.commitments = object.commitments.map((e) => channel_1.PacketState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.commitments) {
          obj.commitments = message.commitments.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.commitments = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryPacketCommitmentsResponse();
        message.commitments = ((_a = object.commitments) == null ? void 0 : _a.map((e) => channel_1.PacketState.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryPacketReceiptRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports2.QueryPacketReceiptRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketReceiptRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketReceiptRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketReceiptResponse() {
      return {
        received: false,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryPacketReceiptResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.received === true) {
          writer.uint32(16).bool(message.received);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.received = reader.bool();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketReceiptResponse();
        if ((0, helpers_1.isSet)(object.received))
          obj.received = Boolean(object.received);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.received !== void 0 && (obj.received = message.received);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketReceiptResponse();
        message.received = object.received ?? false;
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports2.QueryPacketAcknowledgementRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementResponse() {
      return {
        acknowledgement: new Uint8Array(),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryPacketAcknowledgementResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.acknowledgement.length !== 0) {
          writer.uint32(10).bytes(message.acknowledgement);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgement = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementResponse();
        if ((0, helpers_1.isSet)(object.acknowledgement))
          obj.acknowledgement = (0, helpers_1.bytesFromBase64)(object.acknowledgement);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.acknowledgement !== void 0 && (obj.acknowledgement = (0, helpers_1.base64FromBytes)(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementResponse();
        message.acknowledgement = object.acknowledgement ?? new Uint8Array();
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementsRequest() {
      return {
        portId: "",
        channelId: "",
        pagination: void 0,
        packetCommitmentSequences: []
      };
    }
    exports2.QueryPacketAcknowledgementsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.packetCommitmentSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if (Array.isArray(object == null ? void 0 : object.packetCommitmentSequences))
          obj.packetCommitmentSequences = object.packetCommitmentSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryPacketAcknowledgementsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.packetCommitmentSequences = ((_a = object.packetCommitmentSequences) == null ? void 0 : _a.map((e) => BigInt(e.toString()))) || [];
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementsResponse() {
      return {
        acknowledgements: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryPacketAcknowledgementsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.acknowledgements) {
          channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgements.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementsResponse();
        if (Array.isArray(object == null ? void 0 : object.acknowledgements))
          obj.acknowledgements = object.acknowledgements.map((e) => channel_1.PacketState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.acknowledgements) {
          obj.acknowledgements = message.acknowledgements.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.acknowledgements = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryPacketAcknowledgementsResponse();
        message.acknowledgements = ((_a = object.acknowledgements) == null ? void 0 : _a.map((e) => channel_1.PacketState.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryUnreceivedPacketsRequest() {
      return {
        portId: "",
        channelId: "",
        packetCommitmentSequences: []
      };
    }
    exports2.QueryUnreceivedPacketsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v of message.packetCommitmentSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedPacketsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object == null ? void 0 : object.packetCommitmentSequences))
          obj.packetCommitmentSequences = object.packetCommitmentSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryUnreceivedPacketsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.packetCommitmentSequences = ((_a = object.packetCommitmentSequences) == null ? void 0 : _a.map((e) => BigInt(e.toString()))) || [];
        return message;
      }
    };
    function createBaseQueryUnreceivedPacketsResponse() {
      return {
        sequences: [],
        height: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryUnreceivedPacketsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedPacketsResponse();
        if (Array.isArray(object == null ? void 0 : object.sequences))
          obj.sequences = object.sequences.map((e) => BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryUnreceivedPacketsResponse();
        message.sequences = ((_a = object.sequences) == null ? void 0 : _a.map((e) => BigInt(e.toString()))) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryUnreceivedAcksRequest() {
      return {
        portId: "",
        channelId: "",
        packetAckSequences: []
      };
    }
    exports2.QueryUnreceivedAcksRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v of message.packetAckSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetAckSequences.push(reader.uint64());
                }
              } else {
                message.packetAckSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedAcksRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object == null ? void 0 : object.packetAckSequences))
          obj.packetAckSequences = object.packetAckSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetAckSequences) {
          obj.packetAckSequences = message.packetAckSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetAckSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryUnreceivedAcksRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.packetAckSequences = ((_a = object.packetAckSequences) == null ? void 0 : _a.map((e) => BigInt(e.toString()))) || [];
        return message;
      }
    };
    function createBaseQueryUnreceivedAcksResponse() {
      return {
        sequences: [],
        height: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryUnreceivedAcksResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedAcksResponse();
        if (Array.isArray(object == null ? void 0 : object.sequences))
          obj.sequences = object.sequences.map((e) => BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryUnreceivedAcksResponse();
        message.sequences = ((_a = object.sequences) == null ? void 0 : _a.map((e) => BigInt(e.toString()))) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryNextSequenceReceiveRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports2.QueryNextSequenceReceiveRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceReceiveRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceReceiveRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryNextSequenceReceiveResponse() {
      return {
        nextSequenceReceive: BigInt(0),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryNextSequenceReceiveResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextSequenceReceive !== BigInt(0)) {
          writer.uint32(8).uint64(message.nextSequenceReceive);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextSequenceReceive = reader.uint64();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceReceiveResponse();
        if ((0, helpers_1.isSet)(object.nextSequenceReceive))
          obj.nextSequenceReceive = BigInt(object.nextSequenceReceive.toString());
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.nextSequenceReceive !== void 0 && (obj.nextSequenceReceive = (message.nextSequenceReceive || BigInt(0)).toString());
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceReceiveResponse();
        if (object.nextSequenceReceive !== void 0 && object.nextSequenceReceive !== null) {
          message.nextSequenceReceive = BigInt(object.nextSequenceReceive.toString());
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Channel = this.Channel.bind(this);
        this.Channels = this.Channels.bind(this);
        this.ConnectionChannels = this.ConnectionChannels.bind(this);
        this.ChannelClientState = this.ChannelClientState.bind(this);
        this.ChannelConsensusState = this.ChannelConsensusState.bind(this);
        this.PacketCommitment = this.PacketCommitment.bind(this);
        this.PacketCommitments = this.PacketCommitments.bind(this);
        this.PacketReceipt = this.PacketReceipt.bind(this);
        this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this);
        this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this);
        this.UnreceivedPackets = this.UnreceivedPackets.bind(this);
        this.UnreceivedAcks = this.UnreceivedAcks.bind(this);
        this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
      }
      Channel(request) {
        const data = exports2.QueryChannelRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channel", data);
        return promise.then((data2) => exports2.QueryChannelResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Channels(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data = exports2.QueryChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channels", data);
        return promise.then((data2) => exports2.QueryChannelsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ConnectionChannels(request) {
        const data = exports2.QueryConnectionChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", data);
        return promise.then((data2) => exports2.QueryConnectionChannelsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ChannelClientState(request) {
        const data = exports2.QueryChannelClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", data);
        return promise.then((data2) => exports2.QueryChannelClientStateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ChannelConsensusState(request) {
        const data = exports2.QueryChannelConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", data);
        return promise.then((data2) => exports2.QueryChannelConsensusStateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      PacketCommitment(request) {
        const data = exports2.QueryPacketCommitmentRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", data);
        return promise.then((data2) => exports2.QueryPacketCommitmentResponse.decode(new binary_1.BinaryReader(data2)));
      }
      PacketCommitments(request) {
        const data = exports2.QueryPacketCommitmentsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", data);
        return promise.then((data2) => exports2.QueryPacketCommitmentsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      PacketReceipt(request) {
        const data = exports2.QueryPacketReceiptRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", data);
        return promise.then((data2) => exports2.QueryPacketReceiptResponse.decode(new binary_1.BinaryReader(data2)));
      }
      PacketAcknowledgement(request) {
        const data = exports2.QueryPacketAcknowledgementRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", data);
        return promise.then((data2) => exports2.QueryPacketAcknowledgementResponse.decode(new binary_1.BinaryReader(data2)));
      }
      PacketAcknowledgements(request) {
        const data = exports2.QueryPacketAcknowledgementsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", data);
        return promise.then((data2) => exports2.QueryPacketAcknowledgementsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UnreceivedPackets(request) {
        const data = exports2.QueryUnreceivedPacketsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", data);
        return promise.then((data2) => exports2.QueryUnreceivedPacketsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UnreceivedAcks(request) {
        const data = exports2.QueryUnreceivedAcksRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", data);
        return promise.then((data2) => exports2.QueryUnreceivedAcksResponse.decode(new binary_1.BinaryReader(data2)));
      }
      NextSequenceReceive(request) {
        const data = exports2.QueryNextSequenceReceiveRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", data);
        return promise.then((data2) => exports2.QueryNextSequenceReceiveResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/cosmjs-types/ibc/core/client/v1/query.js
var require_query9 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/client/v1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryUpgradedConsensusStateResponse = exports2.QueryUpgradedConsensusStateRequest = exports2.QueryUpgradedClientStateResponse = exports2.QueryUpgradedClientStateRequest = exports2.QueryClientParamsResponse = exports2.QueryClientParamsRequest = exports2.QueryClientStatusResponse = exports2.QueryClientStatusRequest = exports2.QueryConsensusStateHeightsResponse = exports2.QueryConsensusStateHeightsRequest = exports2.QueryConsensusStatesResponse = exports2.QueryConsensusStatesRequest = exports2.QueryConsensusStateResponse = exports2.QueryConsensusStateRequest = exports2.QueryClientStatesResponse = exports2.QueryClientStatesRequest = exports2.QueryClientStateResponse = exports2.QueryClientStateRequest = exports2.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.core.client.v1";
    function createBaseQueryClientStateRequest() {
      return {
        clientId: ""
      };
    }
    exports2.QueryClientStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStateRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStateRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientStateResponse() {
      return {
        clientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryClientStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStateResponse();
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStateResponse();
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryClientStatesRequest() {
      return {
        pagination: void 0
      };
    }
    exports2.QueryClientStatesRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatesRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatesRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryClientStatesResponse() {
      return {
        clientStates: [],
        pagination: void 0
      };
    }
    exports2.QueryClientStatesResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.clientStates) {
          client_1.IdentifiedClientState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientStates.push(client_1.IdentifiedClientState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatesResponse();
        if (Array.isArray(object == null ? void 0 : object.clientStates))
          obj.clientStates = object.clientStates.map((e) => client_1.IdentifiedClientState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.clientStates) {
          obj.clientStates = message.clientStates.map((e) => e ? client_1.IdentifiedClientState.toJSON(e) : void 0);
        } else {
          obj.clientStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryClientStatesResponse();
        message.clientStates = ((_a = object.clientStates) == null ? void 0 : _a.map((e) => client_1.IdentifiedClientState.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateRequest() {
      return {
        clientId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0),
        latestHeight: false
      };
    }
    exports2.QueryConsensusStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        if (message.latestHeight === true) {
          writer.uint32(32).bool(message.latestHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            case 4:
              message.latestHeight = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        if ((0, helpers_1.isSet)(object.latestHeight))
          obj.latestHeight = Boolean(object.latestHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateRequest();
        message.clientId = object.clientId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        message.latestHeight = object.latestHeight ?? false;
        return message;
      }
    };
    function createBaseQueryConsensusStateResponse() {
      return {
        consensusState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryConsensusStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStatesRequest() {
      return {
        clientId: "",
        pagination: void 0
      };
    }
    exports2.QueryConsensusStatesRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStatesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStatesRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStatesRequest();
        message.clientId = object.clientId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStatesResponse() {
      return {
        consensusStates: [],
        pagination: void 0
      };
    }
    exports2.QueryConsensusStatesResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStatesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.consensusStates) {
          client_1.ConsensusStateWithHeight.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusStates.push(client_1.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStatesResponse();
        if (Array.isArray(object == null ? void 0 : object.consensusStates))
          obj.consensusStates = object.consensusStates.map((e) => client_1.ConsensusStateWithHeight.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? client_1.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConsensusStatesResponse();
        message.consensusStates = ((_a = object.consensusStates) == null ? void 0 : _a.map((e) => client_1.ConsensusStateWithHeight.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateHeightsRequest() {
      return {
        clientId: "",
        pagination: void 0
      };
    }
    exports2.QueryConsensusStateHeightsRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateHeightsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateHeightsRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateHeightsRequest();
        message.clientId = object.clientId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateHeightsResponse() {
      return {
        consensusStateHeights: [],
        pagination: void 0
      };
    }
    exports2.QueryConsensusStateHeightsResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.consensusStateHeights) {
          client_1.Height.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateHeightsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusStateHeights.push(client_1.Height.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateHeightsResponse();
        if (Array.isArray(object == null ? void 0 : object.consensusStateHeights))
          obj.consensusStateHeights = object.consensusStateHeights.map((e) => client_1.Height.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.consensusStateHeights) {
          obj.consensusStateHeights = message.consensusStateHeights.map((e) => e ? client_1.Height.toJSON(e) : void 0);
        } else {
          obj.consensusStateHeights = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConsensusStateHeightsResponse();
        message.consensusStateHeights = ((_a = object.consensusStateHeights) == null ? void 0 : _a.map((e) => client_1.Height.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryClientStatusRequest() {
      return {
        clientId: ""
      };
    }
    exports2.QueryClientStatusRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatusRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatusRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatusRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientStatusResponse() {
      return {
        status: ""
      };
    }
    exports2.QueryClientStatusResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatusResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatusResponse();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = String(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatusResponse();
        message.status = object.status ?? "";
        return message;
      }
    };
    function createBaseQueryClientParamsRequest() {
      return {};
    }
    exports2.QueryClientParamsRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryClientParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryClientParamsRequest();
        return message;
      }
    };
    function createBaseQueryClientParamsResponse() {
      return {
        params: void 0
      };
    }
    exports2.QueryClientParamsResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryUpgradedClientStateRequest() {
      return {};
    }
    exports2.QueryUpgradedClientStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryUpgradedClientStateRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryUpgradedClientStateRequest();
        return message;
      }
    };
    function createBaseQueryUpgradedClientStateResponse() {
      return {
        upgradedClientState: void 0
      };
    }
    exports2.QueryUpgradedClientStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradedClientStateResponse();
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradedClientStateResponse();
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
    function createBaseQueryUpgradedConsensusStateRequest() {
      return {};
    }
    exports2.QueryUpgradedConsensusStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryUpgradedConsensusStateRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryUpgradedConsensusStateRequest();
        return message;
      }
    };
    function createBaseQueryUpgradedConsensusStateResponse() {
      return {
        upgradedConsensusState: void 0
      };
    }
    exports2.QueryUpgradedConsensusStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradedConsensusState !== void 0) {
          any_1.Any.encode(message.upgradedConsensusState, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradedConsensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradedConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.upgradedConsensusState))
          obj.upgradedConsensusState = any_1.Any.fromJSON(object.upgradedConsensusState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradedConsensusState !== void 0 && (obj.upgradedConsensusState = message.upgradedConsensusState ? any_1.Any.toJSON(message.upgradedConsensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradedConsensusStateResponse();
        if (object.upgradedConsensusState !== void 0 && object.upgradedConsensusState !== null) {
          message.upgradedConsensusState = any_1.Any.fromPartial(object.upgradedConsensusState);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ClientState = this.ClientState.bind(this);
        this.ClientStates = this.ClientStates.bind(this);
        this.ConsensusState = this.ConsensusState.bind(this);
        this.ConsensusStates = this.ConsensusStates.bind(this);
        this.ConsensusStateHeights = this.ConsensusStateHeights.bind(this);
        this.ClientStatus = this.ClientStatus.bind(this);
        this.ClientParams = this.ClientParams.bind(this);
        this.UpgradedClientState = this.UpgradedClientState.bind(this);
        this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this);
      }
      ClientState(request) {
        const data = exports2.QueryClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientState", data);
        return promise.then((data2) => exports2.QueryClientStateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ClientStates(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data = exports2.QueryClientStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStates", data);
        return promise.then((data2) => exports2.QueryClientStatesResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ConsensusState(request) {
        const data = exports2.QueryConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", data);
        return promise.then((data2) => exports2.QueryConsensusStateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ConsensusStates(request) {
        const data = exports2.QueryConsensusStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", data);
        return promise.then((data2) => exports2.QueryConsensusStatesResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ConsensusStateHeights(request) {
        const data = exports2.QueryConsensusStateHeightsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStateHeights", data);
        return promise.then((data2) => exports2.QueryConsensusStateHeightsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ClientStatus(request) {
        const data = exports2.QueryClientStatusRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", data);
        return promise.then((data2) => exports2.QueryClientStatusResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ClientParams(request = {}) {
        const data = exports2.QueryClientParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientParams", data);
        return promise.then((data2) => exports2.QueryClientParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpgradedClientState(request = {}) {
        const data = exports2.QueryUpgradedClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", data);
        return promise.then((data2) => exports2.QueryUpgradedClientStateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpgradedConsensusState(request = {}) {
        const data = exports2.QueryUpgradedConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", data);
        return promise.then((data2) => exports2.QueryUpgradedConsensusStateResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/cosmjs-types/ibc/core/connection/v1/query.js
var require_query10 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/connection/v1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryConnectionParamsResponse = exports2.QueryConnectionParamsRequest = exports2.QueryConnectionConsensusStateResponse = exports2.QueryConnectionConsensusStateRequest = exports2.QueryConnectionClientStateResponse = exports2.QueryConnectionClientStateRequest = exports2.QueryClientConnectionsResponse = exports2.QueryClientConnectionsRequest = exports2.QueryConnectionsResponse = exports2.QueryConnectionsRequest = exports2.QueryConnectionResponse = exports2.QueryConnectionRequest = exports2.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var connection_1 = require_connection();
    var client_1 = require_client();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.core.connection.v1";
    function createBaseQueryConnectionRequest() {
      return {
        connectionId: ""
      };
    }
    exports2.QueryConnectionRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionRequest();
        message.connectionId = object.connectionId ?? "";
        return message;
      }
    };
    function createBaseQueryConnectionResponse() {
      return {
        connection: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryConnectionResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connection !== void 0) {
          connection_1.ConnectionEnd.encode(message.connection, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = connection_1.ConnectionEnd.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionResponse();
        if ((0, helpers_1.isSet)(object.connection))
          obj.connection = connection_1.ConnectionEnd.fromJSON(object.connection);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection ? connection_1.ConnectionEnd.toJSON(message.connection) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionResponse();
        if (object.connection !== void 0 && object.connection !== null) {
          message.connection = connection_1.ConnectionEnd.fromPartial(object.connection);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionsRequest() {
      return {
        pagination: void 0
      };
    }
    exports2.QueryConnectionsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConnectionsResponse() {
      return {
        connections: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryConnectionsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.connections) {
          connection_1.IdentifiedConnection.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connections.push(connection_1.IdentifiedConnection.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionsResponse();
        if (Array.isArray(object == null ? void 0 : object.connections))
          obj.connections = object.connections.map((e) => connection_1.IdentifiedConnection.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.connections) {
          obj.connections = message.connections.map((e) => e ? connection_1.IdentifiedConnection.toJSON(e) : void 0);
        } else {
          obj.connections = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryConnectionsResponse();
        message.connections = ((_a = object.connections) == null ? void 0 : _a.map((e) => connection_1.IdentifiedConnection.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryClientConnectionsRequest() {
      return {
        clientId: ""
      };
    }
    exports2.QueryClientConnectionsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientConnectionsRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientConnectionsRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientConnectionsResponse() {
      return {
        connectionPaths: [],
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryClientConnectionsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.connectionPaths) {
          writer.uint32(10).string(v);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionPaths.push(reader.string());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientConnectionsResponse();
        if (Array.isArray(object == null ? void 0 : object.connectionPaths))
          obj.connectionPaths = object.connectionPaths.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.connectionPaths) {
          obj.connectionPaths = message.connectionPaths.map((e) => e);
        } else {
          obj.connectionPaths = [];
        }
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryClientConnectionsResponse();
        message.connectionPaths = ((_a = object.connectionPaths) == null ? void 0 : _a.map((e) => e)) || [];
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionClientStateRequest() {
      return {
        connectionId: ""
      };
    }
    exports2.QueryConnectionClientStateRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionClientStateRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionClientStateRequest();
        message.connectionId = object.connectionId ?? "";
        return message;
      }
    };
    function createBaseQueryConnectionClientStateResponse() {
      return {
        identifiedClientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryConnectionClientStateResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionClientStateResponse();
        if ((0, helpers_1.isSet)(object.identifiedClientState))
          obj.identifiedClientState = client_1.IdentifiedClientState.fromJSON(object.identifiedClientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionClientStateResponse();
        if (object.identifiedClientState !== void 0 && object.identifiedClientState !== null) {
          message.identifiedClientState = client_1.IdentifiedClientState.fromPartial(object.identifiedClientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionConsensusStateRequest() {
      return {
        connectionId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports2.QueryConnectionConsensusStateRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionConsensusStateRequest();
        message.connectionId = object.connectionId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseQueryConnectionConsensusStateResponse() {
      return {
        consensusState: void 0,
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports2.QueryConnectionConsensusStateResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionParamsRequest() {
      return {};
    }
    exports2.QueryConnectionParamsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryConnectionParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryConnectionParamsRequest();
        return message;
      }
    };
    function createBaseQueryConnectionParamsResponse() {
      return {
        params: void 0
      };
    }
    exports2.QueryConnectionParamsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Connection = this.Connection.bind(this);
        this.Connections = this.Connections.bind(this);
        this.ClientConnections = this.ClientConnections.bind(this);
        this.ConnectionClientState = this.ConnectionClientState.bind(this);
        this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this);
        this.ConnectionParams = this.ConnectionParams.bind(this);
      }
      Connection(request) {
        const data = exports2.QueryConnectionRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connection", data);
        return promise.then((data2) => exports2.QueryConnectionResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Connections(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data = exports2.QueryConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connections", data);
        return promise.then((data2) => exports2.QueryConnectionsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ClientConnections(request) {
        const data = exports2.QueryClientConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", data);
        return promise.then((data2) => exports2.QueryClientConnectionsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ConnectionClientState(request) {
        const data = exports2.QueryConnectionClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", data);
        return promise.then((data2) => exports2.QueryConnectionClientStateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ConnectionConsensusState(request) {
        const data = exports2.QueryConnectionConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", data);
        return promise.then((data2) => exports2.QueryConnectionConsensusStateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ConnectionParams(request = {}) {
        const data = exports2.QueryConnectionParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionParams", data);
        return promise.then((data2) => exports2.QueryConnectionParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/cosmjs-types/tendermint/crypto/proof.js
var require_proof = __commonJS({
  "node_modules/cosmjs-types/tendermint/crypto/proof.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProofOps = exports2.ProofOp = exports2.DominoOp = exports2.ValueOp = exports2.Proof = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "tendermint.crypto";
    function createBaseProof() {
      return {
        total: BigInt(0),
        index: BigInt(0),
        leafHash: new Uint8Array(),
        aunts: []
      };
    }
    exports2.Proof = {
      typeUrl: "/tendermint.crypto.Proof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.total !== BigInt(0)) {
          writer.uint32(8).int64(message.total);
        }
        if (message.index !== BigInt(0)) {
          writer.uint32(16).int64(message.index);
        }
        if (message.leafHash.length !== 0) {
          writer.uint32(26).bytes(message.leafHash);
        }
        for (const v of message.aunts) {
          writer.uint32(34).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.int64();
              break;
            case 2:
              message.index = reader.int64();
              break;
            case 3:
              message.leafHash = reader.bytes();
              break;
            case 4:
              message.aunts.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProof();
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        if ((0, helpers_1.isSet)(object.index))
          obj.index = BigInt(object.index.toString());
        if ((0, helpers_1.isSet)(object.leafHash))
          obj.leafHash = (0, helpers_1.bytesFromBase64)(object.leafHash);
        if (Array.isArray(object == null ? void 0 : object.aunts))
          obj.aunts = object.aunts.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        message.index !== void 0 && (obj.index = (message.index || BigInt(0)).toString());
        message.leafHash !== void 0 && (obj.leafHash = (0, helpers_1.base64FromBytes)(message.leafHash !== void 0 ? message.leafHash : new Uint8Array()));
        if (message.aunts) {
          obj.aunts = message.aunts.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.aunts = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseProof();
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        if (object.index !== void 0 && object.index !== null) {
          message.index = BigInt(object.index.toString());
        }
        message.leafHash = object.leafHash ?? new Uint8Array();
        message.aunts = ((_a = object.aunts) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseValueOp() {
      return {
        key: new Uint8Array(),
        proof: void 0
      };
    }
    exports2.ValueOp = {
      typeUrl: "/tendermint.crypto.ValueOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.proof !== void 0) {
          exports2.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValueOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.proof = exports2.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValueOp();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = exports2.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? exports2.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValueOp();
        message.key = object.key ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = exports2.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
    function createBaseDominoOp() {
      return {
        key: "",
        input: "",
        output: ""
      };
    }
    exports2.DominoOp = {
      typeUrl: "/tendermint.crypto.DominoOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.input !== "") {
          writer.uint32(18).string(message.input);
        }
        if (message.output !== "") {
          writer.uint32(26).string(message.output);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDominoOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.input = reader.string();
              break;
            case 3:
              message.output = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDominoOp();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.input))
          obj.input = String(object.input);
        if ((0, helpers_1.isSet)(object.output))
          obj.output = String(object.output);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.input !== void 0 && (obj.input = message.input);
        message.output !== void 0 && (obj.output = message.output);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDominoOp();
        message.key = object.key ?? "";
        message.input = object.input ?? "";
        message.output = object.output ?? "";
        return message;
      }
    };
    function createBaseProofOp() {
      return {
        type: "",
        key: new Uint8Array(),
        data: new Uint8Array()
      };
    }
    exports2.ProofOp = {
      typeUrl: "/tendermint.crypto.ProofOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.key.length !== 0) {
          writer.uint32(18).bytes(message.key);
        }
        if (message.data.length !== 0) {
          writer.uint32(26).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.key = reader.bytes();
              break;
            case 3:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofOp();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProofOp();
        message.type = object.type ?? "";
        message.key = object.key ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProofOps() {
      return {
        ops: []
      };
    }
    exports2.ProofOps = {
      typeUrl: "/tendermint.crypto.ProofOps",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.ops) {
          exports2.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOps();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ops.push(exports2.ProofOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofOps();
        if (Array.isArray(object == null ? void 0 : object.ops))
          obj.ops = object.ops.map((e) => exports2.ProofOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.ops) {
          obj.ops = message.ops.map((e) => e ? exports2.ProofOp.toJSON(e) : void 0);
        } else {
          obj.ops = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseProofOps();
        message.ops = ((_a = object.ops) == null ? void 0 : _a.map((e) => exports2.ProofOp.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/tendermint/version/types.js
var require_types2 = __commonJS({
  "node_modules/cosmjs-types/tendermint/version/types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Consensus = exports2.App = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "tendermint.version";
    function createBaseApp() {
      return {
        protocol: BigInt(0),
        software: ""
      };
    }
    exports2.App = {
      typeUrl: "/tendermint.version.App",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.protocol !== BigInt(0)) {
          writer.uint32(8).uint64(message.protocol);
        }
        if (message.software !== "") {
          writer.uint32(18).string(message.software);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseApp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.protocol = reader.uint64();
              break;
            case 2:
              message.software = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseApp();
        if ((0, helpers_1.isSet)(object.protocol))
          obj.protocol = BigInt(object.protocol.toString());
        if ((0, helpers_1.isSet)(object.software))
          obj.software = String(object.software);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.protocol !== void 0 && (obj.protocol = (message.protocol || BigInt(0)).toString());
        message.software !== void 0 && (obj.software = message.software);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseApp();
        if (object.protocol !== void 0 && object.protocol !== null) {
          message.protocol = BigInt(object.protocol.toString());
        }
        message.software = object.software ?? "";
        return message;
      }
    };
    function createBaseConsensus() {
      return {
        block: BigInt(0),
        app: BigInt(0)
      };
    }
    exports2.Consensus = {
      typeUrl: "/tendermint.version.Consensus",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.block !== BigInt(0)) {
          writer.uint32(8).uint64(message.block);
        }
        if (message.app !== BigInt(0)) {
          writer.uint32(16).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensus();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = reader.uint64();
              break;
            case 2:
              message.app = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensus();
        if ((0, helpers_1.isSet)(object.block))
          obj.block = BigInt(object.block.toString());
        if ((0, helpers_1.isSet)(object.app))
          obj.app = BigInt(object.app.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = (message.block || BigInt(0)).toString());
        message.app !== void 0 && (obj.app = (message.app || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensus();
        if (object.block !== void 0 && object.block !== null) {
          message.block = BigInt(object.block.toString());
        }
        if (object.app !== void 0 && object.app !== null) {
          message.app = BigInt(object.app.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/tendermint/crypto/keys.js
var require_keys4 = __commonJS({
  "node_modules/cosmjs-types/tendermint/crypto/keys.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKey = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "tendermint.crypto";
    function createBasePublicKey() {
      return {
        ed25519: void 0,
        secp256k1: void 0
      };
    }
    exports2.PublicKey = {
      typeUrl: "/tendermint.crypto.PublicKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.ed25519 !== void 0) {
          writer.uint32(10).bytes(message.ed25519);
        }
        if (message.secp256k1 !== void 0) {
          writer.uint32(18).bytes(message.secp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ed25519 = reader.bytes();
              break;
            case 2:
              message.secp256k1 = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePublicKey();
        if ((0, helpers_1.isSet)(object.ed25519))
          obj.ed25519 = (0, helpers_1.bytesFromBase64)(object.ed25519);
        if ((0, helpers_1.isSet)(object.secp256k1))
          obj.secp256k1 = (0, helpers_1.bytesFromBase64)(object.secp256k1);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.ed25519 !== void 0 && (obj.ed25519 = message.ed25519 !== void 0 ? (0, helpers_1.base64FromBytes)(message.ed25519) : void 0);
        message.secp256k1 !== void 0 && (obj.secp256k1 = message.secp256k1 !== void 0 ? (0, helpers_1.base64FromBytes)(message.secp256k1) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePublicKey();
        message.ed25519 = object.ed25519 ?? void 0;
        message.secp256k1 = object.secp256k1 ?? void 0;
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/tendermint/types/validator.js
var require_validator = __commonJS({
  "node_modules/cosmjs-types/tendermint/types/validator.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SimpleValidator = exports2.Validator = exports2.ValidatorSet = exports2.protobufPackage = void 0;
    var keys_1 = require_keys4();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "tendermint.types";
    function createBaseValidatorSet() {
      return {
        validators: [],
        proposer: void 0,
        totalVotingPower: BigInt(0)
      };
    }
    exports2.ValidatorSet = {
      typeUrl: "/tendermint.types.ValidatorSet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          exports2.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.proposer !== void 0) {
          exports2.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(exports2.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.proposer = exports2.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSet();
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => exports2.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = exports2.Validator.fromJSON(object.proposer);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports2.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer ? exports2.Validator.toJSON(message.proposer) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorSet();
        message.validators = ((_a = object.validators) == null ? void 0 : _a.map((e) => exports2.Validator.fromPartial(e))) || [];
        if (object.proposer !== void 0 && object.proposer !== null) {
          message.proposer = exports2.Validator.fromPartial(object.proposer);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        return message;
      }
    };
    function createBaseValidator() {
      return {
        address: new Uint8Array(),
        pubKey: keys_1.PublicKey.fromPartial({}),
        votingPower: BigInt(0),
        proposerPriority: BigInt(0)
      };
    }
    exports2.Validator = {
      typeUrl: "/tendermint.types.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.votingPower);
        }
        if (message.proposerPriority !== BigInt(0)) {
          writer.uint32(32).int64(message.proposerPriority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 2:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPower = reader.int64();
              break;
            case 4:
              message.proposerPriority = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = (0, helpers_1.bytesFromBase64)(object.address);
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.votingPower))
          obj.votingPower = BigInt(object.votingPower.toString());
        if ((0, helpers_1.isSet)(object.proposerPriority))
          obj.proposerPriority = BigInt(object.proposerPriority.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== void 0 ? message.address : new Uint8Array()));
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || BigInt(0)).toString());
        message.proposerPriority !== void 0 && (obj.proposerPriority = (message.proposerPriority || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidator();
        message.address = object.address ?? new Uint8Array();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.votingPower !== void 0 && object.votingPower !== null) {
          message.votingPower = BigInt(object.votingPower.toString());
        }
        if (object.proposerPriority !== void 0 && object.proposerPriority !== null) {
          message.proposerPriority = BigInt(object.proposerPriority.toString());
        }
        return message;
      }
    };
    function createBaseSimpleValidator() {
      return {
        pubKey: void 0,
        votingPower: BigInt(0)
      };
    }
    exports2.SimpleValidator = {
      typeUrl: "/tendermint.types.SimpleValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.votingPower !== BigInt(0)) {
          writer.uint32(16).int64(message.votingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimpleValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.votingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimpleValidator();
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.votingPower))
          obj.votingPower = BigInt(object.votingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimpleValidator();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.votingPower !== void 0 && object.votingPower !== null) {
          message.votingPower = BigInt(object.votingPower.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/tendermint/types/types.js
var require_types3 = __commonJS({
  "node_modules/cosmjs-types/tendermint/types/types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TxProof = exports2.BlockMeta = exports2.LightBlock = exports2.SignedHeader = exports2.Proposal = exports2.CommitSig = exports2.Commit = exports2.Vote = exports2.Data = exports2.Header = exports2.BlockID = exports2.Part = exports2.PartSetHeader = exports2.signedMsgTypeToJSON = exports2.signedMsgTypeFromJSON = exports2.SignedMsgType = exports2.blockIDFlagToJSON = exports2.blockIDFlagFromJSON = exports2.BlockIDFlag = exports2.protobufPackage = void 0;
    var proof_1 = require_proof();
    var types_1 = require_types2();
    var timestamp_1 = require_timestamp();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "tendermint.types";
    var BlockIDFlag;
    (function(BlockIDFlag2) {
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
      BlockIDFlag2[BlockIDFlag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BlockIDFlag || (exports2.BlockIDFlag = BlockIDFlag = {}));
    function blockIDFlagFromJSON(object) {
      switch (object) {
        case 0:
        case "BLOCK_ID_FLAG_UNKNOWN":
          return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
        case 1:
        case "BLOCK_ID_FLAG_ABSENT":
          return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
        case 2:
        case "BLOCK_ID_FLAG_COMMIT":
          return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
        case 3:
        case "BLOCK_ID_FLAG_NIL":
          return BlockIDFlag.BLOCK_ID_FLAG_NIL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BlockIDFlag.UNRECOGNIZED;
      }
    }
    exports2.blockIDFlagFromJSON = blockIDFlagFromJSON;
    function blockIDFlagToJSON(object) {
      switch (object) {
        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
          return "BLOCK_ID_FLAG_UNKNOWN";
        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
          return "BLOCK_ID_FLAG_ABSENT";
        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
          return "BLOCK_ID_FLAG_COMMIT";
        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
          return "BLOCK_ID_FLAG_NIL";
        case BlockIDFlag.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.blockIDFlagToJSON = blockIDFlagToJSON;
    var SignedMsgType;
    (function(SignedMsgType2) {
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
      SignedMsgType2[SignedMsgType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignedMsgType || (exports2.SignedMsgType = SignedMsgType = {}));
    function signedMsgTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGNED_MSG_TYPE_UNKNOWN":
          return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
        case 1:
        case "SIGNED_MSG_TYPE_PREVOTE":
          return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
        case 2:
        case "SIGNED_MSG_TYPE_PRECOMMIT":
          return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
        case 32:
        case "SIGNED_MSG_TYPE_PROPOSAL":
          return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignedMsgType.UNRECOGNIZED;
      }
    }
    exports2.signedMsgTypeFromJSON = signedMsgTypeFromJSON;
    function signedMsgTypeToJSON(object) {
      switch (object) {
        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
          return "SIGNED_MSG_TYPE_UNKNOWN";
        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
          return "SIGNED_MSG_TYPE_PREVOTE";
        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
          return "SIGNED_MSG_TYPE_PRECOMMIT";
        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
          return "SIGNED_MSG_TYPE_PROPOSAL";
        case SignedMsgType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.signedMsgTypeToJSON = signedMsgTypeToJSON;
    function createBasePartSetHeader() {
      return {
        total: 0,
        hash: new Uint8Array()
      };
    }
    exports2.PartSetHeader = {
      typeUrl: "/tendermint.types.PartSetHeader",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.total !== 0) {
          writer.uint32(8).uint32(message.total);
        }
        if (message.hash.length !== 0) {
          writer.uint32(18).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePartSetHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.uint32();
              break;
            case 2:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePartSetHeader();
        if ((0, helpers_1.isSet)(object.total))
          obj.total = Number(object.total);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = Math.round(message.total));
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePartSetHeader();
        message.total = object.total ?? 0;
        message.hash = object.hash ?? new Uint8Array();
        return message;
      }
    };
    function createBasePart() {
      return {
        index: 0,
        bytes: new Uint8Array(),
        proof: proof_1.Proof.fromPartial({})
      };
    }
    exports2.Part = {
      typeUrl: "/tendermint.types.Part",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.bytes.length !== 0) {
          writer.uint32(18).bytes(message.bytes);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePart();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.bytes = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePart();
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.bytes))
          obj.bytes = (0, helpers_1.bytesFromBase64)(object.bytes);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = proof_1.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.bytes !== void 0 && (obj.bytes = (0, helpers_1.base64FromBytes)(message.bytes !== void 0 ? message.bytes : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePart();
        message.index = object.index ?? 0;
        message.bytes = object.bytes ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = proof_1.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
    function createBaseBlockID() {
      return {
        hash: new Uint8Array(),
        partSetHeader: exports2.PartSetHeader.fromPartial({})
      };
    }
    exports2.BlockID = {
      typeUrl: "/tendermint.types.BlockID",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.partSetHeader !== void 0) {
          exports2.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockID();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.partSetHeader = exports2.PartSetHeader.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockID();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.partSetHeader))
          obj.partSetHeader = exports2.PartSetHeader.fromJSON(object.partSetHeader);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.partSetHeader !== void 0 && (obj.partSetHeader = message.partSetHeader ? exports2.PartSetHeader.toJSON(message.partSetHeader) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockID();
        message.hash = object.hash ?? new Uint8Array();
        if (object.partSetHeader !== void 0 && object.partSetHeader !== null) {
          message.partSetHeader = exports2.PartSetHeader.fromPartial(object.partSetHeader);
        }
        return message;
      }
    };
    function createBaseHeader() {
      return {
        version: types_1.Consensus.fromPartial({}),
        chainId: "",
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        lastBlockId: exports2.BlockID.fromPartial({}),
        lastCommitHash: new Uint8Array(),
        dataHash: new Uint8Array(),
        validatorsHash: new Uint8Array(),
        nextValidatorsHash: new Uint8Array(),
        consensusHash: new Uint8Array(),
        appHash: new Uint8Array(),
        lastResultsHash: new Uint8Array(),
        evidenceHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports2.Header = {
      typeUrl: "/tendermint.types.Header",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== void 0) {
          types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (message.lastBlockId !== void 0) {
          exports2.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.lastCommitHash.length !== 0) {
          writer.uint32(50).bytes(message.lastCommitHash);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(58).bytes(message.dataHash);
        }
        if (message.validatorsHash.length !== 0) {
          writer.uint32(66).bytes(message.validatorsHash);
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(74).bytes(message.nextValidatorsHash);
        }
        if (message.consensusHash.length !== 0) {
          writer.uint32(82).bytes(message.consensusHash);
        }
        if (message.appHash.length !== 0) {
          writer.uint32(90).bytes(message.appHash);
        }
        if (message.lastResultsHash.length !== 0) {
          writer.uint32(98).bytes(message.lastResultsHash);
        }
        if (message.evidenceHash.length !== 0) {
          writer.uint32(106).bytes(message.evidenceHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(114).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = types_1.Consensus.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.lastBlockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.lastCommitHash = reader.bytes();
              break;
            case 7:
              message.dataHash = reader.bytes();
              break;
            case 8:
              message.validatorsHash = reader.bytes();
              break;
            case 9:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 10:
              message.consensusHash = reader.bytes();
              break;
            case 11:
              message.appHash = reader.bytes();
              break;
            case 12:
              message.lastResultsHash = reader.bytes();
              break;
            case 13:
              message.evidenceHash = reader.bytes();
              break;
            case 14:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeader();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = types_1.Consensus.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.lastBlockId))
          obj.lastBlockId = exports2.BlockID.fromJSON(object.lastBlockId);
        if ((0, helpers_1.isSet)(object.lastCommitHash))
          obj.lastCommitHash = (0, helpers_1.bytesFromBase64)(object.lastCommitHash);
        if ((0, helpers_1.isSet)(object.dataHash))
          obj.dataHash = (0, helpers_1.bytesFromBase64)(object.dataHash);
        if ((0, helpers_1.isSet)(object.validatorsHash))
          obj.validatorsHash = (0, helpers_1.bytesFromBase64)(object.validatorsHash);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.consensusHash))
          obj.consensusHash = (0, helpers_1.bytesFromBase64)(object.consensusHash);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        if ((0, helpers_1.isSet)(object.lastResultsHash))
          obj.lastResultsHash = (0, helpers_1.bytesFromBase64)(object.lastResultsHash);
        if ((0, helpers_1.isSet)(object.evidenceHash))
          obj.evidenceHash = (0, helpers_1.bytesFromBase64)(object.evidenceHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version ? types_1.Consensus.toJSON(message.version) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.lastBlockId !== void 0 && (obj.lastBlockId = message.lastBlockId ? exports2.BlockID.toJSON(message.lastBlockId) : void 0);
        message.lastCommitHash !== void 0 && (obj.lastCommitHash = (0, helpers_1.base64FromBytes)(message.lastCommitHash !== void 0 ? message.lastCommitHash : new Uint8Array()));
        message.dataHash !== void 0 && (obj.dataHash = (0, helpers_1.base64FromBytes)(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.validatorsHash !== void 0 && (obj.validatorsHash = (0, helpers_1.base64FromBytes)(message.validatorsHash !== void 0 ? message.validatorsHash : new Uint8Array()));
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.consensusHash !== void 0 && (obj.consensusHash = (0, helpers_1.base64FromBytes)(message.consensusHash !== void 0 ? message.consensusHash : new Uint8Array()));
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        message.lastResultsHash !== void 0 && (obj.lastResultsHash = (0, helpers_1.base64FromBytes)(message.lastResultsHash !== void 0 ? message.lastResultsHash : new Uint8Array()));
        message.evidenceHash !== void 0 && (obj.evidenceHash = (0, helpers_1.base64FromBytes)(message.evidenceHash !== void 0 ? message.evidenceHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeader();
        if (object.version !== void 0 && object.version !== null) {
          message.version = types_1.Consensus.fromPartial(object.version);
        }
        message.chainId = object.chainId ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.lastBlockId !== void 0 && object.lastBlockId !== null) {
          message.lastBlockId = exports2.BlockID.fromPartial(object.lastBlockId);
        }
        message.lastCommitHash = object.lastCommitHash ?? new Uint8Array();
        message.dataHash = object.dataHash ?? new Uint8Array();
        message.validatorsHash = object.validatorsHash ?? new Uint8Array();
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.consensusHash = object.consensusHash ?? new Uint8Array();
        message.appHash = object.appHash ?? new Uint8Array();
        message.lastResultsHash = object.lastResultsHash ?? new Uint8Array();
        message.evidenceHash = object.evidenceHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseData() {
      return {
        txs: []
      };
    }
    exports2.Data = {
      typeUrl: "/tendermint.types.Data",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseData();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseData();
        message.txs = ((_a = object.txs) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseVote() {
      return {
        type: 0,
        height: BigInt(0),
        round: 0,
        blockId: exports2.BlockID.fromPartial({}),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        validatorAddress: new Uint8Array(),
        validatorIndex: 0,
        signature: new Uint8Array()
      };
    }
    exports2.Vote = {
      typeUrl: "/tendermint.types.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(50).bytes(message.validatorAddress);
        }
        if (message.validatorIndex !== 0) {
          writer.uint32(56).int32(message.validatorIndex);
        }
        if (message.signature.length !== 0) {
          writer.uint32(66).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.validatorAddress = reader.bytes();
              break;
            case 7:
              message.validatorIndex = reader.int32();
              break;
            case 8:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = signedMsgTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports2.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.validatorIndex))
          obj.validatorIndex = Number(object.validatorIndex);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.validatorIndex !== void 0 && (obj.validatorIndex = Math.round(message.validatorIndex));
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote();
        message.type = object.type ?? 0;
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports2.BlockID.fromPartial(object.blockId);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        message.validatorIndex = object.validatorIndex ?? 0;
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseCommit() {
      return {
        height: BigInt(0),
        round: 0,
        blockId: exports2.BlockID.fromPartial({}),
        signatures: []
      };
    }
    exports2.Commit = {
      typeUrl: "/tendermint.types.Commit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports2.CommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.signatures.push(exports2.CommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommit();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports2.BlockID.fromJSON(object.blockId);
        if (Array.isArray(object == null ? void 0 : object.signatures))
          obj.signatures = object.signatures.map((e) => exports2.CommitSig.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports2.CommitSig.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseCommit();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports2.BlockID.fromPartial(object.blockId);
        }
        message.signatures = ((_a = object.signatures) == null ? void 0 : _a.map((e) => exports2.CommitSig.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommitSig() {
      return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array()
      };
    }
    exports2.CommitSig = {
      typeUrl: "/tendermint.types.CommitSig",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitSig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitSig();
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = blockIDFlagFromJSON(object.blockIdFlag);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitSig();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProposal() {
      return {
        type: 0,
        height: BigInt(0),
        round: 0,
        polRound: 0,
        blockId: exports2.BlockID.fromPartial({}),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array()
      };
    }
    exports2.Proposal = {
      typeUrl: "/tendermint.types.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.polRound !== 0) {
          writer.uint32(32).int32(message.polRound);
        }
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(50).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(58).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.polRound = reader.int32();
              break;
            case 5:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = signedMsgTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.polRound))
          obj.polRound = Number(object.polRound);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports2.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.polRound !== void 0 && (obj.polRound = Math.round(message.polRound));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProposal();
        message.type = object.type ?? 0;
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        message.polRound = object.polRound ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports2.BlockID.fromPartial(object.blockId);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSignedHeader() {
      return {
        header: void 0,
        commit: void 0
      };
    }
    exports2.SignedHeader = {
      typeUrl: "/tendermint.types.SignedHeader",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          exports2.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports2.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignedHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = exports2.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.commit = exports2.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignedHeader();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = exports2.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports2.Commit.fromJSON(object.commit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? exports2.Header.toJSON(message.header) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports2.Commit.toJSON(message.commit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignedHeader();
        if (object.header !== void 0 && object.header !== null) {
          message.header = exports2.Header.fromPartial(object.header);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports2.Commit.fromPartial(object.commit);
        }
        return message;
      }
    };
    function createBaseLightBlock() {
      return {
        signedHeader: void 0,
        validatorSet: void 0
      };
    }
    exports2.LightBlock = {
      typeUrl: "/tendermint.types.LightBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedHeader !== void 0) {
          exports2.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = exports2.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLightBlock();
        if ((0, helpers_1.isSet)(object.signedHeader))
          obj.signedHeader = exports2.SignedHeader.fromJSON(object.signedHeader);
        if ((0, helpers_1.isSet)(object.validatorSet))
          obj.validatorSet = validator_1.ValidatorSet.fromJSON(object.validatorSet);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? exports2.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLightBlock();
        if (object.signedHeader !== void 0 && object.signedHeader !== null) {
          message.signedHeader = exports2.SignedHeader.fromPartial(object.signedHeader);
        }
        if (object.validatorSet !== void 0 && object.validatorSet !== null) {
          message.validatorSet = validator_1.ValidatorSet.fromPartial(object.validatorSet);
        }
        return message;
      }
    };
    function createBaseBlockMeta() {
      return {
        blockId: exports2.BlockID.fromPartial({}),
        blockSize: BigInt(0),
        header: exports2.Header.fromPartial({}),
        numTxs: BigInt(0)
      };
    }
    exports2.BlockMeta = {
      typeUrl: "/tendermint.types.BlockMeta",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockId !== void 0) {
          exports2.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockSize !== BigInt(0)) {
          writer.uint32(16).int64(message.blockSize);
        }
        if (message.header !== void 0) {
          exports2.Header.encode(message.header, writer.uint32(26).fork()).ldelim();
        }
        if (message.numTxs !== BigInt(0)) {
          writer.uint32(32).int64(message.numTxs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockMeta();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockId = exports2.BlockID.decode(reader, reader.uint32());
              break;
            case 2:
              message.blockSize = reader.int64();
              break;
            case 3:
              message.header = exports2.Header.decode(reader, reader.uint32());
              break;
            case 4:
              message.numTxs = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockMeta();
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports2.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.blockSize))
          obj.blockSize = BigInt(object.blockSize.toString());
        if ((0, helpers_1.isSet)(object.header))
          obj.header = exports2.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.numTxs))
          obj.numTxs = BigInt(object.numTxs.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports2.BlockID.toJSON(message.blockId) : void 0);
        message.blockSize !== void 0 && (obj.blockSize = (message.blockSize || BigInt(0)).toString());
        message.header !== void 0 && (obj.header = message.header ? exports2.Header.toJSON(message.header) : void 0);
        message.numTxs !== void 0 && (obj.numTxs = (message.numTxs || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockMeta();
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports2.BlockID.fromPartial(object.blockId);
        }
        if (object.blockSize !== void 0 && object.blockSize !== null) {
          message.blockSize = BigInt(object.blockSize.toString());
        }
        if (object.header !== void 0 && object.header !== null) {
          message.header = exports2.Header.fromPartial(object.header);
        }
        if (object.numTxs !== void 0 && object.numTxs !== null) {
          message.numTxs = BigInt(object.numTxs.toString());
        }
        return message;
      }
    };
    function createBaseTxProof() {
      return {
        rootHash: new Uint8Array(),
        data: new Uint8Array(),
        proof: void 0
      };
    }
    exports2.TxProof = {
      typeUrl: "/tendermint.types.TxProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rootHash.length !== 0) {
          writer.uint32(10).bytes(message.rootHash);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rootHash = reader.bytes();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxProof();
        if ((0, helpers_1.isSet)(object.rootHash))
          obj.rootHash = (0, helpers_1.bytesFromBase64)(object.rootHash);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = proof_1.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rootHash !== void 0 && (obj.rootHash = (0, helpers_1.base64FromBytes)(message.rootHash !== void 0 ? message.rootHash : new Uint8Array()));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxProof();
        message.rootHash = object.rootHash ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = proof_1.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js
var require_tendermint = __commonJS({
  "node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Fraction = exports2.Header = exports2.Misbehaviour = exports2.ConsensusState = exports2.ClientState = exports2.protobufPackage = void 0;
    var duration_1 = require_duration();
    var client_1 = require_client();
    var proofs_1 = require_proofs2();
    var timestamp_1 = require_timestamp();
    var commitment_1 = require_commitment();
    var types_1 = require_types3();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "ibc.lightclients.tendermint.v1";
    function createBaseClientState() {
      return {
        chainId: "",
        trustLevel: exports2.Fraction.fromPartial({}),
        trustingPeriod: duration_1.Duration.fromPartial({}),
        unbondingPeriod: duration_1.Duration.fromPartial({}),
        maxClockDrift: duration_1.Duration.fromPartial({}),
        frozenHeight: client_1.Height.fromPartial({}),
        latestHeight: client_1.Height.fromPartial({}),
        proofSpecs: [],
        upgradePath: [],
        allowUpdateAfterExpiry: false,
        allowUpdateAfterMisbehaviour: false
      };
    }
    exports2.ClientState = {
      typeUrl: "/ibc.lightclients.tendermint.v1.ClientState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.chainId !== "") {
          writer.uint32(10).string(message.chainId);
        }
        if (message.trustLevel !== void 0) {
          exports2.Fraction.encode(message.trustLevel, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustingPeriod !== void 0) {
          duration_1.Duration.encode(message.trustingPeriod, writer.uint32(26).fork()).ldelim();
        }
        if (message.unbondingPeriod !== void 0) {
          duration_1.Duration.encode(message.unbondingPeriod, writer.uint32(34).fork()).ldelim();
        }
        if (message.maxClockDrift !== void 0) {
          duration_1.Duration.encode(message.maxClockDrift, writer.uint32(42).fork()).ldelim();
        }
        if (message.frozenHeight !== void 0) {
          client_1.Height.encode(message.frozenHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.latestHeight !== void 0) {
          client_1.Height.encode(message.latestHeight, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.proofSpecs) {
          proofs_1.ProofSpec.encode(v, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.upgradePath) {
          writer.uint32(74).string(v);
        }
        if (message.allowUpdateAfterExpiry === true) {
          writer.uint32(80).bool(message.allowUpdateAfterExpiry);
        }
        if (message.allowUpdateAfterMisbehaviour === true) {
          writer.uint32(88).bool(message.allowUpdateAfterMisbehaviour);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chainId = reader.string();
              break;
            case 2:
              message.trustLevel = exports2.Fraction.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.unbondingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 5:
              message.maxClockDrift = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 6:
              message.frozenHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.latestHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofSpecs.push(proofs_1.ProofSpec.decode(reader, reader.uint32()));
              break;
            case 9:
              message.upgradePath.push(reader.string());
              break;
            case 10:
              message.allowUpdateAfterExpiry = reader.bool();
              break;
            case 11:
              message.allowUpdateAfterMisbehaviour = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientState();
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.trustLevel))
          obj.trustLevel = exports2.Fraction.fromJSON(object.trustLevel);
        if ((0, helpers_1.isSet)(object.trustingPeriod))
          obj.trustingPeriod = duration_1.Duration.fromJSON(object.trustingPeriod);
        if ((0, helpers_1.isSet)(object.unbondingPeriod))
          obj.unbondingPeriod = duration_1.Duration.fromJSON(object.unbondingPeriod);
        if ((0, helpers_1.isSet)(object.maxClockDrift))
          obj.maxClockDrift = duration_1.Duration.fromJSON(object.maxClockDrift);
        if ((0, helpers_1.isSet)(object.frozenHeight))
          obj.frozenHeight = client_1.Height.fromJSON(object.frozenHeight);
        if ((0, helpers_1.isSet)(object.latestHeight))
          obj.latestHeight = client_1.Height.fromJSON(object.latestHeight);
        if (Array.isArray(object == null ? void 0 : object.proofSpecs))
          obj.proofSpecs = object.proofSpecs.map((e) => proofs_1.ProofSpec.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.upgradePath))
          obj.upgradePath = object.upgradePath.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.allowUpdateAfterExpiry))
          obj.allowUpdateAfterExpiry = Boolean(object.allowUpdateAfterExpiry);
        if ((0, helpers_1.isSet)(object.allowUpdateAfterMisbehaviour))
          obj.allowUpdateAfterMisbehaviour = Boolean(object.allowUpdateAfterMisbehaviour);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.trustLevel !== void 0 && (obj.trustLevel = message.trustLevel ? exports2.Fraction.toJSON(message.trustLevel) : void 0);
        message.trustingPeriod !== void 0 && (obj.trustingPeriod = message.trustingPeriod ? duration_1.Duration.toJSON(message.trustingPeriod) : void 0);
        message.unbondingPeriod !== void 0 && (obj.unbondingPeriod = message.unbondingPeriod ? duration_1.Duration.toJSON(message.unbondingPeriod) : void 0);
        message.maxClockDrift !== void 0 && (obj.maxClockDrift = message.maxClockDrift ? duration_1.Duration.toJSON(message.maxClockDrift) : void 0);
        message.frozenHeight !== void 0 && (obj.frozenHeight = message.frozenHeight ? client_1.Height.toJSON(message.frozenHeight) : void 0);
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight ? client_1.Height.toJSON(message.latestHeight) : void 0);
        if (message.proofSpecs) {
          obj.proofSpecs = message.proofSpecs.map((e) => e ? proofs_1.ProofSpec.toJSON(e) : void 0);
        } else {
          obj.proofSpecs = [];
        }
        if (message.upgradePath) {
          obj.upgradePath = message.upgradePath.map((e) => e);
        } else {
          obj.upgradePath = [];
        }
        message.allowUpdateAfterExpiry !== void 0 && (obj.allowUpdateAfterExpiry = message.allowUpdateAfterExpiry);
        message.allowUpdateAfterMisbehaviour !== void 0 && (obj.allowUpdateAfterMisbehaviour = message.allowUpdateAfterMisbehaviour);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseClientState();
        message.chainId = object.chainId ?? "";
        if (object.trustLevel !== void 0 && object.trustLevel !== null) {
          message.trustLevel = exports2.Fraction.fromPartial(object.trustLevel);
        }
        if (object.trustingPeriod !== void 0 && object.trustingPeriod !== null) {
          message.trustingPeriod = duration_1.Duration.fromPartial(object.trustingPeriod);
        }
        if (object.unbondingPeriod !== void 0 && object.unbondingPeriod !== null) {
          message.unbondingPeriod = duration_1.Duration.fromPartial(object.unbondingPeriod);
        }
        if (object.maxClockDrift !== void 0 && object.maxClockDrift !== null) {
          message.maxClockDrift = duration_1.Duration.fromPartial(object.maxClockDrift);
        }
        if (object.frozenHeight !== void 0 && object.frozenHeight !== null) {
          message.frozenHeight = client_1.Height.fromPartial(object.frozenHeight);
        }
        if (object.latestHeight !== void 0 && object.latestHeight !== null) {
          message.latestHeight = client_1.Height.fromPartial(object.latestHeight);
        }
        message.proofSpecs = ((_a = object.proofSpecs) == null ? void 0 : _a.map((e) => proofs_1.ProofSpec.fromPartial(e))) || [];
        message.upgradePath = ((_b = object.upgradePath) == null ? void 0 : _b.map((e) => e)) || [];
        message.allowUpdateAfterExpiry = object.allowUpdateAfterExpiry ?? false;
        message.allowUpdateAfterMisbehaviour = object.allowUpdateAfterMisbehaviour ?? false;
        return message;
      }
    };
    function createBaseConsensusState() {
      return {
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        root: commitment_1.MerkleRoot.fromPartial({}),
        nextValidatorsHash: new Uint8Array()
      };
    }
    exports2.ConsensusState = {
      typeUrl: "/ibc.lightclients.tendermint.v1.ConsensusState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(10).fork()).ldelim();
        }
        if (message.root !== void 0) {
          commitment_1.MerkleRoot.encode(message.root, writer.uint32(18).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(26).bytes(message.nextValidatorsHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.root = commitment_1.MerkleRoot.decode(reader, reader.uint32());
              break;
            case 3:
              message.nextValidatorsHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusState();
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.root))
          obj.root = commitment_1.MerkleRoot.fromJSON(object.root);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.root !== void 0 && (obj.root = message.root ? commitment_1.MerkleRoot.toJSON(message.root) : void 0);
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusState();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        if (object.root !== void 0 && object.root !== null) {
          message.root = commitment_1.MerkleRoot.fromPartial(object.root);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMisbehaviour() {
      return {
        clientId: "",
        header1: void 0,
        header2: void 0
      };
    }
    exports2.Misbehaviour = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Misbehaviour",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.header1 !== void 0) {
          exports2.Header.encode(message.header1, writer.uint32(18).fork()).ldelim();
        }
        if (message.header2 !== void 0) {
          exports2.Header.encode(message.header2, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMisbehaviour();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.header1 = exports2.Header.decode(reader, reader.uint32());
              break;
            case 3:
              message.header2 = exports2.Header.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMisbehaviour();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.header1))
          obj.header1 = exports2.Header.fromJSON(object.header1);
        if ((0, helpers_1.isSet)(object.header2))
          obj.header2 = exports2.Header.fromJSON(object.header2);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.header1 !== void 0 && (obj.header1 = message.header1 ? exports2.Header.toJSON(message.header1) : void 0);
        message.header2 !== void 0 && (obj.header2 = message.header2 ? exports2.Header.toJSON(message.header2) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMisbehaviour();
        message.clientId = object.clientId ?? "";
        if (object.header1 !== void 0 && object.header1 !== null) {
          message.header1 = exports2.Header.fromPartial(object.header1);
        }
        if (object.header2 !== void 0 && object.header2 !== null) {
          message.header2 = exports2.Header.fromPartial(object.header2);
        }
        return message;
      }
    };
    function createBaseHeader() {
      return {
        signedHeader: void 0,
        validatorSet: void 0,
        trustedHeight: client_1.Height.fromPartial({}),
        trustedValidators: void 0
      };
    }
    exports2.Header = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Header",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedHeader !== void 0) {
          types_1.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustedHeight !== void 0) {
          client_1.Height.encode(message.trustedHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.trustedValidators !== void 0) {
          validator_1.ValidatorSet.encode(message.trustedValidators, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = types_1.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustedHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.trustedValidators = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeader();
        if ((0, helpers_1.isSet)(object.signedHeader))
          obj.signedHeader = types_1.SignedHeader.fromJSON(object.signedHeader);
        if ((0, helpers_1.isSet)(object.validatorSet))
          obj.validatorSet = validator_1.ValidatorSet.fromJSON(object.validatorSet);
        if ((0, helpers_1.isSet)(object.trustedHeight))
          obj.trustedHeight = client_1.Height.fromJSON(object.trustedHeight);
        if ((0, helpers_1.isSet)(object.trustedValidators))
          obj.trustedValidators = validator_1.ValidatorSet.fromJSON(object.trustedValidators);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? types_1.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        message.trustedHeight !== void 0 && (obj.trustedHeight = message.trustedHeight ? client_1.Height.toJSON(message.trustedHeight) : void 0);
        message.trustedValidators !== void 0 && (obj.trustedValidators = message.trustedValidators ? validator_1.ValidatorSet.toJSON(message.trustedValidators) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeader();
        if (object.signedHeader !== void 0 && object.signedHeader !== null) {
          message.signedHeader = types_1.SignedHeader.fromPartial(object.signedHeader);
        }
        if (object.validatorSet !== void 0 && object.validatorSet !== null) {
          message.validatorSet = validator_1.ValidatorSet.fromPartial(object.validatorSet);
        }
        if (object.trustedHeight !== void 0 && object.trustedHeight !== null) {
          message.trustedHeight = client_1.Height.fromPartial(object.trustedHeight);
        }
        if (object.trustedValidators !== void 0 && object.trustedValidators !== null) {
          message.trustedValidators = validator_1.ValidatorSet.fromPartial(object.trustedValidators);
        }
        return message;
      }
    };
    function createBaseFraction() {
      return {
        numerator: BigInt(0),
        denominator: BigInt(0)
      };
    }
    exports2.Fraction = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Fraction",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.numerator !== BigInt(0)) {
          writer.uint32(8).uint64(message.numerator);
        }
        if (message.denominator !== BigInt(0)) {
          writer.uint32(16).uint64(message.denominator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFraction();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.numerator = reader.uint64();
              break;
            case 2:
              message.denominator = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFraction();
        if ((0, helpers_1.isSet)(object.numerator))
          obj.numerator = BigInt(object.numerator.toString());
        if ((0, helpers_1.isSet)(object.denominator))
          obj.denominator = BigInt(object.denominator.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.numerator !== void 0 && (obj.numerator = (message.numerator || BigInt(0)).toString());
        message.denominator !== void 0 && (obj.denominator = (message.denominator || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseFraction();
        if (object.numerator !== void 0 && object.numerator !== null) {
          message.numerator = BigInt(object.numerator.toString());
        }
        if (object.denominator !== void 0 && object.denominator !== null) {
          message.denominator = BigInt(object.denominator.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/@cosmjs/stargate/build/modules/ibc/queries.js
var require_queries7 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/ibc/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupIbcExtension = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var query_1 = require_query7();
    var channel_1 = require_channel();
    var query_2 = require_query8();
    var query_3 = require_query9();
    var query_4 = require_query10();
    var tendermint_1 = require_tendermint();
    var queryclient_1 = require_queryclient2();
    function decodeTendermintClientStateAny(clientState) {
      if ((clientState == null ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ClientState") {
        throw new Error(`Unexpected client state type: ${clientState == null ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ClientState.decode(clientState.value);
    }
    function decodeTendermintConsensusStateAny(clientState) {
      if ((clientState == null ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ConsensusState") {
        throw new Error(`Unexpected client state type: ${clientState == null ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ConsensusState.decode(clientState.value);
    }
    function setupIbcExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const channelQueryService = new query_2.QueryClientImpl(rpc);
      const clientQueryService = new query_3.QueryClientImpl(rpc);
      const connectionQueryService = new query_4.QueryClientImpl(rpc);
      const transferQueryService = new query_1.QueryClientImpl(rpc);
      return {
        ibc: {
          channel: {
            channel: async (portId, channelId) => channelQueryService.Channel({
              portId,
              channelId
            }),
            channels: async (paginationKey) => channelQueryService.Channels({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allChannels: async () => {
              var _a;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.Channels({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            connectionChannels: async (connection, paginationKey) => channelQueryService.ConnectionChannels({
              connection,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnectionChannels: async (connection) => {
              var _a;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.ConnectionChannels({
                  connection,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryConnectionChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            clientState: async (portId, channelId) => channelQueryService.ChannelClientState({
              portId,
              channelId
            }),
            consensusState: async (portId, channelId, revisionNumber, revisionHeight) => channelQueryService.ChannelConsensusState({
              portId,
              channelId,
              revisionNumber: BigInt(revisionNumber),
              revisionHeight: BigInt(revisionHeight)
            }),
            packetCommitment: async (portId, channelId, sequence) => channelQueryService.PacketCommitment({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetCommitments: async (portId, channelId, paginationKey) => channelQueryService.PacketCommitments({
              channelId,
              portId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allPacketCommitments: async (portId, channelId) => {
              var _a;
              const commitments = [];
              let response;
              let key;
              do {
                response = await channelQueryService.PacketCommitments({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                commitments.push(...response.commitments);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketCommitmentsResponse.fromPartial({
                commitments,
                height: response.height
              });
            },
            packetReceipt: async (portId, channelId, sequence) => channelQueryService.PacketReceipt({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgement: async (portId, channelId, sequence) => channelQueryService.PacketAcknowledgement({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgements: async (portId, channelId, paginationKey) => {
              const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                portId,
                channelId,
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return channelQueryService.PacketAcknowledgements(request);
            },
            allPacketAcknowledgements: async (portId, channelId) => {
              var _a;
              const acknowledgements = [];
              let response;
              let key;
              do {
                const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                response = await channelQueryService.PacketAcknowledgements(request);
                acknowledgements.push(...response.acknowledgements);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketAcknowledgementsResponse.fromPartial({
                acknowledgements,
                height: response.height
              });
            },
            unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => channelQueryService.UnreceivedPackets({
              portId,
              channelId,
              packetCommitmentSequences: packetCommitmentSequences.map((s) => BigInt(s))
            }),
            unreceivedAcks: async (portId, channelId, packetAckSequences) => channelQueryService.UnreceivedAcks({
              portId,
              channelId,
              packetAckSequences: packetAckSequences.map((s) => BigInt(s))
            }),
            nextSequenceReceive: async (portId, channelId) => channelQueryService.NextSequenceReceive({
              portId,
              channelId
            })
          },
          client: {
            state: async (clientId) => clientQueryService.ClientState({ clientId }),
            states: async (paginationKey) => clientQueryService.ClientStates({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allStates: async () => {
              var _a;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_3.QueryClientStatesResponse.fromPartial({
                clientStates
              });
            },
            consensusState: async (clientId, consensusHeight) => clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
              clientId,
              revisionHeight: consensusHeight !== void 0 ? BigInt(consensusHeight) : void 0,
              latestHeight: consensusHeight === void 0
            })),
            consensusStates: async (clientId, paginationKey) => clientQueryService.ConsensusStates({
              clientId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConsensusStates: async (clientId) => {
              var _a;
              const consensusStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ConsensusStates({
                  clientId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                consensusStates.push(...response.consensusStates);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_3.QueryConsensusStatesResponse.fromPartial({
                consensusStates
              });
            },
            params: async () => clientQueryService.ClientParams({}),
            stateTm: async (clientId) => {
              const response = await clientQueryService.ClientState({ clientId });
              return decodeTendermintClientStateAny(response.clientState);
            },
            statesTm: async (paginationKey) => {
              const { clientStates } = await clientQueryService.ClientStates({
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            allStatesTm: async () => {
              var _a;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            consensusStateTm: async (clientId, consensusHeight) => {
              const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                clientId,
                revisionHeight: consensusHeight == null ? void 0 : consensusHeight.revisionHeight,
                revisionNumber: consensusHeight == null ? void 0 : consensusHeight.revisionNumber,
                latestHeight: consensusHeight === void 0
              }));
              return decodeTendermintConsensusStateAny(response.consensusState);
            }
          },
          connection: {
            connection: async (connectionId) => connectionQueryService.Connection({
              connectionId
            }),
            connections: async (paginationKey) => connectionQueryService.Connections({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnections: async () => {
              var _a;
              const connections = [];
              let response;
              let key;
              do {
                response = await connectionQueryService.Connections({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                connections.push(...response.connections);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_4.QueryConnectionsResponse.fromPartial({
                connections,
                height: response.height
              });
            },
            clientConnections: async (clientId) => connectionQueryService.ClientConnections({
              clientId
            }),
            clientState: async (connectionId) => connectionQueryService.ConnectionClientState({
              connectionId
            }),
            consensusState: async (connectionId, revisionHeight) => connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({
              connectionId,
              revisionHeight: BigInt(revisionHeight)
            }))
          },
          transfer: {
            denomTrace: async (hash) => transferQueryService.DenomTrace({ hash }),
            denomTraces: async (paginationKey) => transferQueryService.DenomTraces({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allDenomTraces: async () => {
              var _a;
              const denomTraces = [];
              let response;
              let key;
              do {
                response = await transferQueryService.DenomTraces({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                denomTraces.push(...response.denomTraces);
                key = (_a = response.pagination) == null ? void 0 : _a.nextKey;
              } while (key && key.length);
              return query_1.QueryDenomTracesResponse.fromPartial({
                denomTraces
              });
            },
            params: async () => transferQueryService.Params({})
          },
          verified: {
            channel: {
              channel: async (portId, channelId) => {
                const key = (0, encoding_1.toAscii)(`channelEnds/ports/${portId}/channels/${channelId}`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value.length ? channel_1.Channel.decode(value) : null;
              },
              packetCommitment: async (portId, channelId, sequence) => {
                const key = (0, encoding_1.toAscii)(`commitments/ports/${portId}/channels/${channelId}/packets/${sequence}`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value;
              },
              packetAcknowledgement: async (portId, channelId, sequence) => {
                const key = (0, encoding_1.toAscii)(`acks/ports/${portId}/channels/${channelId}/acknowledgements/${sequence}`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value;
              },
              nextSequenceReceive: async (portId, channelId) => {
                const key = (0, encoding_1.toAscii)(`seqAcks/ports/${portId}/channels/${channelId}/nextSequenceAck`);
                const { value } = await base.queryStoreVerified("ibc", key);
                return value.length ? math_1.Uint64.fromBytes(value).toNumber() : null;
              }
            }
          }
        }
      };
    }
    exports2.setupIbcExtension = setupIbcExtension;
  }
});

// node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js
var require_mint = __commonJS({
  "node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.Minter = exports2.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.mint.v1beta1";
    function createBaseMinter() {
      return {
        inflation: "",
        annualProvisions: ""
      };
    }
    exports2.Minter = {
      typeUrl: "/cosmos.mint.v1beta1.Minter",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflation !== "") {
          writer.uint32(10).string(message.inflation);
        }
        if (message.annualProvisions !== "") {
          writer.uint32(18).string(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMinter();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.string();
              break;
            case 2:
              message.annualProvisions = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMinter();
        if ((0, helpers_1.isSet)(object.inflation))
          obj.inflation = String(object.inflation);
        if ((0, helpers_1.isSet)(object.annualProvisions))
          obj.annualProvisions = String(object.annualProvisions);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = message.inflation);
        message.annualProvisions !== void 0 && (obj.annualProvisions = message.annualProvisions);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMinter();
        message.inflation = object.inflation ?? "";
        message.annualProvisions = object.annualProvisions ?? "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        mintDenom: "",
        inflationRateChange: "",
        inflationMax: "",
        inflationMin: "",
        goalBonded: "",
        blocksPerYear: BigInt(0)
      };
    }
    exports2.Params = {
      typeUrl: "/cosmos.mint.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mintDenom !== "") {
          writer.uint32(10).string(message.mintDenom);
        }
        if (message.inflationRateChange !== "") {
          writer.uint32(18).string(message.inflationRateChange);
        }
        if (message.inflationMax !== "") {
          writer.uint32(26).string(message.inflationMax);
        }
        if (message.inflationMin !== "") {
          writer.uint32(34).string(message.inflationMin);
        }
        if (message.goalBonded !== "") {
          writer.uint32(42).string(message.goalBonded);
        }
        if (message.blocksPerYear !== BigInt(0)) {
          writer.uint32(48).uint64(message.blocksPerYear);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mintDenom = reader.string();
              break;
            case 2:
              message.inflationRateChange = reader.string();
              break;
            case 3:
              message.inflationMax = reader.string();
              break;
            case 4:
              message.inflationMin = reader.string();
              break;
            case 5:
              message.goalBonded = reader.string();
              break;
            case 6:
              message.blocksPerYear = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.mintDenom))
          obj.mintDenom = String(object.mintDenom);
        if ((0, helpers_1.isSet)(object.inflationRateChange))
          obj.inflationRateChange = String(object.inflationRateChange);
        if ((0, helpers_1.isSet)(object.inflationMax))
          obj.inflationMax = String(object.inflationMax);
        if ((0, helpers_1.isSet)(object.inflationMin))
          obj.inflationMin = String(object.inflationMin);
        if ((0, helpers_1.isSet)(object.goalBonded))
          obj.goalBonded = String(object.goalBonded);
        if ((0, helpers_1.isSet)(object.blocksPerYear))
          obj.blocksPerYear = BigInt(object.blocksPerYear.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mintDenom !== void 0 && (obj.mintDenom = message.mintDenom);
        message.inflationRateChange !== void 0 && (obj.inflationRateChange = message.inflationRateChange);
        message.inflationMax !== void 0 && (obj.inflationMax = message.inflationMax);
        message.inflationMin !== void 0 && (obj.inflationMin = message.inflationMin);
        message.goalBonded !== void 0 && (obj.goalBonded = message.goalBonded);
        message.blocksPerYear !== void 0 && (obj.blocksPerYear = (message.blocksPerYear || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.mintDenom = object.mintDenom ?? "";
        message.inflationRateChange = object.inflationRateChange ?? "";
        message.inflationMax = object.inflationMax ?? "";
        message.inflationMin = object.inflationMin ?? "";
        message.goalBonded = object.goalBonded ?? "";
        if (object.blocksPerYear !== void 0 && object.blocksPerYear !== null) {
          message.blocksPerYear = BigInt(object.blocksPerYear.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js
var require_query11 = __commonJS({
  "node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryAnnualProvisionsResponse = exports2.QueryAnnualProvisionsRequest = exports2.QueryInflationResponse = exports2.QueryInflationRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.protobufPackage = void 0;
    var mint_1 = require_mint();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.mint.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: mint_1.Params.fromPartial({})
      };
    }
    exports2.QueryParamsResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          mint_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = mint_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = mint_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? mint_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = mint_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryInflationRequest() {
      return {};
    }
    exports2.QueryInflationRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryInflationRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryInflationRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryInflationRequest();
        return message;
      }
    };
    function createBaseQueryInflationResponse() {
      return {
        inflation: new Uint8Array()
      };
    }
    exports2.QueryInflationResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryInflationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflation.length !== 0) {
          writer.uint32(10).bytes(message.inflation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryInflationResponse();
        if ((0, helpers_1.isSet)(object.inflation))
          obj.inflation = (0, helpers_1.bytesFromBase64)(object.inflation);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = (0, helpers_1.base64FromBytes)(message.inflation !== void 0 ? message.inflation : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryInflationResponse();
        message.inflation = object.inflation ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryAnnualProvisionsRequest() {
      return {};
    }
    exports2.QueryAnnualProvisionsRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryAnnualProvisionsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryAnnualProvisionsRequest();
        return message;
      }
    };
    function createBaseQueryAnnualProvisionsResponse() {
      return {
        annualProvisions: new Uint8Array()
      };
    }
    exports2.QueryAnnualProvisionsResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.annualProvisions.length !== 0) {
          writer.uint32(10).bytes(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.annualProvisions = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAnnualProvisionsResponse();
        if ((0, helpers_1.isSet)(object.annualProvisions))
          obj.annualProvisions = (0, helpers_1.bytesFromBase64)(object.annualProvisions);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.annualProvisions !== void 0 && (obj.annualProvisions = (0, helpers_1.base64FromBytes)(message.annualProvisions !== void 0 ? message.annualProvisions : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAnnualProvisionsResponse();
        message.annualProvisions = object.annualProvisions ?? new Uint8Array();
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Inflation = this.Inflation.bind(this);
        this.AnnualProvisions = this.AnnualProvisions.bind(this);
      }
      Params(request = {}) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Inflation(request = {}) {
        const data = exports2.QueryInflationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", data);
        return promise.then((data2) => exports2.QueryInflationResponse.decode(new binary_1.BinaryReader(data2)));
      }
      AnnualProvisions(request = {}) {
        const data = exports2.QueryAnnualProvisionsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", data);
        return promise.then((data2) => exports2.QueryAnnualProvisionsResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/mint/queries.js
var require_queries8 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/mint/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupMintExtension = void 0;
    var utils_1 = require_build3();
    var query_1 = require_query11();
    var queryclient_1 = require_queryclient2();
    function setupMintExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        mint: {
          params: async () => {
            const { params } = await queryService.Params({});
            (0, utils_1.assert)(params);
            return {
              blocksPerYear: params.blocksPerYear,
              goalBonded: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.goalBonded),
              inflationMin: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMin),
              inflationMax: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMax),
              inflationRateChange: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationRateChange),
              mintDenom: params.mintDenom
            };
          },
          inflation: async () => {
            const { inflation } = await queryService.Inflation({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(inflation);
          },
          annualProvisions: async () => {
            const { annualProvisions } = await queryService.AnnualProvisions({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(annualProvisions);
          }
        }
      };
    }
    exports2.setupMintExtension = setupMintExtension;
  }
});

// node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js
var require_aminomessages10 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSlashingAminoConverters = exports2.isAminoMsgUnjail = void 0;
    function isAminoMsgUnjail(msg) {
      return msg.type === "cosmos-sdk/MsgUnjail";
    }
    exports2.isAminoMsgUnjail = isAminoMsgUnjail;
    function createSlashingAminoConverters() {
      throw new Error("Not implemented");
    }
    exports2.createSlashingAminoConverters = createSlashingAminoConverters;
  }
});

// node_modules/cosmjs-types/cosmos/slashing/v1beta1/slashing.js
var require_slashing = __commonJS({
  "node_modules/cosmjs-types/cosmos/slashing/v1beta1/slashing.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Params = exports2.ValidatorSigningInfo = exports2.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.slashing.v1beta1";
    function createBaseValidatorSigningInfo() {
      return {
        address: "",
        startHeight: BigInt(0),
        indexOffset: BigInt(0),
        jailedUntil: timestamp_1.Timestamp.fromPartial({}),
        tombstoned: false,
        missedBlocksCounter: BigInt(0)
      };
    }
    exports2.ValidatorSigningInfo = {
      typeUrl: "/cosmos.slashing.v1beta1.ValidatorSigningInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.startHeight !== BigInt(0)) {
          writer.uint32(16).int64(message.startHeight);
        }
        if (message.indexOffset !== BigInt(0)) {
          writer.uint32(24).int64(message.indexOffset);
        }
        if (message.jailedUntil !== void 0) {
          timestamp_1.Timestamp.encode(message.jailedUntil, writer.uint32(34).fork()).ldelim();
        }
        if (message.tombstoned === true) {
          writer.uint32(40).bool(message.tombstoned);
        }
        if (message.missedBlocksCounter !== BigInt(0)) {
          writer.uint32(48).int64(message.missedBlocksCounter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSigningInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.startHeight = reader.int64();
              break;
            case 3:
              message.indexOffset = reader.int64();
              break;
            case 4:
              message.jailedUntil = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.tombstoned = reader.bool();
              break;
            case 6:
              message.missedBlocksCounter = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSigningInfo();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.startHeight))
          obj.startHeight = BigInt(object.startHeight.toString());
        if ((0, helpers_1.isSet)(object.indexOffset))
          obj.indexOffset = BigInt(object.indexOffset.toString());
        if ((0, helpers_1.isSet)(object.jailedUntil))
          obj.jailedUntil = (0, helpers_1.fromJsonTimestamp)(object.jailedUntil);
        if ((0, helpers_1.isSet)(object.tombstoned))
          obj.tombstoned = Boolean(object.tombstoned);
        if ((0, helpers_1.isSet)(object.missedBlocksCounter))
          obj.missedBlocksCounter = BigInt(object.missedBlocksCounter.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.startHeight !== void 0 && (obj.startHeight = (message.startHeight || BigInt(0)).toString());
        message.indexOffset !== void 0 && (obj.indexOffset = (message.indexOffset || BigInt(0)).toString());
        message.jailedUntil !== void 0 && (obj.jailedUntil = (0, helpers_1.fromTimestamp)(message.jailedUntil).toISOString());
        message.tombstoned !== void 0 && (obj.tombstoned = message.tombstoned);
        message.missedBlocksCounter !== void 0 && (obj.missedBlocksCounter = (message.missedBlocksCounter || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSigningInfo();
        message.address = object.address ?? "";
        if (object.startHeight !== void 0 && object.startHeight !== null) {
          message.startHeight = BigInt(object.startHeight.toString());
        }
        if (object.indexOffset !== void 0 && object.indexOffset !== null) {
          message.indexOffset = BigInt(object.indexOffset.toString());
        }
        if (object.jailedUntil !== void 0 && object.jailedUntil !== null) {
          message.jailedUntil = timestamp_1.Timestamp.fromPartial(object.jailedUntil);
        }
        message.tombstoned = object.tombstoned ?? false;
        if (object.missedBlocksCounter !== void 0 && object.missedBlocksCounter !== null) {
          message.missedBlocksCounter = BigInt(object.missedBlocksCounter.toString());
        }
        return message;
      }
    };
    function createBaseParams() {
      return {
        signedBlocksWindow: BigInt(0),
        minSignedPerWindow: new Uint8Array(),
        downtimeJailDuration: duration_1.Duration.fromPartial({}),
        slashFractionDoubleSign: new Uint8Array(),
        slashFractionDowntime: new Uint8Array()
      };
    }
    exports2.Params = {
      typeUrl: "/cosmos.slashing.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedBlocksWindow !== BigInt(0)) {
          writer.uint32(8).int64(message.signedBlocksWindow);
        }
        if (message.minSignedPerWindow.length !== 0) {
          writer.uint32(18).bytes(message.minSignedPerWindow);
        }
        if (message.downtimeJailDuration !== void 0) {
          duration_1.Duration.encode(message.downtimeJailDuration, writer.uint32(26).fork()).ldelim();
        }
        if (message.slashFractionDoubleSign.length !== 0) {
          writer.uint32(34).bytes(message.slashFractionDoubleSign);
        }
        if (message.slashFractionDowntime.length !== 0) {
          writer.uint32(42).bytes(message.slashFractionDowntime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedBlocksWindow = reader.int64();
              break;
            case 2:
              message.minSignedPerWindow = reader.bytes();
              break;
            case 3:
              message.downtimeJailDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.slashFractionDoubleSign = reader.bytes();
              break;
            case 5:
              message.slashFractionDowntime = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.signedBlocksWindow))
          obj.signedBlocksWindow = BigInt(object.signedBlocksWindow.toString());
        if ((0, helpers_1.isSet)(object.minSignedPerWindow))
          obj.minSignedPerWindow = (0, helpers_1.bytesFromBase64)(object.minSignedPerWindow);
        if ((0, helpers_1.isSet)(object.downtimeJailDuration))
          obj.downtimeJailDuration = duration_1.Duration.fromJSON(object.downtimeJailDuration);
        if ((0, helpers_1.isSet)(object.slashFractionDoubleSign))
          obj.slashFractionDoubleSign = (0, helpers_1.bytesFromBase64)(object.slashFractionDoubleSign);
        if ((0, helpers_1.isSet)(object.slashFractionDowntime))
          obj.slashFractionDowntime = (0, helpers_1.bytesFromBase64)(object.slashFractionDowntime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedBlocksWindow !== void 0 && (obj.signedBlocksWindow = (message.signedBlocksWindow || BigInt(0)).toString());
        message.minSignedPerWindow !== void 0 && (obj.minSignedPerWindow = (0, helpers_1.base64FromBytes)(message.minSignedPerWindow !== void 0 ? message.minSignedPerWindow : new Uint8Array()));
        message.downtimeJailDuration !== void 0 && (obj.downtimeJailDuration = message.downtimeJailDuration ? duration_1.Duration.toJSON(message.downtimeJailDuration) : void 0);
        message.slashFractionDoubleSign !== void 0 && (obj.slashFractionDoubleSign = (0, helpers_1.base64FromBytes)(message.slashFractionDoubleSign !== void 0 ? message.slashFractionDoubleSign : new Uint8Array()));
        message.slashFractionDowntime !== void 0 && (obj.slashFractionDowntime = (0, helpers_1.base64FromBytes)(message.slashFractionDowntime !== void 0 ? message.slashFractionDowntime : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.signedBlocksWindow !== void 0 && object.signedBlocksWindow !== null) {
          message.signedBlocksWindow = BigInt(object.signedBlocksWindow.toString());
        }
        message.minSignedPerWindow = object.minSignedPerWindow ?? new Uint8Array();
        if (object.downtimeJailDuration !== void 0 && object.downtimeJailDuration !== null) {
          message.downtimeJailDuration = duration_1.Duration.fromPartial(object.downtimeJailDuration);
        }
        message.slashFractionDoubleSign = object.slashFractionDoubleSign ?? new Uint8Array();
        message.slashFractionDowntime = object.slashFractionDowntime ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js
var require_query12 = __commonJS({
  "node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QuerySigningInfosResponse = exports2.QuerySigningInfosRequest = exports2.QuerySigningInfoResponse = exports2.QuerySigningInfoRequest = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var slashing_1 = require_slashing();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.slashing.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: slashing_1.Params.fromPartial({})
      };
    }
    exports2.QueryParamsResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          slashing_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = slashing_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = slashing_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? slashing_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = slashing_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfoRequest() {
      return {
        consAddress: ""
      };
    }
    exports2.QuerySigningInfoRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consAddress !== "") {
          writer.uint32(10).string(message.consAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfoRequest();
        if ((0, helpers_1.isSet)(object.consAddress))
          obj.consAddress = String(object.consAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consAddress !== void 0 && (obj.consAddress = message.consAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfoRequest();
        message.consAddress = object.consAddress ?? "";
        return message;
      }
    };
    function createBaseQuerySigningInfoResponse() {
      return {
        valSigningInfo: slashing_1.ValidatorSigningInfo.fromPartial({})
      };
    }
    exports2.QuerySigningInfoResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.valSigningInfo !== void 0) {
          slashing_1.ValidatorSigningInfo.encode(message.valSigningInfo, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.valSigningInfo = slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfoResponse();
        if ((0, helpers_1.isSet)(object.valSigningInfo))
          obj.valSigningInfo = slashing_1.ValidatorSigningInfo.fromJSON(object.valSigningInfo);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.valSigningInfo !== void 0 && (obj.valSigningInfo = message.valSigningInfo ? slashing_1.ValidatorSigningInfo.toJSON(message.valSigningInfo) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfoResponse();
        if (object.valSigningInfo !== void 0 && object.valSigningInfo !== null) {
          message.valSigningInfo = slashing_1.ValidatorSigningInfo.fromPartial(object.valSigningInfo);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfosRequest() {
      return {
        pagination: void 0
      };
    }
    exports2.QuerySigningInfosRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfosRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfosRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfosResponse() {
      return {
        info: [],
        pagination: void 0
      };
    }
    exports2.QuerySigningInfosResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.info) {
          slashing_1.ValidatorSigningInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.info.push(slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfosResponse();
        if (Array.isArray(object == null ? void 0 : object.info))
          obj.info = object.info.map((e) => slashing_1.ValidatorSigningInfo.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.info) {
          obj.info = message.info.map((e) => e ? slashing_1.ValidatorSigningInfo.toJSON(e) : void 0);
        } else {
          obj.info = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQuerySigningInfosResponse();
        message.info = ((_a = object.info) == null ? void 0 : _a.map((e) => slashing_1.ValidatorSigningInfo.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.SigningInfo = this.SigningInfo.bind(this);
        this.SigningInfos = this.SigningInfos.bind(this);
      }
      Params(request = {}) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      SigningInfo(request) {
        const data = exports2.QuerySigningInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", data);
        return promise.then((data2) => exports2.QuerySigningInfoResponse.decode(new binary_1.BinaryReader(data2)));
      }
      SigningInfos(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data = exports2.QuerySigningInfosRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", data);
        return promise.then((data2) => exports2.QuerySigningInfosResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/slashing/queries.js
var require_queries9 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/slashing/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupSlashingExtension = void 0;
    var query_1 = require_query12();
    var queryclient_1 = require_queryclient2();
    function setupSlashingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        slashing: {
          signingInfo: async (consAddress) => {
            const response = await queryService.SigningInfo({
              consAddress
            });
            return response;
          },
          signingInfos: async (paginationKey) => {
            const response = await queryService.SigningInfos({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          }
        }
      };
    }
    exports2.setupSlashingExtension = setupSlashingExtension;
  }
});

// node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js
var require_aminomessages11 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createStakingAminoConverters = exports2.isAminoMsgCancelUnbondingDelegation = exports2.isAminoMsgUndelegate = exports2.isAminoMsgBeginRedelegate = exports2.isAminoMsgDelegate = exports2.isAminoMsgEditValidator = exports2.isAminoMsgCreateValidator = exports2.protoDecimalToJson = void 0;
    var math_1 = require_build2();
    var proto_signing_1 = require_build8();
    var utils_1 = require_build3();
    function protoDecimalToJson(decimal) {
      const parsed = math_1.Decimal.fromAtomics(decimal, 18);
      const [whole, fractional] = parsed.toString().split(".");
      return `${whole}.${(fractional ?? "").padEnd(18, "0")}`;
    }
    exports2.protoDecimalToJson = protoDecimalToJson;
    function jsonDecimalToProto(decimal) {
      const parsed = math_1.Decimal.fromUserInput(decimal, 18);
      return parsed.atomics;
    }
    function isAminoMsgCreateValidator(msg) {
      return msg.type === "cosmos-sdk/MsgCreateValidator";
    }
    exports2.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
    function isAminoMsgEditValidator(msg) {
      return msg.type === "cosmos-sdk/MsgEditValidator";
    }
    exports2.isAminoMsgEditValidator = isAminoMsgEditValidator;
    function isAminoMsgDelegate(msg) {
      return msg.type === "cosmos-sdk/MsgDelegate";
    }
    exports2.isAminoMsgDelegate = isAminoMsgDelegate;
    function isAminoMsgBeginRedelegate(msg) {
      return msg.type === "cosmos-sdk/MsgBeginRedelegate";
    }
    exports2.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
    function isAminoMsgUndelegate(msg) {
      return msg.type === "cosmos-sdk/MsgUndelegate";
    }
    exports2.isAminoMsgUndelegate = isAminoMsgUndelegate;
    function isAminoMsgCancelUnbondingDelegation(msg) {
      return msg.type === "cosmos-sdk/MsgCancelUnbondingDelegation";
    }
    exports2.isAminoMsgCancelUnbondingDelegation = isAminoMsgCancelUnbondingDelegation;
    function createStakingAminoConverters() {
      return {
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
          aminoType: "cosmos-sdk/MsgBeginRedelegate",
          toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_src_address: validatorSrcAddress,
              validator_dst_address: validatorDstAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorSrcAddress: validator_src_address,
            validatorDstAddress: validator_dst_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
          aminoType: "cosmos-sdk/MsgCreateValidator",
          toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            (0, utils_1.assertDefinedAndNotNull)(commission, "missing commission");
            (0, utils_1.assertDefinedAndNotNull)(pubkey, "missing pubkey");
            (0, utils_1.assertDefinedAndNotNull)(value, "missing value");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              commission: {
                rate: protoDecimalToJson(commission.rate),
                max_rate: protoDecimalToJson(commission.maxRate),
                max_change_rate: protoDecimalToJson(commission.maxChangeRate)
              },
              min_self_delegation: minSelfDelegation,
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              pubkey: (0, proto_signing_1.decodePubkey)(pubkey),
              value
            };
          },
          fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value }) => {
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                securityContact: description.security_contact,
                details: description.details
              },
              commission: {
                rate: jsonDecimalToProto(commission.rate),
                maxRate: jsonDecimalToProto(commission.max_rate),
                maxChangeRate: jsonDecimalToProto(commission.max_change_rate)
              },
              minSelfDelegation: min_self_delegation,
              delegatorAddress: delegator_address,
              validatorAddress: validator_address,
              pubkey: (0, proto_signing_1.encodePubkey)(pubkey),
              value
            };
          }
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
          aminoType: "cosmos-sdk/MsgDelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
          aminoType: "cosmos-sdk/MsgEditValidator",
          toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              // empty string in the protobuf document means "do not change"
              commission_rate: commissionRate ? protoDecimalToJson(commissionRate) : void 0,
              // empty string in the protobuf document means "do not change"
              min_self_delegation: minSelfDelegation ? minSelfDelegation : void 0,
              validator_address: validatorAddress
            };
          },
          fromAmino: ({ description, commission_rate, min_self_delegation, validator_address }) => ({
            description: {
              moniker: description.moniker,
              identity: description.identity,
              website: description.website,
              securityContact: description.security_contact,
              details: description.details
            },
            // empty string in the protobuf document means "do not change"
            commissionRate: commission_rate ? jsonDecimalToProto(commission_rate) : "",
            // empty string in the protobuf document means "do not change"
            minSelfDelegation: min_self_delegation ?? "",
            validatorAddress: validator_address
          })
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
          aminoType: "cosmos-sdk/MsgUndelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation": {
          aminoType: "cosmos-sdk/MsgCancelUnbondingDelegation",
          toAmino: ({ delegatorAddress, validatorAddress, amount, creationHeight }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount,
              creation_height: creationHeight.toString()
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount, creation_height }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount,
            creationHeight: BigInt(creation_height)
          })
        }
      };
    }
    exports2.createStakingAminoConverters = createStakingAminoConverters;
  }
});

// node_modules/cosmjs-types/tendermint/types/params.js
var require_params = __commonJS({
  "node_modules/cosmjs-types/tendermint/types/params.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HashedParams = exports2.VersionParams = exports2.ValidatorParams = exports2.EvidenceParams = exports2.BlockParams = exports2.ConsensusParams = exports2.protobufPackage = void 0;
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "tendermint.types";
    function createBaseConsensusParams() {
      return {
        block: void 0,
        evidence: void 0,
        validator: void 0,
        version: void 0
      };
    }
    exports2.ConsensusParams = {
      typeUrl: "/tendermint.types.ConsensusParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.block !== void 0) {
          exports2.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          exports2.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        }
        if (message.validator !== void 0) {
          exports2.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== void 0) {
          exports2.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = exports2.BlockParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.evidence = exports2.EvidenceParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.validator = exports2.ValidatorParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.version = exports2.VersionParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusParams();
        if ((0, helpers_1.isSet)(object.block))
          obj.block = exports2.BlockParams.fromJSON(object.block);
        if ((0, helpers_1.isSet)(object.evidence))
          obj.evidence = exports2.EvidenceParams.fromJSON(object.evidence);
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports2.ValidatorParams.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = exports2.VersionParams.fromJSON(object.version);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = message.block ? exports2.BlockParams.toJSON(message.block) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? exports2.EvidenceParams.toJSON(message.evidence) : void 0);
        message.validator !== void 0 && (obj.validator = message.validator ? exports2.ValidatorParams.toJSON(message.validator) : void 0);
        message.version !== void 0 && (obj.version = message.version ? exports2.VersionParams.toJSON(message.version) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusParams();
        if (object.block !== void 0 && object.block !== null) {
          message.block = exports2.BlockParams.fromPartial(object.block);
        }
        if (object.evidence !== void 0 && object.evidence !== null) {
          message.evidence = exports2.EvidenceParams.fromPartial(object.evidence);
        }
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports2.ValidatorParams.fromPartial(object.validator);
        }
        if (object.version !== void 0 && object.version !== null) {
          message.version = exports2.VersionParams.fromPartial(object.version);
        }
        return message;
      }
    };
    function createBaseBlockParams() {
      return {
        maxBytes: BigInt(0),
        maxGas: BigInt(0)
      };
    }
    exports2.BlockParams = {
      typeUrl: "/tendermint.types.BlockParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.maxBytes);
        }
        if (message.maxGas !== BigInt(0)) {
          writer.uint32(16).int64(message.maxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxBytes = reader.int64();
              break;
            case 2:
              message.maxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockParams();
        if ((0, helpers_1.isSet)(object.maxBytes))
          obj.maxBytes = BigInt(object.maxBytes.toString());
        if ((0, helpers_1.isSet)(object.maxGas))
          obj.maxGas = BigInt(object.maxGas.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || BigInt(0)).toString());
        message.maxGas !== void 0 && (obj.maxGas = (message.maxGas || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockParams();
        if (object.maxBytes !== void 0 && object.maxBytes !== null) {
          message.maxBytes = BigInt(object.maxBytes.toString());
        }
        if (object.maxGas !== void 0 && object.maxGas !== null) {
          message.maxGas = BigInt(object.maxGas.toString());
        }
        return message;
      }
    };
    function createBaseEvidenceParams() {
      return {
        maxAgeNumBlocks: BigInt(0),
        maxAgeDuration: duration_1.Duration.fromPartial({}),
        maxBytes: BigInt(0)
      };
    }
    exports2.EvidenceParams = {
      typeUrl: "/tendermint.types.EvidenceParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxAgeNumBlocks !== BigInt(0)) {
          writer.uint32(8).int64(message.maxAgeNumBlocks);
        }
        if (message.maxAgeDuration !== void 0) {
          duration_1.Duration.encode(message.maxAgeDuration, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxBytes !== BigInt(0)) {
          writer.uint32(24).int64(message.maxBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidenceParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxAgeNumBlocks = reader.int64();
              break;
            case 2:
              message.maxAgeDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxBytes = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidenceParams();
        if ((0, helpers_1.isSet)(object.maxAgeNumBlocks))
          obj.maxAgeNumBlocks = BigInt(object.maxAgeNumBlocks.toString());
        if ((0, helpers_1.isSet)(object.maxAgeDuration))
          obj.maxAgeDuration = duration_1.Duration.fromJSON(object.maxAgeDuration);
        if ((0, helpers_1.isSet)(object.maxBytes))
          obj.maxBytes = BigInt(object.maxBytes.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxAgeNumBlocks !== void 0 && (obj.maxAgeNumBlocks = (message.maxAgeNumBlocks || BigInt(0)).toString());
        message.maxAgeDuration !== void 0 && (obj.maxAgeDuration = message.maxAgeDuration ? duration_1.Duration.toJSON(message.maxAgeDuration) : void 0);
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidenceParams();
        if (object.maxAgeNumBlocks !== void 0 && object.maxAgeNumBlocks !== null) {
          message.maxAgeNumBlocks = BigInt(object.maxAgeNumBlocks.toString());
        }
        if (object.maxAgeDuration !== void 0 && object.maxAgeDuration !== null) {
          message.maxAgeDuration = duration_1.Duration.fromPartial(object.maxAgeDuration);
        }
        if (object.maxBytes !== void 0 && object.maxBytes !== null) {
          message.maxBytes = BigInt(object.maxBytes.toString());
        }
        return message;
      }
    };
    function createBaseValidatorParams() {
      return {
        pubKeyTypes: []
      };
    }
    exports2.ValidatorParams = {
      typeUrl: "/tendermint.types.ValidatorParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pubKeyTypes) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKeyTypes.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorParams();
        if (Array.isArray(object == null ? void 0 : object.pubKeyTypes))
          obj.pubKeyTypes = object.pubKeyTypes.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pubKeyTypes) {
          obj.pubKeyTypes = message.pubKeyTypes.map((e) => e);
        } else {
          obj.pubKeyTypes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorParams();
        message.pubKeyTypes = ((_a = object.pubKeyTypes) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseVersionParams() {
      return {
        app: BigInt(0)
      };
    }
    exports2.VersionParams = {
      typeUrl: "/tendermint.types.VersionParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.app !== BigInt(0)) {
          writer.uint32(8).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVersionParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.app = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVersionParams();
        if ((0, helpers_1.isSet)(object.app))
          obj.app = BigInt(object.app.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.app !== void 0 && (obj.app = (message.app || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVersionParams();
        if (object.app !== void 0 && object.app !== null) {
          message.app = BigInt(object.app.toString());
        }
        return message;
      }
    };
    function createBaseHashedParams() {
      return {
        blockMaxBytes: BigInt(0),
        blockMaxGas: BigInt(0)
      };
    }
    exports2.HashedParams = {
      typeUrl: "/tendermint.types.HashedParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockMaxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.blockMaxBytes);
        }
        if (message.blockMaxGas !== BigInt(0)) {
          writer.uint32(16).int64(message.blockMaxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHashedParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockMaxBytes = reader.int64();
              break;
            case 2:
              message.blockMaxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHashedParams();
        if ((0, helpers_1.isSet)(object.blockMaxBytes))
          obj.blockMaxBytes = BigInt(object.blockMaxBytes.toString());
        if ((0, helpers_1.isSet)(object.blockMaxGas))
          obj.blockMaxGas = BigInt(object.blockMaxGas.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockMaxBytes !== void 0 && (obj.blockMaxBytes = (message.blockMaxBytes || BigInt(0)).toString());
        message.blockMaxGas !== void 0 && (obj.blockMaxGas = (message.blockMaxGas || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHashedParams();
        if (object.blockMaxBytes !== void 0 && object.blockMaxBytes !== null) {
          message.blockMaxBytes = BigInt(object.blockMaxBytes.toString());
        }
        if (object.blockMaxGas !== void 0 && object.blockMaxGas !== null) {
          message.blockMaxGas = BigInt(object.blockMaxGas.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/tendermint/abci/types.js
var require_types4 = __commonJS({
  "node_modules/cosmjs-types/tendermint/abci/types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResponsePrepareProposal = exports2.ResponseApplySnapshotChunk = exports2.ResponseLoadSnapshotChunk = exports2.ResponseOfferSnapshot = exports2.ResponseListSnapshots = exports2.ResponseCommit = exports2.ResponseEndBlock = exports2.ResponseDeliverTx = exports2.ResponseCheckTx = exports2.ResponseBeginBlock = exports2.ResponseQuery = exports2.ResponseInitChain = exports2.ResponseInfo = exports2.ResponseFlush = exports2.ResponseEcho = exports2.ResponseException = exports2.Response = exports2.RequestProcessProposal = exports2.RequestPrepareProposal = exports2.RequestApplySnapshotChunk = exports2.RequestLoadSnapshotChunk = exports2.RequestOfferSnapshot = exports2.RequestListSnapshots = exports2.RequestCommit = exports2.RequestEndBlock = exports2.RequestDeliverTx = exports2.RequestCheckTx = exports2.RequestBeginBlock = exports2.RequestQuery = exports2.RequestInitChain = exports2.RequestInfo = exports2.RequestFlush = exports2.RequestEcho = exports2.Request = exports2.misbehaviorTypeToJSON = exports2.misbehaviorTypeFromJSON = exports2.MisbehaviorType = exports2.responseProcessProposal_ProposalStatusToJSON = exports2.responseProcessProposal_ProposalStatusFromJSON = exports2.ResponseProcessProposal_ProposalStatus = exports2.responseApplySnapshotChunk_ResultToJSON = exports2.responseApplySnapshotChunk_ResultFromJSON = exports2.ResponseApplySnapshotChunk_Result = exports2.responseOfferSnapshot_ResultToJSON = exports2.responseOfferSnapshot_ResultFromJSON = exports2.ResponseOfferSnapshot_Result = exports2.checkTxTypeToJSON = exports2.checkTxTypeFromJSON = exports2.CheckTxType = exports2.protobufPackage = void 0;
    exports2.ABCIApplicationClientImpl = exports2.Snapshot = exports2.Misbehavior = exports2.ExtendedVoteInfo = exports2.VoteInfo = exports2.ValidatorUpdate = exports2.Validator = exports2.TxResult = exports2.EventAttribute = exports2.Event = exports2.ExtendedCommitInfo = exports2.CommitInfo = exports2.ResponseProcessProposal = void 0;
    var timestamp_1 = require_timestamp();
    var params_1 = require_params();
    var types_1 = require_types3();
    var proof_1 = require_proof();
    var keys_1 = require_keys4();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "tendermint.abci";
    var CheckTxType;
    (function(CheckTxType2) {
      CheckTxType2[CheckTxType2["NEW"] = 0] = "NEW";
      CheckTxType2[CheckTxType2["RECHECK"] = 1] = "RECHECK";
      CheckTxType2[CheckTxType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CheckTxType || (exports2.CheckTxType = CheckTxType = {}));
    function checkTxTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "NEW":
          return CheckTxType.NEW;
        case 1:
        case "RECHECK":
          return CheckTxType.RECHECK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return CheckTxType.UNRECOGNIZED;
      }
    }
    exports2.checkTxTypeFromJSON = checkTxTypeFromJSON;
    function checkTxTypeToJSON(object) {
      switch (object) {
        case CheckTxType.NEW:
          return "NEW";
        case CheckTxType.RECHECK:
          return "RECHECK";
        case CheckTxType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.checkTxTypeToJSON = checkTxTypeToJSON;
    var ResponseOfferSnapshot_Result;
    (function(ResponseOfferSnapshot_Result2) {
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ABORT"] = 2] = "ABORT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT"] = 3] = "REJECT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_SENDER"] = 5] = "REJECT_SENDER";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseOfferSnapshot_Result || (exports2.ResponseOfferSnapshot_Result = ResponseOfferSnapshot_Result = {}));
    function responseOfferSnapshot_ResultFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseOfferSnapshot_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseOfferSnapshot_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseOfferSnapshot_Result.ABORT;
        case 3:
        case "REJECT":
          return ResponseOfferSnapshot_Result.REJECT;
        case 4:
        case "REJECT_FORMAT":
          return ResponseOfferSnapshot_Result.REJECT_FORMAT;
        case 5:
        case "REJECT_SENDER":
          return ResponseOfferSnapshot_Result.REJECT_SENDER;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseOfferSnapshot_Result.UNRECOGNIZED;
      }
    }
    exports2.responseOfferSnapshot_ResultFromJSON = responseOfferSnapshot_ResultFromJSON;
    function responseOfferSnapshot_ResultToJSON(object) {
      switch (object) {
        case ResponseOfferSnapshot_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseOfferSnapshot_Result.ACCEPT:
          return "ACCEPT";
        case ResponseOfferSnapshot_Result.ABORT:
          return "ABORT";
        case ResponseOfferSnapshot_Result.REJECT:
          return "REJECT";
        case ResponseOfferSnapshot_Result.REJECT_FORMAT:
          return "REJECT_FORMAT";
        case ResponseOfferSnapshot_Result.REJECT_SENDER:
          return "REJECT_SENDER";
        case ResponseOfferSnapshot_Result.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.responseOfferSnapshot_ResultToJSON = responseOfferSnapshot_ResultToJSON;
    var ResponseApplySnapshotChunk_Result;
    (function(ResponseApplySnapshotChunk_Result2) {
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ABORT"] = 2] = "ABORT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY"] = 3] = "RETRY";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseApplySnapshotChunk_Result || (exports2.ResponseApplySnapshotChunk_Result = ResponseApplySnapshotChunk_Result = {}));
    function responseApplySnapshotChunk_ResultFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseApplySnapshotChunk_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseApplySnapshotChunk_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseApplySnapshotChunk_Result.ABORT;
        case 3:
        case "RETRY":
          return ResponseApplySnapshotChunk_Result.RETRY;
        case 4:
        case "RETRY_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;
        case 5:
        case "REJECT_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;
      }
    }
    exports2.responseApplySnapshotChunk_ResultFromJSON = responseApplySnapshotChunk_ResultFromJSON;
    function responseApplySnapshotChunk_ResultToJSON(object) {
      switch (object) {
        case ResponseApplySnapshotChunk_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseApplySnapshotChunk_Result.ACCEPT:
          return "ACCEPT";
        case ResponseApplySnapshotChunk_Result.ABORT:
          return "ABORT";
        case ResponseApplySnapshotChunk_Result.RETRY:
          return "RETRY";
        case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:
          return "RETRY_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:
          return "REJECT_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.responseApplySnapshotChunk_ResultToJSON = responseApplySnapshotChunk_ResultToJSON;
    var ResponseProcessProposal_ProposalStatus;
    (function(ResponseProcessProposal_ProposalStatus2) {
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["ACCEPT"] = 1] = "ACCEPT";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["REJECT"] = 2] = "REJECT";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseProcessProposal_ProposalStatus || (exports2.ResponseProcessProposal_ProposalStatus = ResponseProcessProposal_ProposalStatus = {}));
    function responseProcessProposal_ProposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseProcessProposal_ProposalStatus.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseProcessProposal_ProposalStatus.ACCEPT;
        case 2:
        case "REJECT":
          return ResponseProcessProposal_ProposalStatus.REJECT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseProcessProposal_ProposalStatus.UNRECOGNIZED;
      }
    }
    exports2.responseProcessProposal_ProposalStatusFromJSON = responseProcessProposal_ProposalStatusFromJSON;
    function responseProcessProposal_ProposalStatusToJSON(object) {
      switch (object) {
        case ResponseProcessProposal_ProposalStatus.UNKNOWN:
          return "UNKNOWN";
        case ResponseProcessProposal_ProposalStatus.ACCEPT:
          return "ACCEPT";
        case ResponseProcessProposal_ProposalStatus.REJECT:
          return "REJECT";
        case ResponseProcessProposal_ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.responseProcessProposal_ProposalStatusToJSON = responseProcessProposal_ProposalStatusToJSON;
    var MisbehaviorType;
    (function(MisbehaviorType2) {
      MisbehaviorType2[MisbehaviorType2["UNKNOWN"] = 0] = "UNKNOWN";
      MisbehaviorType2[MisbehaviorType2["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
      MisbehaviorType2[MisbehaviorType2["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
      MisbehaviorType2[MisbehaviorType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(MisbehaviorType || (exports2.MisbehaviorType = MisbehaviorType = {}));
    function misbehaviorTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return MisbehaviorType.UNKNOWN;
        case 1:
        case "DUPLICATE_VOTE":
          return MisbehaviorType.DUPLICATE_VOTE;
        case 2:
        case "LIGHT_CLIENT_ATTACK":
          return MisbehaviorType.LIGHT_CLIENT_ATTACK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return MisbehaviorType.UNRECOGNIZED;
      }
    }
    exports2.misbehaviorTypeFromJSON = misbehaviorTypeFromJSON;
    function misbehaviorTypeToJSON(object) {
      switch (object) {
        case MisbehaviorType.UNKNOWN:
          return "UNKNOWN";
        case MisbehaviorType.DUPLICATE_VOTE:
          return "DUPLICATE_VOTE";
        case MisbehaviorType.LIGHT_CLIENT_ATTACK:
          return "LIGHT_CLIENT_ATTACK";
        case MisbehaviorType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.misbehaviorTypeToJSON = misbehaviorTypeToJSON;
    function createBaseRequest() {
      return {
        echo: void 0,
        flush: void 0,
        info: void 0,
        initChain: void 0,
        query: void 0,
        beginBlock: void 0,
        checkTx: void 0,
        deliverTx: void 0,
        endBlock: void 0,
        commit: void 0,
        listSnapshots: void 0,
        offerSnapshot: void 0,
        loadSnapshotChunk: void 0,
        applySnapshotChunk: void 0,
        prepareProposal: void 0,
        processProposal: void 0
      };
    }
    exports2.Request = {
      typeUrl: "/tendermint.abci.Request",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.echo !== void 0) {
          exports2.RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports2.RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports2.RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports2.RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports2.RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();
        }
        if (message.beginBlock !== void 0) {
          exports2.RequestBeginBlock.encode(message.beginBlock, writer.uint32(58).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports2.RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();
        }
        if (message.deliverTx !== void 0) {
          exports2.RequestDeliverTx.encode(message.deliverTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.endBlock !== void 0) {
          exports2.RequestEndBlock.encode(message.endBlock, writer.uint32(82).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports2.RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports2.RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports2.RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports2.RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports2.RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.prepareProposal !== void 0) {
          exports2.RequestPrepareProposal.encode(message.prepareProposal, writer.uint32(130).fork()).ldelim();
        }
        if (message.processProposal !== void 0) {
          exports2.RequestProcessProposal.encode(message.processProposal, writer.uint32(138).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.echo = exports2.RequestEcho.decode(reader, reader.uint32());
              break;
            case 2:
              message.flush = exports2.RequestFlush.decode(reader, reader.uint32());
              break;
            case 3:
              message.info = exports2.RequestInfo.decode(reader, reader.uint32());
              break;
            case 5:
              message.initChain = exports2.RequestInitChain.decode(reader, reader.uint32());
              break;
            case 6:
              message.query = exports2.RequestQuery.decode(reader, reader.uint32());
              break;
            case 7:
              message.beginBlock = exports2.RequestBeginBlock.decode(reader, reader.uint32());
              break;
            case 8:
              message.checkTx = exports2.RequestCheckTx.decode(reader, reader.uint32());
              break;
            case 9:
              message.deliverTx = exports2.RequestDeliverTx.decode(reader, reader.uint32());
              break;
            case 10:
              message.endBlock = exports2.RequestEndBlock.decode(reader, reader.uint32());
              break;
            case 11:
              message.commit = exports2.RequestCommit.decode(reader, reader.uint32());
              break;
            case 12:
              message.listSnapshots = exports2.RequestListSnapshots.decode(reader, reader.uint32());
              break;
            case 13:
              message.offerSnapshot = exports2.RequestOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 14:
              message.loadSnapshotChunk = exports2.RequestLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 15:
              message.applySnapshotChunk = exports2.RequestApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            case 16:
              message.prepareProposal = exports2.RequestPrepareProposal.decode(reader, reader.uint32());
              break;
            case 17:
              message.processProposal = exports2.RequestProcessProposal.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequest();
        if ((0, helpers_1.isSet)(object.echo))
          obj.echo = exports2.RequestEcho.fromJSON(object.echo);
        if ((0, helpers_1.isSet)(object.flush))
          obj.flush = exports2.RequestFlush.fromJSON(object.flush);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = exports2.RequestInfo.fromJSON(object.info);
        if ((0, helpers_1.isSet)(object.initChain))
          obj.initChain = exports2.RequestInitChain.fromJSON(object.initChain);
        if ((0, helpers_1.isSet)(object.query))
          obj.query = exports2.RequestQuery.fromJSON(object.query);
        if ((0, helpers_1.isSet)(object.beginBlock))
          obj.beginBlock = exports2.RequestBeginBlock.fromJSON(object.beginBlock);
        if ((0, helpers_1.isSet)(object.checkTx))
          obj.checkTx = exports2.RequestCheckTx.fromJSON(object.checkTx);
        if ((0, helpers_1.isSet)(object.deliverTx))
          obj.deliverTx = exports2.RequestDeliverTx.fromJSON(object.deliverTx);
        if ((0, helpers_1.isSet)(object.endBlock))
          obj.endBlock = exports2.RequestEndBlock.fromJSON(object.endBlock);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports2.RequestCommit.fromJSON(object.commit);
        if ((0, helpers_1.isSet)(object.listSnapshots))
          obj.listSnapshots = exports2.RequestListSnapshots.fromJSON(object.listSnapshots);
        if ((0, helpers_1.isSet)(object.offerSnapshot))
          obj.offerSnapshot = exports2.RequestOfferSnapshot.fromJSON(object.offerSnapshot);
        if ((0, helpers_1.isSet)(object.loadSnapshotChunk))
          obj.loadSnapshotChunk = exports2.RequestLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);
        if ((0, helpers_1.isSet)(object.applySnapshotChunk))
          obj.applySnapshotChunk = exports2.RequestApplySnapshotChunk.fromJSON(object.applySnapshotChunk);
        if ((0, helpers_1.isSet)(object.prepareProposal))
          obj.prepareProposal = exports2.RequestPrepareProposal.fromJSON(object.prepareProposal);
        if ((0, helpers_1.isSet)(object.processProposal))
          obj.processProposal = exports2.RequestProcessProposal.fromJSON(object.processProposal);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.echo !== void 0 && (obj.echo = message.echo ? exports2.RequestEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports2.RequestFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports2.RequestInfo.toJSON(message.info) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports2.RequestInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports2.RequestQuery.toJSON(message.query) : void 0);
        message.beginBlock !== void 0 && (obj.beginBlock = message.beginBlock ? exports2.RequestBeginBlock.toJSON(message.beginBlock) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports2.RequestCheckTx.toJSON(message.checkTx) : void 0);
        message.deliverTx !== void 0 && (obj.deliverTx = message.deliverTx ? exports2.RequestDeliverTx.toJSON(message.deliverTx) : void 0);
        message.endBlock !== void 0 && (obj.endBlock = message.endBlock ? exports2.RequestEndBlock.toJSON(message.endBlock) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports2.RequestCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports2.RequestListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports2.RequestOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports2.RequestLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports2.RequestApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        message.prepareProposal !== void 0 && (obj.prepareProposal = message.prepareProposal ? exports2.RequestPrepareProposal.toJSON(message.prepareProposal) : void 0);
        message.processProposal !== void 0 && (obj.processProposal = message.processProposal ? exports2.RequestProcessProposal.toJSON(message.processProposal) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequest();
        if (object.echo !== void 0 && object.echo !== null) {
          message.echo = exports2.RequestEcho.fromPartial(object.echo);
        }
        if (object.flush !== void 0 && object.flush !== null) {
          message.flush = exports2.RequestFlush.fromPartial(object.flush);
        }
        if (object.info !== void 0 && object.info !== null) {
          message.info = exports2.RequestInfo.fromPartial(object.info);
        }
        if (object.initChain !== void 0 && object.initChain !== null) {
          message.initChain = exports2.RequestInitChain.fromPartial(object.initChain);
        }
        if (object.query !== void 0 && object.query !== null) {
          message.query = exports2.RequestQuery.fromPartial(object.query);
        }
        if (object.beginBlock !== void 0 && object.beginBlock !== null) {
          message.beginBlock = exports2.RequestBeginBlock.fromPartial(object.beginBlock);
        }
        if (object.checkTx !== void 0 && object.checkTx !== null) {
          message.checkTx = exports2.RequestCheckTx.fromPartial(object.checkTx);
        }
        if (object.deliverTx !== void 0 && object.deliverTx !== null) {
          message.deliverTx = exports2.RequestDeliverTx.fromPartial(object.deliverTx);
        }
        if (object.endBlock !== void 0 && object.endBlock !== null) {
          message.endBlock = exports2.RequestEndBlock.fromPartial(object.endBlock);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports2.RequestCommit.fromPartial(object.commit);
        }
        if (object.listSnapshots !== void 0 && object.listSnapshots !== null) {
          message.listSnapshots = exports2.RequestListSnapshots.fromPartial(object.listSnapshots);
        }
        if (object.offerSnapshot !== void 0 && object.offerSnapshot !== null) {
          message.offerSnapshot = exports2.RequestOfferSnapshot.fromPartial(object.offerSnapshot);
        }
        if (object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null) {
          message.loadSnapshotChunk = exports2.RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);
        }
        if (object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null) {
          message.applySnapshotChunk = exports2.RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk);
        }
        if (object.prepareProposal !== void 0 && object.prepareProposal !== null) {
          message.prepareProposal = exports2.RequestPrepareProposal.fromPartial(object.prepareProposal);
        }
        if (object.processProposal !== void 0 && object.processProposal !== null) {
          message.processProposal = exports2.RequestProcessProposal.fromPartial(object.processProposal);
        }
        return message;
      }
    };
    function createBaseRequestEcho() {
      return {
        message: ""
      };
    }
    exports2.RequestEcho = {
      typeUrl: "/tendermint.abci.RequestEcho",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestEcho();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestEcho();
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestEcho();
        message.message = object.message ?? "";
        return message;
      }
    };
    function createBaseRequestFlush() {
      return {};
    }
    exports2.RequestFlush = {
      typeUrl: "/tendermint.abci.RequestFlush",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestFlush();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseRequestFlush();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestFlush();
        return message;
      }
    };
    function createBaseRequestInfo() {
      return {
        version: "",
        blockVersion: BigInt(0),
        p2pVersion: BigInt(0),
        abciVersion: ""
      };
    }
    exports2.RequestInfo = {
      typeUrl: "/tendermint.abci.RequestInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        if (message.blockVersion !== BigInt(0)) {
          writer.uint32(16).uint64(message.blockVersion);
        }
        if (message.p2pVersion !== BigInt(0)) {
          writer.uint32(24).uint64(message.p2pVersion);
        }
        if (message.abciVersion !== "") {
          writer.uint32(34).string(message.abciVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            case 2:
              message.blockVersion = reader.uint64();
              break;
            case 3:
              message.p2pVersion = reader.uint64();
              break;
            case 4:
              message.abciVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestInfo();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.blockVersion))
          obj.blockVersion = BigInt(object.blockVersion.toString());
        if ((0, helpers_1.isSet)(object.p2pVersion))
          obj.p2pVersion = BigInt(object.p2pVersion.toString());
        if ((0, helpers_1.isSet)(object.abciVersion))
          obj.abciVersion = String(object.abciVersion);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version);
        message.blockVersion !== void 0 && (obj.blockVersion = (message.blockVersion || BigInt(0)).toString());
        message.p2pVersion !== void 0 && (obj.p2pVersion = (message.p2pVersion || BigInt(0)).toString());
        message.abciVersion !== void 0 && (obj.abciVersion = message.abciVersion);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestInfo();
        message.version = object.version ?? "";
        if (object.blockVersion !== void 0 && object.blockVersion !== null) {
          message.blockVersion = BigInt(object.blockVersion.toString());
        }
        if (object.p2pVersion !== void 0 && object.p2pVersion !== null) {
          message.p2pVersion = BigInt(object.p2pVersion.toString());
        }
        message.abciVersion = object.abciVersion ?? "";
        return message;
      }
    };
    function createBaseRequestInitChain() {
      return {
        time: timestamp_1.Timestamp.fromPartial({}),
        chainId: "",
        consensusParams: void 0,
        validators: [],
        appStateBytes: new Uint8Array(),
        initialHeight: BigInt(0)
      };
    }
    exports2.RequestInitChain = {
      typeUrl: "/tendermint.abci.RequestInitChain",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.consensusParams !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.validators) {
          exports2.ValidatorUpdate.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.appStateBytes.length !== 0) {
          writer.uint32(42).bytes(message.appStateBytes);
        }
        if (message.initialHeight !== BigInt(0)) {
          writer.uint32(48).int64(message.initialHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestInitChain();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.validators.push(exports2.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 5:
              message.appStateBytes = reader.bytes();
              break;
            case 6:
              message.initialHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestInitChain();
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.consensusParams))
          obj.consensusParams = params_1.ConsensusParams.fromJSON(object.consensusParams);
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => exports2.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.appStateBytes))
          obj.appStateBytes = (0, helpers_1.bytesFromBase64)(object.appStateBytes);
        if ((0, helpers_1.isSet)(object.initialHeight))
          obj.initialHeight = BigInt(object.initialHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports2.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appStateBytes !== void 0 && (obj.appStateBytes = (0, helpers_1.base64FromBytes)(message.appStateBytes !== void 0 ? message.appStateBytes : new Uint8Array()));
        message.initialHeight !== void 0 && (obj.initialHeight = (message.initialHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseRequestInitChain();
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.chainId = object.chainId ?? "";
        if (object.consensusParams !== void 0 && object.consensusParams !== null) {
          message.consensusParams = params_1.ConsensusParams.fromPartial(object.consensusParams);
        }
        message.validators = ((_a = object.validators) == null ? void 0 : _a.map((e) => exports2.ValidatorUpdate.fromPartial(e))) || [];
        message.appStateBytes = object.appStateBytes ?? new Uint8Array();
        if (object.initialHeight !== void 0 && object.initialHeight !== null) {
          message.initialHeight = BigInt(object.initialHeight.toString());
        }
        return message;
      }
    };
    function createBaseRequestQuery() {
      return {
        data: new Uint8Array(),
        path: "",
        height: BigInt(0),
        prove: false
      };
    }
    exports2.RequestQuery = {
      typeUrl: "/tendermint.abci.RequestQuery",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.path !== "") {
          writer.uint32(18).string(message.path);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.prove === true) {
          writer.uint32(32).bool(message.prove);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestQuery();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.path = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.prove = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestQuery();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.path))
          obj.path = String(object.path);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.prove))
          obj.prove = Boolean(object.prove);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.path !== void 0 && (obj.path = message.path);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.prove !== void 0 && (obj.prove = message.prove);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestQuery();
        message.data = object.data ?? new Uint8Array();
        message.path = object.path ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.prove = object.prove ?? false;
        return message;
      }
    };
    function createBaseRequestBeginBlock() {
      return {
        hash: new Uint8Array(),
        header: types_1.Header.fromPartial({}),
        lastCommitInfo: exports2.CommitInfo.fromPartial({}),
        byzantineValidators: []
      };
    }
    exports2.RequestBeginBlock = {
      typeUrl: "/tendermint.abci.RequestBeginBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(18).fork()).ldelim();
        }
        if (message.lastCommitInfo !== void 0) {
          exports2.CommitInfo.encode(message.lastCommitInfo, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.byzantineValidators) {
          exports2.Misbehavior.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestBeginBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 3:
              message.lastCommitInfo = exports2.CommitInfo.decode(reader, reader.uint32());
              break;
            case 4:
              message.byzantineValidators.push(exports2.Misbehavior.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestBeginBlock();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.header))
          obj.header = types_1.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.lastCommitInfo))
          obj.lastCommitInfo = exports2.CommitInfo.fromJSON(object.lastCommitInfo);
        if (Array.isArray(object == null ? void 0 : object.byzantineValidators))
          obj.byzantineValidators = object.byzantineValidators.map((e) => exports2.Misbehavior.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        message.lastCommitInfo !== void 0 && (obj.lastCommitInfo = message.lastCommitInfo ? exports2.CommitInfo.toJSON(message.lastCommitInfo) : void 0);
        if (message.byzantineValidators) {
          obj.byzantineValidators = message.byzantineValidators.map((e) => e ? exports2.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.byzantineValidators = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseRequestBeginBlock();
        message.hash = object.hash ?? new Uint8Array();
        if (object.header !== void 0 && object.header !== null) {
          message.header = types_1.Header.fromPartial(object.header);
        }
        if (object.lastCommitInfo !== void 0 && object.lastCommitInfo !== null) {
          message.lastCommitInfo = exports2.CommitInfo.fromPartial(object.lastCommitInfo);
        }
        message.byzantineValidators = ((_a = object.byzantineValidators) == null ? void 0 : _a.map((e) => exports2.Misbehavior.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseRequestCheckTx() {
      return {
        tx: new Uint8Array(),
        type: 0
      };
    }
    exports2.RequestCheckTx = {
      typeUrl: "/tendermint.abci.RequestCheckTx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx.length !== 0) {
          writer.uint32(10).bytes(message.tx);
        }
        if (message.type !== 0) {
          writer.uint32(16).int32(message.type);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestCheckTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = reader.bytes();
              break;
            case 2:
              message.type = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestCheckTx();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        if ((0, helpers_1.isSet)(object.type))
          obj.type = checkTxTypeFromJSON(object.type);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.type !== void 0 && (obj.type = checkTxTypeToJSON(message.type));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestCheckTx();
        message.tx = object.tx ?? new Uint8Array();
        message.type = object.type ?? 0;
        return message;
      }
    };
    function createBaseRequestDeliverTx() {
      return {
        tx: new Uint8Array()
      };
    }
    exports2.RequestDeliverTx = {
      typeUrl: "/tendermint.abci.RequestDeliverTx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx.length !== 0) {
          writer.uint32(10).bytes(message.tx);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestDeliverTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestDeliverTx();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== void 0 ? message.tx : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestDeliverTx();
        message.tx = object.tx ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestEndBlock() {
      return {
        height: BigInt(0)
      };
    }
    exports2.RequestEndBlock = {
      typeUrl: "/tendermint.abci.RequestEndBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestEndBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestEndBlock();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestEndBlock();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        return message;
      }
    };
    function createBaseRequestCommit() {
      return {};
    }
    exports2.RequestCommit = {
      typeUrl: "/tendermint.abci.RequestCommit",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseRequestCommit();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestCommit();
        return message;
      }
    };
    function createBaseRequestListSnapshots() {
      return {};
    }
    exports2.RequestListSnapshots = {
      typeUrl: "/tendermint.abci.RequestListSnapshots",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestListSnapshots();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseRequestListSnapshots();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseRequestListSnapshots();
        return message;
      }
    };
    function createBaseRequestOfferSnapshot() {
      return {
        snapshot: void 0,
        appHash: new Uint8Array()
      };
    }
    exports2.RequestOfferSnapshot = {
      typeUrl: "/tendermint.abci.RequestOfferSnapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.snapshot !== void 0) {
          exports2.Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(18).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestOfferSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshot = exports2.Snapshot.decode(reader, reader.uint32());
              break;
            case 2:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestOfferSnapshot();
        if ((0, helpers_1.isSet)(object.snapshot))
          obj.snapshot = exports2.Snapshot.fromJSON(object.snapshot);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.snapshot !== void 0 && (obj.snapshot = message.snapshot ? exports2.Snapshot.toJSON(message.snapshot) : void 0);
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestOfferSnapshot();
        if (object.snapshot !== void 0 && object.snapshot !== null) {
          message.snapshot = exports2.Snapshot.fromPartial(object.snapshot);
        }
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestLoadSnapshotChunk() {
      return {
        height: BigInt(0),
        format: 0,
        chunk: 0
      };
    }
    exports2.RequestLoadSnapshotChunk = {
      typeUrl: "/tendermint.abci.RequestLoadSnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunk !== 0) {
          writer.uint32(24).uint32(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestLoadSnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunk = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestLoadSnapshotChunk();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.format))
          obj.format = Number(object.format);
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = Number(object.chunk);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.format !== void 0 && (obj.format = Math.round(message.format));
        message.chunk !== void 0 && (obj.chunk = Math.round(message.chunk));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestLoadSnapshotChunk();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.format = object.format ?? 0;
        message.chunk = object.chunk ?? 0;
        return message;
      }
    };
    function createBaseRequestApplySnapshotChunk() {
      return {
        index: 0,
        chunk: new Uint8Array(),
        sender: ""
      };
    }
    exports2.RequestApplySnapshotChunk = {
      typeUrl: "/tendermint.abci.RequestApplySnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.chunk.length !== 0) {
          writer.uint32(18).bytes(message.chunk);
        }
        if (message.sender !== "") {
          writer.uint32(26).string(message.sender);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestApplySnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.chunk = reader.bytes();
              break;
            case 3:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestApplySnapshotChunk();
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = (0, helpers_1.bytesFromBase64)(object.chunk);
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.chunk !== void 0 && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        message.sender !== void 0 && (obj.sender = message.sender);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestApplySnapshotChunk();
        message.index = object.index ?? 0;
        message.chunk = object.chunk ?? new Uint8Array();
        message.sender = object.sender ?? "";
        return message;
      }
    };
    function createBaseRequestPrepareProposal() {
      return {
        maxTxBytes: BigInt(0),
        txs: [],
        localLastCommit: exports2.ExtendedCommitInfo.fromPartial({}),
        misbehavior: [],
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports2.RequestPrepareProposal = {
      typeUrl: "/tendermint.abci.RequestPrepareProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxTxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.maxTxBytes);
        }
        for (const v of message.txs) {
          writer.uint32(18).bytes(v);
        }
        if (message.localLastCommit !== void 0) {
          exports2.ExtendedCommitInfo.encode(message.localLastCommit, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.misbehavior) {
          exports2.Misbehavior.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestPrepareProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxTxBytes = reader.int64();
              break;
            case 2:
              message.txs.push(reader.bytes());
              break;
            case 3:
              message.localLastCommit = exports2.ExtendedCommitInfo.decode(reader, reader.uint32());
              break;
            case 4:
              message.misbehavior.push(exports2.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestPrepareProposal();
        if ((0, helpers_1.isSet)(object.maxTxBytes))
          obj.maxTxBytes = BigInt(object.maxTxBytes.toString());
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.localLastCommit))
          obj.localLastCommit = exports2.ExtendedCommitInfo.fromJSON(object.localLastCommit);
        if (Array.isArray(object == null ? void 0 : object.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports2.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxTxBytes !== void 0 && (obj.maxTxBytes = (message.maxTxBytes || BigInt(0)).toString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.localLastCommit !== void 0 && (obj.localLastCommit = message.localLastCommit ? exports2.ExtendedCommitInfo.toJSON(message.localLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports2.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseRequestPrepareProposal();
        if (object.maxTxBytes !== void 0 && object.maxTxBytes !== null) {
          message.maxTxBytes = BigInt(object.maxTxBytes.toString());
        }
        message.txs = ((_a = object.txs) == null ? void 0 : _a.map((e) => e)) || [];
        if (object.localLastCommit !== void 0 && object.localLastCommit !== null) {
          message.localLastCommit = exports2.ExtendedCommitInfo.fromPartial(object.localLastCommit);
        }
        message.misbehavior = ((_b = object.misbehavior) == null ? void 0 : _b.map((e) => exports2.Misbehavior.fromPartial(e))) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestProcessProposal() {
      return {
        txs: [],
        proposedLastCommit: exports2.CommitInfo.fromPartial({}),
        misbehavior: [],
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports2.RequestProcessProposal = {
      typeUrl: "/tendermint.abci.RequestProcessProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        if (message.proposedLastCommit !== void 0) {
          exports2.CommitInfo.encode(message.proposedLastCommit, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.misbehavior) {
          exports2.Misbehavior.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestProcessProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            case 2:
              message.proposedLastCommit = exports2.CommitInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.misbehavior.push(exports2.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestProcessProposal();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.proposedLastCommit))
          obj.proposedLastCommit = exports2.CommitInfo.fromJSON(object.proposedLastCommit);
        if (Array.isArray(object == null ? void 0 : object.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports2.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.proposedLastCommit !== void 0 && (obj.proposedLastCommit = message.proposedLastCommit ? exports2.CommitInfo.toJSON(message.proposedLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports2.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseRequestProcessProposal();
        message.txs = ((_a = object.txs) == null ? void 0 : _a.map((e) => e)) || [];
        if (object.proposedLastCommit !== void 0 && object.proposedLastCommit !== null) {
          message.proposedLastCommit = exports2.CommitInfo.fromPartial(object.proposedLastCommit);
        }
        message.misbehavior = ((_b = object.misbehavior) == null ? void 0 : _b.map((e) => exports2.Misbehavior.fromPartial(e))) || [];
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponse() {
      return {
        exception: void 0,
        echo: void 0,
        flush: void 0,
        info: void 0,
        initChain: void 0,
        query: void 0,
        beginBlock: void 0,
        checkTx: void 0,
        deliverTx: void 0,
        endBlock: void 0,
        commit: void 0,
        listSnapshots: void 0,
        offerSnapshot: void 0,
        loadSnapshotChunk: void 0,
        applySnapshotChunk: void 0,
        prepareProposal: void 0,
        processProposal: void 0
      };
    }
    exports2.Response = {
      typeUrl: "/tendermint.abci.Response",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exception !== void 0) {
          exports2.ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();
        }
        if (message.echo !== void 0) {
          exports2.ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports2.ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports2.ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports2.ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports2.ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();
        }
        if (message.beginBlock !== void 0) {
          exports2.ResponseBeginBlock.encode(message.beginBlock, writer.uint32(66).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports2.ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.deliverTx !== void 0) {
          exports2.ResponseDeliverTx.encode(message.deliverTx, writer.uint32(82).fork()).ldelim();
        }
        if (message.endBlock !== void 0) {
          exports2.ResponseEndBlock.encode(message.endBlock, writer.uint32(90).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports2.ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports2.ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports2.ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports2.ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports2.ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();
        }
        if (message.prepareProposal !== void 0) {
          exports2.ResponsePrepareProposal.encode(message.prepareProposal, writer.uint32(138).fork()).ldelim();
        }
        if (message.processProposal !== void 0) {
          exports2.ResponseProcessProposal.encode(message.processProposal, writer.uint32(146).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exception = exports2.ResponseException.decode(reader, reader.uint32());
              break;
            case 2:
              message.echo = exports2.ResponseEcho.decode(reader, reader.uint32());
              break;
            case 3:
              message.flush = exports2.ResponseFlush.decode(reader, reader.uint32());
              break;
            case 4:
              message.info = exports2.ResponseInfo.decode(reader, reader.uint32());
              break;
            case 6:
              message.initChain = exports2.ResponseInitChain.decode(reader, reader.uint32());
              break;
            case 7:
              message.query = exports2.ResponseQuery.decode(reader, reader.uint32());
              break;
            case 8:
              message.beginBlock = exports2.ResponseBeginBlock.decode(reader, reader.uint32());
              break;
            case 9:
              message.checkTx = exports2.ResponseCheckTx.decode(reader, reader.uint32());
              break;
            case 10:
              message.deliverTx = exports2.ResponseDeliverTx.decode(reader, reader.uint32());
              break;
            case 11:
              message.endBlock = exports2.ResponseEndBlock.decode(reader, reader.uint32());
              break;
            case 12:
              message.commit = exports2.ResponseCommit.decode(reader, reader.uint32());
              break;
            case 13:
              message.listSnapshots = exports2.ResponseListSnapshots.decode(reader, reader.uint32());
              break;
            case 14:
              message.offerSnapshot = exports2.ResponseOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 15:
              message.loadSnapshotChunk = exports2.ResponseLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 16:
              message.applySnapshotChunk = exports2.ResponseApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            case 17:
              message.prepareProposal = exports2.ResponsePrepareProposal.decode(reader, reader.uint32());
              break;
            case 18:
              message.processProposal = exports2.ResponseProcessProposal.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponse();
        if ((0, helpers_1.isSet)(object.exception))
          obj.exception = exports2.ResponseException.fromJSON(object.exception);
        if ((0, helpers_1.isSet)(object.echo))
          obj.echo = exports2.ResponseEcho.fromJSON(object.echo);
        if ((0, helpers_1.isSet)(object.flush))
          obj.flush = exports2.ResponseFlush.fromJSON(object.flush);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = exports2.ResponseInfo.fromJSON(object.info);
        if ((0, helpers_1.isSet)(object.initChain))
          obj.initChain = exports2.ResponseInitChain.fromJSON(object.initChain);
        if ((0, helpers_1.isSet)(object.query))
          obj.query = exports2.ResponseQuery.fromJSON(object.query);
        if ((0, helpers_1.isSet)(object.beginBlock))
          obj.beginBlock = exports2.ResponseBeginBlock.fromJSON(object.beginBlock);
        if ((0, helpers_1.isSet)(object.checkTx))
          obj.checkTx = exports2.ResponseCheckTx.fromJSON(object.checkTx);
        if ((0, helpers_1.isSet)(object.deliverTx))
          obj.deliverTx = exports2.ResponseDeliverTx.fromJSON(object.deliverTx);
        if ((0, helpers_1.isSet)(object.endBlock))
          obj.endBlock = exports2.ResponseEndBlock.fromJSON(object.endBlock);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports2.ResponseCommit.fromJSON(object.commit);
        if ((0, helpers_1.isSet)(object.listSnapshots))
          obj.listSnapshots = exports2.ResponseListSnapshots.fromJSON(object.listSnapshots);
        if ((0, helpers_1.isSet)(object.offerSnapshot))
          obj.offerSnapshot = exports2.ResponseOfferSnapshot.fromJSON(object.offerSnapshot);
        if ((0, helpers_1.isSet)(object.loadSnapshotChunk))
          obj.loadSnapshotChunk = exports2.ResponseLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);
        if ((0, helpers_1.isSet)(object.applySnapshotChunk))
          obj.applySnapshotChunk = exports2.ResponseApplySnapshotChunk.fromJSON(object.applySnapshotChunk);
        if ((0, helpers_1.isSet)(object.prepareProposal))
          obj.prepareProposal = exports2.ResponsePrepareProposal.fromJSON(object.prepareProposal);
        if ((0, helpers_1.isSet)(object.processProposal))
          obj.processProposal = exports2.ResponseProcessProposal.fromJSON(object.processProposal);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exception !== void 0 && (obj.exception = message.exception ? exports2.ResponseException.toJSON(message.exception) : void 0);
        message.echo !== void 0 && (obj.echo = message.echo ? exports2.ResponseEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports2.ResponseFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports2.ResponseInfo.toJSON(message.info) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports2.ResponseInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports2.ResponseQuery.toJSON(message.query) : void 0);
        message.beginBlock !== void 0 && (obj.beginBlock = message.beginBlock ? exports2.ResponseBeginBlock.toJSON(message.beginBlock) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports2.ResponseCheckTx.toJSON(message.checkTx) : void 0);
        message.deliverTx !== void 0 && (obj.deliverTx = message.deliverTx ? exports2.ResponseDeliverTx.toJSON(message.deliverTx) : void 0);
        message.endBlock !== void 0 && (obj.endBlock = message.endBlock ? exports2.ResponseEndBlock.toJSON(message.endBlock) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports2.ResponseCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports2.ResponseListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports2.ResponseOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports2.ResponseLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports2.ResponseApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        message.prepareProposal !== void 0 && (obj.prepareProposal = message.prepareProposal ? exports2.ResponsePrepareProposal.toJSON(message.prepareProposal) : void 0);
        message.processProposal !== void 0 && (obj.processProposal = message.processProposal ? exports2.ResponseProcessProposal.toJSON(message.processProposal) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponse();
        if (object.exception !== void 0 && object.exception !== null) {
          message.exception = exports2.ResponseException.fromPartial(object.exception);
        }
        if (object.echo !== void 0 && object.echo !== null) {
          message.echo = exports2.ResponseEcho.fromPartial(object.echo);
        }
        if (object.flush !== void 0 && object.flush !== null) {
          message.flush = exports2.ResponseFlush.fromPartial(object.flush);
        }
        if (object.info !== void 0 && object.info !== null) {
          message.info = exports2.ResponseInfo.fromPartial(object.info);
        }
        if (object.initChain !== void 0 && object.initChain !== null) {
          message.initChain = exports2.ResponseInitChain.fromPartial(object.initChain);
        }
        if (object.query !== void 0 && object.query !== null) {
          message.query = exports2.ResponseQuery.fromPartial(object.query);
        }
        if (object.beginBlock !== void 0 && object.beginBlock !== null) {
          message.beginBlock = exports2.ResponseBeginBlock.fromPartial(object.beginBlock);
        }
        if (object.checkTx !== void 0 && object.checkTx !== null) {
          message.checkTx = exports2.ResponseCheckTx.fromPartial(object.checkTx);
        }
        if (object.deliverTx !== void 0 && object.deliverTx !== null) {
          message.deliverTx = exports2.ResponseDeliverTx.fromPartial(object.deliverTx);
        }
        if (object.endBlock !== void 0 && object.endBlock !== null) {
          message.endBlock = exports2.ResponseEndBlock.fromPartial(object.endBlock);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports2.ResponseCommit.fromPartial(object.commit);
        }
        if (object.listSnapshots !== void 0 && object.listSnapshots !== null) {
          message.listSnapshots = exports2.ResponseListSnapshots.fromPartial(object.listSnapshots);
        }
        if (object.offerSnapshot !== void 0 && object.offerSnapshot !== null) {
          message.offerSnapshot = exports2.ResponseOfferSnapshot.fromPartial(object.offerSnapshot);
        }
        if (object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null) {
          message.loadSnapshotChunk = exports2.ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);
        }
        if (object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null) {
          message.applySnapshotChunk = exports2.ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk);
        }
        if (object.prepareProposal !== void 0 && object.prepareProposal !== null) {
          message.prepareProposal = exports2.ResponsePrepareProposal.fromPartial(object.prepareProposal);
        }
        if (object.processProposal !== void 0 && object.processProposal !== null) {
          message.processProposal = exports2.ResponseProcessProposal.fromPartial(object.processProposal);
        }
        return message;
      }
    };
    function createBaseResponseException() {
      return {
        error: ""
      };
    }
    exports2.ResponseException = {
      typeUrl: "/tendermint.abci.ResponseException",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.error !== "") {
          writer.uint32(10).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseException();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseException();
        if ((0, helpers_1.isSet)(object.error))
          obj.error = String(object.error);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseException();
        message.error = object.error ?? "";
        return message;
      }
    };
    function createBaseResponseEcho() {
      return {
        message: ""
      };
    }
    exports2.ResponseEcho = {
      typeUrl: "/tendermint.abci.ResponseEcho",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseEcho();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseEcho();
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseEcho();
        message.message = object.message ?? "";
        return message;
      }
    };
    function createBaseResponseFlush() {
      return {};
    }
    exports2.ResponseFlush = {
      typeUrl: "/tendermint.abci.ResponseFlush",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseFlush();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseResponseFlush();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseResponseFlush();
        return message;
      }
    };
    function createBaseResponseInfo() {
      return {
        data: "",
        version: "",
        appVersion: BigInt(0),
        lastBlockHeight: BigInt(0),
        lastBlockAppHash: new Uint8Array()
      };
    }
    exports2.ResponseInfo = {
      typeUrl: "/tendermint.abci.ResponseInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data !== "") {
          writer.uint32(10).string(message.data);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        if (message.appVersion !== BigInt(0)) {
          writer.uint32(24).uint64(message.appVersion);
        }
        if (message.lastBlockHeight !== BigInt(0)) {
          writer.uint32(32).int64(message.lastBlockHeight);
        }
        if (message.lastBlockAppHash.length !== 0) {
          writer.uint32(42).bytes(message.lastBlockAppHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.string();
              break;
            case 2:
              message.version = reader.string();
              break;
            case 3:
              message.appVersion = reader.uint64();
              break;
            case 4:
              message.lastBlockHeight = reader.int64();
              break;
            case 5:
              message.lastBlockAppHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseInfo();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = String(object.data);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.appVersion))
          obj.appVersion = BigInt(object.appVersion.toString());
        if ((0, helpers_1.isSet)(object.lastBlockHeight))
          obj.lastBlockHeight = BigInt(object.lastBlockHeight.toString());
        if ((0, helpers_1.isSet)(object.lastBlockAppHash))
          obj.lastBlockAppHash = (0, helpers_1.bytesFromBase64)(object.lastBlockAppHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = message.data);
        message.version !== void 0 && (obj.version = message.version);
        message.appVersion !== void 0 && (obj.appVersion = (message.appVersion || BigInt(0)).toString());
        message.lastBlockHeight !== void 0 && (obj.lastBlockHeight = (message.lastBlockHeight || BigInt(0)).toString());
        message.lastBlockAppHash !== void 0 && (obj.lastBlockAppHash = (0, helpers_1.base64FromBytes)(message.lastBlockAppHash !== void 0 ? message.lastBlockAppHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseInfo();
        message.data = object.data ?? "";
        message.version = object.version ?? "";
        if (object.appVersion !== void 0 && object.appVersion !== null) {
          message.appVersion = BigInt(object.appVersion.toString());
        }
        if (object.lastBlockHeight !== void 0 && object.lastBlockHeight !== null) {
          message.lastBlockHeight = BigInt(object.lastBlockHeight.toString());
        }
        message.lastBlockAppHash = object.lastBlockAppHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseInitChain() {
      return {
        consensusParams: void 0,
        validators: [],
        appHash: new Uint8Array()
      };
    }
    exports2.ResponseInitChain = {
      typeUrl: "/tendermint.abci.ResponseInitChain",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusParams !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.validators) {
          exports2.ValidatorUpdate.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(26).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseInitChain();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.validators.push(exports2.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 3:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseInitChain();
        if ((0, helpers_1.isSet)(object.consensusParams))
          obj.consensusParams = params_1.ConsensusParams.fromJSON(object.consensusParams);
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => exports2.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports2.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseInitChain();
        if (object.consensusParams !== void 0 && object.consensusParams !== null) {
          message.consensusParams = params_1.ConsensusParams.fromPartial(object.consensusParams);
        }
        message.validators = ((_a = object.validators) == null ? void 0 : _a.map((e) => exports2.ValidatorUpdate.fromPartial(e))) || [];
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseQuery() {
      return {
        code: 0,
        log: "",
        info: "",
        index: BigInt(0),
        key: new Uint8Array(),
        value: new Uint8Array(),
        proofOps: void 0,
        height: BigInt(0),
        codespace: ""
      };
    }
    exports2.ResponseQuery = {
      typeUrl: "/tendermint.abci.ResponseQuery",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.index !== BigInt(0)) {
          writer.uint32(40).int64(message.index);
        }
        if (message.key.length !== 0) {
          writer.uint32(50).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(58).bytes(message.value);
        }
        if (message.proofOps !== void 0) {
          proof_1.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(72).int64(message.height);
        }
        if (message.codespace !== "") {
          writer.uint32(82).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseQuery();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.index = reader.int64();
              break;
            case 6:
              message.key = reader.bytes();
              break;
            case 7:
              message.value = reader.bytes();
              break;
            case 8:
              message.proofOps = proof_1.ProofOps.decode(reader, reader.uint32());
              break;
            case 9:
              message.height = reader.int64();
              break;
            case 10:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseQuery();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.index))
          obj.index = BigInt(object.index.toString());
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.proofOps))
          obj.proofOps = proof_1.ProofOps.fromJSON(object.proofOps);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.index !== void 0 && (obj.index = (message.index || BigInt(0)).toString());
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.proofOps !== void 0 && (obj.proofOps = message.proofOps ? proof_1.ProofOps.toJSON(message.proofOps) : void 0);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseQuery();
        message.code = object.code ?? 0;
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.index !== void 0 && object.index !== null) {
          message.index = BigInt(object.index.toString());
        }
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.proofOps !== void 0 && object.proofOps !== null) {
          message.proofOps = proof_1.ProofOps.fromPartial(object.proofOps);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseResponseBeginBlock() {
      return {
        events: []
      };
    }
    exports2.ResponseBeginBlock = {
      typeUrl: "/tendermint.abci.ResponseBeginBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.events) {
          exports2.Event.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseBeginBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(exports2.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseBeginBlock();
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => exports2.Event.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports2.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseBeginBlock();
        message.events = ((_a = object.events) == null ? void 0 : _a.map((e) => exports2.Event.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseResponseCheckTx() {
      return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        events: [],
        codespace: "",
        sender: "",
        priority: BigInt(0),
        mempoolError: ""
      };
    }
    exports2.ResponseCheckTx = {
      typeUrl: "/tendermint.abci.ResponseCheckTx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
          exports2.Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        if (message.sender !== "") {
          writer.uint32(74).string(message.sender);
        }
        if (message.priority !== BigInt(0)) {
          writer.uint32(80).int64(message.priority);
        }
        if (message.mempoolError !== "") {
          writer.uint32(90).string(message.mempoolError);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseCheckTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports2.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            case 9:
              message.sender = reader.string();
              break;
            case 10:
              message.priority = reader.int64();
              break;
            case 11:
              message.mempoolError = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseCheckTx();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gas_wanted))
          obj.gasWanted = BigInt(object.gas_wanted.toString());
        if ((0, helpers_1.isSet)(object.gas_used))
          obj.gasUsed = BigInt(object.gas_used.toString());
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => exports2.Event.fromJSON(e));
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.priority))
          obj.priority = BigInt(object.priority.toString());
        if ((0, helpers_1.isSet)(object.mempoolError))
          obj.mempoolError = String(object.mempoolError);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || BigInt(0)).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports2.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        message.sender !== void 0 && (obj.sender = message.sender);
        message.priority !== void 0 && (obj.priority = (message.priority || BigInt(0)).toString());
        message.mempoolError !== void 0 && (obj.mempoolError = message.mempoolError);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseCheckTx();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        message.events = ((_a = object.events) == null ? void 0 : _a.map((e) => exports2.Event.fromPartial(e))) || [];
        message.codespace = object.codespace ?? "";
        message.sender = object.sender ?? "";
        if (object.priority !== void 0 && object.priority !== null) {
          message.priority = BigInt(object.priority.toString());
        }
        message.mempoolError = object.mempoolError ?? "";
        return message;
      }
    };
    function createBaseResponseDeliverTx() {
      return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        events: [],
        codespace: ""
      };
    }
    exports2.ResponseDeliverTx = {
      typeUrl: "/tendermint.abci.ResponseDeliverTx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
          exports2.Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseDeliverTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports2.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseDeliverTx();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gas_wanted))
          obj.gasWanted = BigInt(object.gas_wanted.toString());
        if ((0, helpers_1.isSet)(object.gas_used))
          obj.gasUsed = BigInt(object.gas_used.toString());
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => exports2.Event.fromJSON(e));
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || BigInt(0)).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports2.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseDeliverTx();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        message.events = ((_a = object.events) == null ? void 0 : _a.map((e) => exports2.Event.fromPartial(e))) || [];
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseResponseEndBlock() {
      return {
        validatorUpdates: [],
        consensusParamUpdates: void 0,
        events: []
      };
    }
    exports2.ResponseEndBlock = {
      typeUrl: "/tendermint.abci.ResponseEndBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validatorUpdates) {
          exports2.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusParamUpdates !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.events) {
          exports2.Event.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseEndBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorUpdates.push(exports2.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 2:
              message.consensusParamUpdates = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.events.push(exports2.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseEndBlock();
        if (Array.isArray(object == null ? void 0 : object.validatorUpdates))
          obj.validatorUpdates = object.validatorUpdates.map((e) => exports2.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.consensusParamUpdates))
          obj.consensusParamUpdates = params_1.ConsensusParams.fromJSON(object.consensusParamUpdates);
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => exports2.Event.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validatorUpdates) {
          obj.validatorUpdates = message.validatorUpdates.map((e) => e ? exports2.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validatorUpdates = [];
        }
        message.consensusParamUpdates !== void 0 && (obj.consensusParamUpdates = message.consensusParamUpdates ? params_1.ConsensusParams.toJSON(message.consensusParamUpdates) : void 0);
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports2.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseResponseEndBlock();
        message.validatorUpdates = ((_a = object.validatorUpdates) == null ? void 0 : _a.map((e) => exports2.ValidatorUpdate.fromPartial(e))) || [];
        if (object.consensusParamUpdates !== void 0 && object.consensusParamUpdates !== null) {
          message.consensusParamUpdates = params_1.ConsensusParams.fromPartial(object.consensusParamUpdates);
        }
        message.events = ((_b = object.events) == null ? void 0 : _b.map((e) => exports2.Event.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseResponseCommit() {
      return {
        data: new Uint8Array(),
        retainHeight: BigInt(0)
      };
    }
    exports2.ResponseCommit = {
      typeUrl: "/tendermint.abci.ResponseCommit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.retainHeight !== BigInt(0)) {
          writer.uint32(24).int64(message.retainHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.retainHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseCommit();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.retainHeight))
          obj.retainHeight = BigInt(object.retainHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.retainHeight !== void 0 && (obj.retainHeight = (message.retainHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseCommit();
        message.data = object.data ?? new Uint8Array();
        if (object.retainHeight !== void 0 && object.retainHeight !== null) {
          message.retainHeight = BigInt(object.retainHeight.toString());
        }
        return message;
      }
    };
    function createBaseResponseListSnapshots() {
      return {
        snapshots: []
      };
    }
    exports2.ResponseListSnapshots = {
      typeUrl: "/tendermint.abci.ResponseListSnapshots",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.snapshots) {
          exports2.Snapshot.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseListSnapshots();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshots.push(exports2.Snapshot.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseListSnapshots();
        if (Array.isArray(object == null ? void 0 : object.snapshots))
          obj.snapshots = object.snapshots.map((e) => exports2.Snapshot.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.snapshots) {
          obj.snapshots = message.snapshots.map((e) => e ? exports2.Snapshot.toJSON(e) : void 0);
        } else {
          obj.snapshots = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponseListSnapshots();
        message.snapshots = ((_a = object.snapshots) == null ? void 0 : _a.map((e) => exports2.Snapshot.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseResponseOfferSnapshot() {
      return {
        result: 0
      };
    }
    exports2.ResponseOfferSnapshot = {
      typeUrl: "/tendermint.abci.ResponseOfferSnapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseOfferSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseOfferSnapshot();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseOfferSnapshot_ResultFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseOfferSnapshot_ResultToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseOfferSnapshot();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseResponseLoadSnapshotChunk() {
      return {
        chunk: new Uint8Array()
      };
    }
    exports2.ResponseLoadSnapshotChunk = {
      typeUrl: "/tendermint.abci.ResponseLoadSnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.chunk.length !== 0) {
          writer.uint32(10).bytes(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseLoadSnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chunk = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseLoadSnapshotChunk();
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = (0, helpers_1.bytesFromBase64)(object.chunk);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.chunk !== void 0 && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseLoadSnapshotChunk();
        message.chunk = object.chunk ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseApplySnapshotChunk() {
      return {
        result: 0,
        refetchChunks: [],
        rejectSenders: []
      };
    }
    exports2.ResponseApplySnapshotChunk = {
      typeUrl: "/tendermint.abci.ResponseApplySnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        writer.uint32(18).fork();
        for (const v of message.refetchChunks) {
          writer.uint32(v);
        }
        writer.ldelim();
        for (const v of message.rejectSenders) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseApplySnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            case 2:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.refetchChunks.push(reader.uint32());
                }
              } else {
                message.refetchChunks.push(reader.uint32());
              }
              break;
            case 3:
              message.rejectSenders.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseApplySnapshotChunk();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseApplySnapshotChunk_ResultFromJSON(object.result);
        if (Array.isArray(object == null ? void 0 : object.refetchChunks))
          obj.refetchChunks = object.refetchChunks.map((e) => Number(e));
        if (Array.isArray(object == null ? void 0 : object.rejectSenders))
          obj.rejectSenders = object.rejectSenders.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseApplySnapshotChunk_ResultToJSON(message.result));
        if (message.refetchChunks) {
          obj.refetchChunks = message.refetchChunks.map((e) => Math.round(e));
        } else {
          obj.refetchChunks = [];
        }
        if (message.rejectSenders) {
          obj.rejectSenders = message.rejectSenders.map((e) => e);
        } else {
          obj.rejectSenders = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseResponseApplySnapshotChunk();
        message.result = object.result ?? 0;
        message.refetchChunks = ((_a = object.refetchChunks) == null ? void 0 : _a.map((e) => e)) || [];
        message.rejectSenders = ((_b = object.rejectSenders) == null ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseResponsePrepareProposal() {
      return {
        txs: []
      };
    }
    exports2.ResponsePrepareProposal = {
      typeUrl: "/tendermint.abci.ResponsePrepareProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponsePrepareProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponsePrepareProposal();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseResponsePrepareProposal();
        message.txs = ((_a = object.txs) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseResponseProcessProposal() {
      return {
        status: 0
      };
    }
    exports2.ResponseProcessProposal = {
      typeUrl: "/tendermint.abci.ResponseProcessProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== 0) {
          writer.uint32(8).int32(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseProcessProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseProcessProposal();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = responseProcessProposal_ProposalStatusFromJSON(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = responseProcessProposal_ProposalStatusToJSON(message.status));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseProcessProposal();
        message.status = object.status ?? 0;
        return message;
      }
    };
    function createBaseCommitInfo() {
      return {
        round: 0,
        votes: []
      };
    }
    exports2.CommitInfo = {
      typeUrl: "/tendermint.abci.CommitInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.round !== 0) {
          writer.uint32(8).int32(message.round);
        }
        for (const v of message.votes) {
          exports2.VoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.round = reader.int32();
              break;
            case 2:
              message.votes.push(exports2.VoteInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitInfo();
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if (Array.isArray(object == null ? void 0 : object.votes))
          obj.votes = object.votes.map((e) => exports2.VoteInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.round !== void 0 && (obj.round = Math.round(message.round));
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? exports2.VoteInfo.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseCommitInfo();
        message.round = object.round ?? 0;
        message.votes = ((_a = object.votes) == null ? void 0 : _a.map((e) => exports2.VoteInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseExtendedCommitInfo() {
      return {
        round: 0,
        votes: []
      };
    }
    exports2.ExtendedCommitInfo = {
      typeUrl: "/tendermint.abci.ExtendedCommitInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.round !== 0) {
          writer.uint32(8).int32(message.round);
        }
        for (const v of message.votes) {
          exports2.ExtendedVoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommitInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.round = reader.int32();
              break;
            case 2:
              message.votes.push(exports2.ExtendedVoteInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedCommitInfo();
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if (Array.isArray(object == null ? void 0 : object.votes))
          obj.votes = object.votes.map((e) => exports2.ExtendedVoteInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.round !== void 0 && (obj.round = Math.round(message.round));
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? exports2.ExtendedVoteInfo.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseExtendedCommitInfo();
        message.round = object.round ?? 0;
        message.votes = ((_a = object.votes) == null ? void 0 : _a.map((e) => exports2.ExtendedVoteInfo.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseEvent() {
      return {
        type: "",
        attributes: []
      };
    }
    exports2.Event = {
      typeUrl: "/tendermint.abci.Event",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
          exports2.EventAttribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports2.EventAttribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvent();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if (Array.isArray(object == null ? void 0 : object.attributes))
          obj.attributes = object.attributes.map((e) => exports2.EventAttribute.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports2.EventAttribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseEvent();
        message.type = object.type ?? "";
        message.attributes = ((_a = object.attributes) == null ? void 0 : _a.map((e) => exports2.EventAttribute.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseEventAttribute() {
      return {
        key: "",
        value: "",
        index: false
      };
    }
    exports2.EventAttribute = {
      typeUrl: "/tendermint.abci.EventAttribute",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        if (message.index === true) {
          writer.uint32(24).bool(message.index);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEventAttribute();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            case 3:
              message.index = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEventAttribute();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = String(object.value);
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Boolean(object.index);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        message.index !== void 0 && (obj.index = message.index);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEventAttribute();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        message.index = object.index ?? false;
        return message;
      }
    };
    function createBaseTxResult() {
      return {
        height: BigInt(0),
        index: 0,
        tx: new Uint8Array(),
        result: exports2.ResponseDeliverTx.fromPartial({})
      };
    }
    exports2.TxResult = {
      typeUrl: "/tendermint.abci.TxResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.index !== 0) {
          writer.uint32(16).uint32(message.index);
        }
        if (message.tx.length !== 0) {
          writer.uint32(26).bytes(message.tx);
        }
        if (message.result !== void 0) {
          exports2.ResponseDeliverTx.encode(message.result, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.index = reader.uint32();
              break;
            case 3:
              message.tx = reader.bytes();
              break;
            case 4:
              message.result = exports2.ResponseDeliverTx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxResult();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = exports2.ResponseDeliverTx.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.tx !== void 0 && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.result !== void 0 && (obj.result = message.result ? exports2.ResponseDeliverTx.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxResult();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.index = object.index ?? 0;
        message.tx = object.tx ?? new Uint8Array();
        if (object.result !== void 0 && object.result !== null) {
          message.result = exports2.ResponseDeliverTx.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseValidator() {
      return {
        address: new Uint8Array(),
        power: BigInt(0)
      };
    }
    exports2.Validator = {
      typeUrl: "/tendermint.abci.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.power !== BigInt(0)) {
          writer.uint32(24).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 3:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = (0, helpers_1.bytesFromBase64)(object.address);
        if ((0, helpers_1.isSet)(object.power))
          obj.power = BigInt(object.power.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== void 0 ? message.address : new Uint8Array()));
        message.power !== void 0 && (obj.power = (message.power || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidator();
        message.address = object.address ?? new Uint8Array();
        if (object.power !== void 0 && object.power !== null) {
          message.power = BigInt(object.power.toString());
        }
        return message;
      }
    };
    function createBaseValidatorUpdate() {
      return {
        pubKey: keys_1.PublicKey.fromPartial({}),
        power: BigInt(0)
      };
    }
    exports2.ValidatorUpdate = {
      typeUrl: "/tendermint.abci.ValidatorUpdate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.power !== BigInt(0)) {
          writer.uint32(16).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorUpdate();
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.power))
          obj.power = BigInt(object.power.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.power !== void 0 && (obj.power = (message.power || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorUpdate();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.power !== void 0 && object.power !== null) {
          message.power = BigInt(object.power.toString());
        }
        return message;
      }
    };
    function createBaseVoteInfo() {
      return {
        validator: exports2.Validator.fromPartial({}),
        signedLastBlock: false
      };
    }
    exports2.VoteInfo = {
      typeUrl: "/tendermint.abci.VoteInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          exports2.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.signedLastBlock === true) {
          writer.uint32(16).bool(message.signedLastBlock);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVoteInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = exports2.Validator.decode(reader, reader.uint32());
              break;
            case 2:
              message.signedLastBlock = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVoteInfo();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports2.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.signedLastBlock))
          obj.signedLastBlock = Boolean(object.signedLastBlock);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? exports2.Validator.toJSON(message.validator) : void 0);
        message.signedLastBlock !== void 0 && (obj.signedLastBlock = message.signedLastBlock);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVoteInfo();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports2.Validator.fromPartial(object.validator);
        }
        message.signedLastBlock = object.signedLastBlock ?? false;
        return message;
      }
    };
    function createBaseExtendedVoteInfo() {
      return {
        validator: exports2.Validator.fromPartial({}),
        signedLastBlock: false,
        voteExtension: new Uint8Array()
      };
    }
    exports2.ExtendedVoteInfo = {
      typeUrl: "/tendermint.abci.ExtendedVoteInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          exports2.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.signedLastBlock === true) {
          writer.uint32(16).bool(message.signedLastBlock);
        }
        if (message.voteExtension.length !== 0) {
          writer.uint32(26).bytes(message.voteExtension);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedVoteInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = exports2.Validator.decode(reader, reader.uint32());
              break;
            case 2:
              message.signedLastBlock = reader.bool();
              break;
            case 3:
              message.voteExtension = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedVoteInfo();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports2.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.signedLastBlock))
          obj.signedLastBlock = Boolean(object.signedLastBlock);
        if ((0, helpers_1.isSet)(object.voteExtension))
          obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? exports2.Validator.toJSON(message.validator) : void 0);
        message.signedLastBlock !== void 0 && (obj.signedLastBlock = message.signedLastBlock);
        message.voteExtension !== void 0 && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== void 0 ? message.voteExtension : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedVoteInfo();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports2.Validator.fromPartial(object.validator);
        }
        message.signedLastBlock = object.signedLastBlock ?? false;
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMisbehavior() {
      return {
        type: 0,
        validator: exports2.Validator.fromPartial({}),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        totalVotingPower: BigInt(0)
      };
    }
    exports2.Misbehavior = {
      typeUrl: "/tendermint.abci.Misbehavior",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.validator !== void 0) {
          exports2.Validator.encode(message.validator, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(40).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMisbehavior();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.validator = exports2.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMisbehavior();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = misbehaviorTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports2.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = misbehaviorTypeToJSON(message.type));
        message.validator !== void 0 && (obj.validator = message.validator ? exports2.Validator.toJSON(message.validator) : void 0);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMisbehavior();
        message.type = object.type ?? 0;
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports2.Validator.fromPartial(object.validator);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        return message;
      }
    };
    function createBaseSnapshot() {
      return {
        height: BigInt(0),
        format: 0,
        chunks: 0,
        hash: new Uint8Array(),
        metadata: new Uint8Array()
      };
    }
    exports2.Snapshot = {
      typeUrl: "/tendermint.abci.Snapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunks !== 0) {
          writer.uint32(24).uint32(message.chunks);
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.metadata.length !== 0) {
          writer.uint32(42).bytes(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunks = reader.uint32();
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.metadata = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSnapshot();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.format))
          obj.format = Number(object.format);
        if ((0, helpers_1.isSet)(object.chunks))
          obj.chunks = Number(object.chunks);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = (0, helpers_1.bytesFromBase64)(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.format !== void 0 && (obj.format = Math.round(message.format));
        message.chunks !== void 0 && (obj.chunks = Math.round(message.chunks));
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.metadata !== void 0 && (obj.metadata = (0, helpers_1.base64FromBytes)(message.metadata !== void 0 ? message.metadata : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSnapshot();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.format = object.format ?? 0;
        message.chunks = object.chunks ?? 0;
        message.hash = object.hash ?? new Uint8Array();
        message.metadata = object.metadata ?? new Uint8Array();
        return message;
      }
    };
    var ABCIApplicationClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Echo = this.Echo.bind(this);
        this.Flush = this.Flush.bind(this);
        this.Info = this.Info.bind(this);
        this.DeliverTx = this.DeliverTx.bind(this);
        this.CheckTx = this.CheckTx.bind(this);
        this.Query = this.Query.bind(this);
        this.Commit = this.Commit.bind(this);
        this.InitChain = this.InitChain.bind(this);
        this.BeginBlock = this.BeginBlock.bind(this);
        this.EndBlock = this.EndBlock.bind(this);
        this.ListSnapshots = this.ListSnapshots.bind(this);
        this.OfferSnapshot = this.OfferSnapshot.bind(this);
        this.LoadSnapshotChunk = this.LoadSnapshotChunk.bind(this);
        this.ApplySnapshotChunk = this.ApplySnapshotChunk.bind(this);
        this.PrepareProposal = this.PrepareProposal.bind(this);
        this.ProcessProposal = this.ProcessProposal.bind(this);
      }
      Echo(request) {
        const data = exports2.RequestEcho.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Echo", data);
        return promise.then((data2) => exports2.ResponseEcho.decode(new binary_1.BinaryReader(data2)));
      }
      Flush(request = {}) {
        const data = exports2.RequestFlush.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Flush", data);
        return promise.then((data2) => exports2.ResponseFlush.decode(new binary_1.BinaryReader(data2)));
      }
      Info(request) {
        const data = exports2.RequestInfo.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Info", data);
        return promise.then((data2) => exports2.ResponseInfo.decode(new binary_1.BinaryReader(data2)));
      }
      DeliverTx(request) {
        const data = exports2.RequestDeliverTx.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "DeliverTx", data);
        return promise.then((data2) => exports2.ResponseDeliverTx.decode(new binary_1.BinaryReader(data2)));
      }
      CheckTx(request) {
        const data = exports2.RequestCheckTx.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "CheckTx", data);
        return promise.then((data2) => exports2.ResponseCheckTx.decode(new binary_1.BinaryReader(data2)));
      }
      Query(request) {
        const data = exports2.RequestQuery.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Query", data);
        return promise.then((data2) => exports2.ResponseQuery.decode(new binary_1.BinaryReader(data2)));
      }
      Commit(request = {}) {
        const data = exports2.RequestCommit.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Commit", data);
        return promise.then((data2) => exports2.ResponseCommit.decode(new binary_1.BinaryReader(data2)));
      }
      InitChain(request) {
        const data = exports2.RequestInitChain.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "InitChain", data);
        return promise.then((data2) => exports2.ResponseInitChain.decode(new binary_1.BinaryReader(data2)));
      }
      BeginBlock(request) {
        const data = exports2.RequestBeginBlock.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "BeginBlock", data);
        return promise.then((data2) => exports2.ResponseBeginBlock.decode(new binary_1.BinaryReader(data2)));
      }
      EndBlock(request) {
        const data = exports2.RequestEndBlock.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "EndBlock", data);
        return promise.then((data2) => exports2.ResponseEndBlock.decode(new binary_1.BinaryReader(data2)));
      }
      ListSnapshots(request = {}) {
        const data = exports2.RequestListSnapshots.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "ListSnapshots", data);
        return promise.then((data2) => exports2.ResponseListSnapshots.decode(new binary_1.BinaryReader(data2)));
      }
      OfferSnapshot(request) {
        const data = exports2.RequestOfferSnapshot.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "OfferSnapshot", data);
        return promise.then((data2) => exports2.ResponseOfferSnapshot.decode(new binary_1.BinaryReader(data2)));
      }
      LoadSnapshotChunk(request) {
        const data = exports2.RequestLoadSnapshotChunk.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "LoadSnapshotChunk", data);
        return promise.then((data2) => exports2.ResponseLoadSnapshotChunk.decode(new binary_1.BinaryReader(data2)));
      }
      ApplySnapshotChunk(request) {
        const data = exports2.RequestApplySnapshotChunk.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "ApplySnapshotChunk", data);
        return promise.then((data2) => exports2.ResponseApplySnapshotChunk.decode(new binary_1.BinaryReader(data2)));
      }
      PrepareProposal(request) {
        const data = exports2.RequestPrepareProposal.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "PrepareProposal", data);
        return promise.then((data2) => exports2.ResponsePrepareProposal.decode(new binary_1.BinaryReader(data2)));
      }
      ProcessProposal(request) {
        const data = exports2.RequestProcessProposal.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "ProcessProposal", data);
        return promise.then((data2) => exports2.ResponseProcessProposal.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.ABCIApplicationClientImpl = ABCIApplicationClientImpl;
  }
});

// node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js
var require_staking = __commonJS({
  "node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidatorUpdates = exports2.Pool = exports2.RedelegationResponse = exports2.RedelegationEntryResponse = exports2.DelegationResponse = exports2.Params = exports2.Redelegation = exports2.RedelegationEntry = exports2.UnbondingDelegationEntry = exports2.UnbondingDelegation = exports2.Delegation = exports2.DVVTriplets = exports2.DVVTriplet = exports2.DVPairs = exports2.DVPair = exports2.ValAddresses = exports2.Validator = exports2.Description = exports2.Commission = exports2.CommissionRates = exports2.HistoricalInfo = exports2.infractionToJSON = exports2.infractionFromJSON = exports2.Infraction = exports2.bondStatusToJSON = exports2.bondStatusFromJSON = exports2.BondStatus = exports2.protobufPackage = void 0;
    var types_1 = require_types3();
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    var duration_1 = require_duration();
    var coin_1 = require_coin();
    var types_2 = require_types4();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.staking.v1beta1";
    var BondStatus;
    (function(BondStatus2) {
      BondStatus2[BondStatus2["BOND_STATUS_UNSPECIFIED"] = 0] = "BOND_STATUS_UNSPECIFIED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDED"] = 1] = "BOND_STATUS_UNBONDED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDING"] = 2] = "BOND_STATUS_UNBONDING";
      BondStatus2[BondStatus2["BOND_STATUS_BONDED"] = 3] = "BOND_STATUS_BONDED";
      BondStatus2[BondStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BondStatus || (exports2.BondStatus = BondStatus = {}));
    function bondStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "BOND_STATUS_UNSPECIFIED":
          return BondStatus.BOND_STATUS_UNSPECIFIED;
        case 1:
        case "BOND_STATUS_UNBONDED":
          return BondStatus.BOND_STATUS_UNBONDED;
        case 2:
        case "BOND_STATUS_UNBONDING":
          return BondStatus.BOND_STATUS_UNBONDING;
        case 3:
        case "BOND_STATUS_BONDED":
          return BondStatus.BOND_STATUS_BONDED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BondStatus.UNRECOGNIZED;
      }
    }
    exports2.bondStatusFromJSON = bondStatusFromJSON;
    function bondStatusToJSON(object) {
      switch (object) {
        case BondStatus.BOND_STATUS_UNSPECIFIED:
          return "BOND_STATUS_UNSPECIFIED";
        case BondStatus.BOND_STATUS_UNBONDED:
          return "BOND_STATUS_UNBONDED";
        case BondStatus.BOND_STATUS_UNBONDING:
          return "BOND_STATUS_UNBONDING";
        case BondStatus.BOND_STATUS_BONDED:
          return "BOND_STATUS_BONDED";
        case BondStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.bondStatusToJSON = bondStatusToJSON;
    var Infraction;
    (function(Infraction2) {
      Infraction2[Infraction2["INFRACTION_UNSPECIFIED"] = 0] = "INFRACTION_UNSPECIFIED";
      Infraction2[Infraction2["INFRACTION_DOUBLE_SIGN"] = 1] = "INFRACTION_DOUBLE_SIGN";
      Infraction2[Infraction2["INFRACTION_DOWNTIME"] = 2] = "INFRACTION_DOWNTIME";
      Infraction2[Infraction2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Infraction || (exports2.Infraction = Infraction = {}));
    function infractionFromJSON(object) {
      switch (object) {
        case 0:
        case "INFRACTION_UNSPECIFIED":
          return Infraction.INFRACTION_UNSPECIFIED;
        case 1:
        case "INFRACTION_DOUBLE_SIGN":
          return Infraction.INFRACTION_DOUBLE_SIGN;
        case 2:
        case "INFRACTION_DOWNTIME":
          return Infraction.INFRACTION_DOWNTIME;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Infraction.UNRECOGNIZED;
      }
    }
    exports2.infractionFromJSON = infractionFromJSON;
    function infractionToJSON(object) {
      switch (object) {
        case Infraction.INFRACTION_UNSPECIFIED:
          return "INFRACTION_UNSPECIFIED";
        case Infraction.INFRACTION_DOUBLE_SIGN:
          return "INFRACTION_DOUBLE_SIGN";
        case Infraction.INFRACTION_DOWNTIME:
          return "INFRACTION_DOWNTIME";
        case Infraction.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.infractionToJSON = infractionToJSON;
    function createBaseHistoricalInfo() {
      return {
        header: types_1.Header.fromPartial({}),
        valset: []
      };
    }
    exports2.HistoricalInfo = {
      typeUrl: "/cosmos.staking.v1beta1.HistoricalInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.valset) {
          exports2.Validator.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHistoricalInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.valset.push(exports2.Validator.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHistoricalInfo();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = types_1.Header.fromJSON(object.header);
        if (Array.isArray(object == null ? void 0 : object.valset))
          obj.valset = object.valset.map((e) => exports2.Validator.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        if (message.valset) {
          obj.valset = message.valset.map((e) => e ? exports2.Validator.toJSON(e) : void 0);
        } else {
          obj.valset = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseHistoricalInfo();
        if (object.header !== void 0 && object.header !== null) {
          message.header = types_1.Header.fromPartial(object.header);
        }
        message.valset = ((_a = object.valset) == null ? void 0 : _a.map((e) => exports2.Validator.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseCommissionRates() {
      return {
        rate: "",
        maxRate: "",
        maxChangeRate: ""
      };
    }
    exports2.CommissionRates = {
      typeUrl: "/cosmos.staking.v1beta1.CommissionRates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rate !== "") {
          writer.uint32(10).string(message.rate);
        }
        if (message.maxRate !== "") {
          writer.uint32(18).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
          writer.uint32(26).string(message.maxChangeRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommissionRates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rate = reader.string();
              break;
            case 2:
              message.maxRate = reader.string();
              break;
            case 3:
              message.maxChangeRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommissionRates();
        if ((0, helpers_1.isSet)(object.rate))
          obj.rate = String(object.rate);
        if ((0, helpers_1.isSet)(object.maxRate))
          obj.maxRate = String(object.maxRate);
        if ((0, helpers_1.isSet)(object.maxChangeRate))
          obj.maxChangeRate = String(object.maxChangeRate);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rate !== void 0 && (obj.rate = message.rate);
        message.maxRate !== void 0 && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== void 0 && (obj.maxChangeRate = message.maxChangeRate);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommissionRates();
        message.rate = object.rate ?? "";
        message.maxRate = object.maxRate ?? "";
        message.maxChangeRate = object.maxChangeRate ?? "";
        return message;
      }
    };
    function createBaseCommission() {
      return {
        commissionRates: exports2.CommissionRates.fromPartial({}),
        updateTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.Commission = {
      typeUrl: "/cosmos.staking.v1beta1.Commission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commissionRates !== void 0) {
          exports2.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();
        }
        if (message.updateTime !== void 0) {
          timestamp_1.Timestamp.encode(message.updateTime, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commissionRates = exports2.CommissionRates.decode(reader, reader.uint32());
              break;
            case 2:
              message.updateTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommission();
        if ((0, helpers_1.isSet)(object.commissionRates))
          obj.commissionRates = exports2.CommissionRates.fromJSON(object.commissionRates);
        if ((0, helpers_1.isSet)(object.updateTime))
          obj.updateTime = (0, helpers_1.fromJsonTimestamp)(object.updateTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commissionRates !== void 0 && (obj.commissionRates = message.commissionRates ? exports2.CommissionRates.toJSON(message.commissionRates) : void 0);
        message.updateTime !== void 0 && (obj.updateTime = (0, helpers_1.fromTimestamp)(message.updateTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommission();
        if (object.commissionRates !== void 0 && object.commissionRates !== null) {
          message.commissionRates = exports2.CommissionRates.fromPartial(object.commissionRates);
        }
        if (object.updateTime !== void 0 && object.updateTime !== null) {
          message.updateTime = timestamp_1.Timestamp.fromPartial(object.updateTime);
        }
        return message;
      }
    };
    function createBaseDescription() {
      return {
        moniker: "",
        identity: "",
        website: "",
        securityContact: "",
        details: ""
      };
    }
    exports2.Description = {
      typeUrl: "/cosmos.staking.v1beta1.Description",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.moniker !== "") {
          writer.uint32(10).string(message.moniker);
        }
        if (message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.website !== "") {
          writer.uint32(26).string(message.website);
        }
        if (message.securityContact !== "") {
          writer.uint32(34).string(message.securityContact);
        }
        if (message.details !== "") {
          writer.uint32(42).string(message.details);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDescription();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moniker = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.website = reader.string();
              break;
            case 4:
              message.securityContact = reader.string();
              break;
            case 5:
              message.details = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDescription();
        if ((0, helpers_1.isSet)(object.moniker))
          obj.moniker = String(object.moniker);
        if ((0, helpers_1.isSet)(object.identity))
          obj.identity = String(object.identity);
        if ((0, helpers_1.isSet)(object.website))
          obj.website = String(object.website);
        if ((0, helpers_1.isSet)(object.securityContact))
          obj.securityContact = String(object.securityContact);
        if ((0, helpers_1.isSet)(object.details))
          obj.details = String(object.details);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.moniker !== void 0 && (obj.moniker = message.moniker);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.website !== void 0 && (obj.website = message.website);
        message.securityContact !== void 0 && (obj.securityContact = message.securityContact);
        message.details !== void 0 && (obj.details = message.details);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDescription();
        message.moniker = object.moniker ?? "";
        message.identity = object.identity ?? "";
        message.website = object.website ?? "";
        message.securityContact = object.securityContact ?? "";
        message.details = object.details ?? "";
        return message;
      }
    };
    function createBaseValidator() {
      return {
        operatorAddress: "",
        consensusPubkey: void 0,
        jailed: false,
        status: 0,
        tokens: "",
        delegatorShares: "",
        description: exports2.Description.fromPartial({}),
        unbondingHeight: BigInt(0),
        unbondingTime: timestamp_1.Timestamp.fromPartial({}),
        commission: exports2.Commission.fromPartial({}),
        minSelfDelegation: "",
        unbondingOnHoldRefCount: BigInt(0),
        unbondingIds: []
      };
    }
    exports2.Validator = {
      typeUrl: "/cosmos.staking.v1beta1.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== void 0) {
          any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();
        }
        if (message.jailed === true) {
          writer.uint32(24).bool(message.jailed);
        }
        if (message.status !== 0) {
          writer.uint32(32).int32(message.status);
        }
        if (message.tokens !== "") {
          writer.uint32(42).string(message.tokens);
        }
        if (message.delegatorShares !== "") {
          writer.uint32(50).string(message.delegatorShares);
        }
        if (message.description !== void 0) {
          exports2.Description.encode(message.description, writer.uint32(58).fork()).ldelim();
        }
        if (message.unbondingHeight !== BigInt(0)) {
          writer.uint32(64).int64(message.unbondingHeight);
        }
        if (message.unbondingTime !== void 0) {
          timestamp_1.Timestamp.encode(message.unbondingTime, writer.uint32(74).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          exports2.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(90).string(message.minSelfDelegation);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(96).int64(message.unbondingOnHoldRefCount);
        }
        writer.uint32(106).fork();
        for (const v of message.unbondingIds) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.jailed = reader.bool();
              break;
            case 4:
              message.status = reader.int32();
              break;
            case 5:
              message.tokens = reader.string();
              break;
            case 6:
              message.delegatorShares = reader.string();
              break;
            case 7:
              message.description = exports2.Description.decode(reader, reader.uint32());
              break;
            case 8:
              message.unbondingHeight = reader.int64();
              break;
            case 9:
              message.unbondingTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.commission = exports2.Commission.decode(reader, reader.uint32());
              break;
            case 11:
              message.minSelfDelegation = reader.string();
              break;
            case 12:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            case 13:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.unbondingIds.push(reader.uint64());
                }
              } else {
                message.unbondingIds.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.operatorAddress))
          obj.operatorAddress = String(object.operatorAddress);
        if ((0, helpers_1.isSet)(object.consensusPubkey))
          obj.consensusPubkey = any_1.Any.fromJSON(object.consensusPubkey);
        if ((0, helpers_1.isSet)(object.jailed))
          obj.jailed = Boolean(object.jailed);
        if ((0, helpers_1.isSet)(object.status))
          obj.status = bondStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.tokens))
          obj.tokens = String(object.tokens);
        if ((0, helpers_1.isSet)(object.delegatorShares))
          obj.delegatorShares = String(object.delegatorShares);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = exports2.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.unbondingHeight))
          obj.unbondingHeight = BigInt(object.unbondingHeight.toString());
        if ((0, helpers_1.isSet)(object.unbondingTime))
          obj.unbondingTime = (0, helpers_1.fromJsonTimestamp)(object.unbondingTime);
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = exports2.Commission.fromJSON(object.commission);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        if (Array.isArray(object == null ? void 0 : object.unbondingIds))
          obj.unbondingIds = object.unbondingIds.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        message.consensusPubkey !== void 0 && (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : void 0);
        message.jailed !== void 0 && (obj.jailed = message.jailed);
        message.status !== void 0 && (obj.status = bondStatusToJSON(message.status));
        message.tokens !== void 0 && (obj.tokens = message.tokens);
        message.delegatorShares !== void 0 && (obj.delegatorShares = message.delegatorShares);
        message.description !== void 0 && (obj.description = message.description ? exports2.Description.toJSON(message.description) : void 0);
        message.unbondingHeight !== void 0 && (obj.unbondingHeight = (message.unbondingHeight || BigInt(0)).toString());
        message.unbondingTime !== void 0 && (obj.unbondingTime = (0, helpers_1.fromTimestamp)(message.unbondingTime).toISOString());
        message.commission !== void 0 && (obj.commission = message.commission ? exports2.Commission.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        if (message.unbondingIds) {
          obj.unbondingIds = message.unbondingIds.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.unbondingIds = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidator();
        message.operatorAddress = object.operatorAddress ?? "";
        if (object.consensusPubkey !== void 0 && object.consensusPubkey !== null) {
          message.consensusPubkey = any_1.Any.fromPartial(object.consensusPubkey);
        }
        message.jailed = object.jailed ?? false;
        message.status = object.status ?? 0;
        message.tokens = object.tokens ?? "";
        message.delegatorShares = object.delegatorShares ?? "";
        if (object.description !== void 0 && object.description !== null) {
          message.description = exports2.Description.fromPartial(object.description);
        }
        if (object.unbondingHeight !== void 0 && object.unbondingHeight !== null) {
          message.unbondingHeight = BigInt(object.unbondingHeight.toString());
        }
        if (object.unbondingTime !== void 0 && object.unbondingTime !== null) {
          message.unbondingTime = timestamp_1.Timestamp.fromPartial(object.unbondingTime);
        }
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = exports2.Commission.fromPartial(object.commission);
        }
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        message.unbondingIds = ((_a = object.unbondingIds) == null ? void 0 : _a.map((e) => BigInt(e.toString()))) || [];
        return message;
      }
    };
    function createBaseValAddresses() {
      return {
        addresses: []
      };
    }
    exports2.ValAddresses = {
      typeUrl: "/cosmos.staking.v1beta1.ValAddresses",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.addresses) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValAddresses();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValAddresses();
        if (Array.isArray(object == null ? void 0 : object.addresses))
          obj.addresses = object.addresses.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValAddresses();
        message.addresses = ((_a = object.addresses) == null ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    function createBaseDVPair() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports2.DVPair = {
      typeUrl: "/cosmos.staking.v1beta1.DVPair",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPair();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVPair();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVPair();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseDVPairs() {
      return {
        pairs: []
      };
    }
    exports2.DVPairs = {
      typeUrl: "/cosmos.staking.v1beta1.DVPairs",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.pairs) {
          exports2.DVPair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPairs();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pairs.push(exports2.DVPair.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVPairs();
        if (Array.isArray(object == null ? void 0 : object.pairs))
          obj.pairs = object.pairs.map((e) => exports2.DVPair.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pairs) {
          obj.pairs = message.pairs.map((e) => e ? exports2.DVPair.toJSON(e) : void 0);
        } else {
          obj.pairs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDVPairs();
        message.pairs = ((_a = object.pairs) == null ? void 0 : _a.map((e) => exports2.DVPair.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDVVTriplet() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: ""
      };
    }
    exports2.DVVTriplet = {
      typeUrl: "/cosmos.staking.v1beta1.DVVTriplet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVVTriplet();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVVTriplet();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        return message;
      }
    };
    function createBaseDVVTriplets() {
      return {
        triplets: []
      };
    }
    exports2.DVVTriplets = {
      typeUrl: "/cosmos.staking.v1beta1.DVVTriplets",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.triplets) {
          exports2.DVVTriplet.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplets();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.triplets.push(exports2.DVVTriplet.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVVTriplets();
        if (Array.isArray(object == null ? void 0 : object.triplets))
          obj.triplets = object.triplets.map((e) => exports2.DVVTriplet.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.triplets) {
          obj.triplets = message.triplets.map((e) => e ? exports2.DVVTriplet.toJSON(e) : void 0);
        } else {
          obj.triplets = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseDVVTriplets();
        message.triplets = ((_a = object.triplets) == null ? void 0 : _a.map((e) => exports2.DVVTriplet.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseDelegation() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        shares: ""
      };
    }
    exports2.Delegation = {
      typeUrl: "/cosmos.staking.v1beta1.Delegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.shares !== "") {
          writer.uint32(26).string(message.shares);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.shares = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.shares))
          obj.shares = String(object.shares);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.shares !== void 0 && (obj.shares = message.shares);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.shares = object.shares ?? "";
        return message;
      }
    };
    function createBaseUnbondingDelegation() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        entries: []
      };
    }
    exports2.UnbondingDelegation = {
      typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v of message.entries) {
          exports2.UnbondingDelegationEntry.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.entries.push(exports2.UnbondingDelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUnbondingDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object == null ? void 0 : object.entries))
          obj.entries = object.entries.map((e) => exports2.UnbondingDelegationEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.UnbondingDelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseUnbondingDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.entries = ((_a = object.entries) == null ? void 0 : _a.map((e) => exports2.UnbondingDelegationEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseUnbondingDelegationEntry() {
      return {
        creationHeight: BigInt(0),
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        initialBalance: "",
        balance: "",
        unbondingId: BigInt(0),
        unbondingOnHoldRefCount: BigInt(0)
      };
    }
    exports2.UnbondingDelegationEntry = {
      typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegationEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        if (message.unbondingId !== BigInt(0)) {
          writer.uint32(40).uint64(message.unbondingId);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(48).int64(message.unbondingOnHoldRefCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.balance = reader.string();
              break;
            case 5:
              message.unbondingId = reader.uint64();
              break;
            case 6:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUnbondingDelegationEntry();
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.initialBalance))
          obj.initialBalance = String(object.initialBalance);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = String(object.balance);
        if ((0, helpers_1.isSet)(object.unbondingId))
          obj.unbondingId = BigInt(object.unbondingId.toString());
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.balance !== void 0 && (obj.balance = message.balance);
        message.unbondingId !== void 0 && (obj.unbondingId = (message.unbondingId || BigInt(0)).toString());
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUnbondingDelegationEntry();
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        message.initialBalance = object.initialBalance ?? "";
        message.balance = object.balance ?? "";
        if (object.unbondingId !== void 0 && object.unbondingId !== null) {
          message.unbondingId = BigInt(object.unbondingId.toString());
        }
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        return message;
      }
    };
    function createBaseRedelegationEntry() {
      return {
        creationHeight: BigInt(0),
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        initialBalance: "",
        sharesDst: "",
        unbondingId: BigInt(0),
        unbondingOnHoldRefCount: BigInt(0)
      };
    }
    exports2.RedelegationEntry = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.sharesDst !== "") {
          writer.uint32(34).string(message.sharesDst);
        }
        if (message.unbondingId !== BigInt(0)) {
          writer.uint32(40).uint64(message.unbondingId);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(48).int64(message.unbondingOnHoldRefCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.sharesDst = reader.string();
              break;
            case 5:
              message.unbondingId = reader.uint64();
              break;
            case 6:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationEntry();
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.initialBalance))
          obj.initialBalance = String(object.initialBalance);
        if ((0, helpers_1.isSet)(object.sharesDst))
          obj.sharesDst = String(object.sharesDst);
        if ((0, helpers_1.isSet)(object.unbondingId))
          obj.unbondingId = BigInt(object.unbondingId.toString());
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.sharesDst !== void 0 && (obj.sharesDst = message.sharesDst);
        message.unbondingId !== void 0 && (obj.unbondingId = (message.unbondingId || BigInt(0)).toString());
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegationEntry();
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        message.initialBalance = object.initialBalance ?? "";
        message.sharesDst = object.sharesDst ?? "";
        if (object.unbondingId !== void 0 && object.unbondingId !== null) {
          message.unbondingId = BigInt(object.unbondingId.toString());
        }
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        return message;
      }
    };
    function createBaseRedelegation() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        entries: []
      };
    }
    exports2.Redelegation = {
      typeUrl: "/cosmos.staking.v1beta1.Redelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        for (const v of message.entries) {
          exports2.RedelegationEntry.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.entries.push(exports2.RedelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        if (Array.isArray(object == null ? void 0 : object.entries))
          obj.entries = object.entries.map((e) => exports2.RedelegationEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.RedelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseRedelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        message.entries = ((_a = object.entries) == null ? void 0 : _a.map((e) => exports2.RedelegationEntry.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        unbondingTime: duration_1.Duration.fromPartial({}),
        maxValidators: 0,
        maxEntries: 0,
        historicalEntries: 0,
        bondDenom: "",
        minCommissionRate: ""
      };
    }
    exports2.Params = {
      typeUrl: "/cosmos.staking.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.unbondingTime !== void 0) {
          duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxValidators !== 0) {
          writer.uint32(16).uint32(message.maxValidators);
        }
        if (message.maxEntries !== 0) {
          writer.uint32(24).uint32(message.maxEntries);
        }
        if (message.historicalEntries !== 0) {
          writer.uint32(32).uint32(message.historicalEntries);
        }
        if (message.bondDenom !== "") {
          writer.uint32(42).string(message.bondDenom);
        }
        if (message.minCommissionRate !== "") {
          writer.uint32(50).string(message.minCommissionRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.maxValidators = reader.uint32();
              break;
            case 3:
              message.maxEntries = reader.uint32();
              break;
            case 4:
              message.historicalEntries = reader.uint32();
              break;
            case 5:
              message.bondDenom = reader.string();
              break;
            case 6:
              message.minCommissionRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.unbondingTime))
          obj.unbondingTime = duration_1.Duration.fromJSON(object.unbondingTime);
        if ((0, helpers_1.isSet)(object.maxValidators))
          obj.maxValidators = Number(object.maxValidators);
        if ((0, helpers_1.isSet)(object.maxEntries))
          obj.maxEntries = Number(object.maxEntries);
        if ((0, helpers_1.isSet)(object.historicalEntries))
          obj.historicalEntries = Number(object.historicalEntries);
        if ((0, helpers_1.isSet)(object.bondDenom))
          obj.bondDenom = String(object.bondDenom);
        if ((0, helpers_1.isSet)(object.minCommissionRate))
          obj.minCommissionRate = String(object.minCommissionRate);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.unbondingTime !== void 0 && (obj.unbondingTime = message.unbondingTime ? duration_1.Duration.toJSON(message.unbondingTime) : void 0);
        message.maxValidators !== void 0 && (obj.maxValidators = Math.round(message.maxValidators));
        message.maxEntries !== void 0 && (obj.maxEntries = Math.round(message.maxEntries));
        message.historicalEntries !== void 0 && (obj.historicalEntries = Math.round(message.historicalEntries));
        message.bondDenom !== void 0 && (obj.bondDenom = message.bondDenom);
        message.minCommissionRate !== void 0 && (obj.minCommissionRate = message.minCommissionRate);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.unbondingTime !== void 0 && object.unbondingTime !== null) {
          message.unbondingTime = duration_1.Duration.fromPartial(object.unbondingTime);
        }
        message.maxValidators = object.maxValidators ?? 0;
        message.maxEntries = object.maxEntries ?? 0;
        message.historicalEntries = object.historicalEntries ?? 0;
        message.bondDenom = object.bondDenom ?? "";
        message.minCommissionRate = object.minCommissionRate ?? "";
        return message;
      }
    };
    function createBaseDelegationResponse() {
      return {
        delegation: exports2.Delegation.fromPartial({}),
        balance: coin_1.Coin.fromPartial({})
      };
    }
    exports2.DelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.DelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegation !== void 0) {
          exports2.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegation = exports2.Delegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegationResponse();
        if ((0, helpers_1.isSet)(object.delegation))
          obj.delegation = exports2.Delegation.fromJSON(object.delegation);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegation !== void 0 && (obj.delegation = message.delegation ? exports2.Delegation.toJSON(message.delegation) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegationResponse();
        if (object.delegation !== void 0 && object.delegation !== null) {
          message.delegation = exports2.Delegation.fromPartial(object.delegation);
        }
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseRedelegationEntryResponse() {
      return {
        redelegationEntry: exports2.RedelegationEntry.fromPartial({}),
        balance: ""
      };
    }
    exports2.RedelegationEntryResponse = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationEntryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.redelegationEntry !== void 0) {
          exports2.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationEntry = exports2.RedelegationEntry.decode(reader, reader.uint32());
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationEntryResponse();
        if ((0, helpers_1.isSet)(object.redelegationEntry))
          obj.redelegationEntry = exports2.RedelegationEntry.fromJSON(object.redelegationEntry);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = String(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.redelegationEntry !== void 0 && (obj.redelegationEntry = message.redelegationEntry ? exports2.RedelegationEntry.toJSON(message.redelegationEntry) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegationEntryResponse();
        if (object.redelegationEntry !== void 0 && object.redelegationEntry !== null) {
          message.redelegationEntry = exports2.RedelegationEntry.fromPartial(object.redelegationEntry);
        }
        message.balance = object.balance ?? "";
        return message;
      }
    };
    function createBaseRedelegationResponse() {
      return {
        redelegation: exports2.Redelegation.fromPartial({}),
        entries: []
      };
    }
    exports2.RedelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.redelegation !== void 0) {
          exports2.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.entries) {
          exports2.RedelegationEntryResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegation = exports2.Redelegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.entries.push(exports2.RedelegationEntryResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationResponse();
        if ((0, helpers_1.isSet)(object.redelegation))
          obj.redelegation = exports2.Redelegation.fromJSON(object.redelegation);
        if (Array.isArray(object == null ? void 0 : object.entries))
          obj.entries = object.entries.map((e) => exports2.RedelegationEntryResponse.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.redelegation !== void 0 && (obj.redelegation = message.redelegation ? exports2.Redelegation.toJSON(message.redelegation) : void 0);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports2.RedelegationEntryResponse.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseRedelegationResponse();
        if (object.redelegation !== void 0 && object.redelegation !== null) {
          message.redelegation = exports2.Redelegation.fromPartial(object.redelegation);
        }
        message.entries = ((_a = object.entries) == null ? void 0 : _a.map((e) => exports2.RedelegationEntryResponse.fromPartial(e))) || [];
        return message;
      }
    };
    function createBasePool() {
      return {
        notBondedTokens: "",
        bondedTokens: ""
      };
    }
    exports2.Pool = {
      typeUrl: "/cosmos.staking.v1beta1.Pool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.notBondedTokens !== "") {
          writer.uint32(10).string(message.notBondedTokens);
        }
        if (message.bondedTokens !== "") {
          writer.uint32(18).string(message.bondedTokens);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.notBondedTokens = reader.string();
              break;
            case 2:
              message.bondedTokens = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePool();
        if ((0, helpers_1.isSet)(object.notBondedTokens))
          obj.notBondedTokens = String(object.notBondedTokens);
        if ((0, helpers_1.isSet)(object.bondedTokens))
          obj.bondedTokens = String(object.bondedTokens);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.notBondedTokens !== void 0 && (obj.notBondedTokens = message.notBondedTokens);
        message.bondedTokens !== void 0 && (obj.bondedTokens = message.bondedTokens);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePool();
        message.notBondedTokens = object.notBondedTokens ?? "";
        message.bondedTokens = object.bondedTokens ?? "";
        return message;
      }
    };
    function createBaseValidatorUpdates() {
      return {
        updates: []
      };
    }
    exports2.ValidatorUpdates = {
      typeUrl: "/cosmos.staking.v1beta1.ValidatorUpdates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.updates) {
          types_2.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.updates.push(types_2.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorUpdates();
        if (Array.isArray(object == null ? void 0 : object.updates))
          obj.updates = object.updates.map((e) => types_2.ValidatorUpdate.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.updates) {
          obj.updates = message.updates.map((e) => e ? types_2.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.updates = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseValidatorUpdates();
        message.updates = ((_a = object.updates) == null ? void 0 : _a.map((e) => types_2.ValidatorUpdate.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js
var require_tx13 = __commonJS({
  "node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgUpdateParamsResponse = exports2.MsgUpdateParams = exports2.MsgCancelUnbondingDelegationResponse = exports2.MsgCancelUnbondingDelegation = exports2.MsgUndelegateResponse = exports2.MsgUndelegate = exports2.MsgBeginRedelegateResponse = exports2.MsgBeginRedelegate = exports2.MsgDelegateResponse = exports2.MsgDelegate = exports2.MsgEditValidatorResponse = exports2.MsgEditValidator = exports2.MsgCreateValidatorResponse = exports2.MsgCreateValidator = exports2.protobufPackage = void 0;
    var staking_1 = require_staking();
    var any_1 = require_any();
    var coin_1 = require_coin();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseMsgCreateValidator() {
      return {
        description: staking_1.Description.fromPartial({}),
        commission: staking_1.CommissionRates.fromPartial({}),
        minSelfDelegation: "",
        delegatorAddress: "",
        validatorAddress: "",
        pubkey: void 0,
        value: coin_1.Coin.fromPartial({})
      };
    }
    exports2.MsgCreateValidator = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(26).string(message.minSelfDelegation);
        }
        if (message.delegatorAddress !== "") {
          writer.uint32(34).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(42).string(message.validatorAddress);
        }
        if (message.pubkey !== void 0) {
          any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();
        }
        if (message.value !== void 0) {
          coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());
              break;
            case 3:
              message.minSelfDelegation = reader.string();
              break;
            case 4:
              message.delegatorAddress = reader.string();
              break;
            case 5:
              message.validatorAddress = reader.string();
              break;
            case 6:
              message.pubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.value = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateValidator();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = staking_1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = staking_1.CommissionRates.fromJSON(object.commission);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.pubkey))
          obj.pubkey = any_1.Any.fromJSON(object.pubkey);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = coin_1.Coin.fromJSON(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.commission !== void 0 && (obj.commission = message.commission ? staking_1.CommissionRates.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.pubkey !== void 0 && (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : void 0);
        message.value !== void 0 && (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateValidator();
        if (object.description !== void 0 && object.description !== null) {
          message.description = staking_1.Description.fromPartial(object.description);
        }
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = staking_1.CommissionRates.fromPartial(object.commission);
        }
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.pubkey !== void 0 && object.pubkey !== null) {
          message.pubkey = any_1.Any.fromPartial(object.pubkey);
        }
        if (object.value !== void 0 && object.value !== null) {
          message.value = coin_1.Coin.fromPartial(object.value);
        }
        return message;
      }
    };
    function createBaseMsgCreateValidatorResponse() {
      return {};
    }
    exports2.MsgCreateValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidatorResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreateValidatorResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateValidatorResponse();
        return message;
      }
    };
    function createBaseMsgEditValidator() {
      return {
        description: staking_1.Description.fromPartial({}),
        validatorAddress: "",
        commissionRate: "",
        minSelfDelegation: ""
      };
    }
    exports2.MsgEditValidator = {
      typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.commissionRate !== "") {
          writer.uint32(26).string(message.commissionRate);
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(34).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.commissionRate = reader.string();
              break;
            case 4:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgEditValidator();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = staking_1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.commissionRate))
          obj.commissionRate = String(object.commissionRate);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.commissionRate !== void 0 && (obj.commissionRate = message.commissionRate);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgEditValidator();
        if (object.description !== void 0 && object.description !== null) {
          message.description = staking_1.Description.fromPartial(object.description);
        }
        message.validatorAddress = object.validatorAddress ?? "";
        message.commissionRate = object.commissionRate ?? "";
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        return message;
      }
    };
    function createBaseMsgEditValidatorResponse() {
      return {};
    }
    exports2.MsgEditValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgEditValidatorResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgEditValidatorResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgEditValidatorResponse();
        return message;
      }
    };
    function createBaseMsgDelegate() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports2.MsgDelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgDelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgDelegateResponse() {
      return {};
    }
    exports2.MsgDelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgDelegateResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgDelegateResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgDelegateResponse();
        return message;
      }
    };
    function createBaseMsgBeginRedelegate() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports2.MsgBeginRedelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgBeginRedelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgBeginRedelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgBeginRedelegateResponse() {
      return {
        completionTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.MsgBeginRedelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgBeginRedelegateResponse();
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgBeginRedelegateResponse();
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        return message;
      }
    };
    function createBaseMsgUndelegate() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports2.MsgUndelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUndelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUndelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgUndelegateResponse() {
      return {
        completionTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.MsgUndelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUndelegateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUndelegateResponse();
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUndelegateResponse();
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        return message;
      }
    };
    function createBaseMsgCancelUnbondingDelegation() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({}),
        creationHeight: BigInt(0)
      };
    }
    exports2.MsgCancelUnbondingDelegation = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(32).int64(message.creationHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.creationHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCancelUnbondingDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCancelUnbondingDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        return message;
      }
    };
    function createBaseMsgCancelUnbondingDelegationResponse() {
      return {};
    }
    exports2.MsgCancelUnbondingDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegationResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCancelUnbondingDelegationResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCancelUnbondingDelegationResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: staking_1.Params.fromPartial({})
      };
    }
    exports2.MsgUpdateParams = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          staking_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = staking_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = staking_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = staking_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports2.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParamsResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateValidator = this.CreateValidator.bind(this);
        this.EditValidator = this.EditValidator.bind(this);
        this.Delegate = this.Delegate.bind(this);
        this.BeginRedelegate = this.BeginRedelegate.bind(this);
        this.Undelegate = this.Undelegate.bind(this);
        this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
      }
      CreateValidator(request) {
        const data = exports2.MsgCreateValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", data);
        return promise.then((data2) => exports2.MsgCreateValidatorResponse.decode(new binary_1.BinaryReader(data2)));
      }
      EditValidator(request) {
        const data = exports2.MsgEditValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", data);
        return promise.then((data2) => exports2.MsgEditValidatorResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Delegate(request) {
        const data = exports2.MsgDelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", data);
        return promise.then((data2) => exports2.MsgDelegateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      BeginRedelegate(request) {
        const data = exports2.MsgBeginRedelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", data);
        return promise.then((data2) => exports2.MsgBeginRedelegateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Undelegate(request) {
        const data = exports2.MsgUndelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", data);
        return promise.then((data2) => exports2.MsgUndelegateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      CancelUnbondingDelegation(request) {
        const data = exports2.MsgCancelUnbondingDelegation.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", data);
        return promise.then((data2) => exports2.MsgCancelUnbondingDelegationResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UpdateParams(request) {
        const data = exports2.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", data);
        return promise.then((data2) => exports2.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/staking/messages.js
var require_messages8 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/staking/messages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgCancelUnbondingDelegationEncodeObject = exports2.isMsgUndelegateEncodeObject = exports2.isMsgEditValidatorEncodeObject = exports2.isMsgDelegateEncodeObject = exports2.isMsgCreateValidatorEncodeObject = exports2.isMsgBeginRedelegateEncodeObject = exports2.stakingTypes = void 0;
    var tx_1 = require_tx13();
    exports2.stakingTypes = [
      ["/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_1.MsgBeginRedelegate],
      ["/cosmos.staking.v1beta1.MsgCreateValidator", tx_1.MsgCreateValidator],
      ["/cosmos.staking.v1beta1.MsgDelegate", tx_1.MsgDelegate],
      ["/cosmos.staking.v1beta1.MsgEditValidator", tx_1.MsgEditValidator],
      ["/cosmos.staking.v1beta1.MsgUndelegate", tx_1.MsgUndelegate],
      ["/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation", tx_1.MsgCancelUnbondingDelegation]
    ];
    function isMsgBeginRedelegateEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
    }
    exports2.isMsgBeginRedelegateEncodeObject = isMsgBeginRedelegateEncodeObject;
    function isMsgCreateValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
    }
    exports2.isMsgCreateValidatorEncodeObject = isMsgCreateValidatorEncodeObject;
    function isMsgDelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
    }
    exports2.isMsgDelegateEncodeObject = isMsgDelegateEncodeObject;
    function isMsgEditValidatorEncodeObject(o) {
      return o.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
    }
    exports2.isMsgEditValidatorEncodeObject = isMsgEditValidatorEncodeObject;
    function isMsgUndelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
    }
    exports2.isMsgUndelegateEncodeObject = isMsgUndelegateEncodeObject;
    function isMsgCancelUnbondingDelegationEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation";
    }
    exports2.isMsgCancelUnbondingDelegationEncodeObject = isMsgCancelUnbondingDelegationEncodeObject;
  }
});

// node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js
var require_query13 = __commonJS({
  "node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryClientImpl = exports2.QueryParamsResponse = exports2.QueryParamsRequest = exports2.QueryPoolResponse = exports2.QueryPoolRequest = exports2.QueryHistoricalInfoResponse = exports2.QueryHistoricalInfoRequest = exports2.QueryDelegatorValidatorResponse = exports2.QueryDelegatorValidatorRequest = exports2.QueryDelegatorValidatorsResponse = exports2.QueryDelegatorValidatorsRequest = exports2.QueryRedelegationsResponse = exports2.QueryRedelegationsRequest = exports2.QueryDelegatorUnbondingDelegationsResponse = exports2.QueryDelegatorUnbondingDelegationsRequest = exports2.QueryDelegatorDelegationsResponse = exports2.QueryDelegatorDelegationsRequest = exports2.QueryUnbondingDelegationResponse = exports2.QueryUnbondingDelegationRequest = exports2.QueryDelegationResponse = exports2.QueryDelegationRequest = exports2.QueryValidatorUnbondingDelegationsResponse = exports2.QueryValidatorUnbondingDelegationsRequest = exports2.QueryValidatorDelegationsResponse = exports2.QueryValidatorDelegationsRequest = exports2.QueryValidatorResponse = exports2.QueryValidatorRequest = exports2.QueryValidatorsResponse = exports2.QueryValidatorsRequest = exports2.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var staking_1 = require_staking();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseQueryValidatorsRequest() {
      return {
        status: "",
        pagination: void 0
      };
    }
    exports2.QueryValidatorsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorsRequest();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = String(object.status);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorsRequest();
        message.status = object.status ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorsResponse() {
      return {
        validators: [],
        pagination: void 0
      };
    }
    exports2.QueryValidatorsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorsResponse();
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => staking_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorsResponse();
        message.validators = ((_a = object.validators) == null ? void 0 : _a.map((e) => staking_1.Validator.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorRequest() {
      return {
        validatorAddr: ""
      };
    }
    exports2.QueryValidatorRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorResponse() {
      return {
        validator: staking_1.Validator.fromPartial({})
      };
    }
    exports2.QueryValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorResponse();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = staking_1.Validator.fromJSON(object.validator);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorResponse();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = staking_1.Validator.fromPartial(object.validator);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDelegationsRequest() {
      return {
        validatorAddr: "",
        pagination: void 0
      };
    }
    exports2.QueryValidatorDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDelegationsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDelegationsRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDelegationsResponse() {
      return {
        delegationResponses: [],
        pagination: void 0
      };
    }
    exports2.QueryValidatorDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDelegationsResponse();
        if (Array.isArray(object == null ? void 0 : object.delegationResponses))
          obj.delegationResponses = object.delegationResponses.map((e) => staking_1.DelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorDelegationsResponse();
        message.delegationResponses = ((_a = object.delegationResponses) == null ? void 0 : _a.map((e) => staking_1.DelegationResponse.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorUnbondingDelegationsRequest() {
      return {
        validatorAddr: "",
        pagination: void 0
      };
    }
    exports2.QueryValidatorUnbondingDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorUnbondingDelegationsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorUnbondingDelegationsResponse() {
      return {
        unbondingResponses: [],
        pagination: void 0
      };
    }
    exports2.QueryValidatorUnbondingDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorUnbondingDelegationsResponse();
        if (Array.isArray(object == null ? void 0 : object.unbondingResponses))
          obj.unbondingResponses = object.unbondingResponses.map((e) => staking_1.UnbondingDelegation.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        message.unbondingResponses = ((_a = object.unbondingResponses) == null ? void 0 : _a.map((e) => staking_1.UnbondingDelegation.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegationRequest() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports2.QueryDelegationRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegationRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationResponse() {
      return {
        delegationResponse: void 0
      };
    }
    exports2.QueryDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegationResponse !== void 0) {
          staking_1.DelegationResponse.encode(message.delegationResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponse = staking_1.DelegationResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationResponse();
        if ((0, helpers_1.isSet)(object.delegationResponse))
          obj.delegationResponse = staking_1.DelegationResponse.fromJSON(object.delegationResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegationResponse !== void 0 && (obj.delegationResponse = message.delegationResponse ? staking_1.DelegationResponse.toJSON(message.delegationResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationResponse();
        if (object.delegationResponse !== void 0 && object.delegationResponse !== null) {
          message.delegationResponse = staking_1.DelegationResponse.fromPartial(object.delegationResponse);
        }
        return message;
      }
    };
    function createBaseQueryUnbondingDelegationRequest() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports2.QueryUnbondingDelegationRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnbondingDelegationRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryUnbondingDelegationResponse() {
      return {
        unbond: staking_1.UnbondingDelegation.fromPartial({})
      };
    }
    exports2.QueryUnbondingDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.unbond !== void 0) {
          staking_1.UnbondingDelegation.encode(message.unbond, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbond = staking_1.UnbondingDelegation.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnbondingDelegationResponse();
        if ((0, helpers_1.isSet)(object.unbond))
          obj.unbond = staking_1.UnbondingDelegation.fromJSON(object.unbond);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.unbond !== void 0 && (obj.unbond = message.unbond ? staking_1.UnbondingDelegation.toJSON(message.unbond) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationResponse();
        if (object.unbond !== void 0 && object.unbond !== null) {
          message.unbond = staking_1.UnbondingDelegation.fromPartial(object.unbond);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorDelegationsRequest() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports2.QueryDelegatorDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorDelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorDelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorDelegationsResponse() {
      return {
        delegationResponses: [],
        pagination: void 0
      };
    }
    exports2.QueryDelegatorDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorDelegationsResponse();
        if (Array.isArray(object == null ? void 0 : object.delegationResponses))
          obj.delegationResponses = object.delegationResponses.map((e) => staking_1.DelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorDelegationsResponse();
        message.delegationResponses = ((_a = object.delegationResponses) == null ? void 0 : _a.map((e) => staking_1.DelegationResponse.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorUnbondingDelegationsRequest() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports2.QueryDelegatorUnbondingDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorUnbondingDelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorUnbondingDelegationsResponse() {
      return {
        unbondingResponses: [],
        pagination: void 0
      };
    }
    exports2.QueryDelegatorUnbondingDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorUnbondingDelegationsResponse();
        if (Array.isArray(object == null ? void 0 : object.unbondingResponses))
          obj.unbondingResponses = object.unbondingResponses.map((e) => staking_1.UnbondingDelegation.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        message.unbondingResponses = ((_a = object.unbondingResponses) == null ? void 0 : _a.map((e) => staking_1.UnbondingDelegation.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryRedelegationsRequest() {
      return {
        delegatorAddr: "",
        srcValidatorAddr: "",
        dstValidatorAddr: "",
        pagination: void 0
      };
    }
    exports2.QueryRedelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.srcValidatorAddr !== "") {
          writer.uint32(18).string(message.srcValidatorAddr);
        }
        if (message.dstValidatorAddr !== "") {
          writer.uint32(26).string(message.dstValidatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.srcValidatorAddr = reader.string();
              break;
            case 3:
              message.dstValidatorAddr = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryRedelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.srcValidatorAddr))
          obj.srcValidatorAddr = String(object.srcValidatorAddr);
        if ((0, helpers_1.isSet)(object.dstValidatorAddr))
          obj.dstValidatorAddr = String(object.dstValidatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.srcValidatorAddr !== void 0 && (obj.srcValidatorAddr = message.srcValidatorAddr);
        message.dstValidatorAddr !== void 0 && (obj.dstValidatorAddr = message.dstValidatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryRedelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.srcValidatorAddr = object.srcValidatorAddr ?? "";
        message.dstValidatorAddr = object.dstValidatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryRedelegationsResponse() {
      return {
        redelegationResponses: [],
        pagination: void 0
      };
    }
    exports2.QueryRedelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.redelegationResponses) {
          staking_1.RedelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationResponses.push(staking_1.RedelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryRedelegationsResponse();
        if (Array.isArray(object == null ? void 0 : object.redelegationResponses))
          obj.redelegationResponses = object.redelegationResponses.map((e) => staking_1.RedelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.redelegationResponses) {
          obj.redelegationResponses = message.redelegationResponses.map((e) => e ? staking_1.RedelegationResponse.toJSON(e) : void 0);
        } else {
          obj.redelegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryRedelegationsResponse();
        message.redelegationResponses = ((_a = object.redelegationResponses) == null ? void 0 : _a.map((e) => staking_1.RedelegationResponse.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsRequest() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports2.QueryDelegatorValidatorsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsResponse() {
      return {
        validators: [],
        pagination: void 0
      };
    }
    exports2.QueryDelegatorValidatorsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.validators) {
          staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsResponse();
        if (Array.isArray(object == null ? void 0 : object.validators))
          obj.validators = object.validators.map((e) => staking_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = ((_a = object.validators) == null ? void 0 : _a.map((e) => staking_1.Validator.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorRequest() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports2.QueryDelegatorValidatorRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorResponse() {
      return {
        validator: staking_1.Validator.fromPartial({})
      };
    }
    exports2.QueryDelegatorValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorResponse();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = staking_1.Validator.fromJSON(object.validator);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorResponse();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = staking_1.Validator.fromPartial(object.validator);
        }
        return message;
      }
    };
    function createBaseQueryHistoricalInfoRequest() {
      return {
        height: BigInt(0)
      };
    }
    exports2.QueryHistoricalInfoRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryHistoricalInfoRequest();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryHistoricalInfoRequest();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        return message;
      }
    };
    function createBaseQueryHistoricalInfoResponse() {
      return {
        hist: void 0
      };
    }
    exports2.QueryHistoricalInfoResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hist !== void 0) {
          staking_1.HistoricalInfo.encode(message.hist, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hist = staking_1.HistoricalInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryHistoricalInfoResponse();
        if ((0, helpers_1.isSet)(object.hist))
          obj.hist = staking_1.HistoricalInfo.fromJSON(object.hist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hist !== void 0 && (obj.hist = message.hist ? staking_1.HistoricalInfo.toJSON(message.hist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryHistoricalInfoResponse();
        if (object.hist !== void 0 && object.hist !== null) {
          message.hist = staking_1.HistoricalInfo.fromPartial(object.hist);
        }
        return message;
      }
    };
    function createBaseQueryPoolRequest() {
      return {};
    }
    exports2.QueryPoolRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryPoolRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryPoolRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryPoolRequest();
        return message;
      }
    };
    function createBaseQueryPoolResponse() {
      return {
        pool: staking_1.Pool.fromPartial({})
      };
    }
    exports2.QueryPoolResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryPoolResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pool !== void 0) {
          staking_1.Pool.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool = staking_1.Pool.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPoolResponse();
        if ((0, helpers_1.isSet)(object.pool))
          obj.pool = staking_1.Pool.fromJSON(object.pool);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pool !== void 0 && (obj.pool = message.pool ? staking_1.Pool.toJSON(message.pool) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPoolResponse();
        if (object.pool !== void 0 && object.pool !== null) {
          message.pool = staking_1.Pool.fromPartial(object.pool);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports2.QueryParamsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryParamsRequest",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: staking_1.Params.fromPartial({})
      };
    }
    exports2.QueryParamsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          staking_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = staking_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = staking_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = staking_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Validators = this.Validators.bind(this);
        this.Validator = this.Validator.bind(this);
        this.ValidatorDelegations = this.ValidatorDelegations.bind(this);
        this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this);
        this.Delegation = this.Delegation.bind(this);
        this.UnbondingDelegation = this.UnbondingDelegation.bind(this);
        this.DelegatorDelegations = this.DelegatorDelegations.bind(this);
        this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this);
        this.Redelegations = this.Redelegations.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorValidator = this.DelegatorValidator.bind(this);
        this.HistoricalInfo = this.HistoricalInfo.bind(this);
        this.Pool = this.Pool.bind(this);
        this.Params = this.Params.bind(this);
      }
      Validators(request) {
        const data = exports2.QueryValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", data);
        return promise.then((data2) => exports2.QueryValidatorsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Validator(request) {
        const data = exports2.QueryValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", data);
        return promise.then((data2) => exports2.QueryValidatorResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ValidatorDelegations(request) {
        const data = exports2.QueryValidatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", data);
        return promise.then((data2) => exports2.QueryValidatorDelegationsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      ValidatorUnbondingDelegations(request) {
        const data = exports2.QueryValidatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", data);
        return promise.then((data2) => exports2.QueryValidatorUnbondingDelegationsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Delegation(request) {
        const data = exports2.QueryDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", data);
        return promise.then((data2) => exports2.QueryDelegationResponse.decode(new binary_1.BinaryReader(data2)));
      }
      UnbondingDelegation(request) {
        const data = exports2.QueryUnbondingDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", data);
        return promise.then((data2) => exports2.QueryUnbondingDelegationResponse.decode(new binary_1.BinaryReader(data2)));
      }
      DelegatorDelegations(request) {
        const data = exports2.QueryDelegatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", data);
        return promise.then((data2) => exports2.QueryDelegatorDelegationsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      DelegatorUnbondingDelegations(request) {
        const data = exports2.QueryDelegatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", data);
        return promise.then((data2) => exports2.QueryDelegatorUnbondingDelegationsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Redelegations(request) {
        const data = exports2.QueryRedelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", data);
        return promise.then((data2) => exports2.QueryRedelegationsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      DelegatorValidators(request) {
        const data = exports2.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", data);
        return promise.then((data2) => exports2.QueryDelegatorValidatorsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      DelegatorValidator(request) {
        const data = exports2.QueryDelegatorValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", data);
        return promise.then((data2) => exports2.QueryDelegatorValidatorResponse.decode(new binary_1.BinaryReader(data2)));
      }
      HistoricalInfo(request) {
        const data = exports2.QueryHistoricalInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", data);
        return promise.then((data2) => exports2.QueryHistoricalInfoResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Pool(request = {}) {
        const data = exports2.QueryPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", data);
        return promise.then((data2) => exports2.QueryPoolResponse.decode(new binary_1.BinaryReader(data2)));
      }
      Params(request = {}) {
        const data = exports2.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports2.QueryParamsResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/staking/queries.js
var require_queries10 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/staking/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupStakingExtension = void 0;
    var query_1 = require_query13();
    var queryclient_1 = require_queryclient2();
    function setupStakingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        staking: {
          delegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.Delegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorUnbondingDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorUnbondingDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorValidator: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegatorValidator({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          historicalInfo: async (height) => {
            const response = await queryService.HistoricalInfo({
              height: BigInt(height)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          pool: async () => {
            const response = await queryService.Pool({});
            return response;
          },
          redelegations: async (delegatorAddress, sourceValidatorAddress, destinationValidatorAddress, paginationKey) => {
            const response = await queryService.Redelegations({
              delegatorAddr: delegatorAddress,
              srcValidatorAddr: sourceValidatorAddress,
              dstValidatorAddr: destinationValidatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          unbondingDelegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.UnbondingDelegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          validator: async (validatorAddress) => {
            const response = await queryService.Validator({ validatorAddr: validatorAddress });
            return response;
          },
          validatorDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validators: async (status, paginationKey) => {
            const response = await queryService.Validators({
              status,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validatorUnbondingDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorUnbondingDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports2.setupStakingExtension = setupStakingExtension;
  }
});

// node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js
var require_abci = __commonJS({
  "node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SearchTxsResult = exports2.TxMsgData = exports2.MsgData = exports2.SimulationResponse = exports2.Result = exports2.GasInfo = exports2.Attribute = exports2.StringEvent = exports2.ABCIMessageLog = exports2.TxResponse = exports2.protobufPackage = void 0;
    var any_1 = require_any();
    var types_1 = require_types4();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.base.abci.v1beta1";
    function createBaseTxResponse() {
      return {
        height: BigInt(0),
        txhash: "",
        codespace: "",
        code: 0,
        data: "",
        rawLog: "",
        logs: [],
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        tx: void 0,
        timestamp: "",
        events: []
      };
    }
    exports2.TxResponse = {
      typeUrl: "/cosmos.base.abci.v1beta1.TxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.txhash !== "") {
          writer.uint32(18).string(message.txhash);
        }
        if (message.codespace !== "") {
          writer.uint32(26).string(message.codespace);
        }
        if (message.code !== 0) {
          writer.uint32(32).uint32(message.code);
        }
        if (message.data !== "") {
          writer.uint32(42).string(message.data);
        }
        if (message.rawLog !== "") {
          writer.uint32(50).string(message.rawLog);
        }
        for (const v of message.logs) {
          exports2.ABCIMessageLog.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.info !== "") {
          writer.uint32(66).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(72).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(80).int64(message.gasUsed);
        }
        if (message.tx !== void 0) {
          any_1.Any.encode(message.tx, writer.uint32(90).fork()).ldelim();
        }
        if (message.timestamp !== "") {
          writer.uint32(98).string(message.timestamp);
        }
        for (const v of message.events) {
          types_1.Event.encode(v, writer.uint32(106).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.txhash = reader.string();
              break;
            case 3:
              message.codespace = reader.string();
              break;
            case 4:
              message.code = reader.uint32();
              break;
            case 5:
              message.data = reader.string();
              break;
            case 6:
              message.rawLog = reader.string();
              break;
            case 7:
              message.logs.push(exports2.ABCIMessageLog.decode(reader, reader.uint32()));
              break;
            case 8:
              message.info = reader.string();
              break;
            case 9:
              message.gasWanted = reader.int64();
              break;
            case 10:
              message.gasUsed = reader.int64();
              break;
            case 11:
              message.tx = any_1.Any.decode(reader, reader.uint32());
              break;
            case 12:
              message.timestamp = reader.string();
              break;
            case 13:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxResponse();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.txhash))
          obj.txhash = String(object.txhash);
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = String(object.data);
        if ((0, helpers_1.isSet)(object.rawLog))
          obj.rawLog = String(object.rawLog);
        if (Array.isArray(object == null ? void 0 : object.logs))
          obj.logs = object.logs.map((e) => exports2.ABCIMessageLog.fromJSON(e));
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gasWanted))
          obj.gasWanted = BigInt(object.gasWanted.toString());
        if ((0, helpers_1.isSet)(object.gasUsed))
          obj.gasUsed = BigInt(object.gasUsed.toString());
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = any_1.Any.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = String(object.timestamp);
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => types_1.Event.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.txhash !== void 0 && (obj.txhash = message.txhash);
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = message.data);
        message.rawLog !== void 0 && (obj.rawLog = message.rawLog);
        if (message.logs) {
          obj.logs = message.logs.map((e) => e ? exports2.ABCIMessageLog.toJSON(e) : void 0);
        } else {
          obj.logs = [];
        }
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || BigInt(0)).toString());
        message.tx !== void 0 && (obj.tx = message.tx ? any_1.Any.toJSON(message.tx) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseTxResponse();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.txhash = object.txhash ?? "";
        message.codespace = object.codespace ?? "";
        message.code = object.code ?? 0;
        message.data = object.data ?? "";
        message.rawLog = object.rawLog ?? "";
        message.logs = ((_a = object.logs) == null ? void 0 : _a.map((e) => exports2.ABCIMessageLog.fromPartial(e))) || [];
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = any_1.Any.fromPartial(object.tx);
        }
        message.timestamp = object.timestamp ?? "";
        message.events = ((_b = object.events) == null ? void 0 : _b.map((e) => types_1.Event.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseABCIMessageLog() {
      return {
        msgIndex: 0,
        log: "",
        events: []
      };
    }
    exports2.ABCIMessageLog = {
      typeUrl: "/cosmos.base.abci.v1beta1.ABCIMessageLog",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msgIndex !== 0) {
          writer.uint32(8).uint32(message.msgIndex);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v of message.events) {
          exports2.StringEvent.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseABCIMessageLog();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgIndex = reader.uint32();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(exports2.StringEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseABCIMessageLog();
        if ((0, helpers_1.isSet)(object.msgIndex))
          obj.msgIndex = Number(object.msgIndex);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => exports2.StringEvent.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msgIndex !== void 0 && (obj.msgIndex = Math.round(message.msgIndex));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports2.StringEvent.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseABCIMessageLog();
        message.msgIndex = object.msgIndex ?? 0;
        message.log = object.log ?? "";
        message.events = ((_a = object.events) == null ? void 0 : _a.map((e) => exports2.StringEvent.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseStringEvent() {
      return {
        type: "",
        attributes: []
      };
    }
    exports2.StringEvent = {
      typeUrl: "/cosmos.base.abci.v1beta1.StringEvent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
          exports2.Attribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStringEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports2.Attribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseStringEvent();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if (Array.isArray(object == null ? void 0 : object.attributes))
          obj.attributes = object.attributes.map((e) => exports2.Attribute.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports2.Attribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseStringEvent();
        message.type = object.type ?? "";
        message.attributes = ((_a = object.attributes) == null ? void 0 : _a.map((e) => exports2.Attribute.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseAttribute() {
      return {
        key: "",
        value: ""
      };
    }
    exports2.Attribute = {
      typeUrl: "/cosmos.base.abci.v1beta1.Attribute",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAttribute();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAttribute();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = String(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAttribute();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
      }
    };
    function createBaseGasInfo() {
      return {
        gasWanted: BigInt(0),
        gasUsed: BigInt(0)
      };
    }
    exports2.GasInfo = {
      typeUrl: "/cosmos.base.abci.v1beta1.GasInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(8).uint64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(16).uint64(message.gasUsed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGasInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasWanted = reader.uint64();
              break;
            case 2:
              message.gasUsed = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGasInfo();
        if ((0, helpers_1.isSet)(object.gasWanted))
          obj.gasWanted = BigInt(object.gasWanted.toString());
        if ((0, helpers_1.isSet)(object.gasUsed))
          obj.gasUsed = BigInt(object.gasUsed.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGasInfo();
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        return message;
      }
    };
    function createBaseResult() {
      return {
        data: new Uint8Array(),
        log: "",
        events: [],
        msgResponses: []
      };
    }
    exports2.Result = {
      typeUrl: "/cosmos.base.abci.v1beta1.Result",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v of message.events) {
          types_1.Event.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.msgResponses) {
          any_1.Any.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            case 4:
              message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResult();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => types_1.Event.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.msgResponses))
          obj.msgResponses = object.msgResponses.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        if (message.msgResponses) {
          obj.msgResponses = message.msgResponses.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgResponses = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseResult();
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.events = ((_a = object.events) == null ? void 0 : _a.map((e) => types_1.Event.fromPartial(e))) || [];
        message.msgResponses = ((_b = object.msgResponses) == null ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSimulationResponse() {
      return {
        gasInfo: exports2.GasInfo.fromPartial({}),
        result: void 0
      };
    }
    exports2.SimulationResponse = {
      typeUrl: "/cosmos.base.abci.v1beta1.SimulationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasInfo !== void 0) {
          exports2.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          exports2.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = exports2.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = exports2.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulationResponse();
        if ((0, helpers_1.isSet)(object.gasInfo))
          obj.gasInfo = exports2.GasInfo.fromJSON(object.gasInfo);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = exports2.Result.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? exports2.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? exports2.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulationResponse();
        if (object.gasInfo !== void 0 && object.gasInfo !== null) {
          message.gasInfo = exports2.GasInfo.fromPartial(object.gasInfo);
        }
        if (object.result !== void 0 && object.result !== null) {
          message.result = exports2.Result.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseMsgData() {
      return {
        msgType: "",
        data: new Uint8Array()
      };
    }
    exports2.MsgData = {
      typeUrl: "/cosmos.base.abci.v1beta1.MsgData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msgType !== "") {
          writer.uint32(10).string(message.msgType);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgType = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgData();
        if ((0, helpers_1.isSet)(object.msgType))
          obj.msgType = String(object.msgType);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msgType !== void 0 && (obj.msgType = message.msgType);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgData();
        message.msgType = object.msgType ?? "";
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxMsgData() {
      return {
        data: [],
        msgResponses: []
      };
    }
    exports2.TxMsgData = {
      typeUrl: "/cosmos.base.abci.v1beta1.TxMsgData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.data) {
          exports2.MsgData.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.msgResponses) {
          any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxMsgData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data.push(exports2.MsgData.decode(reader, reader.uint32()));
              break;
            case 2:
              message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxMsgData();
        if (Array.isArray(object == null ? void 0 : object.data))
          obj.data = object.data.map((e) => exports2.MsgData.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.msgResponses))
          obj.msgResponses = object.msgResponses.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.data) {
          obj.data = message.data.map((e) => e ? exports2.MsgData.toJSON(e) : void 0);
        } else {
          obj.data = [];
        }
        if (message.msgResponses) {
          obj.msgResponses = message.msgResponses.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgResponses = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseTxMsgData();
        message.data = ((_a = object.data) == null ? void 0 : _a.map((e) => exports2.MsgData.fromPartial(e))) || [];
        message.msgResponses = ((_b = object.msgResponses) == null ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseSearchTxsResult() {
      return {
        totalCount: BigInt(0),
        count: BigInt(0),
        pageNumber: BigInt(0),
        pageTotal: BigInt(0),
        limit: BigInt(0),
        txs: []
      };
    }
    exports2.SearchTxsResult = {
      typeUrl: "/cosmos.base.abci.v1beta1.SearchTxsResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalCount !== BigInt(0)) {
          writer.uint32(8).uint64(message.totalCount);
        }
        if (message.count !== BigInt(0)) {
          writer.uint32(16).uint64(message.count);
        }
        if (message.pageNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.pageNumber);
        }
        if (message.pageTotal !== BigInt(0)) {
          writer.uint32(32).uint64(message.pageTotal);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).uint64(message.limit);
        }
        for (const v of message.txs) {
          exports2.TxResponse.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSearchTxsResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalCount = reader.uint64();
              break;
            case 2:
              message.count = reader.uint64();
              break;
            case 3:
              message.pageNumber = reader.uint64();
              break;
            case 4:
              message.pageTotal = reader.uint64();
              break;
            case 5:
              message.limit = reader.uint64();
              break;
            case 6:
              message.txs.push(exports2.TxResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSearchTxsResult();
        if ((0, helpers_1.isSet)(object.totalCount))
          obj.totalCount = BigInt(object.totalCount.toString());
        if ((0, helpers_1.isSet)(object.count))
          obj.count = BigInt(object.count.toString());
        if ((0, helpers_1.isSet)(object.pageNumber))
          obj.pageNumber = BigInt(object.pageNumber.toString());
        if ((0, helpers_1.isSet)(object.pageTotal))
          obj.pageTotal = BigInt(object.pageTotal.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => exports2.TxResponse.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.totalCount !== void 0 && (obj.totalCount = (message.totalCount || BigInt(0)).toString());
        message.count !== void 0 && (obj.count = (message.count || BigInt(0)).toString());
        message.pageNumber !== void 0 && (obj.pageNumber = (message.pageNumber || BigInt(0)).toString());
        message.pageTotal !== void 0 && (obj.pageTotal = (message.pageTotal || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? exports2.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseSearchTxsResult();
        if (object.totalCount !== void 0 && object.totalCount !== null) {
          message.totalCount = BigInt(object.totalCount.toString());
        }
        if (object.count !== void 0 && object.count !== null) {
          message.count = BigInt(object.count.toString());
        }
        if (object.pageNumber !== void 0 && object.pageNumber !== null) {
          message.pageNumber = BigInt(object.pageNumber.toString());
        }
        if (object.pageTotal !== void 0 && object.pageTotal !== null) {
          message.pageTotal = BigInt(object.pageTotal.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.txs = ((_a = object.txs) == null ? void 0 : _a.map((e) => exports2.TxResponse.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/tendermint/types/evidence.js
var require_evidence = __commonJS({
  "node_modules/cosmjs-types/tendermint/types/evidence.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EvidenceList = exports2.LightClientAttackEvidence = exports2.DuplicateVoteEvidence = exports2.Evidence = exports2.protobufPackage = void 0;
    var types_1 = require_types3();
    var timestamp_1 = require_timestamp();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "tendermint.types";
    function createBaseEvidence() {
      return {
        duplicateVoteEvidence: void 0,
        lightClientAttackEvidence: void 0
      };
    }
    exports2.Evidence = {
      typeUrl: "/tendermint.types.Evidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.duplicateVoteEvidence !== void 0) {
          exports2.DuplicateVoteEvidence.encode(message.duplicateVoteEvidence, writer.uint32(10).fork()).ldelim();
        }
        if (message.lightClientAttackEvidence !== void 0) {
          exports2.LightClientAttackEvidence.encode(message.lightClientAttackEvidence, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.duplicateVoteEvidence = exports2.DuplicateVoteEvidence.decode(reader, reader.uint32());
              break;
            case 2:
              message.lightClientAttackEvidence = exports2.LightClientAttackEvidence.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidence();
        if ((0, helpers_1.isSet)(object.duplicateVoteEvidence))
          obj.duplicateVoteEvidence = exports2.DuplicateVoteEvidence.fromJSON(object.duplicateVoteEvidence);
        if ((0, helpers_1.isSet)(object.lightClientAttackEvidence))
          obj.lightClientAttackEvidence = exports2.LightClientAttackEvidence.fromJSON(object.lightClientAttackEvidence);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.duplicateVoteEvidence !== void 0 && (obj.duplicateVoteEvidence = message.duplicateVoteEvidence ? exports2.DuplicateVoteEvidence.toJSON(message.duplicateVoteEvidence) : void 0);
        message.lightClientAttackEvidence !== void 0 && (obj.lightClientAttackEvidence = message.lightClientAttackEvidence ? exports2.LightClientAttackEvidence.toJSON(message.lightClientAttackEvidence) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidence();
        if (object.duplicateVoteEvidence !== void 0 && object.duplicateVoteEvidence !== null) {
          message.duplicateVoteEvidence = exports2.DuplicateVoteEvidence.fromPartial(object.duplicateVoteEvidence);
        }
        if (object.lightClientAttackEvidence !== void 0 && object.lightClientAttackEvidence !== null) {
          message.lightClientAttackEvidence = exports2.LightClientAttackEvidence.fromPartial(object.lightClientAttackEvidence);
        }
        return message;
      }
    };
    function createBaseDuplicateVoteEvidence() {
      return {
        voteA: void 0,
        voteB: void 0,
        totalVotingPower: BigInt(0),
        validatorPower: BigInt(0),
        timestamp: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.DuplicateVoteEvidence = {
      typeUrl: "/tendermint.types.DuplicateVoteEvidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteA !== void 0) {
          types_1.Vote.encode(message.voteA, writer.uint32(10).fork()).ldelim();
        }
        if (message.voteB !== void 0) {
          types_1.Vote.encode(message.voteB, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        if (message.validatorPower !== BigInt(0)) {
          writer.uint32(32).int64(message.validatorPower);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuplicateVoteEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteA = types_1.Vote.decode(reader, reader.uint32());
              break;
            case 2:
              message.voteB = types_1.Vote.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            case 4:
              message.validatorPower = reader.int64();
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDuplicateVoteEvidence();
        if ((0, helpers_1.isSet)(object.voteA))
          obj.voteA = types_1.Vote.fromJSON(object.voteA);
        if ((0, helpers_1.isSet)(object.voteB))
          obj.voteB = types_1.Vote.fromJSON(object.voteB);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if ((0, helpers_1.isSet)(object.validatorPower))
          obj.validatorPower = BigInt(object.validatorPower.toString());
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.voteA !== void 0 && (obj.voteA = message.voteA ? types_1.Vote.toJSON(message.voteA) : void 0);
        message.voteB !== void 0 && (obj.voteB = message.voteB ? types_1.Vote.toJSON(message.voteB) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        message.validatorPower !== void 0 && (obj.validatorPower = (message.validatorPower || BigInt(0)).toString());
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDuplicateVoteEvidence();
        if (object.voteA !== void 0 && object.voteA !== null) {
          message.voteA = types_1.Vote.fromPartial(object.voteA);
        }
        if (object.voteB !== void 0 && object.voteB !== null) {
          message.voteB = types_1.Vote.fromPartial(object.voteB);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        if (object.validatorPower !== void 0 && object.validatorPower !== null) {
          message.validatorPower = BigInt(object.validatorPower.toString());
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        return message;
      }
    };
    function createBaseLightClientAttackEvidence() {
      return {
        conflictingBlock: void 0,
        commonHeight: BigInt(0),
        byzantineValidators: [],
        totalVotingPower: BigInt(0),
        timestamp: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports2.LightClientAttackEvidence = {
      typeUrl: "/tendermint.types.LightClientAttackEvidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.conflictingBlock !== void 0) {
          types_1.LightBlock.encode(message.conflictingBlock, writer.uint32(10).fork()).ldelim();
        }
        if (message.commonHeight !== BigInt(0)) {
          writer.uint32(16).int64(message.commonHeight);
        }
        for (const v of message.byzantineValidators) {
          validator_1.Validator.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(32).int64(message.totalVotingPower);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightClientAttackEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.conflictingBlock = types_1.LightBlock.decode(reader, reader.uint32());
              break;
            case 2:
              message.commonHeight = reader.int64();
              break;
            case 3:
              message.byzantineValidators.push(validator_1.Validator.decode(reader, reader.uint32()));
              break;
            case 4:
              message.totalVotingPower = reader.int64();
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLightClientAttackEvidence();
        if ((0, helpers_1.isSet)(object.conflictingBlock))
          obj.conflictingBlock = types_1.LightBlock.fromJSON(object.conflictingBlock);
        if ((0, helpers_1.isSet)(object.commonHeight))
          obj.commonHeight = BigInt(object.commonHeight.toString());
        if (Array.isArray(object == null ? void 0 : object.byzantineValidators))
          obj.byzantineValidators = object.byzantineValidators.map((e) => validator_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.conflictingBlock !== void 0 && (obj.conflictingBlock = message.conflictingBlock ? types_1.LightBlock.toJSON(message.conflictingBlock) : void 0);
        message.commonHeight !== void 0 && (obj.commonHeight = (message.commonHeight || BigInt(0)).toString());
        if (message.byzantineValidators) {
          obj.byzantineValidators = message.byzantineValidators.map((e) => e ? validator_1.Validator.toJSON(e) : void 0);
        } else {
          obj.byzantineValidators = [];
        }
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseLightClientAttackEvidence();
        if (object.conflictingBlock !== void 0 && object.conflictingBlock !== null) {
          message.conflictingBlock = types_1.LightBlock.fromPartial(object.conflictingBlock);
        }
        if (object.commonHeight !== void 0 && object.commonHeight !== null) {
          message.commonHeight = BigInt(object.commonHeight.toString());
        }
        message.byzantineValidators = ((_a = object.byzantineValidators) == null ? void 0 : _a.map((e) => validator_1.Validator.fromPartial(e))) || [];
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        return message;
      }
    };
    function createBaseEvidenceList() {
      return {
        evidence: []
      };
    }
    exports2.EvidenceList = {
      typeUrl: "/tendermint.types.EvidenceList",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.evidence) {
          exports2.Evidence.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidenceList();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.evidence.push(exports2.Evidence.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidenceList();
        if (Array.isArray(object == null ? void 0 : object.evidence))
          obj.evidence = object.evidence.map((e) => exports2.Evidence.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.evidence) {
          obj.evidence = message.evidence.map((e) => e ? exports2.Evidence.toJSON(e) : void 0);
        } else {
          obj.evidence = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseEvidenceList();
        message.evidence = ((_a = object.evidence) == null ? void 0 : _a.map((e) => exports2.Evidence.fromPartial(e))) || [];
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/tendermint/types/block.js
var require_block = __commonJS({
  "node_modules/cosmjs-types/tendermint/types/block.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Block = exports2.protobufPackage = void 0;
    var types_1 = require_types3();
    var evidence_1 = require_evidence();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "tendermint.types";
    function createBaseBlock() {
      return {
        header: types_1.Header.fromPartial({}),
        data: types_1.Data.fromPartial({}),
        evidence: evidence_1.EvidenceList.fromPartial({}),
        lastCommit: void 0
      };
    }
    exports2.Block = {
      typeUrl: "/tendermint.types.Block",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          types_1.Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          evidence_1.EvidenceList.encode(message.evidence, writer.uint32(26).fork()).ldelim();
        }
        if (message.lastCommit !== void 0) {
          types_1.Commit.encode(message.lastCommit, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = types_1.Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.evidence = evidence_1.EvidenceList.decode(reader, reader.uint32());
              break;
            case 4:
              message.lastCommit = types_1.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlock();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = types_1.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = types_1.Data.fromJSON(object.data);
        if ((0, helpers_1.isSet)(object.evidence))
          obj.evidence = evidence_1.EvidenceList.fromJSON(object.evidence);
        if ((0, helpers_1.isSet)(object.lastCommit))
          obj.lastCommit = types_1.Commit.fromJSON(object.lastCommit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        message.data !== void 0 && (obj.data = message.data ? types_1.Data.toJSON(message.data) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? evidence_1.EvidenceList.toJSON(message.evidence) : void 0);
        message.lastCommit !== void 0 && (obj.lastCommit = message.lastCommit ? types_1.Commit.toJSON(message.lastCommit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlock();
        if (object.header !== void 0 && object.header !== null) {
          message.header = types_1.Header.fromPartial(object.header);
        }
        if (object.data !== void 0 && object.data !== null) {
          message.data = types_1.Data.fromPartial(object.data);
        }
        if (object.evidence !== void 0 && object.evidence !== null) {
          message.evidence = evidence_1.EvidenceList.fromPartial(object.evidence);
        }
        if (object.lastCommit !== void 0 && object.lastCommit !== null) {
          message.lastCommit = types_1.Commit.fromPartial(object.lastCommit);
        }
        return message;
      }
    };
  }
});

// node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js
var require_service2 = __commonJS({
  "node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServiceClientImpl = exports2.TxDecodeAminoResponse = exports2.TxDecodeAminoRequest = exports2.TxEncodeAminoResponse = exports2.TxEncodeAminoRequest = exports2.TxEncodeResponse = exports2.TxEncodeRequest = exports2.TxDecodeResponse = exports2.TxDecodeRequest = exports2.GetBlockWithTxsResponse = exports2.GetBlockWithTxsRequest = exports2.GetTxResponse = exports2.GetTxRequest = exports2.SimulateResponse = exports2.SimulateRequest = exports2.BroadcastTxResponse = exports2.BroadcastTxRequest = exports2.GetTxsEventResponse = exports2.GetTxsEventRequest = exports2.broadcastModeToJSON = exports2.broadcastModeFromJSON = exports2.BroadcastMode = exports2.orderByToJSON = exports2.orderByFromJSON = exports2.OrderBy = exports2.protobufPackage = void 0;
    var tx_1 = require_tx();
    var pagination_1 = require_pagination();
    var abci_1 = require_abci();
    var types_1 = require_types3();
    var block_1 = require_block();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.tx.v1beta1";
    var OrderBy;
    (function(OrderBy2) {
      OrderBy2[OrderBy2["ORDER_BY_UNSPECIFIED"] = 0] = "ORDER_BY_UNSPECIFIED";
      OrderBy2[OrderBy2["ORDER_BY_ASC"] = 1] = "ORDER_BY_ASC";
      OrderBy2[OrderBy2["ORDER_BY_DESC"] = 2] = "ORDER_BY_DESC";
      OrderBy2[OrderBy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(OrderBy || (exports2.OrderBy = OrderBy = {}));
    function orderByFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_BY_UNSPECIFIED":
          return OrderBy.ORDER_BY_UNSPECIFIED;
        case 1:
        case "ORDER_BY_ASC":
          return OrderBy.ORDER_BY_ASC;
        case 2:
        case "ORDER_BY_DESC":
          return OrderBy.ORDER_BY_DESC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return OrderBy.UNRECOGNIZED;
      }
    }
    exports2.orderByFromJSON = orderByFromJSON;
    function orderByToJSON(object) {
      switch (object) {
        case OrderBy.ORDER_BY_UNSPECIFIED:
          return "ORDER_BY_UNSPECIFIED";
        case OrderBy.ORDER_BY_ASC:
          return "ORDER_BY_ASC";
        case OrderBy.ORDER_BY_DESC:
          return "ORDER_BY_DESC";
        case OrderBy.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.orderByToJSON = orderByToJSON;
    var BroadcastMode;
    (function(BroadcastMode2) {
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_UNSPECIFIED"] = 0] = "BROADCAST_MODE_UNSPECIFIED";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_BLOCK"] = 1] = "BROADCAST_MODE_BLOCK";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_SYNC"] = 2] = "BROADCAST_MODE_SYNC";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_ASYNC"] = 3] = "BROADCAST_MODE_ASYNC";
      BroadcastMode2[BroadcastMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BroadcastMode || (exports2.BroadcastMode = BroadcastMode = {}));
    function broadcastModeFromJSON(object) {
      switch (object) {
        case 0:
        case "BROADCAST_MODE_UNSPECIFIED":
          return BroadcastMode.BROADCAST_MODE_UNSPECIFIED;
        case 1:
        case "BROADCAST_MODE_BLOCK":
          return BroadcastMode.BROADCAST_MODE_BLOCK;
        case 2:
        case "BROADCAST_MODE_SYNC":
          return BroadcastMode.BROADCAST_MODE_SYNC;
        case 3:
        case "BROADCAST_MODE_ASYNC":
          return BroadcastMode.BROADCAST_MODE_ASYNC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BroadcastMode.UNRECOGNIZED;
      }
    }
    exports2.broadcastModeFromJSON = broadcastModeFromJSON;
    function broadcastModeToJSON(object) {
      switch (object) {
        case BroadcastMode.BROADCAST_MODE_UNSPECIFIED:
          return "BROADCAST_MODE_UNSPECIFIED";
        case BroadcastMode.BROADCAST_MODE_BLOCK:
          return "BROADCAST_MODE_BLOCK";
        case BroadcastMode.BROADCAST_MODE_SYNC:
          return "BROADCAST_MODE_SYNC";
        case BroadcastMode.BROADCAST_MODE_ASYNC:
          return "BROADCAST_MODE_ASYNC";
        case BroadcastMode.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports2.broadcastModeToJSON = broadcastModeToJSON;
    function createBaseGetTxsEventRequest() {
      return {
        events: [],
        pagination: void 0,
        orderBy: 0,
        page: BigInt(0),
        limit: BigInt(0)
      };
    }
    exports2.GetTxsEventRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxsEventRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.events) {
          writer.uint32(10).string(v);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.orderBy !== 0) {
          writer.uint32(24).int32(message.orderBy);
        }
        if (message.page !== BigInt(0)) {
          writer.uint32(32).uint64(message.page);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).uint64(message.limit);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 3:
              message.orderBy = reader.int32();
              break;
            case 4:
              message.page = reader.uint64();
              break;
            case 5:
              message.limit = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxsEventRequest();
        if (Array.isArray(object == null ? void 0 : object.events))
          obj.events = object.events.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.orderBy))
          obj.orderBy = orderByFromJSON(object.orderBy);
        if ((0, helpers_1.isSet)(object.page))
          obj.page = BigInt(object.page.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e);
        } else {
          obj.events = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        message.orderBy !== void 0 && (obj.orderBy = orderByToJSON(message.orderBy));
        message.page !== void 0 && (obj.page = (message.page || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseGetTxsEventRequest();
        message.events = ((_a = object.events) == null ? void 0 : _a.map((e) => e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.orderBy = object.orderBy ?? 0;
        if (object.page !== void 0 && object.page !== null) {
          message.page = BigInt(object.page.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        return message;
      }
    };
    function createBaseGetTxsEventResponse() {
      return {
        txs: [],
        txResponses: [],
        pagination: void 0,
        total: BigInt(0)
      };
    }
    exports2.GetTxsEventResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxsEventResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.txResponses) {
          abci_1.TxResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        if (message.total !== BigInt(0)) {
          writer.uint32(32).uint64(message.total);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.txResponses.push(abci_1.TxResponse.decode(reader, reader.uint32()));
              break;
            case 3:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 4:
              message.total = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxsEventResponse();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => tx_1.Tx.fromJSON(e));
        if (Array.isArray(object == null ? void 0 : object.txResponses))
          obj.txResponses = object.txResponses.map((e) => abci_1.TxResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        if (message.txResponses) {
          obj.txResponses = message.txResponses.map((e) => e ? abci_1.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = createBaseGetTxsEventResponse();
        message.txs = ((_a = object.txs) == null ? void 0 : _a.map((e) => tx_1.Tx.fromPartial(e))) || [];
        message.txResponses = ((_b = object.txResponses) == null ? void 0 : _b.map((e) => abci_1.TxResponse.fromPartial(e))) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        return message;
      }
    };
    function createBaseBroadcastTxRequest() {
      return {
        txBytes: new Uint8Array(),
        mode: 0
      };
    }
    exports2.BroadcastTxRequest = {
      typeUrl: "/cosmos.tx.v1beta1.BroadcastTxRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        if (message.mode !== 0) {
          writer.uint32(16).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            case 2:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBroadcastTxRequest();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = broadcastModeFromJSON(object.mode);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        message.mode !== void 0 && (obj.mode = broadcastModeToJSON(message.mode));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBroadcastTxRequest();
        message.txBytes = object.txBytes ?? new Uint8Array();
        message.mode = object.mode ?? 0;
        return message;
      }
    };
    function createBaseBroadcastTxResponse() {
      return {
        txResponse: void 0
      };
    }
    exports2.BroadcastTxResponse = {
      typeUrl: "/cosmos.tx.v1beta1.BroadcastTxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBroadcastTxResponse();
        if ((0, helpers_1.isSet)(object.txResponse))
          obj.txResponse = abci_1.TxResponse.fromJSON(object.txResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBroadcastTxResponse();
        if (object.txResponse !== void 0 && object.txResponse !== null) {
          message.txResponse = abci_1.TxResponse.fromPartial(object.txResponse);
        }
        return message;
      }
    };
    function createBaseSimulateRequest() {
      return {
        tx: void 0,
        txBytes: new Uint8Array()
      };
    }
    exports2.SimulateRequest = {
      typeUrl: "/cosmos.tx.v1beta1.SimulateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txBytes.length !== 0) {
          writer.uint32(18).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulateRequest();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulateRequest();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSimulateResponse() {
      return {
        gasInfo: void 0,
        result: void 0
      };
    }
    exports2.SimulateResponse = {
      typeUrl: "/cosmos.tx.v1beta1.SimulateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasInfo !== void 0) {
          abci_1.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          abci_1.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = abci_1.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = abci_1.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulateResponse();
        if ((0, helpers_1.isSet)(object.gasInfo))
          obj.gasInfo = abci_1.GasInfo.fromJSON(object.gasInfo);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = abci_1.Result.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? abci_1.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? abci_1.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulateResponse();
        if (object.gasInfo !== void 0 && object.gasInfo !== null) {
          message.gasInfo = abci_1.GasInfo.fromPartial(object.gasInfo);
        }
        if (object.result !== void 0 && object.result !== null) {
          message.result = abci_1.Result.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseGetTxRequest() {
      return {
        hash: ""
      };
    }
    exports2.GetTxRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxRequest();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxRequest();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseGetTxResponse() {
      return {
        tx: void 0,
        txResponse: void 0
      };
    }
    exports2.GetTxResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxResponse();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.txResponse))
          obj.txResponse = abci_1.TxResponse.fromJSON(object.txResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxResponse();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        if (object.txResponse !== void 0 && object.txResponse !== null) {
          message.txResponse = abci_1.TxResponse.fromPartial(object.txResponse);
        }
        return message;
      }
    };
    function createBaseGetBlockWithTxsRequest() {
      return {
        height: BigInt(0),
        pagination: void 0
      };
    }
    exports2.GetBlockWithTxsRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetBlockWithTxsRequest();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetBlockWithTxsRequest();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseGetBlockWithTxsResponse() {
      return {
        txs: [],
        blockId: void 0,
        block: void 0,
        pagination: void 0
      };
    }
    exports2.GetBlockWithTxsResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v of message.txs) {
          tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockId !== void 0) {
          types_1.BlockID.encode(message.blockId, writer.uint32(18).fork()).ldelim();
        }
        if (message.block !== void 0) {
          block_1.Block.encode(message.block, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.blockId = types_1.BlockID.decode(reader, reader.uint32());
              break;
            case 3:
              message.block = block_1.Block.decode(reader, reader.uint32());
              break;
            case 4:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetBlockWithTxsResponse();
        if (Array.isArray(object == null ? void 0 : object.txs))
          obj.txs = object.txs.map((e) => tx_1.Tx.fromJSON(e));
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = types_1.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.block))
          obj.block = block_1.Block.fromJSON(object.block);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        message.blockId !== void 0 && (obj.blockId = message.blockId ? types_1.BlockID.toJSON(message.blockId) : void 0);
        message.block !== void 0 && (obj.block = message.block ? block_1.Block.toJSON(message.block) : void 0);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseGetBlockWithTxsResponse();
        message.txs = ((_a = object.txs) == null ? void 0 : _a.map((e) => tx_1.Tx.fromPartial(e))) || [];
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = types_1.BlockID.fromPartial(object.blockId);
        }
        if (object.block !== void 0 && object.block !== null) {
          message.block = block_1.Block.fromPartial(object.block);
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseTxDecodeRequest() {
      return {
        txBytes: new Uint8Array()
      };
    }
    exports2.TxDecodeRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeRequest();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeRequest();
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeResponse() {
      return {
        tx: void 0
      };
    }
    exports2.TxDecodeResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeResponse();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeResponse();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        return message;
      }
    };
    function createBaseTxEncodeRequest() {
      return {
        tx: void 0
      };
    }
    exports2.TxEncodeRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeRequest();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeRequest();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        return message;
      }
    };
    function createBaseTxEncodeResponse() {
      return {
        txBytes: new Uint8Array()
      };
    }
    exports2.TxEncodeResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeResponse();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeResponse();
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxEncodeAminoRequest() {
      return {
        aminoJson: ""
      };
    }
    exports2.TxEncodeAminoRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoJson !== "") {
          writer.uint32(10).string(message.aminoJson);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeAminoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoJson = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeAminoRequest();
        if ((0, helpers_1.isSet)(object.aminoJson))
          obj.aminoJson = String(object.aminoJson);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoJson !== void 0 && (obj.aminoJson = message.aminoJson);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeAminoRequest();
        message.aminoJson = object.aminoJson ?? "";
        return message;
      }
    };
    function createBaseTxEncodeAminoResponse() {
      return {
        aminoBinary: new Uint8Array()
      };
    }
    exports2.TxEncodeAminoResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoBinary.length !== 0) {
          writer.uint32(10).bytes(message.aminoBinary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeAminoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoBinary = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeAminoResponse();
        if ((0, helpers_1.isSet)(object.aminoBinary))
          obj.aminoBinary = (0, helpers_1.bytesFromBase64)(object.aminoBinary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoBinary !== void 0 && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== void 0 ? message.aminoBinary : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeAminoResponse();
        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeAminoRequest() {
      return {
        aminoBinary: new Uint8Array()
      };
    }
    exports2.TxDecodeAminoRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoBinary.length !== 0) {
          writer.uint32(10).bytes(message.aminoBinary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeAminoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoBinary = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeAminoRequest();
        if ((0, helpers_1.isSet)(object.aminoBinary))
          obj.aminoBinary = (0, helpers_1.bytesFromBase64)(object.aminoBinary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoBinary !== void 0 && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== void 0 ? message.aminoBinary : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeAminoRequest();
        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeAminoResponse() {
      return {
        aminoJson: ""
      };
    }
    exports2.TxDecodeAminoResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoJson !== "") {
          writer.uint32(10).string(message.aminoJson);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeAminoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoJson = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeAminoResponse();
        if ((0, helpers_1.isSet)(object.aminoJson))
          obj.aminoJson = String(object.aminoJson);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoJson !== void 0 && (obj.aminoJson = message.aminoJson);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeAminoResponse();
        message.aminoJson = object.aminoJson ?? "";
        return message;
      }
    };
    var ServiceClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Simulate = this.Simulate.bind(this);
        this.GetTx = this.GetTx.bind(this);
        this.BroadcastTx = this.BroadcastTx.bind(this);
        this.GetTxsEvent = this.GetTxsEvent.bind(this);
        this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this);
        this.TxDecode = this.TxDecode.bind(this);
        this.TxEncode = this.TxEncode.bind(this);
        this.TxEncodeAmino = this.TxEncodeAmino.bind(this);
        this.TxDecodeAmino = this.TxDecodeAmino.bind(this);
      }
      Simulate(request) {
        const data = exports2.SimulateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", data);
        return promise.then((data2) => exports2.SimulateResponse.decode(new binary_1.BinaryReader(data2)));
      }
      GetTx(request) {
        const data = exports2.GetTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", data);
        return promise.then((data2) => exports2.GetTxResponse.decode(new binary_1.BinaryReader(data2)));
      }
      BroadcastTx(request) {
        const data = exports2.BroadcastTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", data);
        return promise.then((data2) => exports2.BroadcastTxResponse.decode(new binary_1.BinaryReader(data2)));
      }
      GetTxsEvent(request) {
        const data = exports2.GetTxsEventRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", data);
        return promise.then((data2) => exports2.GetTxsEventResponse.decode(new binary_1.BinaryReader(data2)));
      }
      GetBlockWithTxs(request) {
        const data = exports2.GetBlockWithTxsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", data);
        return promise.then((data2) => exports2.GetBlockWithTxsResponse.decode(new binary_1.BinaryReader(data2)));
      }
      TxDecode(request) {
        const data = exports2.TxDecodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", data);
        return promise.then((data2) => exports2.TxDecodeResponse.decode(new binary_1.BinaryReader(data2)));
      }
      TxEncode(request) {
        const data = exports2.TxEncodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", data);
        return promise.then((data2) => exports2.TxEncodeResponse.decode(new binary_1.BinaryReader(data2)));
      }
      TxEncodeAmino(request) {
        const data = exports2.TxEncodeAminoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", data);
        return promise.then((data2) => exports2.TxEncodeAminoResponse.decode(new binary_1.BinaryReader(data2)));
      }
      TxDecodeAmino(request) {
        const data = exports2.TxDecodeAminoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", data);
        return promise.then((data2) => exports2.TxDecodeAminoResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.ServiceClientImpl = ServiceClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/tx/queries.js
var require_queries11 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/tx/queries.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupTxExtension = void 0;
    var proto_signing_1 = require_build8();
    var signing_1 = require_signing();
    var service_1 = require_service2();
    var tx_1 = require_tx();
    var queryclient_1 = require_queryclient2();
    function setupTxExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new service_1.ServiceClientImpl(rpc);
      return {
        tx: {
          getTx: async (txId) => {
            const request = {
              hash: txId
            };
            const response = await queryService.GetTx(request);
            return response;
          },
          simulate: async (messages, memo, signer, sequence) => {
            const tx = tx_1.Tx.fromPartial({
              authInfo: tx_1.AuthInfo.fromPartial({
                fee: tx_1.Fee.fromPartial({}),
                signerInfos: [
                  {
                    publicKey: (0, proto_signing_1.encodePubkey)(signer),
                    sequence: BigInt(sequence),
                    modeInfo: { single: { mode: signing_1.SignMode.SIGN_MODE_UNSPECIFIED } }
                  }
                ]
              }),
              body: tx_1.TxBody.fromPartial({
                messages: Array.from(messages),
                memo
              }),
              signatures: [new Uint8Array()]
            });
            const request = service_1.SimulateRequest.fromPartial({
              txBytes: tx_1.Tx.encode(tx).finish()
            });
            const response = await queryService.Simulate(request);
            return response;
          }
        }
      };
    }
    exports2.setupTxExtension = setupTxExtension;
  }
});

// node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js
var require_aminomessages12 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVestingAminoConverters = exports2.isAminoMsgCreateVestingAccount = void 0;
    function isAminoMsgCreateVestingAccount(msg) {
      return msg.type === "cosmos-sdk/MsgCreateVestingAccount";
    }
    exports2.isAminoMsgCreateVestingAccount = isAminoMsgCreateVestingAccount;
    function createVestingAminoConverters() {
      return {
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
          aminoType: "cosmos-sdk/MsgCreateVestingAccount",
          toAmino: ({ fromAddress, toAddress, amount, endTime, delayed }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount],
            end_time: endTime.toString(),
            delayed
          }),
          fromAmino: ({ from_address, to_address, amount, end_time, delayed }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount],
            endTime: BigInt(end_time),
            delayed
          })
        }
      };
    }
    exports2.createVestingAminoConverters = createVestingAminoConverters;
  }
});

// node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js
var require_tx14 = __commonJS({
  "node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MsgClientImpl = exports2.MsgCreatePeriodicVestingAccountResponse = exports2.MsgCreatePeriodicVestingAccount = exports2.MsgCreatePermanentLockedAccountResponse = exports2.MsgCreatePermanentLockedAccount = exports2.MsgCreateVestingAccountResponse = exports2.MsgCreateVestingAccount = exports2.protobufPackage = void 0;
    var coin_1 = require_coin();
    var vesting_1 = require_vesting();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports2.protobufPackage = "cosmos.vesting.v1beta1";
    function createBaseMsgCreateVestingAccount() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: [],
        endTime: BigInt(0),
        delayed: false
      };
    }
    exports2.MsgCreateVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.endTime !== BigInt(0)) {
          writer.uint32(32).int64(message.endTime);
        }
        if (message.delayed === true) {
          writer.uint32(40).bool(message.delayed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.endTime = reader.int64();
              break;
            case 5:
              message.delayed = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateVestingAccount();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.endTime))
          obj.endTime = BigInt(object.endTime.toString());
        if ((0, helpers_1.isSet)(object.delayed))
          obj.delayed = Boolean(object.delayed);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || BigInt(0)).toString());
        message.delayed !== void 0 && (obj.delayed = message.delayed);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgCreateVestingAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        if (object.endTime !== void 0 && object.endTime !== null) {
          message.endTime = BigInt(object.endTime.toString());
        }
        message.delayed = object.delayed ?? false;
        return message;
      }
    };
    function createBaseMsgCreateVestingAccountResponse() {
      return {};
    }
    exports2.MsgCreateVestingAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreateVestingAccountResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreateVestingAccountResponse();
        return message;
      }
    };
    function createBaseMsgCreatePermanentLockedAccount() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: []
      };
    }
    exports2.MsgCreatePermanentLockedAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePermanentLockedAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreatePermanentLockedAccount();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object == null ? void 0 : object.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgCreatePermanentLockedAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = ((_a = object.amount) == null ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgCreatePermanentLockedAccountResponse() {
      return {};
    }
    exports2.MsgCreatePermanentLockedAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePermanentLockedAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreatePermanentLockedAccountResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreatePermanentLockedAccountResponse();
        return message;
      }
    };
    function createBaseMsgCreatePeriodicVestingAccount() {
      return {
        fromAddress: "",
        toAddress: "",
        startTime: BigInt(0),
        vestingPeriods: []
      };
    }
    exports2.MsgCreatePeriodicVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(24).int64(message.startTime);
        }
        for (const v of message.vestingPeriods) {
          vesting_1.Period.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePeriodicVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.startTime = reader.int64();
              break;
            case 4:
              message.vestingPeriods.push(vesting_1.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreatePeriodicVestingAccount();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        if (Array.isArray(object == null ? void 0 : object.vestingPeriods))
          obj.vestingPeriods = object.vestingPeriods.map((e) => vesting_1.Period.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        if (message.vestingPeriods) {
          obj.vestingPeriods = message.vestingPeriods.map((e) => e ? vesting_1.Period.toJSON(e) : void 0);
        } else {
          obj.vestingPeriods = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = createBaseMsgCreatePeriodicVestingAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        message.vestingPeriods = ((_a = object.vestingPeriods) == null ? void 0 : _a.map((e) => vesting_1.Period.fromPartial(e))) || [];
        return message;
      }
    };
    function createBaseMsgCreatePeriodicVestingAccountResponse() {
      return {};
    }
    exports2.MsgCreatePeriodicVestingAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse",
      encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePeriodicVestingAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const obj = createBaseMsgCreatePeriodicVestingAccountResponse();
        return obj;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = createBaseMsgCreatePeriodicVestingAccountResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateVestingAccount = this.CreateVestingAccount.bind(this);
        this.CreatePermanentLockedAccount = this.CreatePermanentLockedAccount.bind(this);
        this.CreatePeriodicVestingAccount = this.CreatePeriodicVestingAccount.bind(this);
      }
      CreateVestingAccount(request) {
        const data = exports2.MsgCreateVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", data);
        return promise.then((data2) => exports2.MsgCreateVestingAccountResponse.decode(new binary_1.BinaryReader(data2)));
      }
      CreatePermanentLockedAccount(request) {
        const data = exports2.MsgCreatePermanentLockedAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePermanentLockedAccount", data);
        return promise.then((data2) => exports2.MsgCreatePermanentLockedAccountResponse.decode(new binary_1.BinaryReader(data2)));
      }
      CreatePeriodicVestingAccount(request) {
        const data = exports2.MsgCreatePeriodicVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePeriodicVestingAccount", data);
        return promise.then((data2) => exports2.MsgCreatePeriodicVestingAccountResponse.decode(new binary_1.BinaryReader(data2)));
      }
    };
    exports2.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/@cosmjs/stargate/build/modules/vesting/messages.js
var require_messages9 = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/vesting/messages.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.vestingTypes = void 0;
    var tx_1 = require_tx14();
    exports2.vestingTypes = [
      ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", tx_1.MsgCreateVestingAccount]
    ];
  }
});

// node_modules/@cosmjs/stargate/build/modules/index.js
var require_modules = __commonJS({
  "node_modules/@cosmjs/stargate/build/modules/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAminoMsgCreateValidator = exports2.isAminoMsgBeginRedelegate = exports2.createStakingAminoConverters = exports2.setupSlashingExtension = exports2.isAminoMsgUnjail = exports2.createSlashingAminoConverters = exports2.setupMintExtension = exports2.setupIbcExtension = exports2.isMsgTransferEncodeObject = exports2.ibcTypes = exports2.isAminoMsgTransfer = exports2.createIbcAminoConverters = exports2.groupTypes = exports2.createGroupAminoConverters = exports2.setupGovExtension = exports2.isMsgVoteWeightedEncodeObject = exports2.isMsgVoteEncodeObject = exports2.isMsgSubmitProposalEncodeObject = exports2.isMsgDepositEncodeObject = exports2.govTypes = exports2.isAminoMsgVoteWeighted = exports2.isAminoMsgVote = exports2.isAminoMsgSubmitProposal = exports2.isAminoMsgDeposit = exports2.createGovAminoConverters = exports2.setupFeegrantExtension = exports2.feegrantTypes = exports2.createFeegrantAminoConverters = exports2.isAminoMsgSubmitEvidence = exports2.createEvidenceAminoConverters = exports2.setupDistributionExtension = exports2.isMsgWithdrawDelegatorRewardEncodeObject = exports2.distributionTypes = exports2.isAminoMsgWithdrawValidatorCommission = exports2.isAminoMsgWithdrawDelegatorReward = exports2.isAminoMsgSetWithdrawAddress = exports2.isAminoMsgFundCommunityPool = exports2.createDistributionAminoConverters = exports2.isAminoMsgVerifyInvariant = exports2.createCrysisAminoConverters = exports2.setupBankExtension = exports2.isMsgSendEncodeObject = exports2.bankTypes = exports2.isAminoMsgSend = exports2.isAminoMsgMultiSend = exports2.createBankAminoConverters = exports2.setupAuthzExtension = exports2.authzTypes = exports2.createAuthzAminoConverters = exports2.setupAuthExtension = void 0;
    exports2.vestingTypes = exports2.isAminoMsgCreateVestingAccount = exports2.createVestingAminoConverters = exports2.setupTxExtension = exports2.setupStakingExtension = exports2.stakingTypes = exports2.isMsgUndelegateEncodeObject = exports2.isMsgEditValidatorEncodeObject = exports2.isMsgDelegateEncodeObject = exports2.isMsgCreateValidatorEncodeObject = exports2.isMsgCancelUnbondingDelegationEncodeObject = exports2.isMsgBeginRedelegateEncodeObject = exports2.isAminoMsgUndelegate = exports2.isAminoMsgEditValidator = exports2.isAminoMsgDelegate = void 0;
    var queries_1 = require_queries();
    Object.defineProperty(exports2, "setupAuthExtension", { enumerable: true, get: function() {
      return queries_1.setupAuthExtension;
    } });
    var aminomessages_1 = require_aminomessages();
    Object.defineProperty(exports2, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createAuthzAminoConverters;
    } });
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "authzTypes", { enumerable: true, get: function() {
      return messages_1.authzTypes;
    } });
    var queries_2 = require_queries2();
    Object.defineProperty(exports2, "setupAuthzExtension", { enumerable: true, get: function() {
      return queries_2.setupAuthzExtension;
    } });
    var aminomessages_2 = require_aminomessages2();
    Object.defineProperty(exports2, "createBankAminoConverters", { enumerable: true, get: function() {
      return aminomessages_2.createBankAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports2, "isAminoMsgSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgSend;
    } });
    var messages_2 = require_messages2();
    Object.defineProperty(exports2, "bankTypes", { enumerable: true, get: function() {
      return messages_2.bankTypes;
    } });
    Object.defineProperty(exports2, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return messages_2.isMsgSendEncodeObject;
    } });
    var queries_3 = require_queries3();
    Object.defineProperty(exports2, "setupBankExtension", { enumerable: true, get: function() {
      return queries_3.setupBankExtension;
    } });
    var aminomessages_3 = require_aminomessages3();
    Object.defineProperty(exports2, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return aminomessages_3.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return aminomessages_3.isAminoMsgVerifyInvariant;
    } });
    var aminomessages_4 = require_aminomessages4();
    Object.defineProperty(exports2, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return aminomessages_4.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports2, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports2, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports2, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawValidatorCommission;
    } });
    var messages_3 = require_messages3();
    Object.defineProperty(exports2, "distributionTypes", { enumerable: true, get: function() {
      return messages_3.distributionTypes;
    } });
    Object.defineProperty(exports2, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return messages_3.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    var queries_4 = require_queries4();
    Object.defineProperty(exports2, "setupDistributionExtension", { enumerable: true, get: function() {
      return queries_4.setupDistributionExtension;
    } });
    var aminomessages_5 = require_aminomessages5();
    Object.defineProperty(exports2, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return aminomessages_5.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return aminomessages_5.isAminoMsgSubmitEvidence;
    } });
    var aminomessages_6 = require_aminomessages6();
    Object.defineProperty(exports2, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return aminomessages_6.createFeegrantAminoConverters;
    } });
    var messages_4 = require_messages4();
    Object.defineProperty(exports2, "feegrantTypes", { enumerable: true, get: function() {
      return messages_4.feegrantTypes;
    } });
    var queries_5 = require_queries5();
    Object.defineProperty(exports2, "setupFeegrantExtension", { enumerable: true, get: function() {
      return queries_5.setupFeegrantExtension;
    } });
    var aminomessages_7 = require_aminomessages7();
    Object.defineProperty(exports2, "createGovAminoConverters", { enumerable: true, get: function() {
      return aminomessages_7.createGovAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports2, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports2, "isAminoMsgVote", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVote;
    } });
    Object.defineProperty(exports2, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVoteWeighted;
    } });
    var messages_5 = require_messages5();
    Object.defineProperty(exports2, "govTypes", { enumerable: true, get: function() {
      return messages_5.govTypes;
    } });
    Object.defineProperty(exports2, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteWeightedEncodeObject;
    } });
    var queries_6 = require_queries6();
    Object.defineProperty(exports2, "setupGovExtension", { enumerable: true, get: function() {
      return queries_6.setupGovExtension;
    } });
    var aminomessages_8 = require_aminomessages8();
    Object.defineProperty(exports2, "createGroupAminoConverters", { enumerable: true, get: function() {
      return aminomessages_8.createGroupAminoConverters;
    } });
    var messages_6 = require_messages6();
    Object.defineProperty(exports2, "groupTypes", { enumerable: true, get: function() {
      return messages_6.groupTypes;
    } });
    var aminomessages_9 = require_aminomessages9();
    Object.defineProperty(exports2, "createIbcAminoConverters", { enumerable: true, get: function() {
      return aminomessages_9.createIbcAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return aminomessages_9.isAminoMsgTransfer;
    } });
    var messages_7 = require_messages7();
    Object.defineProperty(exports2, "ibcTypes", { enumerable: true, get: function() {
      return messages_7.ibcTypes;
    } });
    Object.defineProperty(exports2, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgTransferEncodeObject;
    } });
    var queries_7 = require_queries7();
    Object.defineProperty(exports2, "setupIbcExtension", { enumerable: true, get: function() {
      return queries_7.setupIbcExtension;
    } });
    var queries_8 = require_queries8();
    Object.defineProperty(exports2, "setupMintExtension", { enumerable: true, get: function() {
      return queries_8.setupMintExtension;
    } });
    var aminomessages_10 = require_aminomessages10();
    Object.defineProperty(exports2, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_10.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgUnjail;
    } });
    var queries_9 = require_queries9();
    Object.defineProperty(exports2, "setupSlashingExtension", { enumerable: true, get: function() {
      return queries_9.setupSlashingExtension;
    } });
    var aminomessages_11 = require_aminomessages11();
    Object.defineProperty(exports2, "createStakingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_11.createStakingAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports2, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports2, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports2, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports2, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgUndelegate;
    } });
    var messages_8 = require_messages8();
    Object.defineProperty(exports2, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "stakingTypes", { enumerable: true, get: function() {
      return messages_8.stakingTypes;
    } });
    var queries_10 = require_queries10();
    Object.defineProperty(exports2, "setupStakingExtension", { enumerable: true, get: function() {
      return queries_10.setupStakingExtension;
    } });
    var queries_11 = require_queries11();
    Object.defineProperty(exports2, "setupTxExtension", { enumerable: true, get: function() {
      return queries_11.setupTxExtension;
    } });
    var aminomessages_12 = require_aminomessages12();
    Object.defineProperty(exports2, "createVestingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_12.createVestingAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return aminomessages_12.isAminoMsgCreateVestingAccount;
    } });
    var messages_9 = require_messages9();
    Object.defineProperty(exports2, "vestingTypes", { enumerable: true, get: function() {
      return messages_9.vestingTypes;
    } });
  }
});

// node_modules/@cosmjs/stargate/build/multisignature.js
var require_multisignature = __commonJS({
  "node_modules/@cosmjs/stargate/build/multisignature.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeMultisignedTxBytes = exports2.makeMultisignedTx = exports2.makeCompactBitArray = void 0;
    var amino_1 = require_build7();
    var encoding_1 = require_build();
    var proto_signing_1 = require_build8();
    var multisig_1 = require_multisig();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    var tx_2 = require_tx();
    function makeCompactBitArray(bits) {
      const byteCount = Math.ceil(bits.length / 8);
      const extraBits = bits.length - Math.floor(bits.length / 8) * 8;
      const bytes = new Uint8Array(byteCount);
      bits.forEach((value, index) => {
        const bytePos = Math.floor(index / 8);
        const bitPos = index % 8;
        if (value)
          bytes[bytePos] |= 1 << 8 - 1 - bitPos;
      });
      return multisig_1.CompactBitArray.fromPartial({ elems: bytes, extraBitsStored: extraBits });
    }
    exports2.makeCompactBitArray = makeCompactBitArray;
    function makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const addresses = Array.from(signatures.keys());
      const prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;
      const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);
      const signaturesList = new Array();
      for (let i = 0; i < multisigPubkey.value.pubkeys.length; i++) {
        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);
        const signature = signatures.get(signerAddress);
        if (signature) {
          signers[i] = true;
          signaturesList.push(signature);
        }
      }
      const signerInfo = {
        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),
        modeInfo: {
          multi: {
            bitarray: makeCompactBitArray(signers),
            modeInfos: signaturesList.map((_) => ({ single: { mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
          }
        },
        sequence: BigInt(sequence)
      };
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: [signerInfo],
        fee: {
          amount: [...fee.amount],
          gasLimit: BigInt(fee.gas)
        }
      });
      const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();
      const signedTx = tx_2.TxRaw.fromPartial({
        bodyBytes,
        authInfoBytes,
        signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({ signatures: signaturesList })).finish()]
      });
      return signedTx;
    }
    exports2.makeMultisignedTx = makeMultisignedTx;
    function makeMultisignedTxBytes(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const signedTx = makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures);
      return Uint8Array.from(tx_2.TxRaw.encode(signedTx).finish());
    }
    exports2.makeMultisignedTxBytes = makeMultisignedTxBytes;
  }
});

// node_modules/@cosmjs/stargate/build/search.js
var require_search = __commonJS({
  "node_modules/@cosmjs/stargate/build/search.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSearchTxQueryArray = void 0;
    function isSearchTxQueryArray(query) {
      return Array.isArray(query);
    }
    exports2.isSearchTxQueryArray = isSearchTxQueryArray;
  }
});

// node_modules/@cosmjs/stargate/build/stargateclient.js
var require_stargateclient = __commonJS({
  "node_modules/@cosmjs/stargate/build/stargateclient.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StargateClient = exports2.BroadcastTxError = exports2.assertIsDeliverTxFailure = exports2.assertIsDeliverTxSuccess = exports2.isDeliverTxSuccess = exports2.isDeliverTxFailure = exports2.TimeoutError = void 0;
    var amino_1 = require_build7();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var tendermint_rpc_1 = require_build6();
    var utils_1 = require_build3();
    var abci_1 = require_abci();
    var accounts_1 = require_accounts();
    var events_1 = require_events();
    var modules_1 = require_modules();
    var queryclient_1 = require_queryclient2();
    var search_1 = require_search();
    var TimeoutError = class extends Error {
      constructor(message, txId) {
        super(message);
        this.txId = txId;
      }
    };
    exports2.TimeoutError = TimeoutError;
    function isDeliverTxFailure(result) {
      return !!result.code;
    }
    exports2.isDeliverTxFailure = isDeliverTxFailure;
    function isDeliverTxSuccess(result) {
      return !isDeliverTxFailure(result);
    }
    exports2.isDeliverTxSuccess = isDeliverTxSuccess;
    function assertIsDeliverTxSuccess(result) {
      if (isDeliverTxFailure(result)) {
        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    exports2.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;
    function assertIsDeliverTxFailure(result) {
      if (isDeliverTxSuccess(result)) {
        throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    exports2.assertIsDeliverTxFailure = assertIsDeliverTxFailure;
    var BroadcastTxError = class extends Error {
      constructor(code, codespace, log) {
        super(`Broadcasting transaction failed with code ${code} (codespace: ${codespace}). Log: ${log}`);
        this.code = code;
        this.codespace = codespace;
        this.log = log;
      }
    };
    exports2.BroadcastTxError = BroadcastTxError;
    var StargateClient = class _StargateClient {
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `create`.
       */
      static async connect(endpoint, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _StargateClient.create(cometClient, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static async create(cometClient, options = {}) {
        return new _StargateClient(cometClient, options);
      }
      constructor(cometClient, options) {
        if (cometClient) {
          this.cometClient = cometClient;
          this.queryClient = queryclient_1.QueryClient.withExtensions(cometClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);
        }
        const { accountParser = accounts_1.accountFromAny } = options;
        this.accountParser = accountParser;
      }
      getCometClient() {
        return this.cometClient;
      }
      forceGetCometClient() {
        if (!this.cometClient) {
          throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
        }
        return this.cometClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetCometClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetCometClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? this.accountParser(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetCometClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      /**
       * Queries all balances for all denoms that belong to this address.
       *
       * Uses the grpc queries (which iterates over the store internally), and we cannot get
       * proofs from such a method.
       */
      async getAllBalances(address) {
        return this.forceGetQueryClient().bank.allBalances(address);
      }
      async getBalanceStaked(address) {
        const allDelegations = [];
        let startAtKey = void 0;
        do {
          const { delegationResponses, pagination } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);
          const loadedDelegations = delegationResponses || [];
          allDelegations.push(...loadedDelegations);
          startAtKey = pagination == null ? void 0 : pagination.nextKey;
        } while (startAtKey !== void 0 && startAtKey.length !== 0);
        const sumValues = allDelegations.reduce((previousValue, currentValue) => {
          (0, utils_1.assert)(currentValue.balance);
          return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;
        }, null);
        return sumValues;
      }
      async getDelegation(delegatorAddress, validatorAddress) {
        var _a;
        let delegatedAmount;
        try {
          delegatedAmount = (_a = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse) == null ? void 0 : _a.balance;
        } catch (e) {
          if (e.toString().includes("key not found")) {
          } else {
            throw e;
          }
        }
        return delegatedAmount || null;
      }
      async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
      }
      async searchTx(query) {
        let rawQuery;
        if (typeof query === "string") {
          rawQuery = query;
        } else if ((0, search_1.isSearchTxQueryArray)(query)) {
          rawQuery = query.map((t) => {
            if (typeof t.value === "string")
              return `${t.key}='${t.value}'`;
            else
              return `${t.key}=${t.value}`;
          }).join(" AND ");
        } else {
          throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
        }
        return this.txsQuery(rawQuery);
      }
      disconnect() {
        if (this.cometClient)
          this.cometClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            txIndex: result.txIndex,
            events: result.events,
            rawLog: result.rawLog,
            transactionHash: txId,
            msgResponses: result.msgResponses,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const transactionId = await this.broadcastTxSync(tx);
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      /**
       * Broadcasts a signed transaction to the network without monitoring it.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
       * usually needs to check if the transaction was included in a block and was successful.
       *
       * @returns Returns the hash of the transaction
       */
      async broadcastTxSync(tx) {
        const broadcasted = await this.forceGetCometClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return transactionId;
      }
      async txsQuery(query) {
        const results = await this.forceGetCometClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          const txMsgData = abci_1.TxMsgData.decode(tx.result.data ?? new Uint8Array());
          return {
            height: tx.height,
            txIndex: tx.index,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            events: tx.result.events.map(events_1.fromTendermintEvent),
            rawLog: tx.result.log || "",
            tx: tx.tx,
            msgResponses: txMsgData.msgResponses,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports2.StargateClient = StargateClient;
  }
});

// node_modules/@cosmjs/stargate/build/signingstargateclient.js
var require_signingstargateclient = __commonJS({
  "node_modules/@cosmjs/stargate/build/signingstargateclient.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SigningStargateClient = exports2.createDefaultAminoConverters = exports2.defaultRegistryTypes = void 0;
    var amino_1 = require_build7();
    var encoding_1 = require_build();
    var math_1 = require_build2();
    var proto_signing_1 = require_build8();
    var tendermint_rpc_1 = require_build6();
    var utils_1 = require_build3();
    var coin_1 = require_coin();
    var tx_1 = require_tx4();
    var tx_2 = require_tx13();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx9();
    var aminotypes_1 = require_aminotypes();
    var fee_1 = require_fee();
    var modules_1 = require_modules();
    var modules_2 = require_modules();
    var stargateclient_1 = require_stargateclient();
    exports2.defaultRegistryTypes = [
      ["/cosmos.base.v1beta1.Coin", coin_1.Coin],
      ...modules_1.authzTypes,
      ...modules_1.bankTypes,
      ...modules_1.distributionTypes,
      ...modules_1.feegrantTypes,
      ...modules_1.govTypes,
      ...modules_1.groupTypes,
      ...modules_1.stakingTypes,
      ...modules_1.ibcTypes,
      ...modules_1.vestingTypes
    ];
    function createDefaultAminoConverters() {
      return {
        ...(0, modules_2.createAuthzAminoConverters)(),
        ...(0, modules_2.createBankAminoConverters)(),
        ...(0, modules_2.createDistributionAminoConverters)(),
        ...(0, modules_2.createGovAminoConverters)(),
        ...(0, modules_2.createStakingAminoConverters)(),
        ...(0, modules_2.createIbcAminoConverters)(),
        ...(0, modules_2.createFeegrantAminoConverters)(),
        ...(0, modules_2.createVestingAminoConverters)()
      };
    }
    exports2.createDefaultAminoConverters = createDefaultAminoConverters;
    var SigningStargateClient = class _SigningStargateClient extends stargateclient_1.StargateClient {
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `createWithSigner`.
       */
      static async connectWithSigner(endpoint, signer, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _SigningStargateClient.createWithSigner(cometClient, signer, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static async createWithSigner(cometClient, signer, options = {}) {
        return new _SigningStargateClient(cometClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new _SigningStargateClient(void 0, signer, options);
      }
      constructor(cometClient, signer, options) {
        super(cometClient, options);
        this.defaultGasMultiplier = 1.4;
        const { registry = new proto_signing_1.Registry(exports2.defaultRegistryTypes), aminoTypes = new aminotypes_1.AminoTypes(createDefaultAminoConverters()) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({
            delegatorAddress,
            validatorAddress
          })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);
      }
      /**
       * @deprecated This API does not support setting the memo field of `MsgTransfer` (only the transaction memo).
       * We'll remove this method at some point because trying to wrap the various message types is a losing strategy.
       * Please migrate to `signAndBroadcast` with an `MsgTransferEncodeObject` created in the caller code instead.
       * @see https://github.com/cosmos/cosmjs/issues/1493
       */
      async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, fee, memo = "") {
        const timeoutTimestampNanoseconds = timeoutTimestamp ? BigInt(timeoutTimestamp) * BigInt(1e9) : void 0;
        const transferMsg = {
          typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
          value: tx_4.MsgTransfer.fromPartial({
            sourcePort,
            sourceChannel,
            sender: senderAddress,
            receiver: recipientAddress,
            token: transferAmount,
            timeoutHeight,
            timeoutTimestamp: timeoutTimestampNanoseconds
          })
        };
        return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);
      }
      async signAndBroadcast(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      /**
       * This method is useful if you want to send a transaction in broadcast,
       * without waiting for it to be placed inside a block, because for example
       * I would like to receive the hash to later track the transaction with another tool.
       * @returns Returns the hash of the transaction
       */
      async signAndBroadcastSync(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTxSync(txBytes);
      }
      /**
       * Gets account number and sequence from the API, creates a sign doc,
       * creates a single signature and assembles the signed transaction.
       *
       * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
       *
       * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
       * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
       * (See the SigningStargateClient.offline constructor).
       */
      async sign(signerAddress, messages, fee, memo, explicitSignerData, timeoutHeight) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData, timeoutHeight) : this.signAmino(signerAddress, messages, fee, memo, signerData, timeoutHeight);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
          memo: signed.memo,
          timeoutHeight
        };
        const signedTxBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: signedTxBody
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo,
            timeoutHeight
          }
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports2.SigningStargateClient = SigningStargateClient;
  }
});

// node_modules/@cosmjs/stargate/build/index.js
var require_build10 = __commonJS({
  "node_modules/@cosmjs/stargate/build/index.js"(exports2) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMsgVoteWeightedEncodeObject = exports2.isMsgVoteEncodeObject = exports2.isMsgUndelegateEncodeObject = exports2.isMsgTransferEncodeObject = exports2.isMsgSubmitProposalEncodeObject = exports2.isMsgSendEncodeObject = exports2.isMsgEditValidatorEncodeObject = exports2.isMsgDepositEncodeObject = exports2.isMsgDelegateEncodeObject = exports2.isMsgCreateValidatorEncodeObject = exports2.isMsgCancelUnbondingDelegationEncodeObject = exports2.isMsgBeginRedelegateEncodeObject = exports2.isAminoMsgWithdrawValidatorCommission = exports2.isAminoMsgWithdrawDelegatorReward = exports2.isAminoMsgVoteWeighted = exports2.isAminoMsgVote = exports2.isAminoMsgVerifyInvariant = exports2.isAminoMsgUnjail = exports2.isAminoMsgUndelegate = exports2.isAminoMsgTransfer = exports2.isAminoMsgSubmitProposal = exports2.isAminoMsgSubmitEvidence = exports2.isAminoMsgSetWithdrawAddress = exports2.isAminoMsgSend = exports2.isAminoMsgMultiSend = exports2.isAminoMsgFundCommunityPool = exports2.isAminoMsgEditValidator = exports2.isAminoMsgDeposit = exports2.isAminoMsgDelegate = exports2.isAminoMsgCreateVestingAccount = exports2.isAminoMsgCreateValidator = exports2.isAminoMsgBeginRedelegate = exports2.createVestingAminoConverters = exports2.createStakingAminoConverters = exports2.createSlashingAminoConverters = exports2.createIbcAminoConverters = exports2.createGroupAminoConverters = exports2.createGovAminoConverters = exports2.createFeegrantAminoConverters = exports2.createEvidenceAminoConverters = exports2.createDistributionAminoConverters = exports2.createCrysisAminoConverters = exports2.createBankAminoConverters = exports2.createAuthzAminoConverters = exports2.logs = exports2.GasPrice = exports2.calculateFee = exports2.fromTendermintEvent = exports2.AminoTypes = exports2.accountFromAny = void 0;
    exports2.parseCoins = exports2.makeCosmoshubPath = exports2.coins = exports2.coin = exports2.TimeoutError = exports2.StargateClient = exports2.isDeliverTxSuccess = exports2.isDeliverTxFailure = exports2.BroadcastTxError = exports2.assertIsDeliverTxSuccess = exports2.assertIsDeliverTxFailure = exports2.SigningStargateClient = exports2.defaultRegistryTypes = exports2.createDefaultAminoConverters = exports2.isSearchTxQueryArray = exports2.QueryClient = exports2.decodeCosmosSdkDecFromProto = exports2.createProtobufRpcClient = exports2.createPagination = exports2.makeMultisignedTxBytes = exports2.makeMultisignedTx = exports2.setupTxExtension = exports2.setupStakingExtension = exports2.setupSlashingExtension = exports2.setupMintExtension = exports2.setupIbcExtension = exports2.setupGovExtension = exports2.setupFeegrantExtension = exports2.setupDistributionExtension = exports2.setupBankExtension = exports2.setupAuthzExtension = exports2.setupAuthExtension = exports2.isMsgWithdrawDelegatorRewardEncodeObject = void 0;
    var accounts_1 = require_accounts();
    Object.defineProperty(exports2, "accountFromAny", { enumerable: true, get: function() {
      return accounts_1.accountFromAny;
    } });
    var aminotypes_1 = require_aminotypes();
    Object.defineProperty(exports2, "AminoTypes", { enumerable: true, get: function() {
      return aminotypes_1.AminoTypes;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "fromTendermintEvent", { enumerable: true, get: function() {
      return events_1.fromTendermintEvent;
    } });
    var fee_1 = require_fee();
    Object.defineProperty(exports2, "calculateFee", { enumerable: true, get: function() {
      return fee_1.calculateFee;
    } });
    Object.defineProperty(exports2, "GasPrice", { enumerable: true, get: function() {
      return fee_1.GasPrice;
    } });
    exports2.logs = __importStar(require_logs());
    var modules_1 = require_modules();
    Object.defineProperty(exports2, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return modules_1.createAuthzAminoConverters;
    } });
    Object.defineProperty(exports2, "createBankAminoConverters", { enumerable: true, get: function() {
      return modules_1.createBankAminoConverters;
    } });
    Object.defineProperty(exports2, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return modules_1.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports2, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return modules_1.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports2, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return modules_1.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports2, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return modules_1.createFeegrantAminoConverters;
    } });
    Object.defineProperty(exports2, "createGovAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGovAminoConverters;
    } });
    Object.defineProperty(exports2, "createGroupAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGroupAminoConverters;
    } });
    Object.defineProperty(exports2, "createIbcAminoConverters", { enumerable: true, get: function() {
      return modules_1.createIbcAminoConverters;
    } });
    Object.defineProperty(exports2, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports2, "createStakingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createStakingAminoConverters;
    } });
    Object.defineProperty(exports2, "createVestingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createVestingAminoConverters;
    } });
    Object.defineProperty(exports2, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports2, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports2, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateVestingAccount;
    } });
    Object.defineProperty(exports2, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports2, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports2, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports2, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return modules_1.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports2, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports2, "isAminoMsgSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSend;
    } });
    Object.defineProperty(exports2, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports2, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitEvidence;
    } });
    Object.defineProperty(exports2, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports2, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return modules_1.isAminoMsgTransfer;
    } });
    Object.defineProperty(exports2, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUndelegate;
    } });
    Object.defineProperty(exports2, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUnjail;
    } });
    Object.defineProperty(exports2, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVerifyInvariant;
    } });
    Object.defineProperty(exports2, "isAminoMsgVote", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVote;
    } });
    Object.defineProperty(exports2, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVoteWeighted;
    } });
    Object.defineProperty(exports2, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports2, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawValidatorCommission;
    } });
    Object.defineProperty(exports2, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSendEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgTransferEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteWeightedEncodeObject;
    } });
    Object.defineProperty(exports2, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    Object.defineProperty(exports2, "setupAuthExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthExtension;
    } });
    Object.defineProperty(exports2, "setupAuthzExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthzExtension;
    } });
    Object.defineProperty(exports2, "setupBankExtension", { enumerable: true, get: function() {
      return modules_1.setupBankExtension;
    } });
    Object.defineProperty(exports2, "setupDistributionExtension", { enumerable: true, get: function() {
      return modules_1.setupDistributionExtension;
    } });
    Object.defineProperty(exports2, "setupFeegrantExtension", { enumerable: true, get: function() {
      return modules_1.setupFeegrantExtension;
    } });
    Object.defineProperty(exports2, "setupGovExtension", { enumerable: true, get: function() {
      return modules_1.setupGovExtension;
    } });
    Object.defineProperty(exports2, "setupIbcExtension", { enumerable: true, get: function() {
      return modules_1.setupIbcExtension;
    } });
    Object.defineProperty(exports2, "setupMintExtension", { enumerable: true, get: function() {
      return modules_1.setupMintExtension;
    } });
    Object.defineProperty(exports2, "setupSlashingExtension", { enumerable: true, get: function() {
      return modules_1.setupSlashingExtension;
    } });
    Object.defineProperty(exports2, "setupStakingExtension", { enumerable: true, get: function() {
      return modules_1.setupStakingExtension;
    } });
    Object.defineProperty(exports2, "setupTxExtension", { enumerable: true, get: function() {
      return modules_1.setupTxExtension;
    } });
    var multisignature_1 = require_multisignature();
    Object.defineProperty(exports2, "makeMultisignedTx", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTx;
    } });
    Object.defineProperty(exports2, "makeMultisignedTxBytes", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTxBytes;
    } });
    var queryclient_1 = require_queryclient2();
    Object.defineProperty(exports2, "createPagination", { enumerable: true, get: function() {
      return queryclient_1.createPagination;
    } });
    Object.defineProperty(exports2, "createProtobufRpcClient", { enumerable: true, get: function() {
      return queryclient_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports2, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return queryclient_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports2, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var search_1 = require_search();
    Object.defineProperty(exports2, "isSearchTxQueryArray", { enumerable: true, get: function() {
      return search_1.isSearchTxQueryArray;
    } });
    var signingstargateclient_1 = require_signingstargateclient();
    Object.defineProperty(exports2, "createDefaultAminoConverters", { enumerable: true, get: function() {
      return signingstargateclient_1.createDefaultAminoConverters;
    } });
    Object.defineProperty(exports2, "defaultRegistryTypes", { enumerable: true, get: function() {
      return signingstargateclient_1.defaultRegistryTypes;
    } });
    Object.defineProperty(exports2, "SigningStargateClient", { enumerable: true, get: function() {
      return signingstargateclient_1.SigningStargateClient;
    } });
    var stargateclient_1 = require_stargateclient();
    Object.defineProperty(exports2, "assertIsDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxFailure;
    } });
    Object.defineProperty(exports2, "assertIsDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxSuccess;
    } });
    Object.defineProperty(exports2, "BroadcastTxError", { enumerable: true, get: function() {
      return stargateclient_1.BroadcastTxError;
    } });
    Object.defineProperty(exports2, "isDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxFailure;
    } });
    Object.defineProperty(exports2, "isDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxSuccess;
    } });
    Object.defineProperty(exports2, "StargateClient", { enumerable: true, get: function() {
      return stargateclient_1.StargateClient;
    } });
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return stargateclient_1.TimeoutError;
    } });
    var proto_signing_1 = require_build8();
    Object.defineProperty(exports2, "coin", { enumerable: true, get: function() {
      return proto_signing_1.coin;
    } });
    Object.defineProperty(exports2, "coins", { enumerable: true, get: function() {
      return proto_signing_1.coins;
    } });
    Object.defineProperty(exports2, "makeCosmoshubPath", { enumerable: true, get: function() {
      return proto_signing_1.makeCosmoshubPath;
    } });
    Object.defineProperty(exports2, "parseCoins", { enumerable: true, get: function() {
      return proto_signing_1.parseCoins;
    } });
  }
});

export {
  require_any,
  require_signing,
  require_tx,
  require_build7 as require_build,
  require_wallet2 as require_wallet,
  require_tx2,
  require_build8 as require_build2,
  require_accounts,
  require_minimal2 as require_minimal,
  require_authz,
  require_tx3,
  require_tx4,
  require_tx13 as require_tx5,
  require_abci,
  require_service2 as require_service,
  require_build10 as require_build3
};
//# sourceMappingURL=chunk-GHUP3OSQ.js.map
