// src/client/BatchCosmWasmClient.ts
import { CosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import {
  HttpBatchClient,
  Tendermint34Client
} from "@cosmjs/tendermint-rpc";
var DEFAULT_BATCH_SIZE_LIMIT = 25;
var DEFAULT_DISPATCH_INTERVAL = 300;
var DEFAULT_BATCH_COSMWASM_CLIENT_OPTIONS = {
  batchSizeLimit: DEFAULT_BATCH_SIZE_LIMIT,
  dispatchInterval: DEFAULT_DISPATCH_INTERVAL
};
var BatchCosmWasmClient = class extends CosmWasmClient {
  constructor(tmClient, options = DEFAULT_BATCH_COSMWASM_CLIENT_OPTIONS) {
    super(tmClient);
    this._batchSizeLimit = options.batchSizeLimit;
    this._dispatchInterval = options.dispatchInterval;
  }
  /**
   * Connect to a endpoint with a new BatchCosmWasmClient.
   * @param {string} endpoint - The endpoint to connect to.
   * @param {BatchCosmWasmClientOptions} options - The options for the HTTP Batch Client.
   * @return {BatchCosmWasmClient} The new BatchCosmWasmClient.
   */
  static async connect(endpoint, options = DEFAULT_BATCH_COSMWASM_CLIENT_OPTIONS) {
    const tendermint = await Tendermint34Client.create(
      new HttpBatchClient(endpoint, {
        batchSizeLimit: options.batchSizeLimit,
        dispatchInterval: options.dispatchInterval
      })
    );
    return new this(tendermint, options);
  }
  /**
   * Get the batch size limit.
   * @return {number} The batch size limit.
   */
  get batchSizeLimit() {
    return this._batchSizeLimit;
  }
  /**
   * Get the dispatch interval.
   * @return {number} The dispatch interval.
   */
  get dispatchInterval() {
    return this._dispatchInterval;
  }
};

// src/client/MultiqueryCosmWasmClient.ts
import { CosmWasmClient as CosmWasmClient2 } from "@cosmjs/cosmwasm-stargate";
import { fromBase64, fromUtf8, toBase64, toUtf8 } from "@cosmjs/encoding";
import { HttpBatchClient as HttpBatchClient2, Tendermint34Client as Tendermint34Client2 } from "@cosmjs/tendermint-rpc";
var jsonToUtf8 = (json) => toUtf8(JSON.stringify(json));
var jsonToBinary = (json) => toBase64(jsonToUtf8(json));
var binaryToJson = (binary) => fromUtf8(fromBase64(binary));
var DEFAULT_BATCH_SIZE_LIMIT2 = 25;
var DEFAULT_DISPATCH_INTERVAL2 = 200;
var DEFAULT_MULTIQUERY_COSMWASM_CLIENT_OPTIONS = {
  batchSizeLimit: DEFAULT_BATCH_SIZE_LIMIT2,
  dispatchInterval: DEFAULT_DISPATCH_INTERVAL2
};
var MultiqueryCosmWasmClient = class extends CosmWasmClient2 {
  constructor(tmClient, options) {
    super(tmClient);
    this.queryQueue = [];
    this._batchSizeLimit = options.batchSizeLimit;
    this._dispatchInterval = options.dispatchInterval;
    this.multiqueryContractAddress = options.multiqueryContract;
    this.queryTimer = setInterval(
      () => this.processQueryQueue(),
      options.dispatchInterval
    );
  }
  static async connect(endpoint, options = {
    ...DEFAULT_MULTIQUERY_COSMWASM_CLIENT_OPTIONS,
    multiqueryContract: ""
  }) {
    if (!options.multiqueryContract) {
      throw new Error("Missing multiquery contract address");
    }
    const tendermint = await Tendermint34Client2.create(
      new HttpBatchClient2(endpoint, {
        batchSizeLimit: options.batchSizeLimit,
        dispatchInterval: options.dispatchInterval
      })
    );
    return new this(tendermint, options);
  }
  /**
   * Get the batch size limit.
   * @return {number} The batch size limit.
   */
  get batchSizeLimit() {
    return this._batchSizeLimit;
  }
  /**
   * Get the dispatch interval.
   * @return {number} The dispatch interval.
   */
  get dispatchInterval() {
    return this._dispatchInterval;
  }
  async queryContractSmart(address, queryMsg) {
    return new Promise((resolve, reject) => {
      this.queryQueue.push({ address, queryMsg, resolve, reject });
      if (this.queryQueue.length >= this.batchSizeLimit || address === this.multiqueryContractAddress) {
        this.processQueryQueue();
      }
    });
  }
  async queryContractsBatch(queries) {
    return Promise.all(
      queries.map(
        ({ address, queryMsg }) => this.queryContractSmart(address, queryMsg)
      )
    );
  }
  /**
   * Aggregate queries with error suppression
   * @param queries Array of contract queries to execute
   * @param requireSuccess If true, throws error when any query fails
   * @returns Array of results where data is either the successful response or error message
   */
  async tryAggregate(queries, requireSuccess = false) {
    const calls = queries.map(({ address, queryMsg }) => ({
      address,
      data: jsonToBinary(queryMsg)
    }));
    const result = await super.queryContractSmart(
      this.multiqueryContractAddress,
      {
        try_aggregate: {
          queries: calls,
          require_success: requireSuccess,
          include_cause: true
        }
      }
    );
    return result.return_data.map(({ success, data }) => {
      if (success) {
        return {
          success: true,
          data: data ? JSON.parse(binaryToJson(data)) : {},
          error: void 0
        };
      } else {
        return {
          success: false,
          data: void 0,
          error: binaryToJson(data) || "Query failed"
        };
      }
    });
  }
  /**
   * Process the accumulated query queue using tryAggregate
   */
  async processQueryQueue() {
    const batch = this.queryQueue.splice(0, this.batchSizeLimit);
    if (!batch.length)
      return;
    try {
      const queries = batch.map(({ address, queryMsg }) => ({
        address,
        queryMsg
      }));
      const results = await this.tryAggregate(queries, false);
      results.forEach((result, index) => {
        if (!batch[index])
          return;
        const { resolve, reject } = batch[index];
        if (result.success) {
          resolve(result.data);
        } else {
          reject(new Error(result.error));
        }
      });
    } catch (error) {
      batch.forEach(({ reject }) => {
        reject(error instanceof Error ? error : new Error(String(error)));
      });
    }
  }
  disconnect() {
    if (this.queryTimer) {
      clearInterval(this.queryTimer);
      this.queryTimer = void 0;
    }
    super.disconnect();
  }
};

export {
  DEFAULT_BATCH_SIZE_LIMIT,
  DEFAULT_DISPATCH_INTERVAL,
  DEFAULT_BATCH_COSMWASM_CLIENT_OPTIONS,
  BatchCosmWasmClient,
  DEFAULT_MULTIQUERY_COSMWASM_CLIENT_OPTIONS,
  MultiqueryCosmWasmClient
};
