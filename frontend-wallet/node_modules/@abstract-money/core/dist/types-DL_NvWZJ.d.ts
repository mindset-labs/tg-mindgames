import { j as AccountId$1 } from './Registry.types-tb_Smu0e.js';

/** Combines members of an intersection into a readable type. */
type Evaluate<type> = {
    [key in keyof type]: type[key];
} & unknown;
/** Strict version of built-in Omit type */
type Omit$1<type, keys extends keyof type> = Pick<type, Exclude<keyof type, keys>>;
type MaybeArray<T> = T | T[];
type SliceFirst<T extends readonly unknown[]> = T extends readonly [
    infer _,
    ...infer Rest
] ? Rest : never;
type WithOptional<T, K extends keyof T> = Omit$1<T, K> & Partial<Pick<T, K>>;

type ContractMsg = Record<string, unknown>;

type ModuleExecuteMsg<TBaseMsg, TAppMsg> = {
    base: TBaseMsg;
} | {
    module: TAppMsg;
};
type ModuleQueryMsg<TBaseMsg, TAppMsg> = {
    base: TBaseMsg;
} | {
    module: TAppMsg;
};
type ModuleInstantiateMsg<TBaseMsg extends ContractMsg, TAppMsg extends ContractMsg> = {
    base: TBaseMsg;
    module: TAppMsg;
};
/**
 * MigrateMsg for modules. Note that Adapters CANNOT be migrated.
 */
type ModuleMigrateMsg<TBaseMsg extends ContractMsg, TAppMsg extends ContractMsg | Record<string, never>> = {
    base: TBaseMsg;
    module: TAppMsg;
};
/**
 * ModuleData returned from the {@link RAW_QUERY_KEYS.ModuleData} raw query.
 */
interface ModuleData {
    module: string;
    version: string;
    dependencies: {
        id: string;
        version_req: string[];
    }[];
    metadata: unknown;
}

type Maybe<T> = T | null;
type InputMaybe<T> = Maybe<T>;
type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
/** All built-in and custom scalars, mapped to their actual values */
type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    /** A field whose value is a bech32 address: https://en.bitcoin.it/wiki/Bech32. */
    Bech32Address: {
        input: string;
        output: string;
    };
    /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
    JSON: {
        input: any;
        output: any;
    };
    /** The `SafeInt` scalar type represents non-fractional signed whole numeric values that are considered safe as defined by the ECMAScript specification. */
    SafeInt: {
        input: number;
        output: number;
    };
    /** A field whose value is a Semantic Version: https://semver.org */
    Semver: {
        input: string;
        output: string;
    };
    /** string tuple custom scalar type */
    StringSemverTuple: {
        input: any;
        output: any;
    };
    /** string tuple custom scalar type */
    StringTuple: {
        input: any;
        output: any;
    };
    _Any: {
        input: any;
        output: any;
    };
    _FieldSet: {
        input: any;
        output: any;
    };
};
/** The asset types supported by CosmWasm */
declare enum AssetType {
    Cw20 = "CW20",
    Cw1155 = "CW1155",
    Native = "NATIVE"
}
type ModuleFilter = {
    /** Filter by the module's name */
    name?: InputMaybe<Scalars['String']['input']>;
    /** Filter by the module's namespace */
    namespace?: InputMaybe<Scalars['String']['input']>;
    /** Filter by the module's status */
    status?: InputMaybe<ModuleStatus>;
    /** Filter by the module's type */
    type?: InputMaybe<ModuleType>;
    /** Filter by the module's version */
    version?: InputMaybe<Scalars['String']['input']>;
};
/** The status of a module in Version Control */
declare enum ModuleStatus {
    Pending = "PENDING",
    Registered = "REGISTERED",
    Yanked = "YANKED"
}
/** The different types of modules supported by Abstract. */
declare enum ModuleType {
    AccountBase = "account_base",
    Adapter = "adapter",
    App = "app",
    Native = "native",
    Standalone = "standalone"
}
type AccountsQuery = {
    __typename?: 'Query';
    accounts: Array<{
        __typename?: 'AbstractAccount';
        accountId: {
            __typename?: 'AccountId';
            chainName: string;
            sequence: number;
            trace?: Array<string> | null;
        };
    }>;
};
type AssetsQueryQuery = {
    __typename?: 'Query';
    ans: {
        __typename?: 'AbstractNameService';
        assets: Array<{
            __typename?: 'AnsAsset';
            id: string;
            type: AssetType;
            address: string;
        }>;
    };
};
type DeploymentQuery = {
    __typename?: 'Query';
    version: string;
    deployment: {
        __typename?: 'Deployment';
        ansHost: string;
        registry: string;
        accountFactory: string;
    };
    chainInfo: {
        __typename?: 'ChainInfo';
        rpcUrl: string;
    };
};

/**
 * AccountId is a globally unique identifier for an account.
 * The chainName is the name of the chain where the account is located.
 */
type AccountId<TChainName extends string = string> = {
    chainName: TChainName;
} & AccountId$1;
declare const ACCOUNT_ID_CHAIN_DELIMITER = ">";
declare const ACCOUNT_ID_SEQUENCE_DELIMITER = "-";

type CW20Token<TAddress extends string = string> = {
    readonly address: TAddress;
    readonly type: 'cw20';
};
declare function isCW20Token(asset: Token): asset is CW20Token;

type NativeToken<TDenom extends string = string> = {
    readonly type: 'native';
    readonly denom: TDenom;
};
declare function isNativeToken(asset: Token): asset is NativeToken;

type Token = NativeToken | CW20Token;

type AnsId<T extends string = string> = T;
type AnsToken<T extends string = string> = Token & {
    readonly id: AnsId<T>;
};

export { type AccountId as A, type CW20Token as C, type DeploymentQuery as D, type Evaluate as E, type ModuleExecuteMsg as M, type NativeToken as N, type Omit$1 as O, type SliceFirst as S, type Token as T, type WithOptional as W, ACCOUNT_ID_CHAIN_DELIMITER as a, ACCOUNT_ID_SEQUENCE_DELIMITER as b, type AnsId as c, type AnsToken as d, isNativeToken as e, type ContractMsg as f, type ModuleQueryMsg as g, type ModuleInstantiateMsg as h, isCW20Token as i, type ModuleMigrateMsg as j, type ModuleData as k, type MaybeArray as l, type Exact as m, type ModuleFilter as n, type AccountsQuery as o, type AssetsQueryQuery as p };
