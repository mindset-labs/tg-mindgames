import {
  AccountClient,
  AccountExecuteMsgBuilder,
  AccountMsgComposer,
  AccountQueryClient,
  AnsHostClient,
  AnsHostQueryClient,
  IbcClientQueryClient,
  IcaClientQueryClient,
  RegistryClient,
  RegistryQueryClient
} from "./chunk-B2V6LSMD.js";

// src/utils/account/encode-create-sub-account-msg.ts
function encodeCreateSubAccountMsg({
  sender,
  accountAddress,
  ...rest
}) {
  const composer = new AccountMsgComposer(sender, accountAddress);
  return composer.createSubAccount(rest);
}

// src/utils/account-id/account-id-api-format-to-account-id.ts
function accountIdApiFormatToAccountId({
  chainName,
  sequence,
  trace
}) {
  return {
    seq: sequence,
    trace: trace ? { remote: trace } : "local",
    chainName
  };
}

// src/utils/account-id/account-id-to-api-format.ts
function accountIdToApiFormat(id) {
  return {
    sequence: id.seq,
    trace: id.trace === "local" ? null : id.trace.remote,
    chain: id.chainName
  };
}

// src/utils/account-id/account-id-to-parameter.ts
function accountIdToParameter(id) {
  return { seq: id.seq, trace: id.trace };
}

// src/utils/account-id/account-id-to-string.ts
import * as s from "string-ts";

// src/utils/account-id/account-id.ts
var ACCOUNT_ID_CHAIN_DELIMITER = ">";
var ACCOUNT_ID_SEQUENCE_DELIMITER = "-";

// src/utils/account-id/account-id-to-string.ts
function accountIdToString(id) {
  if (id.seq < 0) {
    throw new Error(`Invalid account sequence: ${id.seq}`);
  }
  if (!id.chainName) {
    throw new Error("AccountId must have a chainName");
  }
  if (id.trace === "local") {
    if (!id.chainName) {
      throw new Error("chainName must be provided for local account ids");
    }
    return s.join([id.chainName, `${id.seq}`], ACCOUNT_ID_SEQUENCE_DELIMITER);
  }
  if (!id.trace.remote.length || id.trace.remote.some((s9) => !s9)) {
    throw new Error(`Invalid remote trace: ${JSON.stringify(id.trace.remote)}`);
  }
  const sourceChain = id.trace.remote[0];
  const baseId = s.join(
    [sourceChain, `${id.seq}`],
    ACCOUNT_ID_SEQUENCE_DELIMITER
  );
  return `${[id.chainName, ...id.trace.remote.slice(1).reverse()].join(
    ACCOUNT_ID_CHAIN_DELIMITER
  )}${ACCOUNT_ID_CHAIN_DELIMITER}${baseId}`;
}

// src/utils/account-id/seq-to-local-account-id.ts
function sequenceToLocalAccountId({
  chainName,
  sequence
}) {
  return {
    seq: sequence,
    trace: "local",
    chainName
  };
}

// src/utils/account-id/string-to-account-id.ts
function stringToAccountId(value, chainName) {
  const [chainString, sequenceStr] = value.split(ACCOUNT_ID_SEQUENCE_DELIMITER);
  if (!chainString || !sequenceStr) {
    throw new Error(`Cannot find chain or sequence for account: ${value}`);
  }
  const accountSequence = Number.parseInt(sequenceStr);
  if (chainString === "local") {
    if (!chainName)
      throw new Error("chainName must be provided for local account ids");
    return {
      chainName,
      seq: accountSequence,
      trace: "local"
    };
  }
  const splitChainString = chainString.split(ACCOUNT_ID_CHAIN_DELIMITER);
  if (splitChainString.some((s9) => !s9)) {
    throw new Error(`Invalid chain string in account id ${value}`);
  }
  const accountSourceChain = splitChainString.length > 1 ? splitChainString[0] : chainString;
  if (!accountSourceChain) {
    throw new Error(
      `Account must have source chain when not a local one: ${value}`
    );
  }
  if (chainName && chainName !== accountSourceChain) {
    throw new Error(
      `chainName ${chainName} does not match chain in account id ${value}`
    );
  }
  if (splitChainString.length === 1) {
    return {
      chainName: accountSourceChain,
      seq: accountSequence,
      trace: "local"
    };
  }
  return {
    chainName: accountSourceChain,
    seq: accountSequence,
    trace: {
      // The remote trace is reversed
      remote: splitChainString.slice(1, splitChainString.length).reverse()
    }
  };
}

// src/utils/account-id/registry-account-id-to-string.ts
function registryAccountIdToString(id) {
  if (id.trace === "local") {
    return `local-${id.seq}`;
  }
  return `${id.trace.remote.join(
    ACCOUNT_ID_CHAIN_DELIMITER
  )}${ACCOUNT_ID_CHAIN_DELIMITER}${id.seq}`;
}

// src/utils/events.ts
function findAttribute(events, eventType, attrKey) {
  const out = events?.filter(({ type }) => type === eventType)?.flatMap(({ attributes }) => attributes)?.find(({ key }) => key === attrKey);
  if (!out) {
    throw new Error(
      `Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`
    );
  }
  return out;
}
var ABSTRACT_EVENT_MARKER = "wasm-abstract";
function findAbstractAttribute(executeResult, key) {
  return findAttribute(
    executeResult.logs && executeResult.logs?.length > 0 ? executeResult.logs?.[0]?.events : executeResult.events,
    ABSTRACT_EVENT_MARKER,
    key
  );
}

// src/utils/account-factory/parse-create-account-execute-result.ts
function parseCreateAccountExecuteResult(result, chainName) {
  const accountIdString = findAbstractAttribute(result, "account_id").value;
  const accountId = stringToAccountId(accountIdString, chainName);
  const accountAddress = findAbstractAttribute(result, "account_address").value;
  return { accountId, accountAddress };
}

// src/utils/module-factory/get-instantiate2-address.ts
import { instantiate2Address } from "@cosmjs/cosmwasm-stargate";
import { fromHex, toUtf8 as toUtf82 } from "@cosmjs/encoding";
import { bech32 } from "bech32";

// src/utils/encoding.ts
import { fromBase64, fromUtf8, toBase64, toUtf8 } from "@cosmjs/encoding";
var jsonToUtf8 = (json) => toUtf8(JSON.stringify(json));
var utf8ToJson = (binary) => JSON.parse(fromUtf8(binary));
var jsonToBinary = (json) => toBase64(jsonToUtf8(json));
var binaryToJson = (binary) => fromUtf8(fromBase64(binary));
var toUint8Array = (text) => Uint8Array.from(Array.from(text).map((letter) => letter.charCodeAt(0)));
var toSha256 = async (text) => {
  const data = toUtf8(text);
  const hash = await crypto.subtle.digest("SHA-256", data);
  return new Uint8Array(hash);
};

// src/utils/module-factory/get-instantiate2-address.ts
var SALT_POSTFIX = "abstract";
async function getAccountIdSalt(accountId) {
  const sha256 = await toSha256(registryAccountIdToString(accountId));
  return new Uint8Array([...sha256, ...toUtf82(SALT_POSTFIX)]);
}
async function getInstantiate2AddressWithAccountId(creatorAddress, codeIdChecksum, accountId) {
  const salt = await getAccountIdSalt(accountId);
  return getInstantiate2Address(creatorAddress, codeIdChecksum, salt);
}
async function getInstantiate2Address(creatorAddress, codeIdChecksum, salt) {
  const hexedChecksum = fromHex(codeIdChecksum);
  const saltBytes = typeof salt === "string" ? toUtf82(salt) : salt;
  const prefix = bech32.decode(creatorAddress).prefix;
  return instantiate2Address(hexedChecksum, creatorAddress, saltBytes, prefix);
}

// src/utils/assets/coin/coin-to-native-asset.ts
function coinToNativeAsset(value) {
  return {
    denom: value.denom,
    amount: value.amount,
    type: "native"
  };
}

// src/utils/tokens/cw20/types.ts
function isCW20Token(asset) {
  return asset.type === "cw20";
}

// src/utils/assets/cw20/types.ts
function isCW20Asset(asset) {
  return isCW20Token(asset);
}

// src/utils/assets/cw20/asset-to-cw20-asset.ts
function assetToCW20Asset(asset) {
  if (isCW20Asset(asset))
    return asset;
  throw new Error("Asset is not a CW20 asset");
}

// src/utils/assets/cw20/encode-cw20-asset-send-msg.ts
import { MsgExecuteContract } from "cosmjs-types/cosmwasm/wasm/v1/tx";
function encodeCW20AssetSendMsg(asset, sender, msg) {
  return {
    typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
    value: MsgExecuteContract.fromPartial({
      sender,
      contract: asset.address,
      msg: jsonToUtf8({
        send: {
          amount: asset.amount,
          contract: asset.address,
          msg: typeof msg === "string" ? msg : jsonToBinary(msg)
        }
      })
    })
  };
}

// src/utils/assets/cw20/encode-cw20-asset-transfer-msg.ts
function encodeCW20AssetTransferMsg(asset, sender, recipient) {
  return {
    typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
    value: {
      contract: asset.address,
      sender,
      msg: jsonToUtf8({
        transfer: {
          amount: asset.amount,
          recipient
        }
      })
    }
  };
}

// src/utils/assets/native/encode-native-asset-transfer-msg.ts
function encodeNativeAssetTransferMsg(asset, fromAddress, toAddress) {
  return {
    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
    value: {
      fromAddress,
      toAddress,
      amount: [
        {
          denom: asset.denom,
          amount: asset.amount
        }
      ]
    }
  };
}

// src/utils/assets/native/native-asset-to-coin.ts
function nativeAssetToCoin(asset) {
  return {
    denom: asset.denom,
    amount: asset.amount
  };
}

// src/utils/tokens/native/types.ts
function isNativeToken(asset) {
  return asset.type === "native";
}

// src/utils/assets/native/types.ts
function isNativeAsset(asset) {
  return isNativeToken(asset);
}

// src/utils/assets/asset-to-native-asset.ts
function assetToNativeAsset(asset) {
  if (isNativeAsset(asset))
    return asset;
  throw new Error("Asset is not a Native asset");
}

// src/utils/assets/encode-asset-transfer-msg.ts
function encodeAssetTransferMsg(asset, sender, recipient) {
  if (isNativeAsset(asset)) {
    return encodeNativeAssetTransferMsg(asset, sender, recipient);
  }
  if (isCW20Asset(asset)) {
    return encodeCW20AssetTransferMsg(asset, sender, recipient);
  }
  throw new Error(`Asset type not supported: ${JSON.stringify(asset, null, 2)}`);
}

// src/utils/assets/encode-assets-account-transfer-msgs.ts
import { toBase64 as toBase642 } from "@cosmjs/encoding";

// src/utils/assets/encode-assets-transfer-msgs.ts
function encodeAssetsTransfersMsgs(assets2, sender, recipient) {
  const nativeAssets = [];
  const cw20Assets = [];
  for (const asset of assets2) {
    if (isNativeAsset(asset)) {
      nativeAssets.push(asset);
    } else if (isCW20Asset(asset)) {
      cw20Assets.push(asset);
    } else {
      throw new Error(
        `Asset type not supported: ${JSON.stringify(asset, null, 2)}`
      );
    }
  }
  const msgs = [];
  if (nativeAssets.length > 0) {
    const nativeCoins = nativeAssets.map((asset) => nativeAssetToCoin(asset));
    const sendMsg = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSend",
      value: {
        fromAddress: sender,
        toAddress: recipient,
        // the denominations must be sorted alphabetically
        amount: nativeCoins.sort((a, b) => a.denom.localeCompare(b.denom))
      }
    };
    msgs.push(sendMsg);
  }
  cw20Assets.forEach((asset) => {
    msgs.push(encodeCW20AssetTransferMsg(asset, sender, recipient));
  });
  return msgs;
}

// src/utils/assets/encode-assets-account-transfer-msgs.ts
function encodeAssetsAccountTransferMsgs(assets2, sender, recipient) {
  const msgs = encodeAssetsTransfersMsgs(assets2, sender, recipient);
  return msgs.map((msg) => {
    if (msg.typeUrl === "/cosmos.bank.v1beta1.MsgSend") {
      const { amount, toAddress } = msg.value;
      return {
        bank: {
          send: {
            amount,
            to_address: toAddress
          }
        }
      };
    }
    if (msg.typeUrl === "/cosmwasm.wasm.v1.MsgExecuteContract") {
      const { contract, msg: execMsg } = msg.value;
      return {
        wasm: {
          execute: {
            contract_addr: contract,
            funds: [],
            msg: toBase642(execMsg)
          }
        }
      };
    }
    throw new Error(`Unsupported message type: ${msg.typeUrl}`);
  });
}

// src/utils/chain-registry/assets.ts
import { assets as cosmosAssets } from "chain-registry";
var NIBIRU_TESTNET_ASSET_LIST = {
  $schema: "../assetlist.schemaon",
  chain_name: "nibirutestnet",
  assets: [
    {
      description: "The native staking and governance token of Nibiru",
      denom_units: [
        {
          denom: "unibi",
          exponent: 6
        }
      ],
      base: "unibi",
      name: "NIBI",
      display: "unibi",
      symbol: "NIBI"
    }
  ]
};
var assets = [
  ...cosmosAssets.filter(
    ({ chain_name }) => ![NIBIRU_TESTNET_ASSET_LIST.chain_name].includes(chain_name)
  ),
  NIBIRU_TESTNET_ASSET_LIST
];

// src/utils/chain-registry/chains.ts
import { chains as chainRegistryChains } from "chain-registry";
var LOCAL_JUNO_CHAIN = {
  $schema: "../../chain.schemaon",
  chain_name: "localjuno",
  status: "live",
  network_type: "testnet",
  pretty_name: "LocalJuno",
  chain_id: "localjuno",
  bech32_prefix: "juno",
  daemon_name: "junod",
  node_home: "$HOME/.juno",
  key_algos: ["secp256k1"],
  slip44: 118,
  fees: {
    fee_tokens: [
      {
        denom: "ujunox",
        low_gas_price: 0.03,
        average_gas_price: 0.04,
        high_gas_price: 0.05
      }
    ]
  },
  staking: {
    staking_tokens: [
      {
        denom: "ujunox"
      }
    ]
  },
  peers: {
    seeds: [],
    persistent_peers: []
  },
  apis: {
    rpc: [
      {
        address: "http://127.0.0.1:26657"
      }
    ],
    rest: [
      {
        address: "http://127.0.0.1:1317"
      }
    ],
    grpc: [
      {
        address: "http://127.0.0.1:9090"
      }
    ]
  },
  explorers: [
    {
      kind: "EZStaking Tools",
      url: "https://testnet.ezstaking.tools/juno-testnet",
      tx_page: "https://testnet.ezstaking.tools/juno-testnet/txs/${txHash}"
    }
  ]
};
var NIBIRU_TESTNET_CHAIN = {
  $schema: "../chain.schemaon",
  chain_name: "nibirutestnet",
  chain_id: "nibiru-itn-3",
  pretty_name: "Nibiru Chain",
  status: "live",
  network_type: "testnet",
  bech32_prefix: "nibi",
  daemon_name: "nibid",
  node_home: "$HOME/.nibid",
  key_algos: ["secp256k1"],
  slip44: 118,
  fees: {
    fee_tokens: [
      {
        denom: "unibi"
      }
    ]
  },
  staking: {
    staking_tokens: [
      {
        denom: "unibi"
      }
    ]
  },
  codebase: {
    git_repo: "https://github.com/NibiruChain/nibiru",
    genesis: {
      genesis_url: ""
    }
  },
  apis: {
    rpc: [
      {
        address: "https://rpc-t.nibiru.nodestake.top",
        provider: "nodestake"
      },
      {
        address: "https://nibiru-testnet.rpc.kjnodes.com",
        provider: "kjnodes"
      },
      {
        address: "https://rpc-nibiru.nodeist.net",
        provider: "nodeist"
      }
    ],
    rest: [
      {
        address: "https://api-t.nibiru.nodestake.top",
        provider: "nodestake"
      },
      {
        address: "https://nibiru-testnet.api.kjnodes.com",
        provider: "kjnodes"
      },
      {
        address: "https://api-nibiru.nodeist.net",
        provider: "nodeist"
      }
    ],
    grpc: [
      {
        address: "https://grpc-t.nibiru.nodestake.top",
        provider: "nodestake"
      },
      {
        address: "https://nibiru-testnet.grpc.kjnodes.com:13990",
        provider: "kjnodes"
      }
    ]
  },
  explorers: [
    {
      kind: "nibirufi",
      url: "https://explorer.nibiru.fi",
      tx_page: "https://explorer.nibiru.fi/nibiru-itn-2/tx/${txHash}"
    }
  ]
};
var chains = [
  // remove harpoon 4 in favor of manual entry
  ...chainRegistryChains.filter(
    ({ chain_id }) => ![NIBIRU_TESTNET_CHAIN.chain_id].includes(chain_id)
  ),
  LOCAL_JUNO_CHAIN,
  NIBIRU_TESTNET_CHAIN
];

// src/utils/chain-registry/chain-id-to-name.ts
function chainIdToName(chainId) {
  if (chainId === "pisco-1")
    return "terra2testnet";
  const chainName = chains.find(
    ({ chain_id }) => chain_id === chainId
  )?.chain_name;
  if (!chainName) {
    throw new Error(`Chain not found by chainId: ${chainId}`);
  }
  return chainName;
}

// src/clients/create-client.ts
function createBaseClient(parameters) {
  const { key = "base", name = "Base Client" } = parameters;
  const client = {
    key,
    name
  };
  function extend(base) {
    return (extendFn) => {
      const extended = extendFn(base);
      for (const key2 in client)
        delete extended[key2];
      const combined = { ...base, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client, { extend: extend(client) });
}
function createClient(parameters) {
  const client = createBaseClient(parameters);
  return client;
}

// src/actions/public/get-ica-client-query-client.ts
function getIcaClientQueryClient({
  cosmWasmClient,
  icaClientAddress
}) {
  return new IcaClientQueryClient(cosmWasmClient, icaClientAddress);
}

// src/utils/registry/registry-module-to-address.ts
import { P, match } from "ts-pattern";
function registryModuleToAddress(module) {
  return match(module.reference).with({ native: P.select() }, (native) => native).with({ adapter: P.select() }, (adapter) => adapter).otherwise((x) => {
    throw new Error(`Expected addressable module, got ${JSON.stringify(x)}`);
  });
}

// src/actions/public/get-registry-query-client.ts
function getRegistryQueryClient({
  cosmWasmClient,
  registryAddress
}) {
  return new RegistryQueryClient(cosmWasmClient, registryAddress);
}

// src/actions/public/get-abstract-module-address-from-registry.ts
async function getAbstractModuleAddressFromRegistry({
  moduleName,
  cosmWasmClient,
  registryAddress,
  version
}) {
  const registryQueryClient = getRegistryQueryClient({
    cosmWasmClient,
    registryAddress
  });
  const [moduleAddress] = await registryQueryClient.modules({
    infos: [
      {
        name: moduleName,
        namespace: ABSTRACT_NAMESPACE,
        version: version ? { version } : "latest"
      }
    ]
  }).then(
    ({ modules }) => modules.map(({ module }) => registryModuleToAddress(module))
  );
  if (!moduleAddress) {
    throw new Error(
      `Could not fetch address for module ${moduleName} version ${version} from registry ${registryAddress}`
    );
  }
  return moduleAddress;
}

// src/actions/public/get-account-query-client.ts
async function getAccountQueryClient({
  cosmWasmClient,
  accountAddress
}) {
  return new AccountQueryClient(cosmWasmClient, accountAddress);
}

// src/actions/public/types.ts
var CommonModuleNames = /* @__PURE__ */ ((CommonModuleNames2) => {
  CommonModuleNames2["ACCOUNT"] = "account";
  CommonModuleNames2["MODULE_FACTORY"] = "module-factory";
  CommonModuleNames2["ANS_HOST"] = "ans-host";
  CommonModuleNames2["IBC_CLIENT"] = "ibc-client";
  CommonModuleNames2["ICA_CLIENT"] = "ica-client";
  CommonModuleNames2["IBC_HOST"] = "ibc-host";
  return CommonModuleNames2;
})(CommonModuleNames || {});

// src/actions/public/get-ans-host-address-from-registry.ts
async function getAnsHostAddressFromRegistry({
  cosmWasmClient,
  registryAddress,
  version
}) {
  return getAbstractModuleAddressFromRegistry({
    moduleName: "ans-host" /* ANS_HOST */,
    cosmWasmClient,
    registryAddress,
    version
  });
}

// src/actions/public/get-ans-host-query-client.ts
async function getAnsHostQueryClient({
  cosmWasmClient,
  ansHostAddress
}) {
  return new AnsHostQueryClient(cosmWasmClient, ansHostAddress);
}

// src/actions/public/get-ans-host-query-client-from-registry.ts
async function getAnsHostQueryClientFromRegistry({
  cosmWasmClient,
  registryAddress,
  version
}) {
  const ansHostAddress = await getAnsHostAddressFromRegistry({
    cosmWasmClient,
    registryAddress,
    version
  });
  return getAnsHostQueryClient({ cosmWasmClient, ansHostAddress });
}

// src/actions/public/get-cosm-wasm-client.ts
function getCosmWasmClient({
  cosmWasmClient
}) {
  return cosmWasmClient;
}

// src/actions/public/get-ibc-client-query-client.ts
function getIbcClientQueryClient({
  cosmWasmClient,
  ibcClientAddress
}) {
  return new IbcClientQueryClient(cosmWasmClient, ibcClientAddress);
}

// src/actions/public/get-registry-module-data.ts
import { rawQuery } from "@abstract-money/cosmwasm-utils";
import { match as match4 } from "ts-pattern";

// src/utils/registry/module-id/format-module-id-with-version.ts
import * as s2 from "string-ts";

// src/utils/registry/module-id/module-version-to-string.ts
function moduleVersionToString(version) {
  if (typeof version !== "string") {
    return version.version;
  }
  if (version === "latest")
    return version;
  throw new Error(`Unexpected version: ${JSON.stringify(version)}`);
}

// src/utils/registry/module-id/format-module-id-with-version.ts
function formatModuleIdWithVersion(namespace, name, version) {
  return s2.join([namespace, name, moduleVersionToString(version)], ":");
}

// src/utils/registry/registry-module-to-code-id.ts
import { P as P2, match as match2 } from "ts-pattern";
function registryModuleToCodeId(module) {
  return match2(module.reference).with({ account: P2.select() }, (account) => account).with({ app: P2.select() }, (app) => app).with({ standalone: P2.select() }, (standalone) => standalone).otherwise((x) => {
    throw new Error(`Expected module with code id, got ${JSON.stringify(x)}`);
  });
}

// src/utils/registry/registry-module-to-type.ts
import { P as P3, match as match3 } from "ts-pattern";
function registryModuleToType(module) {
  return match3(module.reference).with({ account: P3.select() }, () => "account").with({ app: P3.select() }, () => "app").with({ standalone: P3.select() }, () => "standalone").with({ native: P3.select() }, () => "native").with({ adapter: P3.select() }, () => "adapter").otherwise((x) => {
    throw new Error(`Expected module with code id, got ${JSON.stringify(x)}`);
  });
}

// src/actions/public/get-registry-module-data.ts
async function getRegistryModuleData({
  cosmWasmClient,
  module
}) {
  const moduleType = registryModuleToType(module);
  const firstInstantiation = await match4(moduleType).with("adapter", async () => {
    return Promise.resolve(registryModuleToAddress(module));
  }).with("standalone", "app", async () => {
    const instantiations = await cosmWasmClient.getContracts(
      registryModuleToCodeId(module)
    );
    const firstInstantiation2 = instantiations[0];
    if (!firstInstantiation2) {
      console.warn(
        `Could not find first instantiation of ${formatModuleIdWithVersion(
          module.info.namespace,
          module.info.name,
          module.info.version
        )}`
      );
      return null;
    }
    return Promise.resolve(firstInstantiation2);
  }).with("native", "account", () => {
    return null;
  }).otherwise(() => {
    throw new Error(
      `Expected module known type, got ${JSON.stringify(moduleType)}`
    );
  });
  if (firstInstantiation === null) {
    return null;
  }
  let moduleData = null;
  try {
    moduleData = await rawQuery({
      client: cosmWasmClient,
      address: firstInstantiation,
      key: "mod"
    });
  } catch (error) {
    try {
      moduleData = await rawQuery({
        client: cosmWasmClient,
        address: firstInstantiation,
        key: "module_data"
      });
    } catch (error2) {
      console.debug(
        `Could not retrieve module_data for ${formatModuleIdWithVersion(
          module.info.namespace,
          module.info.name,
          module.info.version
        )}`,
        error,
        error2
      );
    }
  }
  return moduleData;
}

// src/clients/decorators/abstract-base.ts
function abstractBaseActions(cosmWasmClient) {
  return {
    getCosmWasmClient: () => getCosmWasmClient({
      cosmWasmClient
    }),
    getAccountQueryClient: ({ extra, ...parameters }) => getAccountQueryClient({
      cosmWasmClient,
      ...parameters,
      ...extra
    }),
    getRegistryQueryClient: ({ extra, ...parameters }) => getRegistryQueryClient({
      cosmWasmClient,
      ...parameters,
      ...extra
    }),
    getAnsHostQueryClient: ({ extra, ...parameters }) => getAnsHostQueryClient({
      cosmWasmClient,
      ...parameters,
      ...extra
    }),
    getIbcClientQueryClient: ({ extra, ...parameters }) => getIbcClientQueryClient({
      cosmWasmClient,
      ...parameters,
      ...extra
    }),
    getIcaClientQueryClient: ({ extra, ...parameters }) => getIcaClientQueryClient({
      cosmWasmClient,
      ...parameters,
      ...extra
    }),
    getAbstractModuleAddressFromRegistry: ({ extra, ...parameters }) => getAbstractModuleAddressFromRegistry({
      cosmWasmClient,
      ...parameters,
      ...extra
    }),
    getAnsHostAddressFromRegistry: ({ extra, ...parameters }) => getAnsHostAddressFromRegistry({
      cosmWasmClient,
      ...parameters,
      ...extra
    }),
    getAnsHostQueryClientFromRegistry: ({ extra, ...parameters }) => getAnsHostQueryClientFromRegistry({
      cosmWasmClient,
      ...parameters,
      ...extra
    }),
    getRegistryModuleData: ({ extra, ...parameters }) => getRegistryModuleData({
      cosmWasmClient,
      ...parameters,
      ...extra
    })
  };
}

// src/clients/create-abstract-base-client.ts
function createAbstractBaseClient(parameters) {
  const {
    key = "abstract-base",
    name = "Abstract Base Client",
    cosmWasmClient
  } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name
  });
  return client.extend(() => abstractBaseActions(cosmWasmClient));
}

// src/actions/get-account-balance-from-api.ts
import request from "graphql-request";

// src/codegen/gql/graphql.ts
var BalancesDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "Balances" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "ids" } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountIdWithChain" } } } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "accountsByIds" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "ids" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "ids" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "balances" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "amount" } }, { "kind": "Field", "name": { "kind": "Name", "value": "type" } }, { "kind": "Field", "name": { "kind": "Name", "value": "denom" } }] } }] } }] } }] };
var AccountsDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "Accounts" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "chains" } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID" } } } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "page" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Page" } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountFilter" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "accounts" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "chains" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "chains" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "page" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "page" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "filter" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "accountId" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "chainName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "sequence" } }, { "kind": "Field", "name": { "kind": "Name", "value": "trace" } }] } }] } }] } }] };
var AnsHostDeploymentDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "AnsHostDeployment" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "version" } }, { "kind": "Field", "name": { "kind": "Name", "value": "deployment" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "chain" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "ansHost" } }] } }] } }] };
var AssetsQueryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "AssetsQuery" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "IdsFilter" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "ans" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "chain" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "assets" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "filter" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "type" } }, { "kind": "Field", "name": { "kind": "Name", "value": "address" } }] } }] } }] } }] };
var ChainRpcUrlDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "ChainRpcUrl" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "chainInfo" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "chain" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "rpcUrl" } }] } }] } }] };
var ModulesDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "Modules" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ModuleFilter" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "modules" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "chain" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "filter" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "moduleId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "version" } }] } }] } }] };
var RegistryDeploymentDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "RegistryDeployment" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "deployment" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "chain" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "registry" } }] } }] } }] };
var SubAccountsByModulesDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "SubAccountsByModules" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "ids" } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountIdWithChain" } } } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "accountsByIds" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "ids" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "ids" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "subAccounts" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "accountId" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "chainName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "trace" } }, { "kind": "Field", "name": { "kind": "Name", "value": "sequence" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "modules" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }] } }] };
var DeploymentDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "Deployment" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "version" } }, { "kind": "Field", "name": { "kind": "Name", "value": "deployment" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "chain" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "ansHost" } }, { "kind": "Field", "name": { "kind": "Name", "value": "registry" } }, { "kind": "Field", "name": { "kind": "Name", "value": "accountFactory" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "chainInfo" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "chain" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "chain" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "rpcUrl" } }] } }] } }] };

// src/codegen/gql/gql.ts
var documents = {
  "\n      query Balances($ids: [AccountIdWithChain!]!) {\n        accountsByIds(ids: $ids) {\n          balances {\n            amount\n            type\n            denom\n          }\n        }\n      }\n": BalancesDocument,
  "\n  query Accounts($chains: [ID!]!, $page: Page, $filter: AccountFilter) {\n    accounts(chains: $chains, page: $page, filter: $filter) {\n      accountId {\n        chainName\n        sequence\n        trace\n      }\n    }\n  }\n": AccountsDocument,
  "\n      query AnsHostDeployment($chain: ID!) {\n        version\n        deployment(chain: $chain) {\n          ansHost\n        }\n      }\n    ": AnsHostDeploymentDocument,
  "\n      query AssetsQuery($chain: ID!, $filter: IdsFilter!) {\n        ans(chain: $chain) {\n          assets(filter: $filter) {\n            id\n            type\n            address\n          }\n        }\n      }\n  ": AssetsQueryDocument,
  "\n      query ChainRpcUrl($chain: ID!) {\n        chainInfo(chain: $chain) {\n          rpcUrl\n        }\n      }\n    ": ChainRpcUrlDocument,
  "\n      query Modules($chain: ID!, $filter: ModuleFilter) {\n        modules(chain: $chain, filter: $filter) {\n          moduleId\n          version\n        }\n      }\n  ": ModulesDocument,
  "\n      query RegistryDeployment($chain: ID!) {\n        deployment(chain: $chain) {\n          registry\n        }\n      }\n    ": RegistryDeploymentDocument,
  "\n    query SubAccountsByModules($ids: [AccountIdWithChain!]!) {\n        accountsByIds(ids: $ids) {\n            subAccounts {\n                accountId {\n                    chainName\n                    trace\n                    sequence\n                }\n                modules {\n                    id\n                }\n            }\n        }\n    }\n    ": SubAccountsByModulesDocument,
  "\n  query Deployment($chain: ID!) {\n    version\n    deployment(chain: $chain) {\n      ansHost\n      registry\n      accountFactory\n    }\n    chainInfo(chain: $chain) {\n      rpcUrl\n    }\n  }\n": DeploymentDocument,
  "\n  query AssetsQuery($chain: ID!, $filter: IdsFilter!) {\n    ans(chain: $chain) {\n      assets(filter: $filter) {\n        id\n        type\n        address\n      }\n    }\n  }\n": AssetsQueryDocument
};
function gql(source) {
  return documents[source] ?? {};
}

// src/utils/tokens/token-from-api.ts
function tokenFromApi(token) {
  if (token.type === "CW1155" /* Cw1155 */)
    throw new Error("CW1155 tokens are not supported");
  if (token.type === "CW20" /* Cw20 */) {
    return {
      type: "cw20",
      address: token.denom
    };
  }
  return {
    type: "native",
    denom: token.denom
  };
}

// src/actions/get-account-balance-from-api.ts
async function getAccountBalancesFromApi({
  apiUrl,
  accountId
}) {
  const result = await request(
    apiUrl,
    gql(
      /* GraphQL */
      `
      query Balances($ids: [AccountIdWithChain!]!) {
        accountsByIds(ids: $ids) {
          balances {
            amount
            type
            denom
          }
        }
      }
`
    ),
    { ids: [accountIdToApiFormat(accountId)] }
  );
  return result.accountsByIds[0]?.balances.map(
    ({ amount, type, denom }) => tokenToAsset(tokenFromApi({ type, denom }), amount)
  );
}

// src/actions/get-accounts-by-owner-from-api.ts
import request2 from "graphql-request";
async function getAccountsByOwnerFromApi({
  apiUrl,
  owner,
  chains: chains2
}) {
  const result = await request2(
    apiUrl,
    gql(
      /* GraphQL */
      `
  query Accounts($chains: [ID!]!, $page: Page, $filter: AccountFilter) {
    accounts(chains: $chains, page: $page, filter: $filter) {
      accountId {
        chainName
        sequence
        trace
      }
    }
  }
`
    ),
    { filter: { owner }, chains: chains2 }
  );
  return result.accounts.map((r) => accountIdApiFormatToAccountId(r.accountId));
}

// src/actions/get-ans-host-address-from-api.ts
import { request as request3 } from "graphql-request";
async function getAnsHostAddressFromApi({
  apiUrl,
  chainName
}) {
  const deploymentData = await request3(
    apiUrl,
    gql(
      /* GraphQL */
      `
      query AnsHostDeployment($chain: ID!) {
        version
        deployment(chain: $chain) {
          ansHost
        }
      }
    `
    ),
    {
      chain: chainName
    }
  );
  return deploymentData.deployment.ansHost;
}

// src/actions/get-ans-tokens-from-api.ts
import { request as request4 } from "graphql-request";

// src/utils/tokens/ans/ans-token-from-api.ts
function ansTokenFromApi(token) {
  if (token.type === "CW1155" /* Cw1155 */)
    throw new Error("CW1155 tokens are not supported");
  if (token.type === "CW20" /* Cw20 */) {
    return {
      type: "cw20",
      address: token.address,
      id: token.id
    };
  }
  return {
    type: "native",
    denom: token.address,
    id: token.id
  };
}

// src/actions/get-ans-tokens-from-api.ts
async function getAnsTokensFromApi({
  apiUrl,
  chainName,
  ids
}) {
  const result = await request4(
    apiUrl,
    gql(
      /* GraphQL */
      `
      query AssetsQuery($chain: ID!, $filter: IdsFilter!) {
        ans(chain: $chain) {
          assets(filter: $filter) {
            id
            type
            address
          }
        }
      }
  `
    ),
    {
      chain: chainName,
      filter: { ids }
    }
  );
  return result.ans.assets.map((token) => ansTokenFromApi(token));
}

// src/actions/get-ans-token-from-api.ts
async function getAnsTokenFromApi({
  apiUrl,
  chainName,
  id
}) {
  const result = await getAnsTokensFromApi({
    apiUrl,
    chainName,
    ids: [id]
  }).then((tokens) => tokens[0]);
  if (!result)
    throw new Error(`Cannot find token with id ${id}`);
  return result;
}

// src/actions/get-modules-from-api.ts
import { request as request5 } from "graphql-request";
async function getModulesFromApi({
  apiUrl,
  chainName,
  filter
}) {
  const result = await request5(
    apiUrl,
    gql(
      /* GraphQL */
      `
      query Modules($chain: ID!, $filter: ModuleFilter) {
        modules(chain: $chain, filter: $filter) {
          moduleId
          version
        }
      }
  `
    ),
    {
      chain: chainName,
      filter
    }
  );
  return result.modules;
}

// src/actions/get-registry-address-from-api.ts
import { request as request6 } from "graphql-request";
async function getRegistryAddressFromApi({
  apiUrl,
  chainName
}) {
  const deploymentData = await request6(
    apiUrl,
    gql(
      /* GraphQL */
      `
      query RegistryDeployment($chain: ID!) {
        deployment(chain: $chain) {
          registry
        }
      }
    `
    ),
    {
      chain: chainName
    }
  );
  return deploymentData.deployment.registry;
}

// src/actions/get-sub-account-ids-by-module-id.ts
import request7 from "graphql-request";
async function getSubAccountIdsByModuleIdFromApi({
  accountId,
  moduleId,
  apiUrl
}) {
  const subAccountsByModules = await request7(
    apiUrl,
    gql(
      /* GraphQL */
      `
    query SubAccountsByModules($ids: [AccountIdWithChain!]!) {
        accountsByIds(ids: $ids) {
            subAccounts {
                accountId {
                    chainName
                    trace
                    sequence
                }
                modules {
                    id
                }
            }
        }
    }
    `
    ),
    {
      ids: accountIdToApiFormat(accountId)
    }
  );
  const accountData = subAccountsByModules.accountsByIds[0];
  if (!accountData)
    throw new Error(`account id ${accountIdToString(accountId)} does not exist`);
  return accountData.subAccounts.filter(({ modules }) => modules.some((module) => module.id === moduleId)).map(({ accountId: accountId2 }) => accountIdApiFormatToAccountId(accountId2));
}

// src/clients/decorators/api.ts
function apiActions(apiUrl) {
  return {
    getAccountBalancesFromApi: ({ extra, ...parameters }) => getAccountBalancesFromApi({
      apiUrl,
      ...parameters,
      ...extra
    }),
    getAnsHostAddressFromApi: ({ extra, ...parameters }) => getAnsHostAddressFromApi({
      apiUrl,
      ...parameters,
      ...extra
    }),
    getAccountsByOwnerFromApi: ({ extra, ...parameters }) => getAccountsByOwnerFromApi({
      apiUrl,
      ...parameters,
      ...extra
    }),
    getAnsTokenFromApi: ({ extra, ...parameters }) => getAnsTokenFromApi({
      apiUrl,
      ...parameters,
      ...extra
    }),
    getAnsTokensFromApi: ({ extra, ...parameters }) => getAnsTokensFromApi({
      apiUrl,
      ...parameters,
      ...extra
    }),
    getModulesFromApi: ({ extra, ...parameters }) => getModulesFromApi({
      apiUrl,
      ...parameters,
      ...extra
    }),
    getRegistryAddressFromApi: ({ extra, ...parameters }) => getRegistryAddressFromApi({
      apiUrl,
      ...parameters,
      ...extra
    }),
    getSubAccountIdsByModuleIdFromApi: ({ extra, ...parameters }) => getSubAccountIdsByModuleIdFromApi({
      apiUrl,
      ...parameters,
      ...extra
    })
  };
}

// src/utils/cosmos/simulate-cosmos-msgs.ts
import { Registry } from "@cosmjs/proto-signing";
import {
  QueryClient,
  createProtobufRpcClient,
  setupTxExtension
} from "@cosmjs/stargate";
import { MsgSend } from "cosmjs-types/cosmos/bank/v1beta1/tx";
import { SignMode } from "cosmjs-types/cosmos/tx/signing/v1beta1/signing";
import {
  ServiceClientImpl,
  SimulateRequest
} from "cosmjs-types/cosmos/tx/v1beta1/service";
import { AuthInfo, Fee, Tx, TxBody } from "cosmjs-types/cosmos/tx/v1beta1/tx";
import { MsgExecuteContract as MsgExecuteContract3 } from "cosmjs-types/cosmwasm/wasm/v1/tx";

// src/utils/cosmos/encoding.ts
import { fromBase64 as fromBase642 } from "@cosmjs/encoding";
import {
  MsgClearAdmin,
  MsgExecuteContract as MsgExecuteContract2,
  MsgInstantiateContract,
  MsgInstantiateContract2,
  MsgMigrateContract,
  MsgUpdateAdmin
} from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { P as P4, match as match5 } from "ts-pattern";
var encodeWasmCosmosMsgForEmpty = (msg, sender) => {
  return match5(msg).with({ wasm: P4.select() }, (wasm) => wasmEncoder(wasm, sender)).with({ bank: P4.select() }, (bank) => bankEncoder(bank, sender)).otherwise(() => {
    throw new Error("Unsupported cosmos message.");
  });
};
function wasmEncoder(value, sender) {
  return match5(value).with({ execute: P4.select() }, (execute2) => ({
    typeUrl: MsgExecuteContract2.typeUrl,
    value: {
      sender,
      contract: execute2.contract_addr,
      funds: execute2.funds,
      msg: fromBase642(execute2.msg)
    }
  })).with({ instantiate: P4.select() }, (instantiate) => ({
    typeUrl: MsgInstantiateContract.typeUrl,
    value: {
      sender,
      admin: instantiate.admin ?? void 0,
      codeId: BigInt(instantiate.code_id),
      label: instantiate.label,
      msg: fromBase642(instantiate.msg),
      funds: instantiate.funds
    }
  })).with({ instantiate2: P4.select() }, (instantiate2) => ({
    typeUrl: MsgInstantiateContract2.typeUrl,
    value: {
      sender,
      admin: instantiate2.admin ?? void 0,
      codeId: BigInt(instantiate2.code_id),
      label: instantiate2.label,
      msg: fromBase642(instantiate2.msg),
      funds: instantiate2.funds,
      salt: fromBase642(instantiate2.salt)
      // fixMsg: instantiate2.fix_msg,
    }
  })).with({ migrate: P4.select() }, (migrate) => ({
    typeUrl: MsgMigrateContract.typeUrl,
    value: {
      sender,
      contract: migrate.contract_addr,
      codeId: BigInt(migrate.new_code_id),
      msg: fromBase642(migrate.msg)
    }
  })).with({ update_admin: P4.select() }, (update_admin) => ({
    typeUrl: MsgUpdateAdmin.typeUrl,
    value: {
      sender,
      newAdmin: update_admin.admin,
      contract: update_admin.contract_addr
    }
  })).with({ clear_admin: P4.select() }, (clear_admin) => ({
    typeUrl: MsgClearAdmin.typeUrl,
    value: {
      sender,
      contract: clear_admin.contract_addr
    }
  })).otherwise((value2) => {
    throw new Error(`Unsupported wasm message type: ${value2}`);
  });
}
function bankEncoder(value, sender) {
  return match5(value).with({ send: P4.select() }, (send) => ({
    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
    value: {
      fromAddress: sender,
      toAddress: send.to_address,
      amount: send.amount
    }
  })).otherwise((value2) => {
    throw new Error(`Unsupported bank message type: ${value2}`);
  });
}

// src/utils/cosmos/simulate-cosmos-msgs.ts
var typesRegistry = new Registry([
  ["/cosmwasm.wasm.v1.MsgExecuteContract", MsgExecuteContract3],
  ["/cosmos.bank.v1beta1.MsgSend", MsgSend]
]);
var simulateWasmCosmosMsgs = async (cometClient, msgs, senderAddress) => {
  const encodedMsgs = msgs.map((msg) => {
    const encoded = encodeWasmCosmosMsgForEmpty(msg, senderAddress);
    return typesRegistry.encodeAsAny(encoded);
  });
  try {
    return await simulateAnyMessages(cometClient, encodedMsgs);
  } catch (err) {
    await encodedMsgs.reduce(async (p, encoded) => {
      await p;
      console.log("Simulating:", encoded);
      try {
        await simulateAnyMessages(cometClient, [encoded]);
      } catch (err2) {
        console.error(err2);
      }
    }, Promise.resolve());
    throw err;
  }
};
var simulateAnyMessages = async (cometClient, messages) => {
  const tx = Tx.fromPartial({
    authInfo: AuthInfo.fromPartial({
      fee: Fee.fromPartial({}),
      signerInfos: [
        // @ts-ignore
        {
          modeInfo: {
            single: {
              mode: SignMode.SIGN_MODE_DIRECT
            }
          }
        }
      ]
    }),
    body: TxBody.fromPartial({
      messages,
      memo: ""
    }),
    signatures: [new Uint8Array()]
  });
  const request9 = SimulateRequest.fromPartial({
    txBytes: Tx.encode(tx).finish()
  });
  const txClient = QueryClient.withExtensions(cometClient, setupTxExtension);
  return new ServiceClientImpl(createProtobufRpcClient(txClient)).Simulate(
    request9
  );
};

// src/actions/get-comet-client-from-api.ts
import { Comet38Client } from "@cosmjs/tendermint-rpc";

// src/actions/get-chain-rpc-from-api.ts
import { request as request8 } from "graphql-request";
async function getChainRpcUrlFromApi({
  apiUrl,
  chainName
}) {
  const chainData = await request8(
    apiUrl,
    gql(
      /* GraphQL */
      `
      query ChainRpcUrl($chain: ID!) {
        chainInfo(chain: $chain) {
          rpcUrl
        }
      }
    `
    ),
    {
      chain: chainName
    }
  );
  return chainData.chainInfo.rpcUrl;
}

// src/actions/get-comet-client-from-api.ts
async function getCometClientFromApi({
  apiUrl,
  chainName
}) {
  const remoteEndpoint = await getChainRpcUrlFromApi({
    apiUrl,
    chainName
  });
  return await Comet38Client.connect(remoteEndpoint);
}

// src/actions/get-simulation-result-from-api.ts
async function getSimulationResultFromApi({
  apiUrl,
  chainName,
  sender,
  msgs
}) {
  const comet = await getCometClientFromApi({
    apiUrl,
    chainName
  });
  return simulateWasmCosmosMsgs(
    comet,
    Array.isArray(msgs) ? msgs : [msgs],
    sender
  );
}

// src/utils/registry/registry-module-to-version.ts
function registryModuleToVersion(module) {
  return module.info.version;
}

// src/actions/public/get-registry-query-client-from-api.ts
async function getRegistryQueryClientFromApi({
  cosmWasmClient,
  apiUrl
}) {
  const chainId = await cosmWasmClient.getChainId();
  const chainName = chainIdToName(chainId);
  const registryAddress = await getRegistryAddressFromApi({
    apiUrl,
    chainName
  });
  return getRegistryQueryClient({
    cosmWasmClient,
    registryAddress
  });
}

// src/actions/public/get-abstract-module-version.ts
async function getAbstractModuleVersion({
  moduleName,
  cosmWasmClient,
  version,
  apiUrl
}) {
  const registryQueryClient = await getRegistryQueryClientFromApi({
    cosmWasmClient,
    apiUrl
  });
  const [moduleVersion] = await registryQueryClient.modules({
    infos: [
      {
        name: moduleName,
        namespace: "abstract",
        version: version ? { version } : "latest"
      }
    ]
  }).then(
    ({ modules }) => modules.map(({ module }) => registryModuleToVersion(module))
  );
  if (!moduleVersion) {
    throw new Error(
      `Could not fetch address for module ${moduleName} version ${version} from registry ${registryQueryClient.contractAddress}`
    );
  }
  return moduleVersion;
}

// src/actions/public/get-account-addresses-from-api.ts
async function getAccountAddressesFromApi({
  accountIds,
  cosmWasmClient,
  apiUrl
}) {
  const registryQueryClient = await getRegistryQueryClientFromApi({
    cosmWasmClient,
    apiUrl
  });
  return await registryQueryClient.accounts({
    accountIds
  }).then(({ accounts }) => ({
    accounts
  }));
}

// src/actions/public/get-account-instantiate2-address-from-api.ts
import { P as P5, match as match6 } from "ts-pattern";

// src/actions/public/get-app-module-code-id-from-registry.ts
async function getAppModuleCodeIdFromRegistry({
  moduleId,
  cosmWasmClient,
  registryAddress,
  version
}) {
  const registryQueryClient = getRegistryQueryClient({
    cosmWasmClient,
    registryAddress
  });
  const [moduleCodeId] = await registryQueryClient.modules({
    infos: [
      {
        name: moduleIdToName(moduleId),
        namespace: moduleIdToNamespace(moduleId),
        version: version ?? "latest"
      }
    ]
  }).then(
    ({ modules }) => modules.map(({ module }) => registryModuleToCodeId(module))
  );
  if (!moduleCodeId) {
    throw new Error(
      `Could not fetch code id for app module ${moduleId} version ${version} from registry ${registryAddress}`
    );
  }
  return moduleCodeId;
}

// src/actions/public/get-account-instantiate2-address-from-api.ts
async function getAccountInstantiate2AddressFromApi({
  cosmWasmClient,
  apiUrl,
  creator,
  salt
}) {
  const chainId = await cosmWasmClient.getChainId();
  const chainName = chainIdToName(chainId);
  const registryAddress = await getRegistryAddressFromApi({
    apiUrl,
    chainName
  });
  const accountCodeId = await getAppModuleCodeIdFromRegistry({
    moduleId: abstractModuleId("account" /* ACCOUNT */),
    version: "latest",
    cosmWasmClient,
    registryAddress
  });
  const moduleCodeDetails = await cosmWasmClient.getCodeDetails(accountCodeId);
  return await match6(salt).with(
    { accountId: P5.select() },
    async (accountId) => await getInstantiate2AddressWithAccountId(
      creator,
      moduleCodeDetails.checksum,
      accountId
    )
  ).with(
    { custom: P5.select() },
    async (customSalt) => await getInstantiate2Address(
      creator,
      moduleCodeDetails.checksum,
      customSalt
    )
  ).exhaustive();
}

// src/actions/public/get-ans-host-query-client-from-api.ts
async function getAnsHostQueryClientFromApi({
  cosmWasmClient,
  apiUrl
}) {
  const chainId = await cosmWasmClient.getChainId();
  const chainName = chainIdToName(chainId);
  const ansHostAddress = await getAnsHostAddressFromApi({
    apiUrl,
    chainName
  });
  return getAnsHostQueryClient({ cosmWasmClient, ansHostAddress });
}

// src/actions/public/get-ans-host-version-from-api.ts
async function getAnsHostVersionFromApi({
  cosmWasmClient,
  apiUrl,
  version
}) {
  return getAbstractModuleVersion({
    moduleName: "ans-host" /* ANS_HOST */,
    cosmWasmClient,
    apiUrl,
    version
  });
}

// src/actions/public/get-ibc-client-address-from-registry.ts
async function getIbcClientAddressFromRegistry({
  cosmWasmClient,
  registryAddress,
  version
}) {
  return getAbstractModuleAddressFromRegistry({
    moduleName: "ibc-client" /* IBC_CLIENT */,
    cosmWasmClient,
    registryAddress,
    version
  });
}

// src/actions/public/get-ibc-client-query-client-from-registry.ts
async function getIbcClientQueryClientFromRegistry({
  cosmWasmClient,
  registryAddress,
  version
}) {
  const ibcClientAddress = await getIbcClientAddressFromRegistry({
    cosmWasmClient,
    registryAddress,
    version
  });
  return getIbcClientQueryClient({ cosmWasmClient, ibcClientAddress });
}

// src/actions/public/get-remote-hosts-from-api.ts
async function getRemoteHostsFromApi({
  cosmWasmClient,
  apiUrl
}) {
  const registryQueryClient = await getRegistryQueryClientFromApi({
    cosmWasmClient,
    apiUrl
  });
  const ibcQueryClient = await getIbcClientQueryClientFromRegistry({
    cosmWasmClient,
    registryAddress: registryQueryClient.contractAddress
  });
  const { hosts } = await ibcQueryClient.listRemoteHosts();
  return hosts;
}

// src/actions/simulate-remote-cosmos-msg.ts
import { CosmWasmClient } from "@cosmjs/cosmwasm-stargate";

// src/actions/public/get-ibc-host-address-from-registry.ts
async function getIbcHostAddressFromRegistry({
  cosmWasmClient,
  registryAddress,
  version
}) {
  return getAbstractModuleAddressFromRegistry({
    moduleName: "ibc-host" /* IBC_HOST */,
    cosmWasmClient,
    registryAddress,
    version
  });
}

// src/actions/simulate-remote-cosmos-msg.ts
async function simulateRemoteCosmosMsg({
  apiUrl,
  hostChainName,
  msgs
}) {
  const remoteVcAddress = await getRegistryAddressFromApi({
    apiUrl,
    chainName: hostChainName
  });
  const remoteComet = await getCometClientFromApi({
    apiUrl,
    chainName: hostChainName
  });
  const remoteCwClient = await CosmWasmClient.create(remoteComet);
  const ibcHostAddress = await getIbcHostAddressFromRegistry({
    cosmWasmClient: remoteCwClient,
    registryAddress: remoteVcAddress
  });
  return simulateWasmCosmosMsgs(
    remoteComet,
    Array.isArray(msgs) ? msgs : [msgs],
    ibcHostAddress
  );
}

// src/clients/decorators/public.ts
function publicActions(cosmWasmClient, apiUrl) {
  return {
    getAccountsAddresses: ({ extra, ...parameters }) => getAccountAddressesFromApi({
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    predictAccountAddress: ({ extra, ...parameters }) => getAccountInstantiate2AddressFromApi({
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getAbstractModuleVersion: ({ extra, ...parameters }) => getAbstractModuleVersion({
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getAnsHostVersion: ({ extra, ...parameters } = {}) => getAnsHostVersionFromApi({
      apiUrl,
      cosmWasmClient,
      ...parameters,
      ...extra
    }),
    getAnsHostQueryClientFromApi: ({ extra, ...parameters } = {}) => getAnsHostQueryClientFromApi({
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getRegistryQueryClientFromApi: ({ extra, ...parameters } = {}) => getRegistryQueryClientFromApi({
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getRemoteHosts: ({ extra, ...parameters } = {}) => getRemoteHostsFromApi({
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getSimulationResult: ({ extra, ...parameters }) => getSimulationResultFromApi({
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    simulateRemoteCosmosMsg: ({ extra, ...parameters }) => simulateRemoteCosmosMsg({
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    })
  };
}

// src/clients/create-public-client.ts
function createPublicClient(parameters) {
  const {
    key = "public",
    name = "Public Client",
    cosmWasmClient,
    apiUrl = ABSTRACT_API_URL
  } = parameters;
  const baseClient = createAbstractBaseClient({
    ...parameters,
    key,
    name
  });
  return baseClient.extend(() => apiActions(apiUrl)).extend(() => publicActions(cosmWasmClient, apiUrl));
}

// src/utils/modules/wrap-module-exec-msg.ts
import { match as match7 } from "ts-pattern";

// src/utils/modules/msg-factory/Module.msg-factory.ts
var ModuleExecuteMsgFactory = class {
};
ModuleExecuteMsgFactory.base = (baseMsg) => {
  return {
    base: baseMsg
  };
};
ModuleExecuteMsgFactory.module = (moduleMsg) => {
  return {
    module: moduleMsg
  };
};
var ModuleQueryMsgFactory = class {
};
ModuleQueryMsgFactory.base = (baseMsg) => {
  return {
    base: baseMsg
  };
};
ModuleQueryMsgFactory.module = (appMsg) => {
  return {
    module: appMsg
  };
};
var ModuleInitMsgFactory = class {
};
/**
 * Build a module instantiation msg for an Abstract app module.
 * @param ansHostAddress
 * @param registryAddress
 * @param appModuleInitMsg
 */
ModuleInitMsgFactory.app = (ansHostAddress, registryAddress, appModuleInitMsg) => {
  return {
    base: {
      ans_host_address: ansHostAddress,
      registry_address: registryAddress
    },
    module: appModuleInitMsg
  };
};
/**
 * Build a module instantiation msg for an Abstract adapter module.
 * @param ansHostAddress
 * @param registryAddress
 * @param adapterInitMsg
 */
ModuleInitMsgFactory.adapter = (ansHostAddress, registryAddress, adapterInitMsg) => {
  return {
    base: {
      ans_host_address: ansHostAddress,
      registry_address: registryAddress
    },
    module: adapterInitMsg
  };
};
var ModuleMigrateMsgFactory = class {
};
ModuleMigrateMsgFactory.app = (appMigrateMsg) => {
  return {
    base: {},
    module: appMigrateMsg ? appMigrateMsg : {}
  };
};

// src/utils/modules/msg-factory/App.msg-factory.ts
var AppExecuteMsgFactory = class {
};
/**
 * Make a request to an app module.
 * @param moduleMsg
 */
AppExecuteMsgFactory.executeApp = (moduleMsg) => {
  return ModuleExecuteMsgFactory.module(moduleMsg);
};
/**
 * Update an app module's config.
 */
AppExecuteMsgFactory.updateConfig = ({
  ansHostAddress
}) => {
  return ModuleExecuteMsgFactory.base({
    update_config: {
      ans_host_address: ansHostAddress
    }
  });
};
var AppQueryMsgFactory = class {
};
/**
 * Query an app module.
 * @param request request msg for the given app
 */
AppQueryMsgFactory.queryApp = (request9) => {
  return ModuleQueryMsgFactory.module(request9);
};
/**
 * Base app config query.
 */
AppQueryMsgFactory.config = () => {
  return ModuleQueryMsgFactory.base({
    base_config: {}
  });
};
/**
 * Base app admin query.
 */
AppQueryMsgFactory.admin = () => {
  return ModuleQueryMsgFactory.base({
    base_admin: {}
  });
};
/**
 * App module data query.
 */
AppQueryMsgFactory.moduleData = () => {
  return ModuleQueryMsgFactory.base({
    module_data: {}
  });
};
/**
 * App top level owner query.
 */
AppQueryMsgFactory.topLevelOwner = () => {
  return ModuleQueryMsgFactory.base({
    top_level_owner: {}
  });
};

// src/utils/modules/msg-factory/Adapter.msg-factory.ts
var AdapterExecuteMsgFactory = class {
};
/**
 * Make a request to an adapter module.
 * @param accountAddress
 * @param request
 */
AdapterExecuteMsgFactory.executeAdapter = ({
  accountAddress,
  request: request9
}) => {
  return ModuleExecuteMsgFactory.module({
    account_address: accountAddress,
    request: request9
  });
};
/**
 * Update the traders on an adapter.
 */
AdapterExecuteMsgFactory.updateAuthorizedAddresses = ({
  toAdd,
  toRemove
}) => {
  return ModuleExecuteMsgFactory.base({
    update_authorized_addresses: {
      to_add: toAdd,
      to_remove: toRemove
    }
  });
};
var AdapterQueryMsgBuilder = class {
};
/**
 * Query an adatper module.
 * @param request request msg for the given api
 */
AdapterQueryMsgBuilder.query = (request9) => {
  return ModuleQueryMsgFactory.module(request9);
};
/**
 * Base adapter authorized addresses query.
 * @param accountAddress
 */
AdapterQueryMsgBuilder.authorizedAddresses = (accountAddress) => {
  return ModuleQueryMsgFactory.base({
    authorized_addresses: {
      account_address: accountAddress
    }
  });
};
/**
 * Base adapter config query.
 */
AdapterQueryMsgBuilder.config = () => {
  return ModuleQueryMsgFactory.base({
    base_config: {}
  });
};
/**
 * App module data query.
 */
AdapterQueryMsgBuilder.moduleData = () => {
  return ModuleQueryMsgFactory.base({
    module_data: {}
  });
};

// src/utils/modules/wrap-module-exec-msg.ts
var wrapModuleExecMsg = (msg, moduleType) => match7(moduleType).with("app", () => AppExecuteMsgFactory.executeApp(msg)).with(
  "adapter",
  () => AdapterExecuteMsgFactory.executeAdapter({ request: msg })
).otherwise(() => msg);

// src/utils/modules/encode-module-msg.ts
var encodeModuleMsg = (msg, moduleType) => typeof msg === "string" ? msg : jsonToBinary(wrapModuleExecMsg(msg, moduleType));
var executeOnModuleMsg = (moduleId, moduleMsg, moduleType, funds) => AccountExecuteMsgBuilder.executeOnModule({
  moduleId,
  execMsg: encodeModuleMsg(moduleMsg, moduleType),
  funds: funds || []
});

// src/utils/modules/abstract-module-id.ts
var ABSTRACT_NAMESPACE = "abstract";
var abstractModuleId = (moduleName) => `${ABSTRACT_NAMESPACE}:${moduleName}`;

// src/utils/modules/wrap-module-query-msg.ts
import { match as match8 } from "ts-pattern";
function wrapModuleQueryMsg(queryMsg, moduleType) {
  return match8(moduleType).with("app", () => AppQueryMsgFactory.queryApp(queryMsg)).with("adapter", () => AdapterQueryMsgBuilder.query(queryMsg)).otherwise(() => queryMsg);
}

// src/utils/modules/module-install-config.ts
var moduleInstallConfig = ({
  init_msg,
  ...module
}) => {
  return {
    init_msg,
    module
  };
};

// src/actions/account/public/get-account-address-from-registry.ts
async function getAccountAddressFromRegistry({
  accountId,
  cosmWasmClient,
  registryAddress
}) {
  const registryQueryClient = getRegistryQueryClient({
    cosmWasmClient,
    registryAddress
  });
  const { accounts } = await registryQueryClient.accounts({
    accountIds: [accountIdToParameter(accountId)]
  });
  if (!accounts[0]) {
    throw new Error(`Account not found: ${accountId}`);
  }
  return accounts[0];
}

// src/actions/account/public/get-account-address-from-api.ts
async function getAccountAddressFromApi({
  accountId,
  cosmWasmClient,
  apiUrl
}) {
  const registryQueryClient = await getRegistryQueryClientFromApi({
    cosmWasmClient,
    apiUrl
  });
  return getAccountAddressFromRegistry({
    accountId,
    cosmWasmClient,
    registryAddress: registryQueryClient.contractAddress
  });
}

// src/actions/account/public/get-account-query-client-from-api.ts
async function getAccountQueryClientFromApi({
  accountId,
  cosmWasmClient,
  apiUrl
}) {
  const account = await getAccountAddressFromApi({
    accountId,
    cosmWasmClient,
    apiUrl
  });
  return getAccountQueryClient({ cosmWasmClient, accountAddress: account });
}

// src/actions/account/public/get-module-address.ts
async function getModuleAddress({
  accountId,
  cosmWasmClient,
  apiUrl,
  id
}) {
  const accountQueryClient = await getAccountQueryClientFromApi({
    accountId,
    cosmWasmClient,
    apiUrl
  });
  const { modules } = await accountQueryClient.moduleAddresses({ ids: [id] });
  return modules[0]?.[1] ?? null;
}

// src/actions/account/public/query-module.ts
async function queryModule({
  accountId,
  cosmWasmClient,
  apiUrl,
  moduleId,
  moduleType,
  queryMsg
}) {
  const moduleQueryMsg = wrapModuleQueryMsg(queryMsg, moduleType);
  const moduleAddress = await getModuleAddress({
    accountId,
    cosmWasmClient,
    apiUrl,
    id: moduleId
  });
  if (!moduleAddress) {
    throw new Error(`${moduleId} not installed`);
  }
  return await cosmWasmClient.queryContractSmart(moduleAddress, moduleQueryMsg);
}

// src/actions/account/public/get-account-id.ts
async function getAccountId({
  accountId,
  cosmWasmClient
}) {
  const chainId = await cosmWasmClient.getChainId();
  const chainName = chainIdToName(chainId);
  return { ...accountId, chainName };
}

// src/actions/account/public/get-account-settings.ts
async function getAccountSettings({
  accountId,
  cosmWasmClient,
  apiUrl
}) {
  const accountClient = await getAccountQueryClientFromApi({
    accountId,
    cosmWasmClient,
    apiUrl
  });
  let cursor;
  do {
    const fetchedModules = await accountClient.moduleInfos({
      limit: 20,
      startAfter: cursor
    });
    if (fetchedModules.module_infos.length === 0)
      break;
    for (const moduleInfo of fetchedModules.module_infos)
      if (moduleInfo.id === abstractModuleId("ibc-client" /* IBC_CLIENT */))
        return { ibcEnabled: true };
    cursor = fetchedModules.module_infos[fetchedModules.module_infos.length - 1]?.id;
  } while (cursor !== void 0);
  return { ibcEnabled: false };
}

// src/actions/public/get-module-factory-address-from-registry.ts
async function getModuleFactoryAddressFromRegistry({
  cosmWasmClient,
  registryAddress,
  version
}) {
  return getAbstractModuleAddressFromRegistry({
    moduleName: "module-factory" /* MODULE_FACTORY */,
    cosmWasmClient,
    registryAddress,
    version
  });
}

// src/actions/account/public/get-module-instantiate2-address-from-api.ts
async function getModuleInstantiate2AddressFromApi({
  accountId,
  cosmWasmClient,
  apiUrl,
  moduleId,
  version
}) {
  const chainId = await cosmWasmClient.getChainId();
  const chainName = chainIdToName(chainId);
  const registryAddress = await getRegistryAddressFromApi({
    apiUrl,
    chainName
  });
  const moduleFactoryAddress = await getModuleFactoryAddressFromRegistry({
    cosmWasmClient,
    registryAddress
  });
  const moduleCodeId = await getAppModuleCodeIdFromRegistry({
    moduleId,
    version,
    cosmWasmClient,
    registryAddress
  });
  const moduleCodeDetails = await cosmWasmClient.getCodeDetails(moduleCodeId);
  return getInstantiate2AddressWithAccountId(
    moduleFactoryAddress,
    moduleCodeDetails.checksum,
    accountId
  );
}

// src/actions/account/public/get-modules.ts
async function getModules({
  accountId,
  cosmWasmClient,
  apiUrl,
  ...params
}) {
  const accountQueryClient = await getAccountQueryClientFromApi({
    accountId,
    cosmWasmClient,
    apiUrl
  });
  const { module_infos: modules } = await accountQueryClient.moduleInfos(params);
  return modules;
}

// src/actions/account/public/get-namespace.ts
async function getNamespace({
  accountId,
  cosmWasmClient,
  apiUrl
}) {
  const registryQueryClient = await getRegistryQueryClientFromApi({
    cosmWasmClient,
    apiUrl
  });
  const namespace = await registryQueryClient.namespaces({ accounts: [accountIdToParameter(accountId)] }).then((x) => x.namespaces[0]?.[0]);
  return namespace ?? null;
}

// src/actions/account/public/get-owner.ts
async function getOwner({
  accountId,
  cosmWasmClient,
  apiUrl
}) {
  const accountQueryClient = await getAccountQueryClientFromApi({
    accountId,
    cosmWasmClient,
    apiUrl
  });
  return accountQueryClient.ownership().then((res) => res.owner ?? null).catch((error) => {
    console.error("Failed to fetch the owner:", error);
    throw error;
  });
}

// src/actions/account/public/get-registry-account-id.ts
function getRegistryAccountId({
  accountId
}) {
  return accountId;
}

// src/actions/account/public/get-ibc-client-query-client-from-account.ts
async function getIbcClientQueryClientFromAccount({
  accountId,
  cosmWasmClient,
  apiUrl
}) {
  const ibcClientAddress = await getModuleAddress({
    accountId,
    cosmWasmClient,
    apiUrl,
    id: abstractModuleId("ibc-client" /* IBC_CLIENT */)
  });
  if (!ibcClientAddress) {
    throw new Error("IBC-client module not installed");
  }
  return getIbcClientQueryClient({
    cosmWasmClient,
    ibcClientAddress
  });
}

// src/actions/account/public/get-remote-accounts.ts
async function getRemoteAccounts({
  accountId,
  cosmWasmClient,
  apiUrl
}) {
  let ibcClient;
  try {
    ibcClient = await getIbcClientQueryClientFromAccount({
      accountId,
      cosmWasmClient,
      apiUrl
    });
  } catch (e) {
    console.log("remoteAccounts error", e);
    return {};
  }
  const remoteAccounts = await ibcClient.listRemoteAccountsByAccountId({
    accountId: accountIdToParameter(accountId)
  });
  return Object.fromEntries(remoteAccounts.accounts);
}

// src/actions/account/public/get-remote-account-ids.ts
async function getRemoteAccountIds({
  accountId,
  cosmWasmClient,
  apiUrl
}) {
  const remoteAccountAddrs = await getRemoteAccounts({
    accountId,
    cosmWasmClient,
    apiUrl
  });
  console.log("remote account ids: addresses", remoteAccountAddrs);
  const chainId = await cosmWasmClient.getChainId();
  const sourceChainName = chainIdToName(chainId);
  return Object.keys(remoteAccountAddrs).map((hostChainName) => {
    const remoteTrace = accountId.trace === "local" ? [sourceChainName] : accountId.trace.remote.concat(sourceChainName);
    const remoteChainName = hostChainNameToName(hostChainName);
    return {
      seq: accountId.seq,
      trace: { remote: remoteTrace },
      chainName: remoteChainName
    };
  });
}

// src/actions/account/public/get-sub-account-sequences.ts
async function getSubAccountSequences({
  accountId,
  cosmWasmClient,
  apiUrl,
  ...params
}) {
  const accountQueryClient = await getAccountQueryClientFromApi({
    accountId,
    cosmWasmClient,
    apiUrl
  });
  const { sub_accounts } = await accountQueryClient.subAccountIds(params);
  return sub_accounts;
}

// src/actions/account/public/get-sub-account-ids.ts
async function getSubAccountIds({
  accountId,
  cosmWasmClient,
  apiUrl,
  ...params
}) {
  const chainId = await cosmWasmClient.getChainId();
  const chainName = chainIdToName(chainId);
  const sub_accounts = await getSubAccountSequences({
    accountId,
    cosmWasmClient,
    apiUrl,
    ...params
  });
  return sub_accounts.map(
    (sequence) => sequenceToLocalAccountId({ chainName, sequence })
  );
}

// src/actions/account/public/simulate-execute-remote-account.ts
async function simulateExecuteRemoteAccount({
  accountId,
  cosmWasmClient,
  apiUrl,
  hostChainName,
  accountMsg
}) {
  const remoteProxies = await getRemoteAccounts({
    accountId,
    cosmWasmClient,
    apiUrl
  });
  const remoteAccountAddress = remoteProxies[hostChainName];
  if (!remoteAccountAddress) {
    throw new Error(`No remote account found for chain ${hostChainName}`);
  }
  const cosmosAccountMsg = cosmosWasmExecuteMsg(
    remoteAccountAddress,
    accountMsg,
    []
  );
  return simulateRemoteCosmosMsg({
    apiUrl,
    hostChainName,
    msgs: cosmosAccountMsg
  });
}

// src/actions/account/public/simulate-execute-remote.ts
async function simulateExecuteRemote({
  accountId,
  cosmWasmClient,
  apiUrl,
  hostChainName,
  msgs
}) {
  const accountMsg = AccountExecuteMsgBuilder.execute({
    msgs: Array.isArray(msgs) ? msgs : [msgs]
  });
  return simulateExecuteRemoteAccount({
    apiUrl,
    accountId,
    cosmWasmClient,
    hostChainName,
    accountMsg
  });
}

// src/clients/decorators/account-public.ts
function accountPublicActions(accountId, cosmWasmClient, apiUrl) {
  return {
    getRegistryAccountId: () => getRegistryAccountId({ accountId }),
    getAccountId: () => getAccountId({ accountId, cosmWasmClient }),
    getAccountAddress: ({ extra, ...parameters } = {}) => getAccountAddressFromApi({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getAccountSettings: ({ extra, ...parameters } = {}) => getAccountSettings({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getAccountQueryClientFromApi: ({ extra, ...parameters } = {}) => getAccountQueryClientFromApi({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getModuleAddress: ({ extra, ...parameters }) => getModuleAddress({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getModules: ({ extra, ...parameters } = {}) => getModules({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    predictModuleAddress: ({ extra, ...parameters }) => getModuleInstantiate2AddressFromApi({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getNamespace: ({ extra, ...parameters } = {}) => getNamespace({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getOwner: ({ extra, ...parameters } = {}) => getOwner({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getSubAccountIds: ({ extra, ...parameters } = {}) => getSubAccountIds({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getSubAccountSequences: ({ extra, ...parameters } = {}) => getSubAccountSequences({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getRemoteAccounts: ({ extra, ...parameters } = {}) => getRemoteAccounts({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getRemoteAccountIds: ({ extra, ...parameters } = {}) => getRemoteAccountIds({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    simulateExecuteRemoteAccount: ({ extra, ...parameters }) => simulateExecuteRemoteAccount({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    simulateExecuteRemote: ({ extra, ...parameters }) => simulateExecuteRemote({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    }),
    queryModule: ({ extra, ...parameters }) => queryModule({
      accountId,
      cosmWasmClient,
      apiUrl,
      ...parameters,
      ...extra
    })
  };
}

// src/clients/create-account-public-client.ts
function createAccountPublicClient(parameters) {
  const accountIdString = registryAccountIdToString(parameters.accountId);
  const {
    key = `account-public-${accountIdString}`,
    name = `AccountPublic Client (${accountIdString})`,
    accountId,
    cosmWasmClient,
    apiUrl = ABSTRACT_API_URL
  } = parameters;
  const client = createPublicClient({
    ...parameters,
    key,
    name
  });
  return client.extend(
    () => accountPublicActions(accountId, cosmWasmClient, apiUrl)
  );
}

// src/actions/wallet/get-ans-host-client.ts
function getAnsHostClient({
  signingCosmWasmClient,
  sender,
  ansHostAddress
}) {
  return new AnsHostClient(signingCosmWasmClient, sender, ansHostAddress);
}

// src/actions/wallet/get-ans-host-client-from-api.ts
async function getAnsHostClientFromApi({
  signingCosmWasmClient,
  apiUrl,
  sender
}) {
  const chainId = await signingCosmWasmClient.getChainId();
  const chainName = chainIdToName(chainId);
  const ansHostAddress = await getAnsHostAddressFromApi({
    apiUrl,
    chainName
  });
  return getAnsHostClient({
    signingCosmWasmClient,
    sender,
    ansHostAddress
  });
}

// src/actions/wallet/get-ans-host-client-from-registry.ts
async function getAnsHostClientFromRegistry({
  signingCosmWasmClient,
  sender,
  registryAddress,
  version
}) {
  const ansHostAddress = await getAnsHostAddressFromRegistry({
    cosmWasmClient: signingCosmWasmClient,
    registryAddress,
    version
  });
  return getAnsHostClient({
    signingCosmWasmClient,
    sender,
    ansHostAddress
  });
}

// src/actions/wallet/get-registry-client.ts
function getRegistryClient({
  signingCosmWasmClient,
  sender,
  registryAddress
}) {
  return new RegistryClient(signingCosmWasmClient, sender, registryAddress);
}

// src/actions/wallet/get-registry-client-from-api.ts
async function getRegistryClientFromApi({
  signingCosmWasmClient,
  apiUrl,
  sender
}) {
  const chainId = await signingCosmWasmClient.getChainId();
  const chainName = chainIdToName(chainId);
  const registryAddress = await getRegistryAddressFromApi({
    apiUrl,
    chainName
  });
  return getRegistryClient({
    signingCosmWasmClient,
    sender,
    registryAddress
  });
}

// src/actions/wallet/create-account.ts
async function createAccount({
  signingCosmWasmClient,
  apiUrl,
  sender,
  installModules: installModules2 = [],
  description,
  name,
  namespace,
  authenticator,
  link,
  codeId,
  accountId,
  enableIbc: enableIbc2,
  owner,
  fee,
  memo,
  funds
}) {
  const chainId = await signingCosmWasmClient.getChainId();
  const chainName = chainIdToName(chainId);
  if (enableIbc2 && !installModules2.some(
    ({ name: name2, namespace: namespace2 }) => name2 === "ibc-client" /* IBC_CLIENT */ && namespace2 === ABSTRACT_NAMESPACE
  )) {
    installModules2.push({
      name: "ibc-client" /* IBC_CLIENT */,
      namespace: ABSTRACT_NAMESPACE,
      version: "latest"
    });
  }
  const registryAddress = await getRegistryAddressFromApi({
    apiUrl,
    chainName
  });
  const accountCodeId = await getAppModuleCodeIdFromRegistry({
    cosmWasmClient: signingCosmWasmClient,
    registryAddress,
    moduleId: abstractModuleId("account" /* ACCOUNT */),
    version: "latest"
  });
  const instantiateMsg = {
    code_id: codeId ?? accountCodeId,
    owner: owner || {
      monarchy: {
        monarch: sender
      }
    },
    install_modules: installModules2.map((m) => moduleInstallConfig(m)),
    description,
    name,
    namespace,
    link,
    account_id: accountId ? accountIdToParameter(accountId) : void 0,
    authenticator
  };
  const result = await signingCosmWasmClient.instantiate(
    sender,
    accountCodeId,
    instantiateMsg,
    "Abstract Account",
    fee,
    {
      memo,
      funds,
      admin: sender
    }
  );
  return parseCreateAccountExecuteResult(result, chainName);
}

// src/actions/wallet/create-account-monarchy.ts
async function createAccountMonarchy({
  signingCosmWasmClient,
  apiUrl,
  sender,
  installModules: installModules2 = [],
  description,
  name,
  namespace,
  link,
  owner,
  accountId,
  enableIbc: enableIbc2,
  fee,
  memo,
  funds
}) {
  return createAccount({
    signingCosmWasmClient,
    apiUrl,
    sender,
    owner: {
      monarchy: {
        monarch: owner
      }
    },
    name,
    description,
    link,
    installModules: installModules2,
    namespace,
    accountId: accountId ? accountIdToParameter(accountId) : void 0,
    enableIbc: enableIbc2,
    fee,
    memo,
    funds
  });
}

// src/actions/wallet/get-account-client.ts
async function getAccountClient({
  signingCosmWasmClient,
  sender,
  accountAddress
}) {
  return new AccountClient(signingCosmWasmClient, sender, accountAddress);
}

// src/actions/wallet/get-sender-address.ts
function getSenderAddress({ sender }) {
  return sender;
}

// src/actions/wallet/get-signing-cosm-wasm-client.ts
function getSigningCosmWasmClient({
  signingCosmWasmClient
}) {
  return signingCosmWasmClient;
}

// src/clients/decorators/wallet.ts
function walletActions(signingCosmWasmClient, sender, apiUrl) {
  return {
    createAccount: ({ extra, ...parameters }) => createAccount({
      signingCosmWasmClient,
      sender,
      apiUrl,
      ...parameters,
      ...extra
    }),
    createAccountMonarchy: ({ extra, ...parameters }) => createAccountMonarchy({
      signingCosmWasmClient,
      sender,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getAnsHostClient: ({ extra, ...parameters }) => getAnsHostClient({
      signingCosmWasmClient,
      sender,
      ...parameters,
      ...extra
    }),
    getAnsHostClientFromApi: ({ extra, ...parameters } = {}) => getAnsHostClientFromApi({
      signingCosmWasmClient,
      sender,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getAnsHostClientFromRegistry: ({ extra, ...parameters }) => getAnsHostClientFromRegistry({
      signingCosmWasmClient,
      sender,
      ...parameters,
      ...extra
    }),
    getRegistryClientFromApi: ({ extra, ...parameters } = {}) => getRegistryClientFromApi({
      signingCosmWasmClient,
      sender,
      apiUrl,
      ...parameters,
      ...extra
    }),
    getRegistryClient: ({ extra, ...parameters }) => getRegistryClient({
      signingCosmWasmClient,
      sender,
      ...parameters,
      ...extra
    }),
    getAccountClient: ({ extra, ...parameters }) => getAccountClient({
      signingCosmWasmClient,
      sender,
      ...parameters,
      ...extra
    }),
    getSigningCosmWasmClient: () => getSigningCosmWasmClient({
      signingCosmWasmClient
    }),
    getSenderAddress: () => getSenderAddress({
      sender
    })
  };
}

// src/clients/create-wallet-client.ts
function createWalletClient(parameters) {
  const {
    key = "wallet",
    name = "Wallet Client",
    signingCosmWasmClient,
    sender,
    apiUrl = ABSTRACT_API_URL
  } = parameters;
  const client = createPublicClient({
    ...parameters,
    cosmWasmClient: signingCosmWasmClient,
    key,
    name
  });
  return client.extend(
    () => walletActions(signingCosmWasmClient, sender, apiUrl)
  );
}

// src/actions/account/wallet/claim-namespace.ts
async function claimNamespace({
  signingCosmWasmClient,
  apiUrl,
  namespace,
  sender,
  accountId,
  fee,
  funds,
  memo
}) {
  const registryClient = await getRegistryClientFromApi({
    signingCosmWasmClient,
    apiUrl,
    sender
  });
  return registryClient.claimNamespace(
    { accountId: accountIdToParameter(accountId), namespace },
    fee,
    memo,
    funds
  );
}

// src/actions/account/wallet/execute-on-module.ts
async function executeOnModule({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  moduleId,
  moduleType,
  moduleMsg,
  moduleFunds,
  fee,
  memo,
  funds
}) {
  const account = await getAccountAddressFromApi({
    accountId,
    cosmWasmClient: signingCosmWasmClient,
    apiUrl
  });
  return signingCosmWasmClient.signAndBroadcast(
    sender,
    [
      new AccountMsgComposer(sender, account).executeOnModule(
        {
          moduleId,
          execMsg: encodeModuleMsg(moduleMsg, moduleType),
          // TODO: allow for funds to be sent with the message
          funds: moduleFunds || []
        },
        funds
      )
    ],
    fee,
    memo
  );
}

// src/actions/account/wallet/execute-ibc-action.ts
async function executeIbcAction({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  msg,
  fee,
  memo,
  funds
}) {
  const ibcClientAddress = getModuleAddress({
    accountId,
    cosmWasmClient: signingCosmWasmClient,
    apiUrl,
    id: abstractModuleId("ibc-client" /* IBC_CLIENT */)
  });
  if (!ibcClientAddress) {
    throw new Error(
      `${abstractModuleId("ibc-client" /* IBC_CLIENT */)} is not installed`
    );
  }
  return executeOnModule({
    accountId,
    signingCosmWasmClient,
    apiUrl,
    sender,
    moduleId: abstractModuleId("ibc-client" /* IBC_CLIENT */),
    moduleType: "native",
    moduleMsg: msg,
    moduleFunds: funds,
    fee,
    memo,
    // We pass in no funds here because we want to send them along with the module funds
    funds: []
  });
}

// src/actions/account/wallet/create-remote-account.ts
async function createRemoteAccount({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  fee,
  memo,
  hostChainName,
  installModules: installModules2,
  namespace
}) {
  const registerMsg = {
    register: {
      host_chain: hostChainName,
      install_modules: installModules2 ?? [],
      namespace
    }
  };
  return executeIbcAction({
    accountId,
    signingCosmWasmClient,
    apiUrl,
    sender,
    msg: registerMsg,
    fee,
    memo
  });
}

// src/actions/account/wallet/get-account-client-from-api.ts
async function getAccountClientFromApi({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender
}) {
  const account = await getAccountAddressFromApi({
    accountId,
    cosmWasmClient: signingCosmWasmClient,
    apiUrl
  });
  return getAccountClient({
    signingCosmWasmClient,
    sender,
    accountAddress: account
  });
}

// src/actions/account/wallet/create-sub-account.ts
async function createSubAccount({
  accountId,
  subAccountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  fee,
  memo,
  funds,
  ...rest
}) {
  const accountClient = await getAccountClientFromApi({
    accountId,
    signingCosmWasmClient,
    sender,
    apiUrl
  });
  return accountClient.createSubAccount(
    { ...rest, accountId: subAccountId },
    fee,
    memo,
    funds
  );
}

// src/actions/account/wallet/deposit.ts
async function deposit({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  assets: assets2,
  fee,
  memo
}) {
  const account = await getAccountAddressFromApi({
    accountId,
    cosmWasmClient: signingCosmWasmClient,
    apiUrl
  });
  return signingCosmWasmClient.signAndBroadcast(
    sender,
    encodeAssetsTransfersMsgs(assets2, sender, account),
    fee,
    memo
  );
}

// src/actions/account/wallet/install-modules.ts
async function installModules({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  fee,
  memo,
  funds,
  modules,
  ...rest
}) {
  const accountClient = await getAccountClientFromApi({
    accountId,
    signingCosmWasmClient,
    sender,
    apiUrl
  });
  return accountClient.installModules(
    { modules: modules.map((m) => moduleInstallConfig(m)), ...rest },
    fee,
    memo,
    funds
  );
}

// src/actions/account/wallet/enable-ibc.ts
async function enableIbc({
  ...parameters
}) {
  return installModules({
    ...parameters,
    modules: [
      {
        name: "ibc-client" /* IBC_CLIENT */,
        namespace: ABSTRACT_NAMESPACE,
        version: "latest"
      }
    ]
  });
}

// src/actions/account/wallet/execute.ts
import { toUtf8 as toUtf83 } from "@cosmjs/encoding";
import { MsgExecuteContract as MsgExecuteContract4 } from "cosmjs-types/cosmwasm/wasm/v1/tx";
async function execute({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  msgs,
  fee,
  memo,
  funds
}) {
  const account = await getAccountAddressFromApi({
    accountId,
    cosmWasmClient: signingCosmWasmClient,
    apiUrl
  });
  const _msg = {
    execute: {
      msgs: Array.isArray(msgs) ? msgs : [msgs]
    }
  };
  const encoded = {
    typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
    value: MsgExecuteContract4.fromPartial({
      sender,
      contract: account,
      msg: toUtf83(JSON.stringify(_msg)),
      funds
    })
  };
  return signingCosmWasmClient.signAndBroadcast(sender, [encoded], fee, memo);
}

// src/actions/account/wallet/execute-on-remote-account.ts
async function executeOnRemoteAccount({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  accountMsg,
  hostChainName,
  fee,
  memo
}) {
  const remoteAction = {
    remote_action: {
      host_chain: hostChainName,
      action: {
        dispatch: {
          account_msgs: Array.isArray(accountMsg) ? accountMsg : [accountMsg]
        }
      }
    }
  };
  return executeIbcAction({
    accountId,
    signingCosmWasmClient,
    apiUrl,
    sender,
    msg: remoteAction,
    fee,
    memo
  });
}

// src/actions/account/wallet/execute-on-remote-module.ts
async function executeOnRemoteModule({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  moduleId,
  moduleType,
  moduleMsg,
  hostChainName,
  fee,
  memo
}) {
  const accountMsg = executeOnModuleMsg(
    moduleId,
    moduleMsg,
    moduleType
  );
  return executeOnRemoteAccount({
    accountId,
    signingCosmWasmClient,
    apiUrl,
    sender,
    accountMsg,
    hostChainName,
    fee,
    memo
  });
}

// src/actions/account/wallet/execute-remote.ts
async function executeRemote({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  msgs,
  hostChainName,
  fee,
  memo
}) {
  const accountMsg = AccountExecuteMsgBuilder.execute({
    msgs: Array.isArray(msgs) ? msgs : [msgs]
  });
  return executeOnRemoteAccount({
    accountId,
    signingCosmWasmClient,
    apiUrl,
    sender,
    accountMsg,
    hostChainName,
    fee,
    memo
  });
}

// src/actions/account/wallet/remove-namespace.ts
async function revokeNamespace({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  fee,
  memo,
  funds
}) {
  const registryClient = await getRegistryClientFromApi({
    signingCosmWasmClient,
    apiUrl,
    sender
  });
  const namespace = await getNamespace({
    accountId,
    cosmWasmClient: signingCosmWasmClient,
    apiUrl
  });
  if (!namespace)
    throw new Error("Namespace not found");
  return registryClient.forgoNamespace(
    { namespaces: [namespace] },
    fee,
    memo,
    funds
  );
}

// src/actions/account/wallet/request-remote-funds.ts
async function requestFundsFromRemote({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  hostChainName,
  fee,
  memo
}) {
  const requestFundsMsg = {
    remote_action: {
      host_chain: hostChainName,
      action: {
        helpers: "send_all_back"
      }
    }
  };
  return executeIbcAction({
    accountId,
    signingCosmWasmClient,
    apiUrl,
    sender,
    msg: requestFundsMsg,
    fee,
    memo
  });
}

// src/actions/account/wallet/send-funds-to-remote.ts
async function sendFundsToRemote({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  hostChainName,
  assets: assets2,
  fee,
  memo
}) {
  const sendFundsMsg = {
    send_funds: {
      host_chain: hostChainName
    }
  };
  return executeIbcAction({
    accountId,
    signingCosmWasmClient,
    apiUrl,
    sender,
    msg: sendFundsMsg,
    funds: (Array.isArray(assets2) ? assets2 : [assets2]).map(assetToNativeAsset),
    fee,
    memo
  });
}

// src/actions/account/wallet/uninstall-module.ts
async function uninstallModule({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  fee,
  memo,
  funds,
  ...rest
}) {
  const accountClient = await getAccountClientFromApi({
    accountId,
    signingCosmWasmClient,
    sender,
    apiUrl
  });
  return accountClient.uninstallModule(rest, fee, memo, funds);
}

// src/actions/account/wallet/update-info.ts
async function updateInfo({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  fee,
  memo,
  funds,
  ...rest
}) {
  const accountClient = await getAccountClientFromApi({
    accountId,
    signingCosmWasmClient,
    sender,
    apiUrl
  });
  return accountClient.updateInfo({ ...rest }, fee, memo, funds);
}

// src/actions/account/wallet/update-ownership.ts
async function updateOwnership({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  fee,
  memo,
  funds,
  update
}) {
  const accountClient = await getAccountClientFromApi({
    accountId,
    signingCosmWasmClient,
    sender,
    apiUrl
  });
  return accountClient.updateOwnership(update, fee, memo, funds);
}

// src/actions/account/wallet/update-status.ts
async function updateStatus({
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  fee,
  memo,
  funds,
  ...rest
}) {
  const accountClient = await getAccountClientFromApi({
    accountId,
    signingCosmWasmClient,
    sender,
    apiUrl
  });
  return accountClient.updateStatus({ ...rest }, fee, memo, funds);
}

// src/actions/account/wallet/upgrade-modules.ts
async function upgradeModules({
  accountId,
  subAccountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  fee,
  memo,
  funds,
  ...rest
}) {
  const accountClient = await getAccountClientFromApi({
    accountId: subAccountId ? { ...accountId, seq: subAccountId } : accountId,
    signingCosmWasmClient,
    sender,
    apiUrl
  });
  return accountClient.upgrade(rest, fee, memo, funds);
}

// src/actions/account/wallet/withdraw.ts
async function sendFunds({
  fee,
  memo,
  accountId,
  signingCosmWasmClient,
  apiUrl,
  sender,
  assets: assets2,
  recipient,
  funds
}) {
  const account = await getAccountAddressFromApi({
    accountId,
    cosmWasmClient: signingCosmWasmClient,
    apiUrl
  });
  const transferMsgs = encodeAssetsAccountTransferMsgs(
    assets2,
    account,
    recipient
  );
  return execute({
    accountId,
    signingCosmWasmClient,
    apiUrl,
    sender,
    msgs: transferMsgs,
    fee,
    memo,
    funds
  });
}
var withdraw = sendFunds;

// src/clients/decorators/account-wallet.ts
function accountWalletActions(accountId, signingCosmWasmClient, sender, apiUrl) {
  return {
    claimNamespace: ({ extra, ...parameters }) => claimNamespace({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    createSubAccount: ({ extra, ...parameters }) => createSubAccount({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    createRemoteAccount: ({ extra, ...parameters }) => createRemoteAccount({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    deposit: ({ extra, ...parameters }) => deposit({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    execute: ({ extra, ...parameters }) => execute({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    executeOnModule: ({ extra, ...parameters }) => executeOnModule({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    upgradeModules: ({ extra, ...parameters }) => upgradeModules({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    installModules: ({ extra, ...parameters }) => installModules({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    uninstallModule: ({ extra, ...parameters }) => uninstallModule({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    executeOnRemote: ({ extra, ...parameters }) => executeOnRemoteAccount({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    executeOnRemoteModule: ({ extra, ...parameters }) => executeOnRemoteModule({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    executeRemote: ({ extra, ...parameters }) => executeRemote({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    sendFundsToRemote: ({ extra, ...parameters }) => sendFundsToRemote({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    requestFundsFromRemote: ({ extra, ...parameters }) => requestFundsFromRemote({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    withdraw: ({ extra, ...parameters }) => withdraw({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    sendFunds: ({ extra, ...parameters }) => sendFunds({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    updateStatus: ({ extra, ...parameters }) => updateStatus({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    updateInfo: ({ extra, ...parameters }) => updateInfo({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    updateOwnership: ({ extra, ...parameters }) => updateOwnership({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    enableIbc: ({ extra, ...parameters }) => enableIbc({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    revokeNamespace: ({ extra, ...parameters }) => revokeNamespace({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    }),
    getAccountClientFromApi: ({ extra, ...parameters }) => getAccountClientFromApi({
      accountId,
      signingCosmWasmClient,
      apiUrl,
      sender,
      ...parameters,
      ...extra
    })
  };
}

// src/clients/create-account-wallet-client.ts
function createAccountWalletClient(parameters) {
  const accountIdString = registryAccountIdToString(parameters.accountId);
  const {
    key = `account-wallet-${accountIdString}`,
    name = `AccountWallet Client (${accountIdString})`,
    accountId,
    signingCosmWasmClient,
    sender,
    apiUrl = ABSTRACT_API_URL
  } = parameters;
  const client = createWalletClient({
    ...parameters,
    key,
    name
  });
  return client.extend(
    () => accountWalletActions(accountId, signingCosmWasmClient, sender, apiUrl)
  );
}

// src/utils/constants.ts
var ABSTRACT_CONSTANTS = {
  MAX_PAGE_SIZE: 25,
  MAX_VC_PAGE_SIZE: 20,
  MAX_PROXY_PAGE_SIZE: 20,
  MAX_MANAGER_PAGE_SIZE: 10
};
var ABSTRACT_API_URL = "https://abstract-subgraph-0-19.fly.dev/graphql";
var RAW_QUERY_KEYS = {
  ModuleData: "module_data",
  ContractInfo: "contract_info"
};

// src/clients/create-api-client.ts
function createApiClient(parameters) {
  const {
    apiUrl = ABSTRACT_API_URL,
    key = "api",
    name = "Api Client"
  } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name
  });
  return client.extend(() => apiActions(apiUrl));
}

// src/utils/chain-registry/host-chain-name-to-name.ts
function hostChainNameToName(hostChainName) {
  const chainName = chains.find(
    ({ chain_name, chain_id }) => chain_name === hostChainName || chain_id && chainIdToHostChainName(chain_id) === hostChainName
  )?.chain_name;
  if (!chainName) {
    throw new Error(`Chain not found by hostChain: ${hostChainName}`);
  }
  return chainName;
}

// src/utils/chain-registry/chain-id-to-host-chain-name.ts
var CHAIN_ID_SEPARATOR = "-";
var chainIdToHostChainName = (chainId) => {
  return chainId.split(CHAIN_ID_SEPARATOR)[0];
};

// src/utils/chain-registry/chain-name-to-id.ts
function chainNameToId(chainName) {
  if (chainName === "terra2testnet")
    return "pisco-1";
  const chainId = chains.find(
    ({ chain_name }) => chain_name === chainName
  )?.chain_id;
  if (!chainId) {
    throw new Error(`Chain not found by chainName: ${chainName}`);
  }
  return chainId;
}

// src/utils/tokens/ans/constants.ts
var CHAIN_SEPARATOR = ">";
var PROTOCOL_SEPARATOR = "/";

// src/utils/tokens/ans/format-ans-name-without-protocol.ts
import * as s3 from "string-ts";
function formatAnsNameWithoutProtocol(name) {
  const nameWithoutProtocol = s3.split(name, PROTOCOL_SEPARATOR)[1];
  if (!nameWithoutProtocol) {
    throw new Error(`Invalid name: ${name}`);
  }
  return s3.lowerCase(nameWithoutProtocol);
}

// src/utils/tokens/ans/ibc-token-to-ans-id.ts
function ibcTokenToAnsId(chainName, asset) {
  return `${chainName.toLowerCase().replace("testnet", "")}${CHAIN_SEPARATOR}${asset}`;
}

// src/utils/tokens/ans/join-asset-names.ts
function joinAssetNames(assetNames) {
  return assetNames.map((s9) => s9.toLowerCase()).sort().join(",");
}

// src/utils/tokens/ans/lp-token-to-ans-id.ts
function lpTokenToAnsId(dexName, assetNames) {
  return `${dexName.toLowerCase()}/${joinAssetNames(
    assetNames
  )}`;
}

// src/utils/tokens/ans/parse-source-chain.ts
import * as s4 from "string-ts";
function parseSourceChain(id) {
  return s4.split(id, CHAIN_SEPARATOR)[0];
}

// src/utils/tokens/ans/parse-source-protocol.ts
import * as s5 from "string-ts";
function parseSourceProtocol(name) {
  return s5.split(name, PROTOCOL_SEPARATOR)[0];
}

// src/utils/tokens/ans/parse-symbol.ts
import * as s6 from "string-ts";
function parseSymbol(name) {
  const split7 = s6.split(name, CHAIN_SEPARATOR);
  return s6.lowerCase(
    s6.join(split7.slice(1), CHAIN_SEPARATOR)
  );
}

// src/utils/tokens/ans/staking-contract-to-ans-id.ts
function stakingContractToAnsId(providerName, assetNames) {
  return ["staking", providerName, joinAssetNames(assetNames)].join(
    "/"
  );
}

// src/utils/tokens/token-to-asset.ts
function tokenToAsset(token, amount) {
  return { ...token, amount };
}

// src/utils/registry/module-id/module-id-to-name.ts
import * as s7 from "string-ts";

// src/utils/registry/module-id/types.ts
var MODULE_DELIMITER = ":";

// src/utils/registry/module-id/module-id-to-name.ts
function moduleIdToName(id) {
  const split7 = s7.split(id, MODULE_DELIMITER);
  if (split7.length < 2 || !split7[1]) {
    throw new Error(`Cannot find name for module: ${id}`);
  }
  return split7[1];
}

// src/utils/registry/module-id/module-id-to-namespace.ts
import * as s8 from "string-ts";
function moduleIdToNamespace(id) {
  const split7 = s8.split(id, MODULE_DELIMITER);
  const namespace = split7[0];
  if (split7.length < 2 || !namespace) {
    throw new Error(`Cannot find namespace for module: ${id}`);
  }
  return namespace;
}

// src/utils/authz/auth-transactions-types-url.ts
var AuthzTransactionTypeUrl = /* @__PURE__ */ ((AuthzTransactionTypeUrl2) => {
  AuthzTransactionTypeUrl2["AuthzMsgExec"] = "/cosmos.authz.v1beta1.MsgExec";
  AuthzTransactionTypeUrl2["AuthzMsgGrant"] = "/cosmos.authz.v1beta1.MsgGrant";
  AuthzTransactionTypeUrl2["GenericAuthorization"] = "/cosmos.authz.v1beta1.GenericAuthorization";
  AuthzTransactionTypeUrl2["SendAuthorization"] = "/cosmos.bank.v1beta1.SendAuthorization";
  return AuthzTransactionTypeUrl2;
})(AuthzTransactionTypeUrl || {});

// src/utils/authz/bank-transaction-types-url.ts
var BankTransactionTypeUrl = /* @__PURE__ */ ((BankTransactionTypeUrl2) => {
  BankTransactionTypeUrl2["Send"] = "/cosmos.bank.v1beta1.MsgSend";
  BankTransactionTypeUrl2["MultiSend"] = "/cosmos.bank.v1beta1.MsgMultiSend";
  return BankTransactionTypeUrl2;
})(BankTransactionTypeUrl || {});

// src/utils/authz/encode-bank-send-msg.ts
import { MsgSend as MsgSend2 } from "cosmjs-types/cosmos/bank/v1beta1/tx";
function encodeBankSendMsg(fromAddress, toAddress, amount) {
  return {
    typeUrl: "/cosmos.bank.v1beta1.MsgSend" /* Send */,
    value: MsgSend2.encode(
      MsgSend2.fromPartial({
        fromAddress,
        toAddress,
        amount
      })
    ).finish()
  };
}

// src/utils/authz/encode-authz-exec-msg.ts
import { MsgExec } from "cosmjs-types/cosmos/authz/v1beta1/tx";
function encodeAuthzExecMsg(grantee, msgs) {
  return {
    typeUrl: "/cosmos.authz.v1beta1.MsgExec" /* AuthzMsgExec */,
    value: MsgExec.fromPartial({
      grantee,
      msgs
    })
  };
}

// src/utils/authz/encode-authz-grant-send-authorization-msg.ts
import { MsgGrant } from "cosmjs-types/cosmos/authz/v1beta1/tx";
import { SendAuthorization } from "cosmjs-types/cosmos/bank/v1beta1/authz";
function encodeAuthzGrantSendAuthorizationMsg(granter, grantee, options, expiration) {
  return {
    typeUrl: "/cosmos.authz.v1beta1.MsgGrant" /* AuthzMsgGrant */,
    value: MsgGrant.fromPartial({
      granter,
      grantee,
      grant: {
        authorization: {
          typeUrl: "/cosmos.bank.v1beta1.SendAuthorization" /* SendAuthorization */,
          value: SendAuthorization.encode(
            SendAuthorization.fromPartial(options)
          ).finish()
        },
        expiration
      }
    })
  };
}

// src/utils/authz/encode-authz-grant-generic-authorization-msg.ts
import { GenericAuthorization } from "cosmjs-types/cosmos/authz/v1beta1/authz";
import { MsgGrant as MsgGrant2 } from "cosmjs-types/cosmos/authz/v1beta1/tx";
function encodeAuthzGrantGenericAuthorizationMsg(granter, grantee, permission, expiration) {
  return {
    typeUrl: "/cosmos.authz.v1beta1.MsgGrant" /* AuthzMsgGrant */,
    value: MsgGrant2.fromPartial({
      granter,
      grantee,
      grant: {
        authorization: {
          typeUrl: "/cosmos.authz.v1beta1.GenericAuthorization" /* GenericAuthorization */,
          value: GenericAuthorization.encode(
            GenericAuthorization.fromPartial({
              msg: permission
            })
          ).finish()
        },
        expiration
      }
    })
  };
}

// src/utils/cosmwasm/raw-query.ts
import { fromAscii, toAscii } from "@cosmjs/encoding";
var rawQuery2 = async ({
  cosmWasmClient,
  address,
  key
}) => {
  if (!cosmWasmClient)
    return Promise.reject(new Error("No cosmWasmClient"));
  return cosmWasmClient.queryContractRaw(address, toAscii(key)).then((response) => {
    if (!response)
      return response;
    try {
      const res = JSON.parse(fromAscii(response));
      return res;
    } catch (e) {
      console.error("Could not parse response", e, fromAscii(response));
    }
  });
};

// src/utils/cosmwasm/wasm-execute.ts
var wasmExecuteMsg = (contractAddress, msg, funds) => {
  return {
    execute: {
      contract_addr: contractAddress,
      funds: funds ?? [],
      msg: typeof msg === "string" ? msg : jsonToBinary(msg)
    }
  };
};
var cosmosWasmExecuteMsg = (contractAddress, msg, funds) => {
  return {
    wasm: wasmExecuteMsg(contractAddress, msg, funds)
  };
};

export {
  encodeCreateSubAccountMsg,
  accountIdApiFormatToAccountId,
  accountIdToApiFormat,
  accountIdToParameter,
  ACCOUNT_ID_CHAIN_DELIMITER,
  ACCOUNT_ID_SEQUENCE_DELIMITER,
  accountIdToString,
  sequenceToLocalAccountId,
  stringToAccountId,
  registryAccountIdToString,
  findAttribute,
  ABSTRACT_EVENT_MARKER,
  findAbstractAttribute,
  parseCreateAccountExecuteResult,
  jsonToUtf8,
  utf8ToJson,
  jsonToBinary,
  binaryToJson,
  toUint8Array,
  toSha256,
  getAccountIdSalt,
  getInstantiate2AddressWithAccountId,
  getInstantiate2Address,
  coinToNativeAsset,
  isCW20Token,
  isCW20Asset,
  assetToCW20Asset,
  encodeCW20AssetSendMsg,
  encodeCW20AssetTransferMsg,
  encodeNativeAssetTransferMsg,
  nativeAssetToCoin,
  isNativeToken,
  isNativeAsset,
  assetToNativeAsset,
  encodeAssetTransferMsg,
  encodeAssetsTransfersMsgs,
  encodeAssetsAccountTransferMsgs,
  assets,
  chains,
  chainIdToName,
  hostChainNameToName,
  chainIdToHostChainName,
  chainNameToId,
  ansTokenFromApi,
  CHAIN_SEPARATOR,
  PROTOCOL_SEPARATOR,
  formatAnsNameWithoutProtocol,
  ibcTokenToAnsId,
  joinAssetNames,
  lpTokenToAnsId,
  parseSourceChain,
  parseSourceProtocol,
  parseSymbol,
  stakingContractToAnsId,
  tokenToAsset,
  moduleVersionToString,
  formatModuleIdWithVersion,
  MODULE_DELIMITER,
  moduleIdToName,
  moduleIdToNamespace,
  registryModuleToAddress,
  registryModuleToCodeId,
  registryModuleToType,
  registryModuleToVersion,
  ABSTRACT_CONSTANTS,
  ABSTRACT_API_URL,
  RAW_QUERY_KEYS,
  AuthzTransactionTypeUrl,
  BankTransactionTypeUrl,
  encodeBankSendMsg,
  encodeAuthzExecMsg,
  encodeAuthzGrantSendAuthorizationMsg,
  encodeAuthzGrantGenericAuthorizationMsg,
  rawQuery2 as rawQuery,
  wasmExecuteMsg,
  cosmosWasmExecuteMsg,
  ModuleExecuteMsgFactory,
  ModuleQueryMsgFactory,
  ModuleInitMsgFactory,
  ModuleMigrateMsgFactory,
  AppExecuteMsgFactory,
  AppQueryMsgFactory,
  AdapterExecuteMsgFactory,
  AdapterQueryMsgBuilder,
  wrapModuleExecMsg,
  encodeModuleMsg,
  executeOnModuleMsg,
  ABSTRACT_NAMESPACE,
  abstractModuleId,
  wrapModuleQueryMsg,
  moduleInstallConfig,
  createClient,
  getIcaClientQueryClient,
  getRegistryQueryClient,
  getAbstractModuleAddressFromRegistry,
  getAccountQueryClient,
  CommonModuleNames,
  getAnsHostAddressFromRegistry,
  getAnsHostQueryClient,
  getAnsHostQueryClientFromRegistry,
  getCosmWasmClient,
  getIbcClientQueryClient,
  getRegistryModuleData,
  createAbstractBaseClient,
  gql,
  getAccountBalancesFromApi,
  getAccountsByOwnerFromApi,
  getAnsHostAddressFromApi,
  getAnsTokensFromApi,
  getAnsTokenFromApi,
  getModulesFromApi,
  getRegistryAddressFromApi,
  getSubAccountIdsByModuleIdFromApi,
  getChainRpcUrlFromApi,
  getRegistryQueryClientFromApi,
  getAbstractModuleVersion,
  getAppModuleCodeIdFromRegistry,
  getAnsHostQueryClientFromApi,
  getAnsHostVersionFromApi,
  getIbcClientAddressFromRegistry,
  getIbcClientQueryClientFromRegistry,
  createPublicClient,
  getAccountAddressFromApi,
  getAccountQueryClientFromApi,
  getModuleAddress,
  getModuleFactoryAddressFromRegistry,
  getModuleInstantiate2AddressFromApi,
  getModules,
  getNamespace,
  getOwner,
  getIbcClientQueryClientFromAccount,
  getRemoteAccounts,
  getRemoteAccountIds,
  getSubAccountSequences,
  getSubAccountIds,
  createAccountPublicClient,
  getAnsHostClient,
  getAnsHostClientFromApi,
  getAnsHostClientFromRegistry,
  getRegistryClient,
  getRegistryClientFromApi,
  createAccount,
  createAccountMonarchy,
  getAccountClient,
  getSenderAddress,
  getSigningCosmWasmClient,
  createWalletClient,
  claimNamespace,
  getAccountClientFromApi,
  createSubAccount,
  deposit,
  execute,
  revokeNamespace,
  upgradeModules,
  sendFunds,
  withdraw,
  createAccountWalletClient,
  createApiClient
};
