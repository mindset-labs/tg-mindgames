import {
  ABSTRACT_API_URL,
  ABSTRACT_CONSTANTS,
  AdapterQueryMsgBuilder,
  AppQueryMsgFactory,
  RAW_QUERY_KEYS,
  accountIdToParameter,
  accountIdToString,
  assets,
  chains,
  createApiClient,
  createPublicClient,
  gql,
  jsonToBinary,
  jsonToUtf8,
  rawQuery,
  sequenceToLocalAccountId
} from "../chunk-WASRJSPC.js";
import {
  AccountClient,
  AccountQueryClient,
  AnsHostClient,
  AnsHostQueryClient,
  RegistryClient,
  RegistryQueryClient
} from "../chunk-B2V6LSMD.js";

// src/legacy/api/apiRequest.ts
import request from "graphql-request";
var graphqlRequest = request;

// src/legacy/clients/objects/AbstractModule.ts
import { P as P2, match as match2 } from "ts-pattern";

// src/legacy/clients/errors.ts
var ModuleNotFoundError = class extends Error {
  constructor(moduleId, version) {
    super(`${moduleId} ${version ? `with version ${version} ` : ""} not found.`);
    this.name = "ModuleNotFoundError";
  }
};
var AbstractNotFoundError = class extends Error {
  constructor(message) {
    super(`Abstract not found. Additional context: ${message}`);
    this.name = "AbstractNotFoundError";
  }
};
var AccountNotFoundError = class extends Error {
  constructor(accountId) {
    super(`Account ${accountId} not found.`);
    this.name = "AccountNotFoundError";
  }
};

// src/legacy/clients/objects/moduleInfo.ts
import { P, match } from "ts-pattern";
var _ModuleInfo = class _ModuleInfo {
  /**
  
     * @param moduleId
     * @param moduleProvider
     * @param moduleName
     * @param version IF not provided, latest will be loaded
     */
  constructor({
    moduleId,
    namespace: moduleProvider,
    name: moduleName,
    version
  }) {
    const [provider, name] = moduleId ? moduleId.split(":") : [moduleProvider, moduleName];
    this.name = name;
    this.namespace = provider;
    this.version = version && version !== "latest" ? { version } : "latest";
  }
  /**
   * Return the full module id with the namespace and name.
   */
  get id() {
    return [this.namespace, this.name].join(":");
  }
  /**
   * Return the full module id with the namespace and name concatenated with the version.
   */
  get idWithVersion() {
    return [this.id, this.versionString].join(":");
  }
  /**
   * Get the version as a string.
   * Latest version returns "latest".
   */
  get versionString() {
    return _ModuleInfo.versionAsString(this.version);
  }
  static from(moduleInfo) {
    const version = this.versionAsString(moduleInfo.version);
    return new _ModuleInfo({
      namespace: moduleInfo.namespace,
      name: moduleInfo.name,
      version
    });
  }
  static versionAsString(version) {
    return match(version).with({ version: P.select() }, (version2) => version2).with("latest", () => "latest").otherwise((x) => {
      throw new Error(`Unexpected version: ${JSON.stringify(x)}`);
    });
  }
  static latest(idOrName) {
    return new _ModuleInfo({ ...idOrName });
  }
  /**
   * Build abstract module info from the given name and version.
   * @param moduleName
   * @param version
   */
  static abstract(moduleName, version) {
    return new _ModuleInfo({
      namespace: this.ABSTRACT_PROVIDER,
      name: moduleName,
      version
    });
  }
  /**
   * Transform a string formatted like "namespace:name:version" into a ModuleInfo object.
   * @param info
   */
  static fromString(info) {
    const split = info.split(":");
    if (split.length !== 3) {
      throw new Error(`Invalid module info: ${info}`);
    }
    const [namespace, name, version] = split;
    return new _ModuleInfo({
      // TODO: remove this hack
      namespace,
      // TODO: remove this hack
      name,
      version
    });
  }
};
_ModuleInfo.ABSTRACT_PROVIDER = "abstract";
var ModuleInfo = _ModuleInfo;

// src/legacy/clients/objects/AbstractModule.ts
var AbstractModule = class _AbstractModule {
  constructor({ info, reference }, config) {
    this.info = ModuleInfo.from(info);
    this.reference = reference;
    this.config = config;
    this._data = null;
  }
  /**
   * Create an Abstract module from the chain response.
   * @param response
   */
  static fromResponse(response) {
    return new _AbstractModule(response.module, response.config);
  }
  // static from(response: [VcModuleInfo, ModuleReference]) {
  //   const [info, reference] = response
  //   return new Module({ info, reference })
  // }
  /**
   * The module id with the namespace.
   * Example: abstract:bank
   */
  get name() {
    return this.info.name;
  }
  static async loadById(registryClient, moduleId, version) {
    const moduleInfo = new ModuleInfo({ moduleId, version });
    return await _AbstractModule.loadByInfo(registryClient, moduleInfo);
  }
  static async loadByInfo(registryClient, moduleInfo) {
    const info = ModuleInfo.from(moduleInfo);
    return await registryClient.modules({
      infos: [info]
    }).then(({ modules }) => modules?.[0]).then((m) => {
      if (!m)
        throw new ModuleNotFoundError(info.id, info.versionString);
      return m;
    }).catch((_2) => {
      throw new ModuleNotFoundError(info.id, info.versionString);
    }).then(_AbstractModule.fromResponse);
  }
  static async loadByInfos(registryClient, moduleInfos) {
    const modules = await registryClient.modules({
      infos: moduleInfos
    }).then(({ modules: modules2 }) => modules2);
    return modules.map(_AbstractModule.fromResponse);
  }
  /**
   * Get the type of this module.
   */
  get type() {
    return match2(this.reference).with({ account: P2.select() }, () => "account").with({ app: P2.select() }, () => "app").with({ standalone: P2.select() }, () => "standalone").with({ native: P2.select() }, () => "native").with({ adapter: P2.select() }, () => "adapter").otherwise((x) => {
      throw new Error(
        `Expected module with code id, got ${JSON.stringify(x)}`
      );
    });
  }
  get address() {
    return match2(this.reference).with({ native: P2.select() }, (native) => native).with({ adapter: P2.select() }, (adapter) => adapter).otherwise((x) => {
      throw new Error(`Expected addressable module, got ${JSON.stringify(x)}`);
    });
  }
  get codeId() {
    return match2(this.reference).with({ account: P2.select() }, (core) => core).with({ app: P2.select() }, (app) => app).with({ standalone: P2.select() }, (standalone) => standalone).otherwise((x) => {
      throw new Error(
        `Expected module with code id, got ${JSON.stringify(x)}`
      );
    });
  }
  /**
   * Retrieve the module data for a given module.
   * @throws Error if module not found
   * @returns module data if instantiated, null otherwise
   */
  async getModuleData(client) {
    if (this._data != null) {
      return this._data;
    }
    const firstInstantiation = await match2(this.type).with("adapter", async () => {
      return Promise.resolve(this.address);
    }).with("standalone", "app", async () => {
      const instantiations = await client.getContracts(this.codeId);
      const firstInstantiation2 = instantiations[0];
      if (!firstInstantiation2) {
        console.log(
          `Could not find first instantiation of ${this.info.idWithVersion}`
        );
        return null;
      }
      return Promise.resolve(firstInstantiation2);
    }).with("native", "account", () => {
      return null;
    }).otherwise(() => {
      throw new Error(
        `Expected module known type, got ${JSON.stringify(this.type)}`
      );
    });
    if (firstInstantiation === null) {
      return null;
    }
    console.log(firstInstantiation);
    return await rawQuery({
      cosmWasmClient: client,
      address: firstInstantiation,
      key: RAW_QUERY_KEYS.ModuleData
    });
  }
};

// src/legacy/clients/objects/AnsAssetEntry.ts
var ANS_CHAIN_SEPARATOR = ">";
var ANS_PROTOCOL_SEPARATOR = "/";
var AnsAssetEntry = class {
  constructor(ansName) {
    this._ansName = ansName;
  }
  validate() {
    const split = this._ansName.split(ANS_CHAIN_SEPARATOR);
    if (split.length < 2) {
      throw new Error(`Invalid ANS name, missing chain: ${this._ansName}`);
    }
    return this;
  }
  /**
   * Returns the protocol of the asset.
   * astroport/x,y -> astroport
   */
  get sourceProtocol() {
    return this._ansName.split(ANS_PROTOCOL_SEPARATOR)[0];
  }
  /**
   * Get the ans name.
   */
  get ansName() {
    return this._ansName;
  }
  get hasProtocol() {
    return this._ansName.includes(ANS_PROTOCOL_SEPARATOR);
  }
  /**
   * Returns the lowercased name of the asset without the protocol.
   * astroport/x,y -> x,y
   */
  get withoutProtocol() {
    const split = this._ansName.split(ANS_PROTOCOL_SEPARATOR);
    return split.slice(1).join(ANS_PROTOCOL_SEPARATOR).toLowerCase();
  }
  /**
   * Returns the source chain of the asset.
   * osmosis>juno>dao -> osmosis
   */
  get sourceChain() {
    return this._ansName.split(ANS_CHAIN_SEPARATOR)[0];
  }
  /**
   * Returns the lowercased symbol of the asset. Keep in mind that this method maintains the
   * chain information. So, if the asset has passed through multiple chains, the most recent
   * chain is first.
   *
   * osmosis>juno>dao -> juno>dao
   * juno>dao -> dao
   * @unstable
   */
  get symbol() {
    const split = this._ansName.split(ANS_CHAIN_SEPARATOR);
    return split.slice(1).join(ANS_CHAIN_SEPARATOR).toLowerCase();
  }
};

// src/legacy/clients/objects/AnsAssetList.ts
import { match as match5 } from "ts-pattern";

// src/legacy/clients/objects/Asset.ts
import { parseCoins } from "@cosmjs/stargate";
import { MsgExecuteContract } from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { P as P3, match as match3 } from "ts-pattern";
var Asset = class _Asset {
  constructor(info, amount) {
    this.info = info;
    this.amount = amount;
    if (info.cw1155 !== void 0) {
      throw new Error("CW1155 not supported yet");
    }
  }
  /**
   * Create an asset from a coin.
   */
  static fromCoin(coin) {
    return new _Asset({ native: coin.denom }, coin.amount);
  }
  /**
   * Parse a string of the format {amount}{denom} into an AssetUnchecked object. This is the format
   * that Cosmos SDK uses to stringify native coins. For example:
   *
   * 12345uatom
   * 69420ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2
   * 88888factory/osmo1z926ax906k0ycsuckele6x5hh66e2m4m6ry7dn
   * Since native coin denoms can only start with a non-numerial character, while its amount can
   * only contain numerical characters, we simply consider the first non-numerical character and
   * all that comes after as the denom, while all that comes before it as the amount. This is the
   * approach used in the Steak Hub contract.
   * @param sdkString
   * @throws if the string is not in the expected format
   */
  static fromSdkString(sdkString) {
    return parseCoins(sdkString).map((coin) => _Asset.fromCoin(coin))[0];
  }
  /**
   * Create a new asset instance representing a native coin of given denom and amount
   * @param denom
   * @param amount
   */
  static native(denom, amount) {
    return new _Asset({ native: denom }, amount);
  }
  /**
   * Create a new asset instance representing a CW20 token of given contract address and amount.
   * @param address
   * @param amount
   */
  static cw20(address, amount) {
    return new _Asset({ cw20: address }, amount);
  }
  /**
   * Return whether this asset is a native asset.
   */
  isNative() {
    return this.info.native !== void 0;
  }
  /**
   * Return whether this asset is a CW20 token.
   */
  isCw20() {
    return this.info.cw20 !== void 0;
  }
  /**
   * Turn a native asset into a coin.
   * @throws if the asset is not a native asset
   */
  intoCoin() {
    if (!this.isNative()) {
      throw new Error(`Expected native asset, got ${JSON.stringify(this.info)}`);
    }
    return {
      denom: this.info.native,
      amount: this.amount
    };
  }
  /**
   * Retrieve the contract address of the CW20 token.
   * @throws if the asset is not a CW20 token
   */
  cw20Address() {
    if (!this.isCw20()) {
      throw new Error(`Expected CW20 asset, got ${JSON.stringify(this.info)}`);
    }
    return this.info.cw20;
  }
  /**
   * Generate a message that transfers the asset from the sender to a specified recipient.
   * @param sender
   * @param recipient
   * @param funds funds to send with the message ONLY FOR CW20s
   */
  transferMsg(sender, recipient, funds) {
    return match3(this.info).with({ native: P3.select() }, (nativeDenom) => ({
      typeUrl: "/cosmos.bank.v1beta1.MsgSend",
      value: {
        fromAddress: sender,
        toAddress: recipient,
        amount: [
          {
            denom: nativeDenom,
            amount: this.amount
          }
        ]
      }
    })).with({ cw20: P3.select() }, (cw20Addr) => ({
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender,
        contract: cw20Addr,
        msg: jsonToUtf8({
          transfer: {
            amount: this.amount,
            recipient
          }
        }),
        funds
      })
    })).otherwise((x) => {
      throw new Error(
        `Expected assetInfo with address, got ${JSON.stringify(x)}`
      );
    });
  }
  /**
   * Generate a message that sends a CW20 token to the specified recipient with a binary payload.
   *
   * @throws if invoked on an Asset instance representing a native coin, as native coins do not
   *   have an equivalent method implemented.
   * @param sender
   * @param contractAddress the contract address to hook
   * @param msg the binary payload to send. Can also provide json
   * @param funds funds to send with the message
   */
  sendMsg(sender, contractAddress, msg, funds) {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender,
        contract: contractAddress,
        msg: jsonToUtf8({
          send: {
            amount: this.amount,
            contract: contractAddress,
            msg: typeof msg === "string" ? msg : jsonToBinary(msg)
          }
        }),
        funds
      })
    };
  }
};

// src/legacy/clients/objects/AssetList.ts
import { toBase64 } from "@cosmjs/encoding";
import { match as match4 } from "ts-pattern";
var AssetList = class _AssetList {
  constructor(_assets) {
    this._assets = _assets;
  }
  /**
   * Create an asset list from a list of native coins.
   */
  static fromCoins(coins) {
    return new _AssetList(coins.map((coin) => Asset.fromCoin(coin)));
  }
  /**
   * Get the list of assets.
   */
  get assets() {
    return this._assets;
  }
  /**
   * Get the length of the list.
   */
  get length() {
    return this._assets.length;
  }
  /**
   * Add an asset to the list.
   * @param asset
   */
  add(asset) {
    this._assets.push(asset);
    return this;
  }
  /**
   * Generate a list of messages to send all the assets to a recipient.
   * Combines all native asset transfers into a single message.
   */
  transferMsgs(sender, recipient) {
    const msgs = [];
    const [natives, others] = this._assets.reduce(
      ([natives2, others2], asset) => {
        if (asset.isNative()) {
          natives2.push(asset);
        } else {
          others2.push(asset);
        }
        return [natives2, others2];
      },
      [[], []]
    );
    if (natives.length > 0) {
      const nativeCoins = natives.map((asset) => asset.intoCoin());
      const sendMsg = {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value: {
          fromAddress: sender,
          toAddress: recipient,
          // the denominations must be sorted alphabetically
          amount: nativeCoins.sort((a, b) => a.denom.localeCompare(b.denom))
        }
      };
      msgs.push(sendMsg);
    }
    others.forEach((asset) => {
      msgs.push(asset.transferMsg(sender, recipient));
    });
    return msgs;
  }
  /**
   * Generate a list of Cosmos messages to send all the assets to a recipient.
   * These would be executed by a contract such as the Abstract proxy.
   *
   * Combines all native asset transfers into a single message.
   */
  cosmosTransferMsgs(sender, recipient) {
    const msgs = this.transferMsgs(sender, recipient);
    return msgs.map((msg) => {
      return match4(msg.typeUrl).with("/cosmos.bank.v1beta1.MsgSend", () => {
        const { amount, toAddress } = msg.value;
        return {
          bank: {
            send: {
              amount,
              to_address: toAddress
            }
          }
        };
      }).with("/cosmwasm.wasm.v1.MsgExecuteContract", () => {
        const { contract, msg: execMsg } = msg.value;
        return {
          wasm: {
            execute: {
              contract_addr: contract,
              funds: [],
              msg: toBase64(execMsg)
            }
          }
        };
      }).otherwise(() => {
        throw new Error(`Unsupported message type: ${msg.typeUrl}`);
      });
    });
  }
};

// src/legacy/clients/objects/AnsAssetList.ts
var assetsQuery = gql(
  /* GraphQL */
  `
  query AssetsQuery($chain: ID!, $filter: IdsFilter!) {
    ans(chain: $chain) {
      assets(filter: $filter) {
        id
        type
        address
      }
    }
  }
`
);
var AnsAssetList = class {
  constructor(_assets) {
    this._assets = _assets;
    /**
     * Resolves the assets into an {@link AssetList} by querying the chain.
     */
    this.resolve = async (queryClient) => {
      const chainName = await queryClient.getChainName();
      const ids = this.assets.map((asset) => asset.name.ansName);
      const {
        ans: { assets: resolvedAssets }
      } = await queryClient.queryApi(assetsQuery, {
        chain: chainName,
        filter: {
          ids
        }
      });
      const assets2 = resolvedAssets.map(({ type, address, id }) => {
        const asset = this.assets.find(
          // sanity
          (asset2) => asset2.name.ansName.toLowerCase() === id.toLowerCase()
        );
        if (!asset) {
          throw new Error(`Could not find asset ${id}`);
        }
        const amount = asset.amount;
        return match5(type).with("CW20" /* Cw20 */, () => Asset.cw20(address, amount)).with("NATIVE" /* Native */, () => Asset.native(address, amount)).with(
          "CW1155" /* Cw1155 */,
          () => (
            // cw1155 is not supported by default, and is a highly uncommon asset type
            new Asset(
              {
                cw1155: address
              },
              amount
            )
          )
        ).exhaustive();
      });
      return new AssetList(assets2);
    };
  }
  /**
   * Get the list of ans assets.
   */
  get assets() {
    return this._assets;
  }
  /**
   * Get the length of the list.
   */
  get length() {
    return this._assets.length;
  }
  /**
   * Add an asset to the list.
   * @param asset
   */
  add(asset) {
    this._assets.push(asset);
    return this;
  }
  /**
   * Generate a list of messages to send all the assets to a recipient.
   * Combines all native asset transfers into a single message.
   * @param queryClient - Abstract query client to use for resolving the assets
   * @param sender
   * @param recipient
   *
   * @see {@link AssetList.transferMsgs}
   */
  async transferMsgs(queryClient, sender, recipient) {
    const resolved = await this.resolve(queryClient);
    return resolved.transferMsgs(sender, recipient);
  }
};

// src/legacy/clients/objects/AnsAsset.ts
var AnsAsset = class {
  constructor(amount, name) {
    /**
     * Resolves the asset to its info and type.
     */
    this.resolve = async (client) => {
      const resolved = await new AnsAssetList([this]).resolve(client);
      return resolved.assets[0];
    };
    /**
     * Generate a message that transfers the asset from the sender to a specified recipient.
     * @param queryClient - ABstract query client to use for resolving the asset
     * @param sender
     * @param recipient
     * @param funds funds to send with the message ONLY FOR CW20s
     * @see {@link Asset.transferMsg}
     */
    this.transferMsg = async (queryClient, sender, recipient, funds) => {
      const resolved = await this.resolve(queryClient);
      return resolved.transferMsg(sender, recipient, funds);
    };
    this.amount = amount;
    this.name = typeof name === "string" ? new AnsAssetEntry(name) : name;
    this.name.validate();
  }
};

// src/legacy/clients/objects/AnsName.ts
var AnsName = class {
  static chainNameIbcAsset(chainName, asset) {
    return `${chainName.toLowerCase().replace("testnet", "")}>${asset}`;
  }
  /**
   * `staking/wyndex/juno>juno,juno>wynd`
   */
  static stakingContract(providerName, assetNames) {
    return ["staking", providerName, this.joinAssetNames(assetNames)].join("/");
  }
  /**
   * `wyndex/juno>juno,juno>wynd`
   */
  static lpToken(dexName, assetNames) {
    return `${dexName.toLowerCase()}/${this.joinAssetNames(assetNames)}`;
  }
  /** asset names sorted by name and lowercased */
  static joinAssetNames(assetNames) {
    return assetNames.map((s) => s.toLowerCase()).sort().join(",");
  }
};

// src/legacy/clients/AbstractAccountClient.ts
import { P as P4, match as match6 } from "ts-pattern";
var AbstractAccountQueryClient = class _AbstractAccountQueryClient {
  constructor({
    abstract,
    accountId,
    accountAddress
  }) {
    this.accountId = accountId;
    this.abstract = abstract;
    this.accountAddress = accountAddress;
  }
  /**
   * Load the abstract account client given the **accountId** and the **abstractClient**.
   * @param abstractClient Abstract client connected to the chain.
   * @param accountId The account id.
   */
  static async load(abstractClient, accountId) {
    const { accounts } = await abstractClient.registryQueryClient.accounts({
      accountIds: [accountIdToParameter(accountId)]
    });
    if (!accounts[0]) {
      throw new Error(`Account ${accountId} not found.`);
    }
    return new _AbstractAccountQueryClient({
      abstract: abstractClient,
      accountId,
      accountAddress: accounts[0]
    });
  }
  /**
   * Get the manager query client.
   */
  get accountQueryClient() {
    return new AccountQueryClient(this.abstract.client, this.accountAddress);
  }
  /**
   * Retrieve the account sequence.
   */
  get accountSequence() {
    return this.accountId.seq;
  }
  /**
   * Retrieve the deposit address.
   */
  get depositAddress() {
    return this.accountAddress;
  }
  /**
   * Load the module information for those installed on this Account.
   */
  async getModules() {
    const { module_infos: modules } = await this.accountQueryClient.moduleInfos(
      {
        limit: ABSTRACT_CONSTANTS.MAX_PAGE_SIZE
      }
    );
    return modules;
  }
  /**
   * Retrieve the list of subaccount ids for this Account.
   * @returns the list of subaccount ids.
   */
  async getSubAccountSequences() {
    return this.accountQueryClient.subAccountIds({
      limit: ABSTRACT_CONSTANTS.MAX_PAGE_SIZE
    }).then(({ sub_accounts }) => sub_accounts);
  }
  /**
   * Retrieve the list of subaccount ids for this Account.
   * @returns the list of subaccount ids.
   */
  async getSubAccountIds() {
    const chainName = await this.abstract.getChainName();
    return this.accountQueryClient.subAccountIds({
      limit: ABSTRACT_CONSTANTS.MAX_PAGE_SIZE
    }).then(({ sub_accounts }) => sub_accounts).then(
      (subAccounts) => subAccounts.map(
        (seq) => sequenceToLocalAccountId({ chainName, sequence: seq })
      )
    );
  }
  /**
   * Retrieve the list of sub-accounts for this Account.
   */
  async getSubAccounts() {
    const subAccountIds = await this.getSubAccountSequences();
    const chainName = await this.abstract.getChainName();
    return Promise.all(
      subAccountIds.map(
        (subAccountId) => this.abstract.loadAccount(
          sequenceToLocalAccountId({ chainName, sequence: subAccountId })
        )
      )
    );
  }
  /**
   * Load the namespace registered on the Account.
   * @returns the namespace or null if no namespace is registered.
   */
  async getNamespace() {
    const { registryQueryClient } = this.abstract;
    const namespace = await registryQueryClient.namespaces({ accounts: [accountIdToParameter(this.accountId)] }).then((x) => x.namespaces[0]?.[0]);
    return namespace ?? null;
  }
  /**
   * Return the owner of the Account.
   *
   * @param invalidateCache If true, refetch the owner from the accountQueryClient.
   * @returns The owner address, or null if no owner is set.
   */
  async getOwner(invalidateCache) {
    if (invalidateCache || this._owner === void 0) {
      const governance = await this.accountQueryClient.ownership().then(({ owner }) => owner);
      this._owner = match6(governance).with({ monarchy: { monarch: P4.select() } }, (monarch) => monarch).with({ sub_account: { account: P4.select() } }, (proxy) => proxy).with({ renounced: {} }, () => null).with({ n_f_t: { collection_addr: P4.select() } }, (col) => col).with({ external: { governance_address: P4.select() } }, (ext) => ext).otherwise((e) => {
        console.warn(
          `Unknown governance type for ${this.accountAddress}: ${JSON.stringify(e)}`
        );
        return JSON.stringify(e);
      });
    }
    return this._owner ?? null;
  }
  /**
   * Given the **moduleId**, get the address of the module installed on this Account.
   * @param moduleId
   * @returns null if not installed
   */
  async getModuleAddress(moduleId) {
    return await this.accountQueryClient.moduleAddresses({ ids: [moduleId] }).then(({ modules }) => modules[0]?.[1] ?? null);
  }
  /**
   * This constructs a query message that is tailored to the specified module and its
   * type. It can handle 'app' and 'adapter' module types, with the message just being passed on in
   * the default case.
   *
   * @param queryMsg the query message
   * @param moduleType the type of the module
   */
  wrapModuleQueryMsg(queryMsg, moduleType) {
    return match6(moduleType).with("app", () => AppQueryMsgFactory.queryApp(queryMsg)).with("adapter", () => AdapterQueryMsgBuilder.query(queryMsg)).otherwise(() => queryMsg);
  }
  /**
   * Query a module. Not recommended to use directly, use the module specific query methods.
   * @param moduleId
   * @param moduleType
   * @param queryMsg
   */
  async queryModule({
    moduleId,
    moduleType,
    queryMsg
  }) {
    const moduleQueryMsg = this.wrapModuleQueryMsg(
      queryMsg,
      moduleType
    );
    const moduleAddress = await this.getModuleAddress(moduleId);
    if (!moduleAddress) {
      throw new Error(`${moduleId} not installed`);
    }
    return await this.abstract.client.queryContractSmart(
      moduleAddress,
      moduleQueryMsg
    );
  }
  /**
   * Upgrade the Abstract Account client to an executable client.
   * @param abstract Abstract client connected to the chain.
   * @see AbstractAccountClient#fromQueryClient
   */
  connectAbstractClient(abstract) {
    return AbstractAccountClient.fromQueryClient(this, abstract);
  }
  /**
   * Upgrade the Abstract Account client to an executable client.
   * @see AbstractAccountClient#fromQueryClient
   */
  connectSigningClient(signingClient, sender) {
    const signingAbstract = this.abstract.connectSigningClient(
      signingClient,
      sender
    );
    return this.connectAbstractClient(signingAbstract);
  }
};
var AbstractAccountClient = class _AbstractAccountClient extends AbstractAccountQueryClient {
  constructor(base) {
    super(base);
    const { abstract } = base;
    const { sender } = abstract;
    this.sender = sender;
    this.abstract = abstract;
  }
  /**
   * Get the manager executable client.
   */
  get accountClient() {
    return new AccountClient(
      this.abstract.client,
      this.sender,
      this.accountAddress
    );
  }
  /**
   * Retrieve the {@link SigningCosmWasmClient} associated with the account.
   */
  get client() {
    return this.abstract.client;
  }
  // /**
  //  * Get the messages for depositing assets into the account.
  //  */
  // public depositMsgs(toDeposit: AssetList): EncodedMsg[] {
  //   return toDeposit.transferMsgs(this.sender, this.depositAddress)
  // }
  // //
  // // /**
  // //  * Deposit assets into the account.
  // //  */
  // // public async deposit(
  // //   toDeposit: AssetList,
  // //   fee: StdFee | 'auto' | number,
  // //   memo?: string,
  // // ) {
  // //   const depositMsgs = this.depositMsgs(toDeposit)
  // //   return this.client.signAndBroadcast(this.sender, depositMsgs, fee, memo)
  // // }
  // /**
  //  * Deposit ANS assets into the Account.
  //  */
  // public async depositAnsAssets(
  //   assets: AnsAssetList,
  //   fee: StdFee | 'auto' | number,
  //   memo?: string,
  // ) {
  //   const resolved = await assets.resolve(this.abstract)
  //   return this.deposit(resolved, fee, memo)
  // }
  //
  // /**
  //  * Get the withdraw messages for the given assets.
  //  * @param toWithdraw - The assets to withdraw.
  //  * @param recipient - The recipient for the assets.
  //  * @param funds - Optional. Any funds to send with the message.
  //  */
  // public withdrawMsgs(
  //   toWithdraw: AssetList,
  //   recipient: string,
  //   funds?: Coin[],
  // ): EncodedMsg[] {
  //   const transferMsgs = toWithdraw.cosmosTransferMsgs(
  //     this.depositAddress,
  //     recipient,
  //   )
  //
  //   // what the proxy executes
  //   return [this.executeMsg(transferMsgs, funds)]
  // }
  // /**
  //  * Compose an execute message for a specific module, given its type.
  //  *
  //  * @param moduleId - The ID of the module on which the message should be executed.
  //  * @param moduleType - The type of the module.
  //  * @param execMsg - The execution message.
  //  * @param funds - Optional. The funds involved in the execution.
  //  *
  //  * @returns An encoded object representing the execution message for the specified module.
  //  *
  //  * @see {AppExecuteMsgFactory} for building app requests
  //  * @see {AdapterExecuteMsgFactory} for building adapter requests
  //  */
  // public composeExecuteOnModule(
  //   { moduleId, moduleType, execMsg }: ExecuteOnModule,
  //   funds?: Coin[],
  // ): MsgExecuteContractEncodeObject {
  //   const moduleExecMsg = this.wrapModuleExecMsg(execMsg, moduleType)
  //
  //   return this.managerMsgComposer().executeOnModule(
  //     {
  //       execMsg: jsonToBinary(moduleExecMsg),
  //       moduleId,
  //     },
  //     funds,
  //   )
  // }
  // /**
  //  * Build a message for executing an action on the Account.
  //  * @param msgs - The messages to execute.
  //  * @param funds
  //  */
  // public executeMsg(
  //   msgs: CosmosMsgForEmpty | CosmosMsgForEmpty[],
  //   funds?: Coin[],
  // ): MsgExecuteContractEncodeObject {
  //   return this.composeExecuteOnModule(
  //     {
  //       moduleId: PROXY_MODULE_ID,
  //       moduleType: 'account',
  //       execMsg: AccountExecuteMsgBuilder.moduleAction({ msgs: [msgs].flat() }),
  //     },
  //     funds,
  //   )
  // }
  /**
   * Upgrade a query client to a signing client.
   *
   * This method takes an AbstractAccountQueryClient and upgrades it to an AbstractAccountClient,
   * which has signing capabilities.
   *
   * @param queryClient - The AbstractAccountQueryClient to be upgraded.
   * @param abstract - The AbstractClient to be associated with the new AbstractAccountClient.
   *
   * @returns A new AbstractAccountClient, upgraded from the provided AbstractAccountQueryClient.
   */
  static fromQueryClient(queryClient, abstract) {
    return new _AbstractAccountClient({ ...queryClient, abstract });
  }
};

// src/legacy/clients/AbstractClient.ts
import {
  BatchCosmWasmClient
} from "@abstract-money/cosmwasm-utils";
import {
  CosmWasmClient
} from "@cosmjs/cosmwasm-stargate";
import semverSatisfies from "semver/functions/satisfies";

// src/legacy/clients/AnsClient.ts
import { BiMap } from "@rimbu/bimap";
import { Mixin } from "ts-mixer";
var AnsQueryClient = class extends AnsHostQueryClient {
  constructor(client, contractAddress) {
    super(client, contractAddress);
    this.assetCache = BiMap.empty();
    /**
     * Clear the asset cache.
     */
    this.clearAssetCache = () => {
      console.log("clearing asset cache");
      this.assetCache = BiMap.empty();
    };
    /**
     * Add a new asset entry to the cache based on the response.
     * @param entry
     */
    this.cacheAssetEntry = (entry) => {
      this.assetCache = this.assetCache.addEntry(entry);
    };
    /**
     * Retrieve an asset entry via its info. (reverse query).
     * @param info
     */
    this.entryByInfo = async (info) => {
      await this.listAssets();
      const ansId = this.assetCache.getKey(info);
      return ansId === void 0 ? void 0 : [ansId, info];
    };
    this.listAssets = this.listAssets.bind(this);
    this.filterAssets = this.filterAssets.bind(this);
    this.listContracts = this.listContracts.bind(this);
    this.filterContracts = this.filterContracts.bind(this);
    this.listChannels = this.listChannels.bind(this);
    this.filterChannels = this.filterChannels.bind(this);
  }
  /**
   * List all assets in ANS.
   * If *cached* is set to false, it will hard refresh.
   */
  async listAssets({
    ignoreCache = false,
    startAfter: userPageToken
  } = {}) {
    if (!ignoreCache && !this.assetCache.isEmpty) {
      return this.assetCache.toArray();
    }
    const resolvedEntries = [];
    let startAfter = userPageToken;
    let hasNextPage = true;
    while (hasNextPage) {
      resolvedEntries.push(
        ...await this.assetList({
          limit: ABSTRACT_CONSTANTS.MAX_PAGE_SIZE,
          startAfter
        }).then(({ assets: assets2 }) => {
          hasNextPage = assets2.length === ABSTRACT_CONSTANTS.MAX_PAGE_SIZE;
          startAfter = assets2[assets2.length - 1]?.[0];
          return assets2;
        })
      );
    }
    resolvedEntries.forEach(this.cacheAssetEntry);
    return resolvedEntries;
  }
  /**
   * Filter assets in ANS by their ids.
   * @param ids
   */
  async filterAssets({
    ids
  }) {
    return this.assets({
      names: ids
    }).then(({ assets: assets2 }) => assets2);
  }
  /**
   * List all the channels in ANS.
   * @param userPageToken
   */
  async listChannels({
    startAfter: userPageToken
  }) {
    const resolvedEntries = [];
    let startAfter = userPageToken;
    let hasNextPage = true;
    while (hasNextPage) {
      resolvedEntries.push(
        ...await this.channelList({
          limit: ABSTRACT_CONSTANTS.MAX_PAGE_SIZE,
          startAfter
        }).then(({ channels }) => {
          hasNextPage = channels.length === ABSTRACT_CONSTANTS.MAX_PAGE_SIZE;
          startAfter = channels[channels.length - 1]?.[0];
          return channels;
        })
      );
    }
    return resolvedEntries;
  }
  /**
   * Filter channels in ANS by their ids.
   * @param entries
   */
  async filterChannels({
    entries
  }) {
    return this.channels({
      entries
    }).then(({ channels }) => channels);
  }
  async listContracts({
    startAfter: userPageToken
  }) {
    const resolvedEntries = [];
    let startAfter = userPageToken;
    let hasNextPage = true;
    while (hasNextPage) {
      resolvedEntries.push(
        ...await this.contractList({
          limit: ABSTRACT_CONSTANTS.MAX_PAGE_SIZE,
          startAfter
        }).then(({ contracts }) => {
          hasNextPage = contracts.length === ABSTRACT_CONSTANTS.MAX_PAGE_SIZE;
          startAfter = contracts[contracts.length - 1]?.[0];
          return contracts;
        })
      );
    }
    return resolvedEntries;
  }
  /**
   * Filter contracts in ANS by their ids.
   * @param entries
   */
  async filterContracts({
    entries
  }) {
    return this.contracts({
      entries
    }).then(({ contracts }) => contracts);
  }
};
var AnsClient = class extends Mixin(AnsHostClient, AnsQueryClient) {
};

// src/legacy/clients/ChainRegistryClient.ts
import _ from "lodash";
var ChainRegistryClient = class {
  constructor(chains2, assetLists) {
    this._chains = chains2;
    this._assetLists = assetLists;
  }
  get chains() {
    return this._chains;
  }
  get assetLists() {
    return this._assetLists;
  }
  chainIdToName(chainId) {
    if (chainId === "pisco-1")
      return "terra2testnet";
    const chainName = this.findChainBy({ chain_id: chainId }).chain_name;
    if (!chainName) {
      throw new Error(`Chain not found by chainId: ${chainId}`);
    }
    return chainName;
  }
  findChainBy(filters) {
    const filteredChains = this.findChainsBy(filters);
    if (filteredChains.length > 1) {
      throw new Error(
        `${filteredChains.length} chains found by filters: ${JSON.stringify(
          filters
        )}`
      );
    }
    return filteredChains[0];
  }
  /**
   * Find chains by filters.
   * @param filters
   */
  findChainsBy(filters) {
    let filteredChains = this.chains;
    for (const key in filters) {
      const value = filters[key];
      filteredChains = filteredChains.filter(
        (chain) => _.isEqual(chain[key], value)
      );
    }
    if (!filteredChains.length) {
      throw new Error(`Chain not found by filters: ${JSON.stringify(filters)}`);
    }
    return filteredChains;
  }
  findAssetsBy(filters, options = {
    throwIfNotFound: true
  }) {
    let filteredAssets = this.assetLists.filter(
      ({ chain_name }) => options.chainNameFilter ? options.chainNameFilter === chain_name : true
    ).flatMap(({ assets: assets2 }) => assets2);
    for (const key in filters) {
      const value = filters[key];
      if (Array.isArray(value)) {
        filteredAssets = filteredAssets.filter(
          (asset) => Array.isArray(asset[key]) && asset[key].some(
            (item) => (
              // @ts-ignore
              Object.keys(value[0]).every((k) => item[k] === value[0][k])
            )
          )
        );
      } else {
        filteredAssets = filteredAssets.filter(
          (asset) => _.isEqual(asset[key], value)
        );
      }
    }
    if (!filteredAssets.length && options.throwIfNotFound) {
      throw new Error(`Asset not found by filters: ${JSON.stringify(filters)}`);
    }
    return filteredAssets;
  }
  findAssetBy(filters, options = {}) {
    const filteredAssets = this.findAssetsBy(filters, options);
    if (filteredAssets.length > 1) {
      throw new Error(
        `${filteredAssets.length} assets found by filters: ${JSON.stringify(
          filters
        )}`
      );
    }
    return filteredAssets[0];
  }
  static findLogoUri(asset) {
    return asset.logo_URIs?.png || asset.logo_URIs?.svg || asset.logo_URIs?.jpeg || null;
  }
  externalChainDenomToAnsName(searchDenom) {
    let found;
    for (const list of this.assetLists) {
      const { chain_name, assets: assets2 } = list;
      const foundAsset = assets2.find(
        (unit) => unit.denom_units.some((unit2) => unit2.denom === searchDenom)
      );
      if (foundAsset) {
        found = { chain: chain_name, symbol: foundAsset.symbol.toLowerCase() };
        break;
      }
    }
    if (!found) {
      throw new Error(`Asset not found: ${searchDenom}`);
    }
    return AnsName.chainNameIbcAsset(found.chain, found.symbol);
  }
  findSymbol(chainId, denom) {
    const chainName = this.chainIdToName(chainId);
    const asset = this.findAssetBy(
      {
        denom_units: [{ denom }]
      },
      {
        chainNameFilter: chainName
      }
    );
    if (!asset) {
      throw new Error(`Asset not found by denom: ${denom}`);
    }
    return asset.symbol.toLowerCase();
  }
  assetBySymbol(assetSymbol) {
    return this.assetLists.flatMap(({ assets: assets2 }) => assets2).find(
      ({ symbol, denom_units }) => denom_units.find(
        ({ aliases, denom }) => aliases?.includes(assetSymbol) || denom === assetSymbol
      ) || symbol.toLowerCase() === assetSymbol.toLowerCase()
    );
  }
};

// src/legacy/clients/AbstractClient.ts
var CHAIN_DEPLOYMENT_QUERY = gql(
  /* GraphQL */
  `
  query Deployment($chain: ID!) {
    version
    deployment(chain: $chain) {
      ansHost
      registry
      accountFactory
    }
    chainInfo(chain: $chain) {
      rpcUrl
    }
  }
`
);
var DEFAULT_ABSTRACT_QUERY_CLIENT_OPTIONS = { useBatchClient: false };
var AbstractQueryClient = class _AbstractQueryClient {
  constructor({
    client,
    registryAddress,
    ansHostAddress
  }, options) {
    this.accountCache = /* @__PURE__ */ new Map();
    if (!client)
      throw new Error(`CosmWasm client is missing: ${client}`);
    this.client = client;
    this.registryAddress = registryAddress;
    this.ansHostAddress = ansHostAddress;
    this.apiUrl = options?.apiUrl ?? ABSTRACT_API_URL;
    this.connectSigningClient = this.connectSigningClient.bind(this);
    this._publicClient = createPublicClient({
      apiUrl: options?.apiUrl,
      cosmWasmClient: client
    });
    this._apiClient = createApiClient({ apiUrl: options?.apiUrl });
  }
  async getAccountsOfOwner(owner, chains2) {
    const result = await this._apiClient.getAccountsByOwnerFromApi({
      owner,
      chains: chains2
    });
    return result.map((r) => ({
      chainName: r.chainName,
      seq: r.seq,
      trace: r.trace
    }));
  }
  /**
   * Connect to a specific instance of Abstract via its Registry address.
   * @param endpoint
   * @param registryAddress
   * @param version - the version of abstract to load
   * @param options - options for the query client
   */
  static async connect(endpoint, registryAddress, version, options = DEFAULT_ABSTRACT_QUERY_CLIENT_OPTIONS) {
    const apiUrl = options.overrideApiUrl ?? ABSTRACT_API_URL;
    const cosmWasmClient = await (options.useBatchClient ? BatchCosmWasmClient.connect(endpoint, options.batchClientOptions) : CosmWasmClient.connect(endpoint));
    const registryClient = new RegistryQueryClient(
      cosmWasmClient,
      registryAddress
    );
    const [ansHostAddress] = await Promise.all(
      ["ans-host"].map(async (moduleName) => {
        const module = await AbstractModule.loadById(
          registryClient,
          `abstract:${moduleName}`,
          version
        );
        return module.address;
      })
    );
    return new _AbstractQueryClient(
      {
        client: cosmWasmClient,
        registryAddress,
        ansHostAddress
      },
      { apiUrl }
    );
  }
  /**
   * Connect to Abstract on a specific chain. This will query the Abstract API to find the
   * addresses of the deployed contracts on the chain.
   * @param chainId - The chain ID to connect to. For example, 'juno-1'.
   * @param options - Options for the query client. Allows overriding of certain defaults such as
   *   the RPC url.
   */
  static async connectToChain(chainId, options = DEFAULT_ABSTRACT_QUERY_CLIENT_OPTIONS) {
    const apiUrl = options.overrideApiUrl ?? ABSTRACT_API_URL;
    const deploymentData = await graphqlRequest(
      apiUrl,
      CHAIN_DEPLOYMENT_QUERY,
      {
        chain: chainId
      }
    );
    const { ansHost: ansHostAddress, registry: registryAddress } = deploymentData.deployment;
    const rpcEndpoint = options.rpcUrl || deploymentData.chainInfo.rpcUrl;
    const cosmWasmClient = await (options.useBatchClient ? BatchCosmWasmClient.connect(rpcEndpoint, options.batchClientOptions) : CosmWasmClient.connect(rpcEndpoint));
    return new _AbstractQueryClient(
      {
        client: cosmWasmClient,
        registryAddress,
        ansHostAddress
      },
      { apiUrl }
    );
  }
  /**
   * Query the Abstract API.
   * @param params
   */
  async queryApi(...params) {
    return graphqlRequest(this.apiUrl, ...params);
  }
  async getChainName() {
    if (this._chainName)
      return this._chainName;
    const chainId = await this.client.getChainId();
    const chainName = new ChainRegistryClient(chains, assets).chainIdToName(
      chainId
    );
    this._chainName = chainName;
    return chainName;
  }
  /**
   * Get the chain id for the connected chain.
   */
  async getChainId() {
    return this.client.getChainId();
  }
  /**
   * Get the registry query client.
   */
  get registryQueryClient() {
    return new RegistryQueryClient(this.client, this.registryAddress);
  }
  /**
   * Get the Abstract Name Service query client.
   */
  get ansQueryClient() {
    return new AnsQueryClient(this.client, this.ansHostAddress);
  }
  /**
   * Load an Account query client.
   * @param accountId - {@link AbstractAccountId} or a number representing the sequence of the
   *   account.
   * @param refetch - If true, the account will be loaded from the blockchain, even if it is
   *   already in the cache.
   */
  async loadAccount(accountId, refetch) {
    let account;
    const accountIdString = accountIdToString(accountId);
    if (this.accountCache.has(accountIdString) && !refetch) {
      account = this.accountCache.get(
        accountIdString
      );
    } else {
      account = await AbstractAccountQueryClient.load(this, accountId);
      this.accountCache.set(accountIdString, account);
    }
    return account;
  }
  /**
   * Load all local accounts.
   */
  async loadAccounts({
    startAfter: startAfter_
  } = {}) {
    const chainName = await this.getChainName();
    const allAccounts = [];
    let startAfter = startAfter_;
    let hasMore = true;
    while (hasMore) {
      const { accounts } = await this.registryQueryClient.accountList({
        limit: ABSTRACT_CONSTANTS.MAX_PAGE_SIZE,
        startAfter
      });
      const accountQueryClients = accounts.map(
        ([accountId, address]) => new AbstractAccountQueryClient({
          abstract: this,
          accountId: {
            ...accountId,
            chainName
          },
          accountAddress: address
        })
      );
      accountQueryClients.map((q) => {
        this.accountCache.set(accountIdToString(q.accountId), q);
      });
      allAccounts.push(...accountQueryClients);
      if (accounts.length < ABSTRACT_CONSTANTS.MAX_PAGE_SIZE) {
        hasMore = false;
      } else {
        startAfter = accounts[accounts.length - 1][0];
      }
    }
    return allAccounts;
  }
  /**
   * Filter the list of Accounts by the given filter.
   * This method is extremely inefficient if querying live (as opposed to archive) nodes.
   * @param filter
   */
  async filterAccounts(filter) {
    const chainName = await this.getChainName();
    const allAccounts = await this.loadAccounts();
    const matchingAccounts = [];
    for (const account of allAccounts) {
      if (filter.owner) {
        const owner = await account.getOwner();
        if (owner !== filter.owner)
          continue;
      }
      const installedModules = filter.moduleIds || filter.modules ? await account.getModules() : [];
      const modulesFilter = filter.modules || [];
      if (filter.moduleIds) {
        modulesFilter.push(...filter.moduleIds.map((id) => ({ id })));
      }
      if (modulesFilter.every(({ id, version }) => {
        const installedModule = installedModules.find(
          (module) => module.id === id
        );
        return installedModule && (!version || semverSatisfies(installedModule.version.version, version));
      })) {
        matchingAccounts.push(account);
      }
    }
    return matchingAccounts;
  }
  /**
   * Upgrade the abstract client to an executable client.
   * @param signingClient
   * @param sender
   * @see AbstractClient#fromQueryClient
   */
  connectSigningClient(signingClient, sender) {
    return AbstractClient.fromQueryClient(this, signingClient, sender);
  }
  /**
   * Clear the account cache.
   */
  clearAccountCache() {
    this.accountCache.clear();
  }
};
var AbstractClient = class _AbstractClient extends AbstractQueryClient {
  constructor(base, options) {
    super(base, options);
    const { client, sender } = base;
    this.client = client;
    this.sender = sender;
  }
  /**
   * Get the Abstract name service client.
   */
  get ansClient() {
    return new AnsClient(this.client, this.sender, this.ansHostAddress);
  }
  /**
   * Get the registry client.
   */
  get registryClient() {
    return new RegistryClient(this.client, this.sender, this.registryAddress);
  }
  /**
   * Upgrade a query client to a signing client.
   */
  static fromQueryClient(queryClient, signingClient, sender) {
    return new _AbstractClient({ ...queryClient, client: signingClient, sender });
  }
};
export {
  AbstractAccountClient,
  AbstractAccountQueryClient,
  AbstractClient,
  AbstractModule,
  AbstractNotFoundError,
  AbstractQueryClient,
  AccountNotFoundError,
  AnsAsset,
  AnsAssetEntry,
  AnsAssetList,
  AnsClient,
  AnsName,
  AnsQueryClient,
  Asset,
  AssetList,
  CHAIN_DEPLOYMENT_QUERY,
  ChainRegistryClient,
  DEFAULT_ABSTRACT_QUERY_CLIENT_OPTIONS,
  ModuleInfo,
  ModuleNotFoundError,
  graphqlRequest
};
