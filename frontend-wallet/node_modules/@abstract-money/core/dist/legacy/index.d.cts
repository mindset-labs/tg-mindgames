import request, { Variables } from 'graphql-request';
export { RequestDocument, Variables } from 'graphql-request';
import { CosmWasmClient, SigningCosmWasmClient, HttpEndpoint } from '@cosmjs/cosmwasm-stargate';
import { N as RegistryQueryClient, t as AccountQueryClient, v as AccountClient, x as AnsHostQueryClient, V as AssetInfoBaseForAddr$1, W as ChannelEntry$1, X as ContractEntry$1, w as AnsHostReadOnlyInterface, y as AnsHostInterface, z as AnsHostClient, S as RegistryClient } from '../Registry.client-DeRpB8OW.js';
import { l as ModuleInfo$1, z as ModuleVersion$1, J as Module, K as ModuleConfiguration$1, c as ModuleReference$1, L as ModuleResponse$1, P as AccountModuleInfo$1, C as CosmosMsgForEmpty$1 } from '../Registry.types-tb_Smu0e.js';
import { k as ModuleData, A as AccountId, f as ContractMsg, D as DeploymentQuery, m as Exact } from '../types-DL_NvWZJ.js';
import { M as ModuleType } from '../module-type-Dq9dh99O.js';
import { Coin } from '@cosmjs/stargate';
import { E as EncodedMsg, c as chains, a as assets } from '../chains-DYLszfiT.js';
import * as _graphql_typed_document_node_core from '@graphql-typed-document-node/core';
export { TypedDocumentNode } from '@graphql-typed-document-node/core';
import { a as PublicClient, b as ApiClient } from '../create-public-client-B8W9RZt-.js';
import { BatchCosmWasmClientOptions } from '@abstract-money/cosmwasm-utils';
import { JsonObject } from '@cosmjs/cosmwasm-stargate/build/modules';
import * as ts_mixer_dist_types_types from 'ts-mixer/dist/types/types';
import '@abstract-money/cli/cosmjs';
import 'chain-registry';
import '@chain-registry/types';
import '../get-registry-query-client-from-api-kZlB8Zat.js';
import 'cosmjs-types/cosmos/tx/v1beta1/service';

/**
 * A strongly-typed query to the Abstract API
 * @param url - Abstract API URL
 * @param gqlQuery
 * @param variablesAndRequestHeaders
 */
declare const graphqlRequest: typeof request;

type VcModuleInfo$1 = ModuleInfo$1;
type ModuleVersion = ModuleVersion$1;
interface ModuleById {
    moduleId: string;
    namespace?: never;
    name?: never;
}
interface ModuleByName {
    moduleId?: never;
    namespace: string;
    name: string;
}
type ModuleByIdOrName = ModuleById | ModuleByName;
/**
 * @deprecated
 */
declare class ModuleInfo implements VcModuleInfo$1 {
    name: string;
    namespace: string;
    version: ModuleVersion;
    static readonly ABSTRACT_PROVIDER = "abstract";
    /**
  
     * @param moduleId
     * @param moduleProvider
     * @param moduleName
     * @param version IF not provided, latest will be loaded
     */
    constructor({ moduleId, namespace: moduleProvider, name: moduleName, version, }: ModuleByIdOrName & {
        version?: string;
    });
    /**
     * Return the full module id with the namespace and name.
     */
    get id(): string;
    /**
     * Return the full module id with the namespace and name concatenated with the version.
     */
    get idWithVersion(): string;
    /**
     * Get the version as a string.
     * Latest version returns "latest".
     */
    get versionString(): string;
    static from(moduleInfo: VcModuleInfo$1): ModuleInfo;
    private static versionAsString;
    static latest(idOrName: ModuleByIdOrName): ModuleInfo;
    /**
     * Build abstract module info from the given name and version.
     * @param moduleName
     * @param version
     */
    static abstract(moduleName: string, version?: string): ModuleInfo;
    /**
     * Transform a string formatted like "namespace:name:version" into a ModuleInfo object.
     * @param info
     */
    static fromString(info: string): ModuleInfo;
}

type VcModule = Module;
type ModuleConfiguration = ModuleConfiguration$1;
type VcModuleInfo = ModuleInfo$1;
type ModuleReference = ModuleReference$1;
type ModuleResponse = ModuleResponse$1;

/**
 * A class representing an abstract module.
 * @deprecated
 */
declare class AbstractModule implements VcModule {
    info: ModuleInfo;
    reference: ModuleReference;
    config: ModuleConfiguration;
    _data: ModuleData | null;
    constructor({ info, reference }: VcModule, config: ModuleConfiguration);
    /**
     * Create an Abstract module from the chain response.
     * @param response
     */
    static fromResponse(response: ModuleResponse): AbstractModule;
    /**
     * The module id with the namespace.
     * Example: abstract:bank
     */
    get name(): string;
    static loadById(registryClient: RegistryQueryClient, moduleId: string, version?: string): Promise<AbstractModule>;
    static loadByInfo(registryClient: RegistryQueryClient, moduleInfo: VcModuleInfo): Promise<AbstractModule>;
    static loadByInfos(registryClient: RegistryQueryClient, moduleInfos: VcModuleInfo[]): Promise<AbstractModule[]>;
    /**
     * Get the type of this module.
     */
    get type(): ModuleType;
    get address(): string;
    get codeId(): number;
    /**
     * Retrieve the module data for a given module.
     * @throws Error if module not found
     * @returns module data if instantiated, null otherwise
     */
    getModuleData(client: CosmWasmClient): Promise<ModuleData | null>;
}

type AccountModuleInfo = AccountModuleInfo$1;
interface IAbstractAccountQueryClient {
    abstract: AbstractQueryClient;
    accountId: AccountId;
    accountAddress: string;
}
/**
 * Query a module with the given msg.
 */
interface QueryModule<TModuleMsg extends ContractMsg = ContractMsg> {
    moduleId: string;
    moduleType?: ModuleType;
    queryMsg: TModuleMsg;
}
/**
 * The AbstractAccountQueryClient class provides an interface to interact with a specific account.
 * It takes an instance of an AbstractQueryClient and an account ID to initialize.
 *
 * The class exposes methods to query information about an account on the blockchain.
 *
 * @property abstract - An instance of AbstractQueryClient.
 * @property accountId - The id of the account this client is responsible for.
 * @property accountAddress - The manager address associated with the account.
 * @property accountAddress - The proxy address associated with the account.
 */
declare class AbstractAccountQueryClient implements IAbstractAccountQueryClient {
    abstract: AbstractQueryClient;
    accountId: AccountId;
    accountAddress: string;
    _owner?: string | null;
    constructor({ abstract, accountId, accountAddress, }: IAbstractAccountQueryClient);
    /**
     * Load the abstract account client given the **accountId** and the **abstractClient**.
     * @param abstractClient Abstract client connected to the chain.
     * @param accountId The account id.
     */
    static load(abstractClient: AbstractQueryClient, accountId: AccountId): Promise<AbstractAccountQueryClient>;
    /**
     * Get the manager query client.
     */
    get accountQueryClient(): AccountQueryClient;
    /**
     * Retrieve the account sequence.
     */
    get accountSequence(): number;
    /**
     * Retrieve the deposit address.
     */
    get depositAddress(): string;
    /**
     * Load the module information for those installed on this Account.
     */
    getModules(): Promise<AccountModuleInfo[]>;
    /**
     * Retrieve the list of subaccount ids for this Account.
     * @returns the list of subaccount ids.
     */
    getSubAccountSequences(): Promise<number[]>;
    /**
     * Retrieve the list of subaccount ids for this Account.
     * @returns the list of subaccount ids.
     */
    getSubAccountIds(): Promise<AccountId[]>;
    /**
     * Retrieve the list of sub-accounts for this Account.
     */
    getSubAccounts(): Promise<AbstractAccountQueryClient[]>;
    /**
     * Load the namespace registered on the Account.
     * @returns the namespace or null if no namespace is registered.
     */
    getNamespace(): Promise<string | null>;
    /**
     * Return the owner of the Account.
     *
     * @param invalidateCache If true, refetch the owner from the accountQueryClient.
     * @returns The owner address, or null if no owner is set.
     */
    getOwner(invalidateCache?: boolean): Promise<string | null>;
    /**
     * Given the **moduleId**, get the address of the module installed on this Account.
     * @param moduleId
     * @returns null if not installed
     */
    getModuleAddress(moduleId: string): Promise<string | null>;
    /**
     * This constructs a query message that is tailored to the specified module and its
     * type. It can handle 'app' and 'adapter' module types, with the message just being passed on in
     * the default case.
     *
     * @param queryMsg the query message
     * @param moduleType the type of the module
     */
    private wrapModuleQueryMsg;
    /**
     * Query a module. Not recommended to use directly, use the module specific query methods.
     * @param moduleId
     * @param moduleType
     * @param queryMsg
     */
    queryModule<TModuleMsg extends ContractMsg = ContractMsg>({ moduleId, moduleType, queryMsg, }: QueryModule<TModuleMsg>): Promise<JsonObject>;
    /**
     * Upgrade the Abstract Account client to an executable client.
     * @param abstract Abstract client connected to the chain.
     * @see AbstractAccountClient#fromQueryClient
     */
    connectAbstractClient(abstract: AbstractClient): AbstractAccountClient;
    /**
     * Upgrade the Abstract Account client to an executable client.
     * @see AbstractAccountClient#fromQueryClient
     */
    connectSigningClient(signingClient: SigningCosmWasmClient, sender: string): AbstractAccountClient;
}
interface IAbstractAccountClient extends IAbstractAccountQueryClient {
    abstract: AbstractClient;
}
/**
 * The AbstractAccountClient class extends the AbstractAccountQueryClient class and provides
 * additional functionality to interact with a specific Account deployed on Abstract.
 *
 * Unlike AbstractAccountQueryClient, AbstractAccountClient can execute transactions.
 *
 * This class should be used when write operations (transactions) need to be performed for the
 * account.
 *
 * @property abstract - An instance of AbstractClient.
 * @property sender - The sender address associated with the signing account.
 */
declare class AbstractAccountClient extends AbstractAccountQueryClient {
    abstract: AbstractClient;
    sender: string;
    constructor(base: IAbstractAccountClient);
    /**
     * Get the manager executable client.
     */
    get accountClient(): AccountClient;
    /**
     * Retrieve the {@link SigningCosmWasmClient} associated with the account.
     */
    get client(): SigningCosmWasmClient;
    /**
     * Upgrade a query client to a signing client.
     *
     * This method takes an AbstractAccountQueryClient and upgrades it to an AbstractAccountClient,
     * which has signing capabilities.
     *
     * @param queryClient - The AbstractAccountQueryClient to be upgraded.
     * @param abstract - The AbstractClient to be associated with the new AbstractAccountClient.
     *
     * @returns A new AbstractAccountClient, upgraded from the provided AbstractAccountQueryClient.
     */
    static fromQueryClient(queryClient: AbstractAccountQueryClient, abstract: AbstractClient): AbstractAccountClient;
}

type AssetInfoBaseForAddr = AssetInfoBaseForAddr$1;
type ChannelEntry = ChannelEntry$1;
type ContractEntry = ContractEntry$1;
type AnsId = string;
type RawAnsAssetEntry = readonly [AnsId, AssetInfoBaseForAddr];
type RawAnsContractEntry = [ContractEntry, string];
type RawAnsChannelEntry = [ChannelEntry, string];
interface IAnsQueryClient extends AnsHostReadOnlyInterface {
    /**
     * List all assets in ANS.
     */
    listAssets({ startAfter, }: {
        startAfter: string;
    }): Promise<RawAnsAssetEntry[]>;
    /**
     * Filter assets in ANS by their ids.
     * @param ids
     */
    filterAssets({ ids }: {
        ids: string[];
    }): Promise<RawAnsAssetEntry[]>;
    /**
     * List all contracts in ANS.
     */
    listContracts({ startAfter, }: {
        startAfter: ContractEntry;
    }): Promise<RawAnsContractEntry[]>;
    /**
     * Filter contracts in ANS by their ids.
     * @param ids
     */
    filterContracts({ entries, }: {
        entries: ContractEntry[];
    }): Promise<RawAnsContractEntry[]>;
    /**
     * List all the channels in ANS.
     */
    listChannels({ startAfter, }: {
        startAfter: ChannelEntry;
    }): Promise<RawAnsChannelEntry[]>;
    /**
     * Filter channels in ANS by their ids.
     * @param ids
     */
    filterChannels({ entries, }: {
        entries: ChannelEntry[];
    }): Promise<RawAnsChannelEntry[]>;
}
/**
 * A query client for interacting with Abstract Name Service.
 */
declare class AnsQueryClient extends AnsHostQueryClient implements IAnsQueryClient {
    constructor(client: CosmWasmClient, contractAddress: string);
    private assetCache;
    /**
     * Clear the asset cache.
     */
    private clearAssetCache;
    /**
     * Add a new asset entry to the cache based on the response.
     * @param entry
     */
    private cacheAssetEntry;
    /**
     * Retrieve an asset entry via its info. (reverse query).
     * @param info
     */
    entryByInfo: (info: AssetInfoBaseForAddr) => Promise<RawAnsAssetEntry | undefined>;
    /**
     * List all assets in ANS.
     * If *cached* is set to false, it will hard refresh.
     */
    listAssets({ ignoreCache, startAfter: userPageToken, }?: {
        ignoreCache?: boolean;
        startAfter?: string;
    }): Promise<RawAnsAssetEntry[]>;
    /**
     * Filter assets in ANS by their ids.
     * @param ids
     */
    filterAssets({ ids, }: {
        ids: AnsId[];
    }): Promise<RawAnsAssetEntry[]>;
    /**
     * List all the channels in ANS.
     * @param userPageToken
     */
    listChannels({ startAfter: userPageToken, }: {
        startAfter: ChannelEntry;
    }): Promise<RawAnsChannelEntry[]>;
    /**
     * Filter channels in ANS by their ids.
     * @param entries
     */
    filterChannels({ entries, }: {
        entries: ChannelEntry[];
    }): Promise<RawAnsChannelEntry[]>;
    listContracts({ startAfter: userPageToken, }: {
        startAfter: ContractEntry;
    }): Promise<RawAnsContractEntry[]>;
    /**
     * Filter contracts in ANS by their ids.
     * @param entries
     */
    filterContracts({ entries, }: {
        entries: ContractEntry[];
    }): Promise<RawAnsContractEntry[]>;
}
/**
 * An interface signaling that the class implements the IAnsQueryClient and AnsHostInterface.
 */
interface IAnsClient extends IAnsQueryClient, AnsHostInterface {
}
declare const AnsClient_base: ts_mixer_dist_types_types.Class<any[], AnsHostClient & AnsQueryClient, typeof AnsHostClient & typeof AnsQueryClient>;
/**
 * AnsClient is a client for interacting with the Abstract Name Service.
 */
declare class AnsClient extends AnsClient_base implements IAnsClient {
}

type ParametersExceptFirst<F> = F extends (arg0: any, ...rest: infer R) => any ? R : never;
interface IAbstractQueryClient {
    client: CosmWasmClient;
    readonly registryAddress: string;
    readonly ansHostAddress: string;
    connectSigningClient(signingClient: SigningCosmWasmClient, sender: string): AbstractClient;
}
interface AccountFilter {
    moduleIds?: string[];
    modules?: AccountModuleFilter[];
    owner?: string;
}
interface AccountModuleFilter {
    id: string;
    version?: string;
}
declare const CHAIN_DEPLOYMENT_QUERY: _graphql_typed_document_node_core.TypedDocumentNode<DeploymentQuery, Exact<{
    chain: string;
}>>;
/**
 * Options for the {@link AbstractQueryClient}
 * @property useBatchClient - Whether to use the {@link BatchCosmWasmClient} instead of the
 *   {@link CosmWasmClient}.
 * @property overrideApiUrl - Override the API URL for accessing Abstract.
 * @property batchClientOptions - Options for the {@link BatchCosmWasmClient}.
 * @property rpcUrl - The RPC URL to use for the {@link CosmWasmClient}.
 * @deprecated
 */
interface AbstractQueryClientOptions {
    useBatchClient?: boolean;
    overrideApiUrl?: string;
    batchClientOptions?: BatchCosmWasmClientOptions;
    rpcUrl?: string;
}
declare const DEFAULT_ABSTRACT_QUERY_CLIENT_OPTIONS: {
    useBatchClient: boolean;
};
/**
 * The AbstractQueryClient class provides an interface to interact with the blockchain.
 *
 * This client provides base functionality for querying data from the blockchain,
 * but does not support write operations (transactions).
 *
 * It provides access to various sub-clients that interact with specific parts of the blockchain,
 * like the Abstract Name Service, Registry, and Account Factory.
 *
 * To perform write operations, use the {@link AbstractClient} class.
 *
 * @property client - An instance of {@link CosmWasmClient}, used for blockchain interactions.
 * @property registryAddress - The address of the registry contract.
 * @property ansHostAddress - The address of the Abstract Name Service host.
 */
declare class AbstractQueryClient implements IAbstractQueryClient {
    readonly _publicClient: PublicClient;
    readonly _apiClient: ApiClient;
    client: CosmWasmClient;
    readonly registryAddress: string;
    readonly ansHostAddress: string;
    readonly apiUrl: string;
    accountCache: Map<string, AbstractAccountQueryClient>;
    _chainName: string | undefined;
    constructor({ client, registryAddress, ansHostAddress, }: Omit<IAbstractQueryClient, 'connectSigningClient'>, options?: {
        apiUrl?: string;
    });
    getAccountsOfOwner(owner: string, chains: string[]): Promise<AccountId[]>;
    /**
     * Connect to a specific instance of Abstract via its Registry address.
     * @param endpoint
     * @param registryAddress
     * @param version - the version of abstract to load
     * @param options - options for the query client
     */
    static connect(endpoint: string | HttpEndpoint, registryAddress: string, version?: string, options?: AbstractQueryClientOptions): Promise<AbstractQueryClient>;
    /**
     * Connect to Abstract on a specific chain. This will query the Abstract API to find the
     * addresses of the deployed contracts on the chain.
     * @param chainId - The chain ID to connect to. For example, 'juno-1'.
     * @param options - Options for the query client. Allows overriding of certain defaults such as
     *   the RPC url.
     */
    static connectToChain(chainId: string, options?: AbstractQueryClientOptions): Promise<AbstractQueryClient>;
    /**
     * Query the Abstract API.
     * @param params
     */
    queryApi<TResult, V extends Variables = Variables>(...params: ParametersExceptFirst<typeof graphqlRequest<TResult, V>>): Promise<ReturnType<typeof graphqlRequest<TResult, V>>>;
    getChainName(): Promise<string>;
    /**
     * Get the chain id for the connected chain.
     */
    getChainId(): Promise<string>;
    /**
     * Get the registry query client.
     */
    get registryQueryClient(): RegistryQueryClient;
    /**
     * Get the Abstract Name Service query client.
     */
    get ansQueryClient(): AnsQueryClient;
    /**
     * Load an Account query client.
     * @param accountId - {@link AbstractAccountId} or a number representing the sequence of the
     *   account.
     * @param refetch - If true, the account will be loaded from the blockchain, even if it is
     *   already in the cache.
     */
    loadAccount(accountId: AccountId, refetch?: boolean): Promise<AbstractAccountQueryClient>;
    /**
     * Load all local accounts.
     */
    loadAccounts({ startAfter: startAfter_, }?: {
        startAfter?: AccountId;
    }): Promise<AbstractAccountQueryClient[]>;
    /**
     * Filter the list of Accounts by the given filter.
     * This method is extremely inefficient if querying live (as opposed to archive) nodes.
     * @param filter
     */
    filterAccounts(filter: AccountFilter): Promise<AbstractAccountQueryClient[]>;
    /**
     * Upgrade the abstract client to an executable client.
     * @param signingClient
     * @param sender
     * @see AbstractClient#fromQueryClient
     */
    connectSigningClient(signingClient: SigningCosmWasmClient, sender: string): AbstractClient;
    /**
     * Clear the account cache.
     */
    clearAccountCache(): void;
}
interface IAbstractClient extends Omit<IAbstractQueryClient, 'connectSigningClient'> {
    client: SigningCosmWasmClient;
    sender: string;
}
/**
 * The AbstractClient class extends the functionality of the AbstractQueryClient.
 *
 * In addition to the query functionality provided by {@link AbstractQueryClient}, AbstractClient
 * also supports executing transactions.
 *
 * Use this class when you need to perform both read and write operations.
 *
 * @see {AbstractQueryClient#connect} - For connecting to the blockchain.
 * Provides access to the Abstract Name Service ({@link AnsClient}), Registry
 *   ({@link RegistryClient}), and Account Factory ({@link FactoryClient}) clients.
 */
declare class AbstractClient extends AbstractQueryClient {
    client: SigningCosmWasmClient;
    sender: string;
    constructor(base: IAbstractClient, options?: {
        apiUrl?: string;
    });
    /**
     * Get the Abstract name service client.
     */
    get ansClient(): AnsClient;
    /**
     * Get the registry client.
     */
    get registryClient(): RegistryClient;
    /**
     * Upgrade a query client to a signing client.
     */
    static fromQueryClient(queryClient: AbstractQueryClient, signingClient: SigningCosmWasmClient, sender: string): AbstractClient;
}

/**
 * A class representing an Asset in Abstract Name Service (ANS)
 * Model: [chain]>[symbol]
 * If the asset has passed through multiple chains, the most recent chain is first.
 * So, "dao" that went through osmosis and then IBC-ed to terra would be:
 * osmosis>juno>dao (ON TERRA)
 *
 * This is because on juno, it is juno>dao. On osmosis, it is juno>dao.
 * From osmosis -> terra, it is osmosis>juno>dao
 * @deprecated
 */
declare class AnsAssetEntry {
    private readonly _ansName;
    constructor(ansName: string);
    validate(): AnsAssetEntry;
    /**
     * Returns the protocol of the asset.
     * astroport/x,y -> astroport
     */
    get sourceProtocol(): string;
    /**
     * Get the ans name.
     */
    get ansName(): string;
    get hasProtocol(): boolean;
    /**
     * Returns the lowercased name of the asset without the protocol.
     * astroport/x,y -> x,y
     */
    get withoutProtocol(): string;
    /**
     * Returns the source chain of the asset.
     * osmosis>juno>dao -> osmosis
     */
    get sourceChain(): string;
    /**
     * Returns the lowercased symbol of the asset. Keep in mind that this method maintains the
     * chain information. So, if the asset has passed through multiple chains, the most recent
     * chain is first.
     *
     * osmosis>juno>dao -> juno>dao
     * juno>dao -> dao
     * @unstable
     */
    get symbol(): string;
}

type AssetInfo = {
    native: string;
} | {
    cw20: string;
} | {
    cw1155: string;
};

/**
 * Represents a fungible asset with a known amount
 *
 * Each asset instance contains two values: `info`, which specifies the asset’s type (CW20 or
 * native), and its `amount`, which specifies the asset’s amount.
 * @deprecated
 */
declare class Asset$1 {
    readonly info: AssetInfo;
    readonly amount: string;
    constructor(info: AssetInfo, amount: string);
    /**
     * Create an asset from a coin.
     */
    static fromCoin(coin: Coin): Asset$1;
    /**
     * Parse a string of the format {amount}{denom} into an AssetUnchecked object. This is the format
     * that Cosmos SDK uses to stringify native coins. For example:
     *
     * 12345uatom
     * 69420ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2
     * 88888factory/osmo1z926ax906k0ycsuckele6x5hh66e2m4m6ry7dn
     * Since native coin denoms can only start with a non-numerial character, while its amount can
     * only contain numerical characters, we simply consider the first non-numerical character and
     * all that comes after as the denom, while all that comes before it as the amount. This is the
     * approach used in the Steak Hub contract.
     * @param sdkString
     * @throws if the string is not in the expected format
     */
    static fromSdkString(sdkString: string): Asset$1;
    /**
     * Create a new asset instance representing a native coin of given denom and amount
     * @param denom
     * @param amount
     */
    static native(denom: string, amount: string): Asset$1;
    /**
     * Create a new asset instance representing a CW20 token of given contract address and amount.
     * @param address
     * @param amount
     */
    static cw20(address: string, amount: string): Asset$1;
    /**
     * Return whether this asset is a native asset.
     */
    isNative(): boolean;
    /**
     * Return whether this asset is a CW20 token.
     */
    isCw20(): boolean;
    /**
     * Turn a native asset into a coin.
     * @throws if the asset is not a native asset
     */
    intoCoin(): Coin;
    /**
     * Retrieve the contract address of the CW20 token.
     * @throws if the asset is not a CW20 token
     */
    cw20Address(): string;
    /**
     * Generate a message that transfers the asset from the sender to a specified recipient.
     * @param sender
     * @param recipient
     * @param funds funds to send with the message ONLY FOR CW20s
     */
    transferMsg(sender: string, recipient: string, funds?: Coin[]): EncodedMsg;
    /**
     * Generate a message that sends a CW20 token to the specified recipient with a binary payload.
     *
     * @throws if invoked on an Asset instance representing a native coin, as native coins do not
     *   have an equivalent method implemented.
     * @param sender
     * @param contractAddress the contract address to hook
     * @param msg the binary payload to send. Can also provide json
     * @param funds funds to send with the message
     */
    sendMsg<TJson extends Record<string, unknown>>(sender: string, contractAddress: string, msg: string | TJson, funds?: Coin[]): EncodedMsg;
}

/**
 * Represents an asset within Abstract Name Service with an amount.
 * @deprecated
 */
declare class AnsAsset {
    readonly amount: string;
    readonly name: AnsAssetEntry;
    constructor(amount: string, name: string | AnsAssetEntry);
    /**
     * Resolves the asset to its info and type.
     */
    resolve: (client: AbstractQueryClient) => Promise<Asset$1>;
    /**
     * Generate a message that transfers the asset from the sender to a specified recipient.
     * @param queryClient - ABstract query client to use for resolving the asset
     * @param sender
     * @param recipient
     * @param funds funds to send with the message ONLY FOR CW20s
     * @see {@link Asset.transferMsg}
     */
    transferMsg: (queryClient: AbstractQueryClient, sender: string, recipient: string, funds?: Coin[]) => Promise<EncodedMsg>;
}

type CosmosMsgForEmpty = CosmosMsgForEmpty$1;

/**
 * Represents a list of fungible tokens, each with a known amount.
 * @deprecated
 */
declare class AssetList$1 {
    _assets: Asset$1[];
    constructor(_assets: Asset$1[]);
    /**
     * Create an asset list from a list of native coins.
     */
    static fromCoins(coins: Coin[]): AssetList$1;
    /**
     * Get the list of assets.
     */
    get assets(): Asset$1[];
    /**
     * Get the length of the list.
     */
    get length(): number;
    /**
     * Add an asset to the list.
     * @param asset
     */
    add(asset: Asset$1): AssetList$1;
    /**
     * Generate a list of messages to send all the assets to a recipient.
     * Combines all native asset transfers into a single message.
     */
    transferMsgs(sender: string, recipient: string): EncodedMsg[];
    /**
     * Generate a list of Cosmos messages to send all the assets to a recipient.
     * These would be executed by a contract such as the Abstract proxy.
     *
     * Combines all native asset transfers into a single message.
     */
    cosmosTransferMsgs(sender: string, recipient: string): CosmosMsgForEmpty[];
}

/**
 * Class representing a list of ANS assets.
 * Also see {@link AssetList}
 * @deprecated
 */
declare class AnsAssetList {
    _assets: AnsAsset[];
    constructor(_assets: AnsAsset[]);
    /**
     * Get the list of ans assets.
     */
    get assets(): AnsAsset[];
    /**
     * Get the length of the list.
     */
    get length(): number;
    /**
     * Add an asset to the list.
     * @param asset
     */
    add(asset: AnsAsset): AnsAssetList;
    /**
     * Resolves the assets into an {@link AssetList} by querying the chain.
     */
    resolve: (queryClient: AbstractQueryClient) => Promise<AssetList$1>;
    /**
     * Generate a list of messages to send all the assets to a recipient.
     * Combines all native asset transfers into a single message.
     * @param queryClient - Abstract query client to use for resolving the assets
     * @param sender
     * @param recipient
     *
     * @see {@link AssetList.transferMsgs}
     */
    transferMsgs(queryClient: AbstractQueryClient, sender: string, recipient: string): Promise<EncodedMsg[]>;
}

/**
 * @deprecated
 */
declare abstract class AnsName {
    static chainNameIbcAsset(chainName: string, asset: string): string;
    /**
     * `staking/wyndex/juno>juno,juno>wynd`
     */
    static stakingContract(providerName: string, assetNames: string[]): string;
    /**
     * `wyndex/juno>juno,juno>wynd`
     */
    static lpToken(dexName: string, assetNames: string[]): string;
    /** asset names sorted by name and lowercased */
    static joinAssetNames(assetNames: string[]): string;
}

type Chain = typeof chains[number];
type AssetList = typeof assets[number];
type Asset = AssetList['assets'][number];
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> ? DeepPartial<U>[] : T[P] extends ReadonlyArray<infer U> ? readonly DeepPartial<U>[] : DeepPartial<T[P]>;
};
declare class ChainRegistryClient {
    _chains: readonly Chain[];
    _assetLists: readonly AssetList[];
    constructor(chains: Chain[], assetLists: AssetList[]);
    get chains(): readonly Chain[];
    get assetLists(): readonly AssetList[];
    chainIdToName(chainId: string): string;
    findChainBy<K extends keyof Chain>(filters: {
        [P in K]?: Chain[P];
    }): Chain;
    /**
     * Find chains by filters.
     * @param filters
     */
    findChainsBy<K extends keyof Chain>(filters: {
        [P in K]?: Chain[P];
    }): readonly Chain[];
    findAssetsBy<K extends keyof Asset>(filters: {
        [P in K]?: DeepPartial<Asset[P]>;
    }, options?: {
        chainNameFilter?: string;
        throwIfNotFound?: boolean;
    }): Asset[];
    findAssetBy<K extends keyof Asset>(filters: {
        [P in K]?: DeepPartial<Asset[P]>;
    }, options?: {
        chainNameFilter?: string;
    }): Asset;
    private static findLogoUri;
    externalChainDenomToAnsName(searchDenom: string): string;
    findSymbol(chainId: string, denom: string): string;
    assetBySymbol(assetSymbol: string): Asset | undefined;
}

declare class ModuleNotFoundError extends Error {
    constructor(moduleId: string, version?: string);
}
declare class AbstractNotFoundError extends Error {
    constructor(message: string);
}
declare class AccountNotFoundError extends Error {
    constructor(accountId: string);
}

export { AbstractAccountClient, AbstractAccountQueryClient, AbstractClient, AbstractModule, AbstractNotFoundError, AbstractQueryClient, type AbstractQueryClientOptions, type AccountFilter, type AccountModuleFilter, AccountNotFoundError, AnsAsset, AnsAssetEntry, AnsAssetList, AnsClient, AnsName, AnsQueryClient, Asset$1 as Asset, type AssetInfo, AssetList$1 as AssetList, CHAIN_DEPLOYMENT_QUERY, type Chain, ChainRegistryClient, type CosmosMsgForEmpty, DEFAULT_ABSTRACT_QUERY_CLIENT_OPTIONS, type IAbstractQueryClient, type ModuleByIdOrName, ModuleInfo, ModuleNotFoundError, type RawAnsAssetEntry, type RawAnsChannelEntry, type RawAnsContractEntry, graphqlRequest };
