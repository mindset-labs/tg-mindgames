import { CosmWasmClient, StdFee, ExecuteResult, SigningCosmWasmClient, Coin as Coin$3 } from '@abstract-money/cli/cosmjs';
import { e as ConfigResponse$3, f as ModuleVersionsResponse, g as ModuleAddressesResponse, h as ModuleInfosResponse, i as InfoResponse, S as SubAccountIdsResponse, T as TopLevelOwnerResponse, O as OwnershipForString$2, B as Binary$2, C as CosmosMsgForEmpty$2, a as Coin$2, I as InternalConfigAction$1, M as ModuleInstallConfig$1, b as ModuleInfo$1, U as UpdateSubAccountAction$1, G as GovAction$1, A as AddAuthenticator, j as AccountId$1, k as AccountsResponse, l as ModuleInfo$2, m as ModulesResponse, N as NamespacesResponse, n as Namespace$1, o as NamespaceResponse, p as ConfigResponse$4, q as AccountListResponse, r as ModuleFilter, s as ModulesListResponse, t as NamespaceListResponse, u as OwnershipForString$3, v as Coin$4, w as UpdateModule, x as ClearableForCoin, y as Action$3 } from './Registry.types-tb_Smu0e.js';

/**
* This file was automatically generated by @abstract-money/ts-codegen@0.37.0-beta-3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/

interface AccountReadOnlyInterface {
    contractAddress: string;
    config: () => Promise<ConfigResponse$3>;
    moduleVersions: ({ ids }: {
        ids: string[];
    }) => Promise<ModuleVersionsResponse>;
    moduleAddresses: ({ ids }: {
        ids: string[];
    }) => Promise<ModuleAddressesResponse>;
    moduleInfos: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<ModuleInfosResponse>;
    info: () => Promise<InfoResponse>;
    subAccountIds: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: number;
    }) => Promise<SubAccountIdsResponse>;
    topLevelOwner: () => Promise<TopLevelOwnerResponse>;
    ownership: () => Promise<OwnershipForString$2>;
    authenticatorByID: ({ id }: {
        id: number;
    }) => Promise<Binary$2>;
    authenticatorIDs: () => Promise<Binary$2>;
}
declare class AccountQueryClient implements AccountReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;
    constructor(client: CosmWasmClient, contractAddress: string);
    config: () => Promise<ConfigResponse$3>;
    moduleVersions: ({ ids }: {
        ids: string[];
    }) => Promise<ModuleVersionsResponse>;
    moduleAddresses: ({ ids }: {
        ids: string[];
    }) => Promise<ModuleAddressesResponse>;
    moduleInfos: ({ limit, startAfter }: {
        limit?: number | undefined;
        startAfter?: string | undefined;
    }) => Promise<ModuleInfosResponse>;
    info: () => Promise<InfoResponse>;
    subAccountIds: ({ limit, startAfter }: {
        limit?: number | undefined;
        startAfter?: number | undefined;
    }) => Promise<SubAccountIdsResponse>;
    topLevelOwner: () => Promise<TopLevelOwnerResponse>;
    ownership: () => Promise<OwnershipForString$2>;
    authenticatorByID: ({ id }: {
        id: number;
    }) => Promise<Binary$2>;
    authenticatorIDs: () => Promise<Binary$2>;
}
interface AccountInterface extends AccountReadOnlyInterface {
    contractAddress: string;
    sender: string;
    execute: ({ msgs }: {
        msgs: CosmosMsgForEmpty$2[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    executeWithData: ({ msg }: {
        msg: CosmosMsgForEmpty$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    executeOnModule: ({ execMsg, funds, moduleId }: {
        execMsg: Binary$2;
        funds: Coin$2[];
        moduleId: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    adminExecute: ({ addr, msg }: {
        addr: string;
        msg: Binary$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    adminExecuteOnModule: ({ moduleId, msg }: {
        moduleId: string;
        msg: Binary$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    icaAction: ({ actionQueryMsg }: {
        actionQueryMsg: Binary$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    updateInternalConfig: (internalConfigAction: InternalConfigAction$1, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    installModules: ({ modules }: {
        modules: ModuleInstallConfig$1[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    uninstallModule: ({ moduleId }: {
        moduleId: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    upgrade: ({ modules }: {
        modules: ModuleInfo$1[][];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    createSubAccount: ({ accountId, description, installModules, link, name, namespace }: {
        accountId?: number;
        description?: string;
        installModules: ModuleInstallConfig$1[];
        link?: string;
        name?: string;
        namespace?: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    updateInfo: ({ description, link, name }: {
        description?: string;
        link?: string;
        name?: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    updateStatus: ({ isSuspended }: {
        isSuspended?: boolean;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    updateSubAccount: (updateSubAccountAction: UpdateSubAccountAction$1, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    updateOwnership: (govAction: GovAction$1, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    addAuthMethod: ({ addAuthenticator }: {
        addAuthenticator: AddAuthenticator;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    removeAuthMethod: ({ id }: {
        id: number;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
}
declare class AccountClient extends AccountQueryClient implements AccountInterface {
    client: SigningCosmWasmClient;
    sender: string;
    contractAddress: string;
    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string);
    execute: ({ msgs }: {
        msgs: CosmosMsgForEmpty$2[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    executeWithData: ({ msg }: {
        msg: CosmosMsgForEmpty$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    executeOnModule: ({ execMsg, funds, moduleId }: {
        execMsg: Binary$2;
        funds: Coin$2[];
        moduleId: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    adminExecute: ({ addr, msg }: {
        addr: string;
        msg: Binary$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    adminExecuteOnModule: ({ moduleId, msg }: {
        moduleId: string;
        msg: Binary$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    icaAction: ({ actionQueryMsg }: {
        actionQueryMsg: Binary$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    updateInternalConfig: (internalConfigAction: InternalConfigAction$1, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    installModules: ({ modules }: {
        modules: ModuleInstallConfig$1[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    uninstallModule: ({ moduleId }: {
        moduleId: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    upgrade: ({ modules }: {
        modules: ModuleInfo$1[][];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    createSubAccount: ({ accountId, description, installModules, link, name, namespace }: {
        accountId?: number | undefined;
        description?: string | undefined;
        installModules: ModuleInstallConfig$1[];
        link?: string | undefined;
        name?: string | undefined;
        namespace?: string | undefined;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    updateInfo: ({ description, link, name }: {
        description?: string | undefined;
        link?: string | undefined;
        name?: string | undefined;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    updateStatus: ({ isSuspended }: {
        isSuspended?: boolean | undefined;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    updateSubAccount: (updateSubAccountAction: UpdateSubAccountAction$1, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    updateOwnership: (govAction: GovAction$1, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    addAuthMethod: ({ addAuthenticator }: {
        addAuthenticator: AddAuthenticator;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
    removeAuthMethod: ({ id }: {
        id: number;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$2[]) => Promise<ExecuteResult>;
}

/**
* This file was automatically generated by @abstract-money/ts-codegen@0.37.0-beta-3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/
interface InstantiateMsg$2 {
    admin: string;
}
type ExecuteMsg$2 = {
    update_contract_addresses: {
        to_add: [UncheckedContractEntry, string][];
        to_remove: UncheckedContractEntry[];
    };
} | {
    update_asset_addresses: {
        to_add: [string, AssetInfoBaseForString][];
        to_remove: string[];
    };
} | {
    update_channels: {
        to_add: [UncheckedChannelEntry, string][];
        to_remove: UncheckedChannelEntry[];
    };
} | {
    update_dexes: {
        to_add: string[];
        to_remove: string[];
    };
} | {
    update_pools: {
        to_add: [PoolAddressBaseForString, PoolMetadata][];
        to_remove: UniquePoolId[];
    };
} | {
    update_ownership: Action$2;
};
type AssetInfoBaseForString = {
    native: string;
} | {
    cw20: string;
};
type PoolAddressBaseForString = {
    separate_addresses: {
        liquidity: string;
        swap: string;
    };
} | {
    contract: string;
} | {
    id: number;
};
type AssetEntry = string;
type PoolType = "ConstantProduct" | "Stable" | "Weighted" | "LiquidityBootstrap" | "ConcentratedLiquidity";
type UniquePoolId = number;
type Action$2 = {
    transfer_ownership: {
        expiry?: Expiration$2 | null;
        new_owner: string;
    };
} | "accept_ownership" | "renounce_ownership";
type Expiration$2 = {
    at_height: number;
} | {
    at_time: Timestamp$2;
} | {
    never: {};
};
type Timestamp$2 = Uint64$2;
type Uint64$2 = string;
interface UncheckedContractEntry {
    contract: string;
    protocol: string;
}
interface UncheckedChannelEntry {
    connected_chain: string;
    protocol: string;
}
interface PoolMetadata {
    assets: AssetEntry[];
    dex: string;
    pool_type: PoolType;
}
type QueryMsg$2 = {
    config: {};
} | {
    assets: {
        names: string[];
    };
} | {
    asset_list: {
        filter?: AssetFilter | null;
        limit?: number | null;
        start_after?: string | null;
    };
} | {
    asset_infos: {
        infos: AssetInfoBaseForString[];
    };
} | {
    asset_info_list: {
        filter?: AssetInfoFilter | null;
        limit?: number | null;
        start_after?: AssetInfoBaseForString | null;
    };
} | {
    contracts: {
        entries: ContractEntry[];
    };
} | {
    contract_list: {
        filter?: ContractFilter | null;
        limit?: number | null;
        start_after?: ContractEntry | null;
    };
} | {
    channels: {
        entries: ChannelEntry[];
    };
} | {
    channel_list: {
        filter?: ChannelFilter | null;
        limit?: number | null;
        start_after?: ChannelEntry | null;
    };
} | {
    registered_dexes: {};
} | {
    pools: {
        pairings: DexAssetPairingForAssetEntry[];
    };
} | {
    pool_list: {
        filter?: AssetPairingFilter | null;
        limit?: number | null;
        start_after?: DexAssetPairingForAssetEntry | null;
    };
} | {
    pool_metadatas: {
        ids: UniquePoolId[];
    };
} | {
    pool_metadata_list: {
        filter?: PoolMetadataFilter | null;
        limit?: number | null;
        start_after?: UniquePoolId | null;
    };
} | {
    ownership: {};
};
type TruncatedChainId$2 = string;
type DexAssetPairingForAssetEntry = [AssetEntry, AssetEntry, string];
interface AssetFilter {
}
interface AssetInfoFilter {
}
interface ContractEntry {
    contract: string;
    protocol: string;
}
interface ContractFilter {
}
interface ChannelEntry {
    connected_chain: TruncatedChainId$2;
    protocol: string;
}
interface ChannelFilter {
}
interface AssetPairingFilter {
    asset_pair?: [AssetEntry, AssetEntry] | null;
    dex?: string | null;
}
interface PoolMetadataFilter {
    pool_type?: PoolType | null;
}
type MigrateMsg$2 = {
    instantiate: InstantiateMsg$2;
} | {
    migrate: {};
};
type AssetInfoBaseForAddr = {
    native: string;
} | {
    cw20: Addr$2;
};
type Addr$2 = string;
interface AssetInfosResponse {
    infos: [AssetInfoBaseForAddr, AssetEntry][];
}
interface AssetsResponse {
    assets: [AssetEntry, AssetInfoBaseForAddr][];
}
interface ChannelListResponse {
    channels: [ChannelEntry, string][];
}
interface ChannelsResponse {
    channels: [ChannelEntry, string][];
}
interface ConfigResponse$2 {
    next_unique_pool_id: UniquePoolId;
}
interface ContractListResponse {
    contracts: [ContractEntry, Addr$2][];
}
interface ContractsResponse {
    contracts: [ContractEntry, Addr$2][];
}
interface OwnershipForString$1 {
    owner?: string | null;
    pending_expiry?: Expiration$2 | null;
    pending_owner?: string | null;
}
type PoolAddressBaseForAddr = {
    separate_addresses: {
        liquidity: Addr$2;
        swap: Addr$2;
    };
} | {
    contract: Addr$2;
} | {
    id: number;
};
interface PoolAddressListResponse {
    pools: [DexAssetPairingForAssetEntry, PoolReference[]][];
}
interface PoolReference {
    pool_address: PoolAddressBaseForAddr;
    unique_id: UniquePoolId;
}
interface PoolMetadataListResponse {
    metadatas: [UniquePoolId, PoolMetadata][];
}
interface PoolMetadatasResponse {
    metadatas: [UniquePoolId, PoolMetadata][];
}
interface PoolsResponse {
    pools: [DexAssetPairingForAssetEntry, PoolReference[]][];
}
interface RegisteredDexesResponse {
    dexes: string[];
}

type AnsHost_types_AssetEntry = AssetEntry;
type AnsHost_types_AssetFilter = AssetFilter;
type AnsHost_types_AssetInfoBaseForAddr = AssetInfoBaseForAddr;
type AnsHost_types_AssetInfoBaseForString = AssetInfoBaseForString;
type AnsHost_types_AssetInfoFilter = AssetInfoFilter;
type AnsHost_types_AssetInfosResponse = AssetInfosResponse;
type AnsHost_types_AssetPairingFilter = AssetPairingFilter;
type AnsHost_types_AssetsResponse = AssetsResponse;
type AnsHost_types_ChannelEntry = ChannelEntry;
type AnsHost_types_ChannelFilter = ChannelFilter;
type AnsHost_types_ChannelListResponse = ChannelListResponse;
type AnsHost_types_ChannelsResponse = ChannelsResponse;
type AnsHost_types_ContractEntry = ContractEntry;
type AnsHost_types_ContractFilter = ContractFilter;
type AnsHost_types_ContractListResponse = ContractListResponse;
type AnsHost_types_ContractsResponse = ContractsResponse;
type AnsHost_types_DexAssetPairingForAssetEntry = DexAssetPairingForAssetEntry;
type AnsHost_types_PoolAddressBaseForAddr = PoolAddressBaseForAddr;
type AnsHost_types_PoolAddressBaseForString = PoolAddressBaseForString;
type AnsHost_types_PoolAddressListResponse = PoolAddressListResponse;
type AnsHost_types_PoolMetadata = PoolMetadata;
type AnsHost_types_PoolMetadataFilter = PoolMetadataFilter;
type AnsHost_types_PoolMetadataListResponse = PoolMetadataListResponse;
type AnsHost_types_PoolMetadatasResponse = PoolMetadatasResponse;
type AnsHost_types_PoolReference = PoolReference;
type AnsHost_types_PoolType = PoolType;
type AnsHost_types_PoolsResponse = PoolsResponse;
type AnsHost_types_RegisteredDexesResponse = RegisteredDexesResponse;
type AnsHost_types_UncheckedChannelEntry = UncheckedChannelEntry;
type AnsHost_types_UncheckedContractEntry = UncheckedContractEntry;
type AnsHost_types_UniquePoolId = UniquePoolId;
declare namespace AnsHost_types {
  export type { Action$2 as Action, Addr$2 as Addr, AnsHost_types_AssetEntry as AssetEntry, AnsHost_types_AssetFilter as AssetFilter, AnsHost_types_AssetInfoBaseForAddr as AssetInfoBaseForAddr, AnsHost_types_AssetInfoBaseForString as AssetInfoBaseForString, AnsHost_types_AssetInfoFilter as AssetInfoFilter, AnsHost_types_AssetInfosResponse as AssetInfosResponse, AnsHost_types_AssetPairingFilter as AssetPairingFilter, AnsHost_types_AssetsResponse as AssetsResponse, AnsHost_types_ChannelEntry as ChannelEntry, AnsHost_types_ChannelFilter as ChannelFilter, AnsHost_types_ChannelListResponse as ChannelListResponse, AnsHost_types_ChannelsResponse as ChannelsResponse, ConfigResponse$2 as ConfigResponse, AnsHost_types_ContractEntry as ContractEntry, AnsHost_types_ContractFilter as ContractFilter, AnsHost_types_ContractListResponse as ContractListResponse, AnsHost_types_ContractsResponse as ContractsResponse, AnsHost_types_DexAssetPairingForAssetEntry as DexAssetPairingForAssetEntry, ExecuteMsg$2 as ExecuteMsg, Expiration$2 as Expiration, InstantiateMsg$2 as InstantiateMsg, MigrateMsg$2 as MigrateMsg, OwnershipForString$1 as OwnershipForString, AnsHost_types_PoolAddressBaseForAddr as PoolAddressBaseForAddr, AnsHost_types_PoolAddressBaseForString as PoolAddressBaseForString, AnsHost_types_PoolAddressListResponse as PoolAddressListResponse, AnsHost_types_PoolMetadata as PoolMetadata, AnsHost_types_PoolMetadataFilter as PoolMetadataFilter, AnsHost_types_PoolMetadataListResponse as PoolMetadataListResponse, AnsHost_types_PoolMetadatasResponse as PoolMetadatasResponse, AnsHost_types_PoolReference as PoolReference, AnsHost_types_PoolType as PoolType, AnsHost_types_PoolsResponse as PoolsResponse, QueryMsg$2 as QueryMsg, AnsHost_types_RegisteredDexesResponse as RegisteredDexesResponse, Timestamp$2 as Timestamp, TruncatedChainId$2 as TruncatedChainId, Uint64$2 as Uint64, AnsHost_types_UncheckedChannelEntry as UncheckedChannelEntry, AnsHost_types_UncheckedContractEntry as UncheckedContractEntry, AnsHost_types_UniquePoolId as UniquePoolId };
}

/**
* This file was automatically generated by @abstract-money/ts-codegen@0.37.0-beta-3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/

interface AnsHostReadOnlyInterface {
    contractAddress: string;
    config: () => Promise<ConfigResponse$2>;
    assets: ({ names }: {
        names: string[];
    }) => Promise<AssetsResponse>;
    assetList: ({ filter, limit, startAfter }: {
        filter?: AssetFilter;
        limit?: number;
        startAfter?: string;
    }) => Promise<AssetsResponse>;
    assetInfos: ({ infos }: {
        infos: AssetInfoBaseForString[];
    }) => Promise<AssetInfosResponse>;
    assetInfoList: ({ filter, limit, startAfter }: {
        filter?: AssetInfoFilter;
        limit?: number;
        startAfter?: AssetInfoBaseForString;
    }) => Promise<AssetInfosResponse>;
    contracts: ({ entries }: {
        entries: ContractEntry[];
    }) => Promise<ContractsResponse>;
    contractList: ({ filter, limit, startAfter }: {
        filter?: ContractFilter;
        limit?: number;
        startAfter?: ContractEntry;
    }) => Promise<ContractListResponse>;
    channels: ({ entries }: {
        entries: ChannelEntry[];
    }) => Promise<ChannelsResponse>;
    channelList: ({ filter, limit, startAfter }: {
        filter?: ChannelFilter;
        limit?: number;
        startAfter?: ChannelEntry;
    }) => Promise<ChannelListResponse>;
    registeredDexes: () => Promise<RegisteredDexesResponse>;
    pools: ({ pairings }: {
        pairings: DexAssetPairingForAssetEntry[];
    }) => Promise<PoolsResponse>;
    poolList: ({ filter, limit, startAfter }: {
        filter?: AssetPairingFilter;
        limit?: number;
        startAfter?: DexAssetPairingForAssetEntry;
    }) => Promise<PoolAddressListResponse>;
    poolMetadatas: ({ ids }: {
        ids: UniquePoolId[];
    }) => Promise<PoolMetadatasResponse>;
    poolMetadataList: ({ filter, limit, startAfter }: {
        filter?: PoolMetadataFilter;
        limit?: number;
        startAfter?: UniquePoolId;
    }) => Promise<PoolMetadataListResponse>;
    ownership: () => Promise<OwnershipForString$1>;
}
declare class AnsHostQueryClient implements AnsHostReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;
    constructor(client: CosmWasmClient, contractAddress: string);
    config: () => Promise<ConfigResponse$2>;
    assets: ({ names }: {
        names: string[];
    }) => Promise<AssetsResponse>;
    assetList: ({ filter, limit, startAfter }: {
        filter?: AssetFilter | undefined;
        limit?: number | undefined;
        startAfter?: string | undefined;
    }) => Promise<AssetsResponse>;
    assetInfos: ({ infos }: {
        infos: AssetInfoBaseForString[];
    }) => Promise<AssetInfosResponse>;
    assetInfoList: ({ filter, limit, startAfter }: {
        filter?: AssetInfoFilter | undefined;
        limit?: number | undefined;
        startAfter?: AssetInfoBaseForString | undefined;
    }) => Promise<AssetInfosResponse>;
    contracts: ({ entries }: {
        entries: ContractEntry[];
    }) => Promise<ContractsResponse>;
    contractList: ({ filter, limit, startAfter }: {
        filter?: ContractFilter | undefined;
        limit?: number | undefined;
        startAfter?: ContractEntry | undefined;
    }) => Promise<ContractListResponse>;
    channels: ({ entries }: {
        entries: ChannelEntry[];
    }) => Promise<ChannelsResponse>;
    channelList: ({ filter, limit, startAfter }: {
        filter?: ChannelFilter | undefined;
        limit?: number | undefined;
        startAfter?: ChannelEntry | undefined;
    }) => Promise<ChannelListResponse>;
    registeredDexes: () => Promise<RegisteredDexesResponse>;
    pools: ({ pairings }: {
        pairings: DexAssetPairingForAssetEntry[];
    }) => Promise<PoolsResponse>;
    poolList: ({ filter, limit, startAfter }: {
        filter?: AssetPairingFilter | undefined;
        limit?: number | undefined;
        startAfter?: DexAssetPairingForAssetEntry | undefined;
    }) => Promise<PoolAddressListResponse>;
    poolMetadatas: ({ ids }: {
        ids: UniquePoolId[];
    }) => Promise<PoolMetadatasResponse>;
    poolMetadataList: ({ filter, limit, startAfter }: {
        filter?: PoolMetadataFilter | undefined;
        limit?: number | undefined;
        startAfter?: number | undefined;
    }) => Promise<PoolMetadataListResponse>;
    ownership: () => Promise<OwnershipForString$1>;
}
interface AnsHostInterface extends AnsHostReadOnlyInterface {
    contractAddress: string;
    sender: string;
    updateContractAddresses: ({ toAdd, toRemove }: {
        toAdd: UncheckedContractEntry[][];
        toRemove: UncheckedContractEntry[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
    updateAssetAddresses: ({ toAdd, toRemove }: {
        toAdd: string[][];
        toRemove: string[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
    updateChannels: ({ toAdd, toRemove }: {
        toAdd: UncheckedChannelEntry[][];
        toRemove: UncheckedChannelEntry[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
    updateDexes: ({ toAdd, toRemove }: {
        toAdd: string[];
        toRemove: string[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
    updatePools: ({ toAdd, toRemove }: {
        toAdd: PoolAddressBaseForString[][];
        toRemove: UniquePoolId[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
    updateOwnership: (action: Action$2, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
}
declare class AnsHostClient extends AnsHostQueryClient implements AnsHostInterface {
    client: SigningCosmWasmClient;
    sender: string;
    contractAddress: string;
    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string);
    updateContractAddresses: ({ toAdd, toRemove }: {
        toAdd: UncheckedContractEntry[][];
        toRemove: UncheckedContractEntry[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
    updateAssetAddresses: ({ toAdd, toRemove }: {
        toAdd: string[][];
        toRemove: string[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
    updateChannels: ({ toAdd, toRemove }: {
        toAdd: UncheckedChannelEntry[][];
        toRemove: UncheckedChannelEntry[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
    updateDexes: ({ toAdd, toRemove }: {
        toAdd: string[];
        toRemove: string[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
    updatePools: ({ toAdd, toRemove }: {
        toAdd: PoolAddressBaseForString[][];
        toRemove: UniquePoolId[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
    updateOwnership: (action: Action$2, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$3[]) => Promise<ExecuteResult>;
}

/**
* This file was automatically generated by @abstract-money/ts-codegen@0.37.0-beta-3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/
interface InstantiateMsg$1 {
}
type ExecuteMsg$1 = {
    update_ownership: Action$1;
} | {
    register_infrastructure: {
        chain: TruncatedChainId$1;
        host: string;
        note: string;
    };
} | {
    send_funds: {
        host_chain: TruncatedChainId$1;
        memo?: string | null;
        receiver?: string | null;
    };
} | {
    send_funds_with_actions: {
        actions: Binary$1[];
        host_chain: TruncatedChainId$1;
    };
} | {
    register: {
        host_chain: TruncatedChainId$1;
        install_modules: ModuleInstallConfig[];
        namespace?: string | null;
    };
} | {
    module_ibc_action: {
        callback?: Callback | null;
        host_chain: TruncatedChainId$1;
        msg: Binary$1;
        target_module: ModuleInfo;
    };
} | {
    ibc_query: {
        callback: Callback;
        host_chain: TruncatedChainId$1;
        queries: QueryRequestForModuleQuery[];
    };
} | {
    remote_action: {
        action: HostAction;
        host_chain: TruncatedChainId$1;
    };
} | {
    remove_host: {
        host_chain: TruncatedChainId$1;
    };
} | {
    callback: CallbackMessage;
};
type Action$1 = {
    transfer_ownership: {
        expiry?: Expiration$1 | null;
        new_owner: string;
    };
} | "accept_ownership" | "renounce_ownership";
type Expiration$1 = {
    at_height: number;
} | {
    at_time: Timestamp$1;
} | {
    never: {};
};
type Timestamp$1 = Uint64$1;
type Uint64$1 = string;
type TruncatedChainId$1 = string;
type Binary$1 = string;
type Namespace = string;
type ModuleVersion = "latest" | {
    version: string;
};
type QueryRequestForModuleQuery = {
    bank: BankQuery;
} | {
    custom: ModuleQuery;
} | {
    staking: StakingQuery;
} | {
    distribution: DistributionQuery;
} | {
    stargate: {
        data: Binary$1;
        path: string;
    };
} | {
    ibc: IbcQuery;
} | {
    wasm: WasmQuery;
} | {
    grpc: GrpcQuery;
};
type BankQuery = {
    supply: {
        denom: string;
    };
} | {
    balance: {
        address: string;
        denom: string;
    };
} | {
    all_balances: {
        address: string;
    };
} | {
    denom_metadata: {
        denom: string;
    };
} | {
    all_denom_metadata: {
        pagination?: PageRequest | null;
    };
};
type AccountTrace = "local" | {
    remote: TruncatedChainId$1[];
};
type StakingQuery = {
    bonded_denom: {};
} | {
    all_delegations: {
        delegator: string;
    };
} | {
    delegation: {
        delegator: string;
        validator: string;
    };
} | {
    all_validators: {};
} | {
    validator: {
        address: string;
    };
};
type DistributionQuery = {
    delegator_withdraw_address: {
        delegator_address: string;
    };
} | {
    delegation_rewards: {
        delegator_address: string;
        validator_address: string;
    };
} | {
    delegation_total_rewards: {
        delegator_address: string;
    };
} | {
    delegator_validators: {
        delegator_address: string;
    };
};
type IbcQuery = {
    port_id: {};
} | {
    list_channels: {
        port_id?: string | null;
    };
} | {
    channel: {
        channel_id: string;
        port_id?: string | null;
    };
};
type WasmQuery = {
    smart: {
        contract_addr: string;
        msg: Binary$1;
    };
} | {
    raw: {
        contract_addr: string;
        key: Binary$1;
    };
} | {
    contract_info: {
        contract_addr: string;
    };
} | {
    code_info: {
        code_id: number;
    };
};
type HostAction = {
    dispatch: {
        account_msgs: ExecuteMsgForEmpty[];
    };
} | {
    internal: InternalAction;
} | {
    helpers: HelperAction;
};
type ExecuteMsgForEmpty = {
    execute: {
        msgs: CosmosMsgForEmpty$1[];
    };
} | {
    execute_with_data: {
        msg: CosmosMsgForEmpty$1;
    };
} | {
    execute_on_module: {
        exec_msg: Binary$1;
        funds: Coin$1[];
        module_id: string;
    };
} | {
    admin_execute: {
        addr: string;
        msg: Binary$1;
    };
} | {
    admin_execute_on_module: {
        module_id: string;
        msg: Binary$1;
    };
} | {
    ica_action: {
        action_query_msg: Binary$1;
    };
} | {
    update_internal_config: InternalConfigAction;
} | {
    install_modules: {
        modules: ModuleInstallConfig[];
    };
} | {
    uninstall_module: {
        module_id: string;
    };
} | {
    upgrade: {
        modules: [ModuleInfo, Binary$1 | null][];
    };
} | {
    create_sub_account: {
        account_id?: number | null;
        description?: string | null;
        install_modules: ModuleInstallConfig[];
        link?: string | null;
        name?: string | null;
        namespace?: string | null;
    };
} | {
    update_info: {
        description?: string | null;
        link?: string | null;
        name?: string | null;
    };
} | {
    update_status: {
        is_suspended?: boolean | null;
    };
} | {
    update_sub_account: UpdateSubAccountAction;
} | {
    update_ownership: GovAction;
} | {
    add_auth_method: {
        add_authenticator: Empty$1;
    };
} | {
    remove_auth_method: {
        id: number;
    };
};
type CosmosMsgForEmpty$1 = {
    bank: BankMsg$1;
} | {
    custom: Empty$1;
} | {
    staking: StakingMsg$1;
} | {
    distribution: DistributionMsg$1;
} | {
    stargate: {
        type_url: string;
        value: Binary$1;
    };
} | {
    any: AnyMsg$1;
} | {
    ibc: IbcMsg$1;
} | {
    wasm: WasmMsg$1;
} | {
    gov: GovMsg$1;
};
type BankMsg$1 = {
    send: {
        amount: Coin$1[];
        to_address: string;
    };
} | {
    burn: {
        amount: Coin$1[];
    };
};
type Uint128$1 = string;
type StakingMsg$1 = {
    delegate: {
        amount: Coin$1;
        validator: string;
    };
} | {
    undelegate: {
        amount: Coin$1;
        validator: string;
    };
} | {
    redelegate: {
        amount: Coin$1;
        dst_validator: string;
        src_validator: string;
    };
};
type DistributionMsg$1 = {
    set_withdraw_address: {
        address: string;
    };
} | {
    withdraw_delegator_reward: {
        validator: string;
    };
} | {
    fund_community_pool: {
        amount: Coin$1[];
    };
};
type IbcMsg$1 = {
    transfer: {
        amount: Coin$1;
        channel_id: string;
        memo?: string | null;
        timeout: IbcTimeout$1;
        to_address: string;
    };
} | {
    send_packet: {
        channel_id: string;
        data: Binary$1;
        timeout: IbcTimeout$1;
    };
} | {
    close_channel: {
        channel_id: string;
    };
};
type WasmMsg$1 = {
    execute: {
        contract_addr: string;
        funds: Coin$1[];
        msg: Binary$1;
    };
} | {
    instantiate: {
        admin?: string | null;
        code_id: number;
        funds: Coin$1[];
        label: string;
        msg: Binary$1;
    };
} | {
    instantiate2: {
        admin?: string | null;
        code_id: number;
        funds: Coin$1[];
        label: string;
        msg: Binary$1;
        salt: Binary$1;
    };
} | {
    migrate: {
        contract_addr: string;
        msg: Binary$1;
        new_code_id: number;
    };
} | {
    update_admin: {
        admin: string;
        contract_addr: string;
    };
} | {
    clear_admin: {
        contract_addr: string;
    };
};
type GovMsg$1 = {
    vote: {
        option: VoteOption$1;
        proposal_id: number;
    };
} | {
    vote_weighted: {
        options: WeightedVoteOption$1[];
        proposal_id: number;
    };
};
type VoteOption$1 = "yes" | "no" | "abstain" | "no_with_veto";
type Decimal$1 = string;
type InternalConfigAction = {
    update_module_addresses: {
        to_add: [string, string][];
        to_remove: string[];
    };
} | {
    update_whitelist: {
        to_add: string[];
        to_remove: string[];
    };
};
type UpdateSubAccountAction = {
    unregister_sub_account: {
        id: number;
    };
} | {
    register_sub_account: {
        id: number;
    };
};
type GovAction = {
    transfer_ownership: {
        expiry?: Expiration$1 | null;
        new_owner: GovernanceDetailsForString;
    };
} | "accept_ownership" | "renounce_ownership";
type GovernanceDetailsForString = {
    monarchy: {
        monarch: string;
    };
} | {
    sub_account: {
        account: string;
    };
} | {
    external: {
        governance_address: string;
        governance_type: string;
    };
} | {
    n_f_t: {
        collection_addr: string;
        token_id: string;
    };
} | {
    abstract_account: {
        address: Addr$1;
    };
} | {
    renounced: {};
};
type Addr$1 = string;
type InternalAction = {
    register: {
        description?: string | null;
        install_modules: ModuleInstallConfig[];
        link?: string | null;
        name?: string | null;
        namespace?: string | null;
    };
};
type HelperAction = "send_all_back";
type Callback2 = {
    query: ResultOfArrayOfBinaryOrErrorResponse;
} | {
    execute: ResultOfExecutionResponseOrString;
} | {
    fatal_error: string;
};
type ResultOfArrayOfBinaryOrErrorResponse = {
    Ok: Binary$1[];
} | {
    Err: ErrorResponse;
};
type ResultOfExecutionResponseOrString = {
    Ok: ExecutionResponse;
} | {
    Err: string;
};
interface ModuleInstallConfig {
    init_msg?: Binary$1 | null;
    module: ModuleInfo;
}
interface ModuleInfo {
    name: string;
    namespace: Namespace;
    version: ModuleVersion;
}
interface Callback {
    msg: Binary$1;
}
interface PageRequest {
    key?: Binary$1 | null;
    limit: number;
    reverse: boolean;
}
interface ModuleQuery {
    msg: Binary$1;
    target_module: InstalledModuleIdentification;
}
interface InstalledModuleIdentification {
    account_id?: AccountId | null;
    module_info: ModuleInfo;
}
interface AccountId {
    seq: number;
    trace: AccountTrace;
}
interface GrpcQuery {
    data: Binary$1;
    path: string;
}
interface Coin$1 {
    amount: Uint128$1;
    denom: string;
}
interface Empty$1 {
}
interface AnyMsg$1 {
    type_url: string;
    value: Binary$1;
}
interface IbcTimeout$1 {
    block?: IbcTimeoutBlock$1 | null;
    timestamp?: Timestamp$1 | null;
}
interface IbcTimeoutBlock$1 {
    height: number;
    revision: number;
}
interface WeightedVoteOption$1 {
    option: VoteOption$1;
    weight: Decimal$1;
}
interface CallbackMessage {
    initiator: Addr$1;
    initiator_msg: Binary$1;
    result: Callback2;
}
interface ErrorResponse {
    error: string;
    message_index: Uint64$1;
}
interface ExecutionResponse {
    executed_by: string;
    result: SubMsgResponse[];
}
interface SubMsgResponse {
    data?: Binary$1 | null;
    events: Event[];
    msg_responses?: MsgResponse[];
}
interface Event {
    attributes: Attribute[];
    type: string;
}
interface Attribute {
    key: string;
    value: string;
}
interface MsgResponse {
    type_url: string;
    value: Binary$1;
}
type QueryMsg$1 = {
    ownership: {};
} | {
    config: {};
} | {
    host: {
        chain_name: TruncatedChainId$1;
    };
} | {
    list_accounts: {
        limit?: number | null;
        start?: [AccountId, string] | null;
    };
} | {
    account: {
        account_id: AccountId;
        chain_name: TruncatedChainId$1;
    };
} | {
    list_remote_hosts: {};
} | {
    list_remote_proxies: {};
} | {
    list_remote_accounts_by_account_id: {
        account_id: AccountId;
    };
} | {
    list_ibc_infrastructures: {};
};
interface MigrateMsg$1 {
}
interface AccountResponse {
    remote_account_addr?: string | null;
}
interface ConfigResponse$1 {
    ans_host: Addr$1;
    registry_address: Addr$1;
}
interface HostResponse {
    remote_host: string;
    remote_polytone_proxy?: string | null;
}
interface ListAccountsResponse {
    accounts: [AccountId, TruncatedChainId$1, string][];
}
interface ListIbcInfrastructureResponse {
    counterparts: [TruncatedChainId$1, IbcInfrastructure][];
}
interface IbcInfrastructure {
    polytone_note: Addr$1;
    remote_abstract_host: string;
    remote_proxy?: string | null;
}
interface ListRemoteAccountsResponse {
    accounts: [TruncatedChainId$1, string | null][];
}
interface ListRemoteHostsResponse {
    hosts: [TruncatedChainId$1, string][];
}
interface OwnershipForAddr {
    owner?: Addr$1 | null;
    pending_expiry?: Expiration$1 | null;
    pending_owner?: Addr$1 | null;
}

type IbcClient_types_AccountId = AccountId;
type IbcClient_types_AccountResponse = AccountResponse;
type IbcClient_types_AccountTrace = AccountTrace;
type IbcClient_types_Attribute = Attribute;
type IbcClient_types_BankQuery = BankQuery;
type IbcClient_types_Callback = Callback;
type IbcClient_types_Callback2 = Callback2;
type IbcClient_types_CallbackMessage = CallbackMessage;
type IbcClient_types_DistributionQuery = DistributionQuery;
type IbcClient_types_ErrorResponse = ErrorResponse;
type IbcClient_types_Event = Event;
type IbcClient_types_ExecuteMsgForEmpty = ExecuteMsgForEmpty;
type IbcClient_types_ExecutionResponse = ExecutionResponse;
type IbcClient_types_GovAction = GovAction;
type IbcClient_types_GovernanceDetailsForString = GovernanceDetailsForString;
type IbcClient_types_GrpcQuery = GrpcQuery;
type IbcClient_types_HelperAction = HelperAction;
type IbcClient_types_HostAction = HostAction;
type IbcClient_types_HostResponse = HostResponse;
type IbcClient_types_IbcInfrastructure = IbcInfrastructure;
type IbcClient_types_IbcQuery = IbcQuery;
type IbcClient_types_InstalledModuleIdentification = InstalledModuleIdentification;
type IbcClient_types_InternalAction = InternalAction;
type IbcClient_types_InternalConfigAction = InternalConfigAction;
type IbcClient_types_ListAccountsResponse = ListAccountsResponse;
type IbcClient_types_ListIbcInfrastructureResponse = ListIbcInfrastructureResponse;
type IbcClient_types_ListRemoteAccountsResponse = ListRemoteAccountsResponse;
type IbcClient_types_ListRemoteHostsResponse = ListRemoteHostsResponse;
type IbcClient_types_ModuleInfo = ModuleInfo;
type IbcClient_types_ModuleInstallConfig = ModuleInstallConfig;
type IbcClient_types_ModuleQuery = ModuleQuery;
type IbcClient_types_ModuleVersion = ModuleVersion;
type IbcClient_types_MsgResponse = MsgResponse;
type IbcClient_types_Namespace = Namespace;
type IbcClient_types_OwnershipForAddr = OwnershipForAddr;
type IbcClient_types_PageRequest = PageRequest;
type IbcClient_types_QueryRequestForModuleQuery = QueryRequestForModuleQuery;
type IbcClient_types_ResultOfArrayOfBinaryOrErrorResponse = ResultOfArrayOfBinaryOrErrorResponse;
type IbcClient_types_ResultOfExecutionResponseOrString = ResultOfExecutionResponseOrString;
type IbcClient_types_StakingQuery = StakingQuery;
type IbcClient_types_SubMsgResponse = SubMsgResponse;
type IbcClient_types_UpdateSubAccountAction = UpdateSubAccountAction;
type IbcClient_types_WasmQuery = WasmQuery;
declare namespace IbcClient_types {
  export type { IbcClient_types_AccountId as AccountId, IbcClient_types_AccountResponse as AccountResponse, IbcClient_types_AccountTrace as AccountTrace, Action$1 as Action, Addr$1 as Addr, AnyMsg$1 as AnyMsg, IbcClient_types_Attribute as Attribute, BankMsg$1 as BankMsg, IbcClient_types_BankQuery as BankQuery, Binary$1 as Binary, IbcClient_types_Callback as Callback, IbcClient_types_Callback2 as Callback2, IbcClient_types_CallbackMessage as CallbackMessage, Coin$1 as Coin, ConfigResponse$1 as ConfigResponse, CosmosMsgForEmpty$1 as CosmosMsgForEmpty, Decimal$1 as Decimal, DistributionMsg$1 as DistributionMsg, IbcClient_types_DistributionQuery as DistributionQuery, Empty$1 as Empty, IbcClient_types_ErrorResponse as ErrorResponse, IbcClient_types_Event as Event, ExecuteMsg$1 as ExecuteMsg, IbcClient_types_ExecuteMsgForEmpty as ExecuteMsgForEmpty, IbcClient_types_ExecutionResponse as ExecutionResponse, Expiration$1 as Expiration, IbcClient_types_GovAction as GovAction, GovMsg$1 as GovMsg, IbcClient_types_GovernanceDetailsForString as GovernanceDetailsForString, IbcClient_types_GrpcQuery as GrpcQuery, IbcClient_types_HelperAction as HelperAction, IbcClient_types_HostAction as HostAction, IbcClient_types_HostResponse as HostResponse, IbcClient_types_IbcInfrastructure as IbcInfrastructure, IbcMsg$1 as IbcMsg, IbcClient_types_IbcQuery as IbcQuery, IbcTimeout$1 as IbcTimeout, IbcTimeoutBlock$1 as IbcTimeoutBlock, IbcClient_types_InstalledModuleIdentification as InstalledModuleIdentification, InstantiateMsg$1 as InstantiateMsg, IbcClient_types_InternalAction as InternalAction, IbcClient_types_InternalConfigAction as InternalConfigAction, IbcClient_types_ListAccountsResponse as ListAccountsResponse, IbcClient_types_ListIbcInfrastructureResponse as ListIbcInfrastructureResponse, IbcClient_types_ListRemoteAccountsResponse as ListRemoteAccountsResponse, IbcClient_types_ListRemoteHostsResponse as ListRemoteHostsResponse, MigrateMsg$1 as MigrateMsg, IbcClient_types_ModuleInfo as ModuleInfo, IbcClient_types_ModuleInstallConfig as ModuleInstallConfig, IbcClient_types_ModuleQuery as ModuleQuery, IbcClient_types_ModuleVersion as ModuleVersion, IbcClient_types_MsgResponse as MsgResponse, IbcClient_types_Namespace as Namespace, IbcClient_types_OwnershipForAddr as OwnershipForAddr, IbcClient_types_PageRequest as PageRequest, QueryMsg$1 as QueryMsg, IbcClient_types_QueryRequestForModuleQuery as QueryRequestForModuleQuery, IbcClient_types_ResultOfArrayOfBinaryOrErrorResponse as ResultOfArrayOfBinaryOrErrorResponse, IbcClient_types_ResultOfExecutionResponseOrString as ResultOfExecutionResponseOrString, StakingMsg$1 as StakingMsg, IbcClient_types_StakingQuery as StakingQuery, IbcClient_types_SubMsgResponse as SubMsgResponse, Timestamp$1 as Timestamp, TruncatedChainId$1 as TruncatedChainId, Uint128$1 as Uint128, Uint64$1 as Uint64, IbcClient_types_UpdateSubAccountAction as UpdateSubAccountAction, VoteOption$1 as VoteOption, WasmMsg$1 as WasmMsg, IbcClient_types_WasmQuery as WasmQuery, WeightedVoteOption$1 as WeightedVoteOption };
}

/**
* This file was automatically generated by @abstract-money/ts-codegen@0.37.0-beta-3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/

interface IbcClientReadOnlyInterface {
    contractAddress: string;
    ownership: () => Promise<OwnershipForAddr>;
    config: () => Promise<ConfigResponse$1>;
    host: ({ chainName }: {
        chainName: TruncatedChainId$1;
    }) => Promise<HostResponse>;
    listAccounts: ({ limit, start }: {
        limit?: number;
        start?: AccountId[][];
    }) => Promise<ListAccountsResponse>;
    account: ({ accountId, chainName }: {
        accountId: AccountId;
        chainName: TruncatedChainId$1;
    }) => Promise<AccountResponse>;
    listRemoteHosts: () => Promise<ListRemoteHostsResponse>;
    listRemoteProxies: () => Promise<ListRemoteAccountsResponse>;
    listRemoteAccountsByAccountId: ({ accountId }: {
        accountId: AccountId;
    }) => Promise<ListRemoteAccountsResponse>;
    listIbcInfrastructures: () => Promise<ListIbcInfrastructureResponse>;
}
declare class IbcClientQueryClient implements IbcClientReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;
    constructor(client: CosmWasmClient, contractAddress: string);
    ownership: () => Promise<OwnershipForAddr>;
    config: () => Promise<ConfigResponse$1>;
    host: ({ chainName }: {
        chainName: TruncatedChainId$1;
    }) => Promise<HostResponse>;
    listAccounts: ({ limit, start }: {
        limit?: number | undefined;
        start?: AccountId[][] | undefined;
    }) => Promise<ListAccountsResponse>;
    account: ({ accountId, chainName }: {
        accountId: AccountId;
        chainName: TruncatedChainId$1;
    }) => Promise<AccountResponse>;
    listRemoteHosts: () => Promise<ListRemoteHostsResponse>;
    listRemoteProxies: () => Promise<ListRemoteAccountsResponse>;
    listRemoteAccountsByAccountId: ({ accountId }: {
        accountId: AccountId;
    }) => Promise<ListRemoteAccountsResponse>;
    listIbcInfrastructures: () => Promise<ListIbcInfrastructureResponse>;
}
interface IbcClientInterface extends IbcClientReadOnlyInterface {
    contractAddress: string;
    sender: string;
    updateOwnership: (action: Action$1, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    registerInfrastructure: ({ chain, host, note }: {
        chain: TruncatedChainId$1;
        host: string;
        note: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    sendFunds: ({ hostChain, memo, receiver }: {
        hostChain: TruncatedChainId$1;
        memo?: string;
        receiver?: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    sendFundsWithActions: ({ actions, hostChain }: {
        actions: Binary$1[];
        hostChain: TruncatedChainId$1;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    register: ({ hostChain, installModules, namespace }: {
        hostChain: TruncatedChainId$1;
        installModules: ModuleInstallConfig[];
        namespace?: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    moduleIbcAction: ({ callback, hostChain, msg, targetModule }: {
        callback?: Callback;
        hostChain: TruncatedChainId$1;
        msg: Binary$1;
        targetModule: ModuleInfo;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    ibcQuery: ({ callback, hostChain, queries }: {
        callback: Callback;
        hostChain: TruncatedChainId$1;
        queries: QueryRequestForModuleQuery[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    remoteAction: ({ action, hostChain }: {
        action: HostAction;
        hostChain: TruncatedChainId$1;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    removeHost: ({ hostChain }: {
        hostChain: TruncatedChainId$1;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    callback: ({ initiator, initiatorMsg, result }: {
        initiator: Addr$1;
        initiatorMsg: Binary$1;
        result: Callback2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
}
declare class IbcClientClient extends IbcClientQueryClient implements IbcClientInterface {
    client: SigningCosmWasmClient;
    sender: string;
    contractAddress: string;
    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string);
    updateOwnership: (action: Action$1, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    registerInfrastructure: ({ chain, host, note }: {
        chain: TruncatedChainId$1;
        host: string;
        note: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    sendFunds: ({ hostChain, memo, receiver }: {
        hostChain: TruncatedChainId$1;
        memo?: string | undefined;
        receiver?: string | undefined;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    sendFundsWithActions: ({ actions, hostChain }: {
        actions: Binary$1[];
        hostChain: TruncatedChainId$1;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    register: ({ hostChain, installModules, namespace }: {
        hostChain: TruncatedChainId$1;
        installModules: ModuleInstallConfig[];
        namespace?: string | undefined;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    moduleIbcAction: ({ callback, hostChain, msg, targetModule }: {
        callback?: Callback | undefined;
        hostChain: TruncatedChainId$1;
        msg: Binary$1;
        targetModule: ModuleInfo;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    ibcQuery: ({ callback, hostChain, queries }: {
        callback: Callback;
        hostChain: TruncatedChainId$1;
        queries: QueryRequestForModuleQuery[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    remoteAction: ({ action, hostChain }: {
        action: HostAction;
        hostChain: TruncatedChainId$1;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    removeHost: ({ hostChain }: {
        hostChain: TruncatedChainId$1;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
    callback: ({ initiator, initiatorMsg, result }: {
        initiator: Addr$1;
        initiatorMsg: Binary$1;
        result: Callback2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$1[]) => Promise<ExecuteResult>;
}

/**
* This file was automatically generated by @abstract-money/ts-codegen@0.37.0-beta-3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/
interface InstantiateMsg {
    ans_host_address: string;
    registry_address: string;
}
type ExecuteMsg = {
    update_ownership: Action;
};
type Action = {
    transfer_ownership: {
        expiry?: Expiration | null;
        new_owner: string;
    };
} | "accept_ownership" | "renounce_ownership";
type Expiration = {
    at_height: number;
} | {
    at_time: Timestamp;
} | {
    never: {};
};
type Timestamp = Uint64;
type Uint64 = string;
type QueryMsg = {
    config: {};
} | {
    ica_action: {
        account_address: string;
        actions: IcaAction[];
        chain: TruncatedChainId;
    };
} | {
    ownership: {};
};
type IcaAction = {
    execute: IcaExecute;
} | {
    fund: {
        funds: Coin[];
        memo?: string | null;
        receiver?: Binary | null;
    };
};
type IcaExecute = {
    evm: {
        callback?: CallbackRequest | null;
        msgs: EvmMsgForString[];
    };
};
type Binary = string;
type EvmMsgForString = {
    call: {
        allow_failure?: boolean | null;
        data: HexBinary;
        to: string;
        value?: Uint128 | null;
    };
} | {
    delegate_call: {
        allow_failure?: boolean | null;
        data: HexBinary;
        to: string;
        value?: Uint128 | null;
    };
};
type HexBinary = string;
type Uint128 = string;
type TruncatedChainId = string;
interface CallbackRequest {
    msg: Binary;
    receiver: string;
}
interface Coin {
    amount: Uint128;
    denom: string;
}
type MigrateMsg = {
    instantiate: InstantiateMsg;
} | {
    migrate: {};
};
type Addr = string;
interface ConfigResponse {
    ans_host: Addr;
    registry_address: Addr;
}
type CosmosMsgForEmpty = {
    bank: BankMsg;
} | {
    custom: Empty;
} | {
    staking: StakingMsg;
} | {
    distribution: DistributionMsg;
} | {
    stargate: {
        type_url: string;
        value: Binary;
    };
} | {
    any: AnyMsg;
} | {
    ibc: IbcMsg;
} | {
    wasm: WasmMsg;
} | {
    gov: GovMsg;
};
type BankMsg = {
    send: {
        amount: Coin[];
        to_address: string;
    };
} | {
    burn: {
        amount: Coin[];
    };
};
type StakingMsg = {
    delegate: {
        amount: Coin;
        validator: string;
    };
} | {
    undelegate: {
        amount: Coin;
        validator: string;
    };
} | {
    redelegate: {
        amount: Coin;
        dst_validator: string;
        src_validator: string;
    };
};
type DistributionMsg = {
    set_withdraw_address: {
        address: string;
    };
} | {
    withdraw_delegator_reward: {
        validator: string;
    };
} | {
    fund_community_pool: {
        amount: Coin[];
    };
};
type IbcMsg = {
    transfer: {
        amount: Coin;
        channel_id: string;
        memo?: string | null;
        timeout: IbcTimeout;
        to_address: string;
    };
} | {
    send_packet: {
        channel_id: string;
        data: Binary;
        timeout: IbcTimeout;
    };
} | {
    close_channel: {
        channel_id: string;
    };
};
type WasmMsg = {
    execute: {
        contract_addr: string;
        funds: Coin[];
        msg: Binary;
    };
} | {
    instantiate: {
        admin?: string | null;
        code_id: number;
        funds: Coin[];
        label: string;
        msg: Binary;
    };
} | {
    instantiate2: {
        admin?: string | null;
        code_id: number;
        funds: Coin[];
        label: string;
        msg: Binary;
        salt: Binary;
    };
} | {
    migrate: {
        contract_addr: string;
        msg: Binary;
        new_code_id: number;
    };
} | {
    update_admin: {
        admin: string;
        contract_addr: string;
    };
} | {
    clear_admin: {
        contract_addr: string;
    };
};
type GovMsg = {
    vote: {
        option: VoteOption;
        proposal_id: number;
    };
} | {
    vote_weighted: {
        options: WeightedVoteOption[];
        proposal_id: number;
    };
};
type VoteOption = "yes" | "no" | "abstain" | "no_with_veto";
type Decimal = string;
interface IcaActionResult {
    msgs: CosmosMsgForEmpty[];
}
interface Empty {
}
interface AnyMsg {
    type_url: string;
    value: Binary;
}
interface IbcTimeout {
    block?: IbcTimeoutBlock | null;
    timestamp?: Timestamp | null;
}
interface IbcTimeoutBlock {
    height: number;
    revision: number;
}
interface WeightedVoteOption {
    option: VoteOption;
    weight: Decimal;
}
interface OwnershipForString {
    owner?: string | null;
    pending_expiry?: Expiration | null;
    pending_owner?: string | null;
}

type IcaClient_types_Action = Action;
type IcaClient_types_Addr = Addr;
type IcaClient_types_AnyMsg = AnyMsg;
type IcaClient_types_BankMsg = BankMsg;
type IcaClient_types_Binary = Binary;
type IcaClient_types_CallbackRequest = CallbackRequest;
type IcaClient_types_Coin = Coin;
type IcaClient_types_ConfigResponse = ConfigResponse;
type IcaClient_types_CosmosMsgForEmpty = CosmosMsgForEmpty;
type IcaClient_types_Decimal = Decimal;
type IcaClient_types_DistributionMsg = DistributionMsg;
type IcaClient_types_Empty = Empty;
type IcaClient_types_EvmMsgForString = EvmMsgForString;
type IcaClient_types_ExecuteMsg = ExecuteMsg;
type IcaClient_types_Expiration = Expiration;
type IcaClient_types_GovMsg = GovMsg;
type IcaClient_types_HexBinary = HexBinary;
type IcaClient_types_IbcMsg = IbcMsg;
type IcaClient_types_IbcTimeout = IbcTimeout;
type IcaClient_types_IbcTimeoutBlock = IbcTimeoutBlock;
type IcaClient_types_IcaAction = IcaAction;
type IcaClient_types_IcaActionResult = IcaActionResult;
type IcaClient_types_IcaExecute = IcaExecute;
type IcaClient_types_InstantiateMsg = InstantiateMsg;
type IcaClient_types_MigrateMsg = MigrateMsg;
type IcaClient_types_OwnershipForString = OwnershipForString;
type IcaClient_types_QueryMsg = QueryMsg;
type IcaClient_types_StakingMsg = StakingMsg;
type IcaClient_types_Timestamp = Timestamp;
type IcaClient_types_TruncatedChainId = TruncatedChainId;
type IcaClient_types_Uint128 = Uint128;
type IcaClient_types_Uint64 = Uint64;
type IcaClient_types_VoteOption = VoteOption;
type IcaClient_types_WasmMsg = WasmMsg;
type IcaClient_types_WeightedVoteOption = WeightedVoteOption;
declare namespace IcaClient_types {
  export type { IcaClient_types_Action as Action, IcaClient_types_Addr as Addr, IcaClient_types_AnyMsg as AnyMsg, IcaClient_types_BankMsg as BankMsg, IcaClient_types_Binary as Binary, IcaClient_types_CallbackRequest as CallbackRequest, IcaClient_types_Coin as Coin, IcaClient_types_ConfigResponse as ConfigResponse, IcaClient_types_CosmosMsgForEmpty as CosmosMsgForEmpty, IcaClient_types_Decimal as Decimal, IcaClient_types_DistributionMsg as DistributionMsg, IcaClient_types_Empty as Empty, IcaClient_types_EvmMsgForString as EvmMsgForString, IcaClient_types_ExecuteMsg as ExecuteMsg, IcaClient_types_Expiration as Expiration, IcaClient_types_GovMsg as GovMsg, IcaClient_types_HexBinary as HexBinary, IcaClient_types_IbcMsg as IbcMsg, IcaClient_types_IbcTimeout as IbcTimeout, IcaClient_types_IbcTimeoutBlock as IbcTimeoutBlock, IcaClient_types_IcaAction as IcaAction, IcaClient_types_IcaActionResult as IcaActionResult, IcaClient_types_IcaExecute as IcaExecute, IcaClient_types_InstantiateMsg as InstantiateMsg, IcaClient_types_MigrateMsg as MigrateMsg, IcaClient_types_OwnershipForString as OwnershipForString, IcaClient_types_QueryMsg as QueryMsg, IcaClient_types_StakingMsg as StakingMsg, IcaClient_types_Timestamp as Timestamp, IcaClient_types_TruncatedChainId as TruncatedChainId, IcaClient_types_Uint128 as Uint128, IcaClient_types_Uint64 as Uint64, IcaClient_types_VoteOption as VoteOption, IcaClient_types_WasmMsg as WasmMsg, IcaClient_types_WeightedVoteOption as WeightedVoteOption };
}

/**
* This file was automatically generated by @abstract-money/ts-codegen@0.37.0-beta-3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/

interface IcaClientReadOnlyInterface {
    contractAddress: string;
    config: () => Promise<ConfigResponse>;
    icaAction: ({ accountAddress, actions, chain }: {
        accountAddress: string;
        actions: IcaAction[];
        chain: TruncatedChainId;
    }) => Promise<IcaActionResult>;
    ownership: () => Promise<OwnershipForString>;
}
declare class IcaClientQueryClient implements IcaClientReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;
    constructor(client: CosmWasmClient, contractAddress: string);
    config: () => Promise<ConfigResponse>;
    icaAction: ({ accountAddress, actions, chain }: {
        accountAddress: string;
        actions: IcaAction[];
        chain: TruncatedChainId;
    }) => Promise<IcaActionResult>;
    ownership: () => Promise<OwnershipForString>;
}
interface IcaClientInterface extends IcaClientReadOnlyInterface {
    contractAddress: string;
    sender: string;
    updateOwnership: (action: Action, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
declare class IcaClientClient extends IcaClientQueryClient implements IcaClientInterface {
    client: SigningCosmWasmClient;
    sender: string;
    contractAddress: string;
    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string);
    updateOwnership: (action: Action, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}

/**
* This file was automatically generated by @abstract-money/ts-codegen@0.37.0-beta-3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @abstract-money/ts-codegen generate command to regenerate this file.
*/

interface RegistryReadOnlyInterface {
    contractAddress: string;
    accounts: ({ accountIds }: {
        accountIds: AccountId$1[];
    }) => Promise<AccountsResponse>;
    modules: ({ infos }: {
        infos: ModuleInfo$2[];
    }) => Promise<ModulesResponse>;
    namespaces: ({ accounts }: {
        accounts: AccountId$1[];
    }) => Promise<NamespacesResponse>;
    namespace: ({ namespace }: {
        namespace: Namespace$1;
    }) => Promise<NamespaceResponse>;
    config: () => Promise<ConfigResponse$4>;
    accountList: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: AccountId$1;
    }) => Promise<AccountListResponse>;
    moduleList: ({ filter, limit, startAfter }: {
        filter?: ModuleFilter;
        limit?: number;
        startAfter?: ModuleInfo$2;
    }) => Promise<ModulesListResponse>;
    namespaceList: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<NamespaceListResponse>;
    ownership: () => Promise<OwnershipForString$3>;
}
declare class RegistryQueryClient implements RegistryReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;
    constructor(client: CosmWasmClient, contractAddress: string);
    accounts: ({ accountIds }: {
        accountIds: AccountId$1[];
    }) => Promise<AccountsResponse>;
    modules: ({ infos }: {
        infos: ModuleInfo$2[];
    }) => Promise<ModulesResponse>;
    namespaces: ({ accounts }: {
        accounts: AccountId$1[];
    }) => Promise<NamespacesResponse>;
    namespace: ({ namespace }: {
        namespace: Namespace$1;
    }) => Promise<NamespaceResponse>;
    config: () => Promise<ConfigResponse$4>;
    accountList: ({ limit, startAfter }: {
        limit?: number | undefined;
        startAfter?: AccountId$1 | undefined;
    }) => Promise<AccountListResponse>;
    moduleList: ({ filter, limit, startAfter }: {
        filter?: ModuleFilter | undefined;
        limit?: number | undefined;
        startAfter?: ModuleInfo$2 | undefined;
    }) => Promise<ModulesListResponse>;
    namespaceList: ({ limit, startAfter }: {
        limit?: number | undefined;
        startAfter?: string | undefined;
    }) => Promise<NamespaceListResponse>;
    ownership: () => Promise<OwnershipForString$3>;
}
interface RegistryInterface extends RegistryReadOnlyInterface {
    contractAddress: string;
    sender: string;
    removeModule: ({ module }: {
        module: ModuleInfo$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    yankModule: ({ module }: {
        module: ModuleInfo$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    proposeModules: ({ modules }: {
        modules: ModuleInfo$2[][];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    updateModuleConfiguration: ({ moduleName, namespace, updateModule }: {
        moduleName: string;
        namespace: Namespace$1;
        updateModule: UpdateModule;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    approveOrRejectModules: ({ approves, rejects }: {
        approves: ModuleInfo$2[];
        rejects: ModuleInfo$2[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    claimNamespace: ({ accountId, namespace }: {
        accountId: AccountId$1;
        namespace: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    forgoNamespace: ({ namespaces }: {
        namespaces: string[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    addAccount: ({ creator, namespace }: {
        creator: string;
        namespace?: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    updateConfig: ({ namespaceRegistrationFee, securityEnabled }: {
        namespaceRegistrationFee?: ClearableForCoin;
        securityEnabled?: boolean;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    updateOwnership: (action: Action$3, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
}
declare class RegistryClient extends RegistryQueryClient implements RegistryInterface {
    client: SigningCosmWasmClient;
    sender: string;
    contractAddress: string;
    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string);
    removeModule: ({ module }: {
        module: ModuleInfo$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    yankModule: ({ module }: {
        module: ModuleInfo$2;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    proposeModules: ({ modules }: {
        modules: ModuleInfo$2[][];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    updateModuleConfiguration: ({ moduleName, namespace, updateModule }: {
        moduleName: string;
        namespace: Namespace$1;
        updateModule: UpdateModule;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    approveOrRejectModules: ({ approves, rejects }: {
        approves: ModuleInfo$2[];
        rejects: ModuleInfo$2[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    claimNamespace: ({ accountId, namespace }: {
        accountId: AccountId$1;
        namespace: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    forgoNamespace: ({ namespaces }: {
        namespaces: string[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    addAccount: ({ creator, namespace }: {
        creator: string;
        namespace?: string | undefined;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    updateConfig: ({ namespaceRegistrationFee, securityEnabled }: {
        namespaceRegistrationFee?: ClearableForCoin | undefined;
        securityEnabled?: boolean | undefined;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
    updateOwnership: (action: Action$3, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin$4[]) => Promise<ExecuteResult>;
}

export { type Action$2 as A, type Binary$1 as B, type Coin$1 as C, type IbcClientReadOnlyInterface as D, type ExecuteMsg$2 as E, type IbcClientInterface as F, IbcClientClient as G, type HostAction as H, IbcClientQueryClient as I, type IcaClientReadOnlyInterface as J, type IcaClientInterface as K, IcaClientClient as L, type ModuleInstallConfig as M, RegistryQueryClient as N, type RegistryInterface as O, type PoolAddressBaseForString as P, type QueryMsg$2 as Q, type RegistryReadOnlyInterface as R, RegistryClient as S, type TruncatedChainId$1 as T, type UncheckedContractEntry as U, type AssetInfoBaseForAddr as V, type ChannelEntry as W, type ContractEntry as X, IcaClientQueryClient as a, type UncheckedChannelEntry as b, type UniquePoolId as c, type Action$1 as d, type ExecuteMsg$1 as e, type QueryMsg$1 as f, type Callback as g, type ModuleInfo as h, type QueryRequestForModuleQuery as i, type Addr$1 as j, type Callback2 as k, type Action as l, type ExecuteMsg as m, type QueryMsg as n, type Coin as o, AnsHost_types as p, IbcClient_types as q, IcaClient_types as r, type AccountReadOnlyInterface as s, AccountQueryClient as t, type AccountInterface as u, AccountClient as v, type AnsHostReadOnlyInterface as w, AnsHostQueryClient as x, type AnsHostInterface as y, AnsHostClient as z };
