import type { BiMapContext, BiMapNonEmptyImpl } from '@rimbu/bimap/custom';
import type { BiMap } from '@rimbu/bimap';
import type { RMap } from '@rimbu/collection-types/map';
import { OptLazy, type RelatedTo, TraverseState } from '@rimbu/common';
import { type StreamSource } from '@rimbu/stream';
export declare class BiMapBuilder<K, V> implements BiMap.Builder<K, V> {
    readonly context: BiMapContext<K, V>;
    source?: BiMapNonEmptyImpl<K, V> | undefined;
    constructor(context: BiMapContext<K, V>, source?: BiMapNonEmptyImpl<K, V> | undefined);
    _keyValueMap?: RMap.Builder<K, V>;
    _valueKeyMap?: RMap.Builder<V, K>;
    _lock: number;
    checkLock(): void;
    get keyValueMap(): RMap.Builder<K, V>;
    get valueKeyMap(): RMap.Builder<V, K>;
    get size(): number;
    get isEmpty(): boolean;
    getValue: <UK, O>(key: RelatedTo<K, UK>, otherwise?: OptLazy<O> | undefined) => V | O;
    hasKey: <UK>(key: RelatedTo<K, UK>) => boolean;
    getKey: <UV, O>(value: RelatedTo<V, UV>, otherwise?: OptLazy<O> | undefined) => K | O;
    hasValue: <UV>(value: RelatedTo<V, UV>) => boolean;
    set: (key: K, value: V) => boolean;
    addEntry: (entry: readonly [K, V]) => boolean;
    addEntries: (source: StreamSource<readonly [K, V]>) => boolean;
    removeKey: <UK, O>(key: RelatedTo<K, UK>, otherwise?: OptLazy<O> | undefined) => V | O;
    removeKeys: <UK>(keys: StreamSource<RelatedTo<K, UK>>) => boolean;
    removeValue: <UV, O>(value: RelatedTo<V, UV>, otherwise?: OptLazy<O> | undefined) => K | O;
    removeValues: <UV>(values: StreamSource<RelatedTo<V, UV>>) => boolean;
    forEach: (f: (entry: readonly [K, V], index: number, halt: () => void) => void, state?: TraverseState) => void;
    build: () => BiMap<K, V>;
}
