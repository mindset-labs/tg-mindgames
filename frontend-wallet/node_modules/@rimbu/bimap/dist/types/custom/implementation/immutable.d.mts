import type { BiMapContext } from '@rimbu/bimap/custom';
import type { BiMap } from '@rimbu/bimap';
import type { RMap } from '@rimbu/collection-types/map';
import { EmptyBase, NonEmptyBase } from '@rimbu/collection-types/map-custom';
import { type ArrayNonEmpty, OptLazy, type RelatedTo, type ToJSON, TraverseState, Update } from '@rimbu/common';
import { Stream, type StreamSource } from '@rimbu/stream';
export declare class BiMapEmpty<K = any, V = any> extends EmptyBase implements BiMap<K, V> {
    readonly context: BiMapContext<K, V>;
    constructor(context: BiMapContext<K, V>);
    get size(): 0;
    get keyValueMap(): RMap<K, V>;
    get valueKeyMap(): RMap<V, K>;
    hasKey(): false;
    hasValue(): false;
    getValue<_, O>(key: K, otherwise?: OptLazy<O>): O;
    getKey<_, O>(value: V, otherwise?: OptLazy<O>): O;
    set(key: K, value: V): BiMap.NonEmpty<K, V>;
    addEntry(entry: readonly [K, V]): BiMap.NonEmpty<K, V>;
    addEntries(entries: StreamSource<readonly [K, V]>): BiMap.NonEmpty<K, V>;
    removeKey(): this;
    removeKeyAndGet(): undefined;
    removeKeys(): this;
    removeValue(): this;
    removeValueAndGet(): undefined;
    removeValues(): this;
    updateKeyAtValue(): this;
    updateValueAtKey(): this;
    streamKeys(): Stream<K>;
    streamValues(): Stream<V>;
    toBuilder(): BiMap.Builder<K, V>;
    toString(): string;
    toJSON(): ToJSON<(readonly [K, V])[], this['context']['typeTag']>;
}
export declare class BiMapNonEmptyImpl<K, V> extends NonEmptyBase<readonly [K, V]> implements BiMap.NonEmpty<K, V> {
    readonly context: BiMapContext<K, V>;
    readonly keyValueMap: RMap.NonEmpty<K, V>;
    readonly valueKeyMap: RMap.NonEmpty<V, K>;
    constructor(context: BiMapContext<K, V>, keyValueMap: RMap.NonEmpty<K, V>, valueKeyMap: RMap.NonEmpty<V, K>);
    copy(keyValueMap?: RMap.NonEmpty<K, V>, valueKeyMap?: RMap.NonEmpty<V, K>): BiMap.NonEmpty<K, V>;
    copyE(keyValueMap?: RMap<K, V>, valueKeyMap?: RMap<V, K>): BiMap<K, V>;
    get size(): number;
    asNormal(): this;
    stream(): Stream.NonEmpty<readonly [K, V]>;
    streamKeys(): Stream.NonEmpty<K>;
    streamValues(): Stream.NonEmpty<V>;
    hasKey<UK>(key: RelatedTo<K, UK>): boolean;
    hasValue<UV>(value: RelatedTo<V, UV>): boolean;
    getValue<UK, O>(key: RelatedTo<K, UK>, otherwise?: OptLazy<O>): V | O;
    getKey<UV, O>(value: RelatedTo<V, UV>, otherwise?: OptLazy<O>): K | O;
    set(key: K, value: V): BiMap.NonEmpty<K, V>;
    addEntry(entry: readonly [K, V]): BiMap.NonEmpty<K, V>;
    addEntries(entries: StreamSource<readonly [K, V]>): BiMap.NonEmpty<K, V>;
    removeKey<UK>(key: RelatedTo<K, UK>): BiMap<K, V>;
    removeKeyAndGet<UK>(key: RelatedTo<K, UK>): [BiMap<K, V>, V] | undefined;
    removeKeys<UK>(keys: Stream<RelatedTo<K, UK>>): BiMap<K, V>;
    removeValue<UV>(value: RelatedTo<V, UV>): BiMap<K, V>;
    removeValueAndGet<UV>(value: RelatedTo<V, UV>): [BiMap<K, V>, K] | undefined;
    removeValues<UV>(values: Stream<RelatedTo<V, UV>>): BiMap<K, V>;
    updateValueAtKey(key: K, valueUpdate: Update<V>): BiMap.NonEmpty<K, V>;
    updateKeyAtValue(keyUpdate: Update<K>, value: V): BiMap.NonEmpty<K, V>;
    forEach(f: (entry: readonly [K, V], index: number, halt: () => void) => void, state?: TraverseState): void;
    filter(pred: (entry: readonly [K, V], index: number, halt: () => void) => boolean): BiMap<K, V>;
    toBuilder(): BiMap.Builder<K, V>;
    toArray(): ArrayNonEmpty<readonly [K, V]>;
    toString(): string;
    toJSON(): ToJSON<(readonly [K, V])[], this['context']['typeTag']>;
}
