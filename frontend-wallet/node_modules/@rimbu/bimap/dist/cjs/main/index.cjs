"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main/index.mts
var main_exports = {};
__export(main_exports, {
  BiMap: () => BiMap
});
module.exports = __toCommonJS(main_exports);

// src/custom/implementation/builder.mts
var import_base = require("@rimbu/base");
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var import_custom = require("@rimbu/stream/custom");
var BiMapBuilder = class {
  constructor(context, source) {
    this.context = context;
    this.source = source;
    this._lock = 0;
    this.getValue = (key, otherwise) => {
      if (void 0 !== this.source)
        return this.source.getValue(key, otherwise);
      return this.keyValueMap.get(key, otherwise);
    };
    // prettier-ignore
    this.hasKey = (key) => {
      const token = Symbol();
      return token !== this.getValue(key, token);
    };
    this.getKey = (value, otherwise) => {
      if (void 0 !== this.source)
        return this.source.getKey(value, otherwise);
      return this.valueKeyMap.get(value, otherwise);
    };
    // prettier-ignore
    this.hasValue = (value) => {
      const token = Symbol();
      return token !== this.getKey(value, token);
    };
    this.set = (key, value) => {
      return this.addEntry([key, value]);
    };
    this.addEntry = (entry) => {
      this.checkLock();
      const [key, value] = entry;
      const token = Symbol();
      const oldValue = this.keyValueMap.get(key, token);
      const oldKey = this.valueKeyMap.get(value, token);
      if (token !== oldKey && token !== oldValue) {
        if (Object.is(oldKey, key) && Object.is(oldValue, value))
          return false;
        this.keyValueMap.removeKey(oldKey);
        this.keyValueMap.addEntry(entry);
        this.valueKeyMap.removeKey(oldValue);
        this.valueKeyMap.set(value, key);
      } else if (token !== oldValue) {
        if (!Object.is(oldValue, value)) {
          this.valueKeyMap.removeKey(oldValue);
          this.valueKeyMap.set(value, key);
        }
        this.keyValueMap.addEntry(entry);
      } else if (token !== oldKey) {
        if (!Object.is(oldKey, key)) {
          this.keyValueMap.removeKey(oldKey);
          this.keyValueMap.addEntry(entry);
        }
        this.valueKeyMap.set(value, key);
      } else {
        this.keyValueMap.addEntry(entry);
        this.valueKeyMap.set(value, key);
      }
      this.source = void 0;
      return true;
    };
    this.addEntries = (source) => {
      this.checkLock();
      return import_stream.Stream.from(source).filterPure(this.addEntry).count() > 0;
    };
    this.removeKey = (key, otherwise) => {
      this.checkLock();
      if (!this.context.keyValueContext.isValidKey(key)) {
        return (0, import_common.OptLazy)(otherwise);
      }
      const token = Symbol();
      const value = this.keyValueMap.removeKey(key, token);
      if (token === value)
        return (0, import_common.OptLazy)(otherwise);
      this.valueKeyMap.removeKey(value);
      this.source = void 0;
      return value;
    };
    // prettier-ignore
    this.removeKeys = (keys) => {
      this.checkLock();
      if ((0, import_custom.isEmptyStreamSourceInstance)(keys))
        return false;
      const notFound = Symbol();
      return import_stream.Stream.from(keys).mapPure(this.removeKey, notFound).countNotElement(notFound) > 0;
    };
    this.removeValue = (value, otherwise) => {
      this.checkLock();
      if (!this.context.valueKeyContext.isValidKey(value)) {
        return (0, import_common.OptLazy)(otherwise);
      }
      const token = Symbol();
      const key = this.valueKeyMap.removeKey(value, token);
      if (token === key)
        return (0, import_common.OptLazy)(otherwise);
      this.keyValueMap.removeKey(key);
      this.source = void 0;
      return key;
    };
    // prettier-ignore
    this.removeValues = (values) => {
      this.checkLock();
      if ((0, import_custom.isEmptyStreamSourceInstance)(values))
        return false;
      const notFound = Symbol();
      return import_stream.Stream.from(values).mapPure(this.removeValue, notFound).countNotElement(notFound) > 0;
    };
    this.forEach = (f, state = (0, import_common.TraverseState)()) => {
      this._lock++;
      if (!this.isEmpty && !state.halted) {
        if (void 0 !== this.source)
          this.source.forEach(f, state);
        else
          this.keyValueMap.forEach(f, state);
      }
      this._lock--;
    };
    this.build = () => {
      if (void 0 !== this.source)
        return this.source;
      if (this.size === 0)
        return this.context.empty();
      return this.context.createNonEmptyImpl(
        this.keyValueMap.build().assumeNonEmpty(),
        this.valueKeyMap.build().assumeNonEmpty()
      );
    };
  }
  checkLock() {
    if (this._lock)
      import_base.RimbuError.throwModifiedBuilderWhileLoopingOverItError();
  }
  get keyValueMap() {
    if (void 0 === this._keyValueMap) {
      if (void 0 === this.source) {
        this._keyValueMap = this.context.keyValueContext.builder();
        this._valueKeyMap = this.context.valueKeyContext.builder();
      } else {
        this._keyValueMap = this.source.keyValueMap.toBuilder();
        this._valueKeyMap = this.source.valueKeyMap.toBuilder();
      }
    }
    return this._keyValueMap;
  }
  get valueKeyMap() {
    if (void 0 === this._valueKeyMap) {
      if (void 0 === this.source) {
        this._keyValueMap = this.context.keyValueContext.builder();
        this._valueKeyMap = this.context.valueKeyContext.builder();
      } else {
        this._keyValueMap = this.source.keyValueMap.toBuilder();
        this._valueKeyMap = this.source.valueKeyMap.toBuilder();
      }
    }
    return this._valueKeyMap;
  }
  get size() {
    return this.source?.size ?? this.keyValueMap.size;
  }
  get isEmpty() {
    return this.size === 0;
  }
};

// src/custom/implementation/immutable.mts
var import_map_custom = require("@rimbu/collection-types/map-custom");
var import_common2 = require("@rimbu/common");
var import_stream2 = require("@rimbu/stream");
var import_custom2 = require("@rimbu/stream/custom");
var BiMapEmpty = class extends import_map_custom.EmptyBase {
  constructor(context) {
    super();
    this.context = context;
  }
  get size() {
    return 0;
  }
  get keyValueMap() {
    return this.context.keyValueContext.empty();
  }
  get valueKeyMap() {
    return this.context.valueKeyContext.empty();
  }
  hasKey() {
    return false;
  }
  hasValue() {
    return false;
  }
  getValue(key, otherwise) {
    return (0, import_common2.OptLazy)(otherwise);
  }
  getKey(value, otherwise) {
    return (0, import_common2.OptLazy)(otherwise);
  }
  set(key, value) {
    return this.addEntry([key, value]);
  }
  addEntry(entry) {
    return new BiMapNonEmptyImpl(
      this.context,
      this.context.keyValueContext.of(entry),
      this.context.valueKeyContext.of([entry[1], entry[0]])
    );
  }
  addEntries(entries) {
    return this.context.from(entries);
  }
  removeKey() {
    return this;
  }
  removeKeyAndGet() {
    return void 0;
  }
  removeKeys() {
    return this;
  }
  removeValue() {
    return this;
  }
  removeValueAndGet() {
    return void 0;
  }
  removeValues() {
    return this;
  }
  updateKeyAtValue() {
    return this;
  }
  updateValueAtKey() {
    return this;
  }
  streamKeys() {
    return import_stream2.Stream.empty();
  }
  streamValues() {
    return import_stream2.Stream.empty();
  }
  toBuilder() {
    return this.context.builder();
  }
  toString() {
    return `BiMap()`;
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: []
    };
  }
};
var BiMapNonEmptyImpl = class _BiMapNonEmptyImpl extends import_map_custom.NonEmptyBase {
  constructor(context, keyValueMap, valueKeyMap) {
    super();
    this.context = context;
    this.keyValueMap = keyValueMap;
    this.valueKeyMap = valueKeyMap;
  }
  copy(keyValueMap = this.keyValueMap, valueKeyMap = this.valueKeyMap) {
    if (keyValueMap === this.keyValueMap && valueKeyMap === this.valueKeyMap)
      return this;
    return new _BiMapNonEmptyImpl(this.context, keyValueMap, valueKeyMap);
  }
  copyE(keyValueMap = this.keyValueMap, valueKeyMap = this.valueKeyMap) {
    if (keyValueMap.nonEmpty() && valueKeyMap.nonEmpty()) {
      return new _BiMapNonEmptyImpl(this.context, keyValueMap, valueKeyMap);
    }
    return this.context.empty();
  }
  get size() {
    return this.keyValueMap.size;
  }
  asNormal() {
    return this;
  }
  stream() {
    return this.keyValueMap.stream();
  }
  streamKeys() {
    return this.keyValueMap.streamKeys();
  }
  streamValues() {
    return this.valueKeyMap.streamKeys();
  }
  hasKey(key) {
    const token = Symbol();
    return token !== this.getValue(key, token);
  }
  hasValue(value) {
    const token = Symbol();
    return token !== this.getKey(value, token);
  }
  getValue(key, otherwise) {
    return this.keyValueMap.get(key, otherwise);
  }
  getKey(value, otherwise) {
    return this.valueKeyMap.get(value, otherwise);
  }
  set(key, value) {
    return this.addEntry([key, value]);
  }
  addEntry(entry) {
    const [key, value] = entry;
    const removeKeyResult = this.keyValueMap.removeKeyAndGet(key);
    const removeValueResult = this.valueKeyMap.removeKeyAndGet(value);
    if (void 0 === removeKeyResult && void 0 === removeValueResult) {
      return this.copy(
        this.keyValueMap.addEntry(entry),
        this.valueKeyMap.set(value, key)
      );
    }
    if (void 0 !== removeKeyResult && void 0 !== removeValueResult) {
      const [removedKeyValueMap, oldValue] = removeKeyResult;
      const [removedValueKeyMap, oldKey] = removeValueResult;
      if (Object.is(oldKey, key) && Object.is(oldValue, value))
        return this;
      const newKeyValueMap2 = removedKeyValueMap.removeKey(oldKey).addEntry(entry);
      const newValueKeyMap2 = removedValueKeyMap.removeKey(oldValue).set(value, key);
      return this.copy(newKeyValueMap2, newValueKeyMap2);
    }
    const newKeyValueMap = (void 0 === removeValueResult ? this.keyValueMap : this.keyValueMap.removeKey(removeValueResult[1])).addEntry(entry);
    const newValueKeyMap = (void 0 === removeKeyResult ? this.valueKeyMap : this.valueKeyMap.removeKey(removeKeyResult[1])).set(value, key);
    return this.copy(newKeyValueMap, newValueKeyMap);
  }
  addEntries(entries) {
    if ((0, import_custom2.isEmptyStreamSourceInstance)(entries))
      return this;
    const builder = this.toBuilder();
    builder.addEntries(entries);
    return builder.build();
  }
  removeKey(key) {
    const removeKeyResult = this.keyValueMap.removeKeyAndGet(key);
    if (void 0 === removeKeyResult)
      return this;
    const [newKeyValueMap, oldValue] = removeKeyResult;
    if (this.size === 1)
      return this.context.empty();
    const newValueKeyMap = this.valueKeyMap.removeKey(oldValue);
    return this.copy(
      newKeyValueMap.assumeNonEmpty(),
      newValueKeyMap.assumeNonEmpty()
    );
  }
  removeKeyAndGet(key) {
    const removeKeyResult = this.keyValueMap.removeKeyAndGet(key);
    if (void 0 === removeKeyResult)
      return void 0;
    const [newKeyValueMap, oldValue] = removeKeyResult;
    if (this.size === 1)
      return [this.context.empty(), oldValue];
    const newValueKeyMap = this.valueKeyMap.removeKey(oldValue);
    return [
      this.copy(
        newKeyValueMap.assumeNonEmpty(),
        newValueKeyMap.assumeNonEmpty()
      ),
      oldValue
    ];
  }
  removeKeys(keys) {
    if ((0, import_custom2.isEmptyStreamSourceInstance)(keys))
      return this;
    const builder = this.toBuilder();
    builder.removeKeys(keys);
    return builder.build();
  }
  removeValue(value) {
    const removeResult = this.valueKeyMap.removeKeyAndGet(value);
    if (void 0 === removeResult)
      return this;
    const [newValueKeyMap, oldKey] = removeResult;
    if (this.size === 1)
      return this.context.empty();
    const newKeyValueMap = this.keyValueMap.removeKey(oldKey);
    return this.copy(
      newKeyValueMap.assumeNonEmpty(),
      newValueKeyMap.assumeNonEmpty()
    );
  }
  removeValueAndGet(value) {
    const removeValueResult = this.valueKeyMap.removeKeyAndGet(value);
    if (void 0 === removeValueResult)
      return void 0;
    const [newValueKeyMap, oldKey] = removeValueResult;
    if (this.size === 1)
      return [this.context.empty(), oldKey];
    const newKeyValueMap = this.keyValueMap.removeKey(oldKey);
    return [
      this.copy(
        newKeyValueMap.assumeNonEmpty(),
        newValueKeyMap.assumeNonEmpty()
      ),
      oldKey
    ];
  }
  removeValues(values) {
    if ((0, import_custom2.isEmptyStreamSourceInstance)(values))
      return this;
    const builder = this.toBuilder();
    builder.removeValues(values);
    return builder.build();
  }
  updateValueAtKey(key, valueUpdate) {
    const token = Symbol();
    const currentValue = this.getValue(key, token);
    if (token === currentValue)
      return this;
    const newValue = (0, import_common2.Update)(currentValue, valueUpdate);
    if (Object.is(newValue, currentValue))
      return this;
    return this.set(key, newValue);
  }
  updateKeyAtValue(keyUpdate, value) {
    const token = Symbol();
    const result = this.getKey(value, token);
    if (token === result)
      return this;
    const newKey = (0, import_common2.Update)(result, keyUpdate);
    if (Object.is(newKey, result))
      return this;
    return this.set(newKey, value);
  }
  forEach(f, state = (0, import_common2.TraverseState)()) {
    if (state.halted)
      return;
    this.keyValueMap.forEach(f, state);
  }
  filter(pred) {
    const builder = this.context.builder();
    builder.addEntries(this.stream().filter(pred));
    if (builder.size === this.size)
      return this;
    return builder.build();
  }
  toBuilder() {
    return this.context.createBuilder(this);
  }
  toArray() {
    return this.keyValueMap.toArray();
  }
  toString() {
    return this.stream().join({
      start: `BiMap(`,
      sep: ", ",
      end: `)`,
      valueToString: (entry) => `${entry[0]} <-> ${entry[1]}`
    });
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: this.toArray()
    };
  }
};

// src/custom/implementation/context.mts
var import_common3 = require("@rimbu/common");
var import_custom4 = require("@rimbu/stream/custom");
var BiMapContext = class {
  constructor(keyValueContext, valueKeyContext) {
    this.keyValueContext = keyValueContext;
    this.valueKeyContext = valueKeyContext;
    this._empty = Object.freeze(
      new BiMapEmpty(this)
    );
    this.empty = () => {
      return this._empty;
    };
    this.of = (...entries) => {
      return this.from(entries);
    };
    this.from = (...sources) => {
      if (sources.length === 1) {
        const source = sources[0];
        if (source instanceof BiMapNonEmptyImpl && source.context === this)
          return source;
      }
      let builder = this.builder();
      let i = -1;
      const length = sources.length;
      while (++i < length) {
        const source = sources[i];
        if ((0, import_custom4.isEmptyStreamSourceInstance)(source))
          continue;
        if (builder.isEmpty && source instanceof BiMapNonEmptyImpl && source.context === this) {
          if (i === length - 1)
            return source;
          builder = source.toBuilder();
          continue;
        }
        builder.addEntries(source);
      }
      return builder.build();
    };
    this.builder = () => {
      return new BiMapBuilder(this);
    };
    this.reducer = (source) => {
      return import_common3.Reducer.create(
        () => void 0 === source ? this.builder() : this.from(source).toBuilder(),
        (builder, entry) => {
          builder.addEntry(entry);
          return builder;
        },
        (builder) => builder.build()
      );
    };
  }
  get typeTag() {
    return "BiMap";
  }
  get _types() {
    return void 0;
  }
  createNonEmptyImpl(keyValueMap, valueKeyMap) {
    return new BiMapNonEmptyImpl(this, keyValueMap, valueKeyMap);
  }
  createBuilder(source) {
    return new BiMapBuilder(this, source);
  }
};

// src/main/interface.mts
var import_hashed = require("@rimbu/hashed");
function createContext(options) {
  return Object.freeze(
    new BiMapContext(
      options?.keyValueContext ?? import_hashed.HashMap.defaultContext(),
      options?.valueKeyContext ?? import_hashed.HashMap.defaultContext()
    )
  );
}
var _defaultContext = createContext();
var BiMap = Object.freeze({
  ..._defaultContext,
  createContext,
  defaultContext() {
    return _defaultContext;
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BiMap
});
