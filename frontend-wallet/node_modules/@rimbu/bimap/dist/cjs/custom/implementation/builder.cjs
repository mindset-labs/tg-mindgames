"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/implementation/builder.mts
var builder_exports = {};
__export(builder_exports, {
  BiMapBuilder: () => BiMapBuilder
});
module.exports = __toCommonJS(builder_exports);
var import_base = require("@rimbu/base");
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var import_custom = require("@rimbu/stream/custom");
var BiMapBuilder = class {
  constructor(context, source) {
    this.context = context;
    this.source = source;
    this._lock = 0;
    this.getValue = (key, otherwise) => {
      if (void 0 !== this.source)
        return this.source.getValue(key, otherwise);
      return this.keyValueMap.get(key, otherwise);
    };
    // prettier-ignore
    this.hasKey = (key) => {
      const token = Symbol();
      return token !== this.getValue(key, token);
    };
    this.getKey = (value, otherwise) => {
      if (void 0 !== this.source)
        return this.source.getKey(value, otherwise);
      return this.valueKeyMap.get(value, otherwise);
    };
    // prettier-ignore
    this.hasValue = (value) => {
      const token = Symbol();
      return token !== this.getKey(value, token);
    };
    this.set = (key, value) => {
      return this.addEntry([key, value]);
    };
    this.addEntry = (entry) => {
      this.checkLock();
      const [key, value] = entry;
      const token = Symbol();
      const oldValue = this.keyValueMap.get(key, token);
      const oldKey = this.valueKeyMap.get(value, token);
      if (token !== oldKey && token !== oldValue) {
        if (Object.is(oldKey, key) && Object.is(oldValue, value))
          return false;
        this.keyValueMap.removeKey(oldKey);
        this.keyValueMap.addEntry(entry);
        this.valueKeyMap.removeKey(oldValue);
        this.valueKeyMap.set(value, key);
      } else if (token !== oldValue) {
        if (!Object.is(oldValue, value)) {
          this.valueKeyMap.removeKey(oldValue);
          this.valueKeyMap.set(value, key);
        }
        this.keyValueMap.addEntry(entry);
      } else if (token !== oldKey) {
        if (!Object.is(oldKey, key)) {
          this.keyValueMap.removeKey(oldKey);
          this.keyValueMap.addEntry(entry);
        }
        this.valueKeyMap.set(value, key);
      } else {
        this.keyValueMap.addEntry(entry);
        this.valueKeyMap.set(value, key);
      }
      this.source = void 0;
      return true;
    };
    this.addEntries = (source) => {
      this.checkLock();
      return import_stream.Stream.from(source).filterPure(this.addEntry).count() > 0;
    };
    this.removeKey = (key, otherwise) => {
      this.checkLock();
      if (!this.context.keyValueContext.isValidKey(key)) {
        return (0, import_common.OptLazy)(otherwise);
      }
      const token = Symbol();
      const value = this.keyValueMap.removeKey(key, token);
      if (token === value)
        return (0, import_common.OptLazy)(otherwise);
      this.valueKeyMap.removeKey(value);
      this.source = void 0;
      return value;
    };
    // prettier-ignore
    this.removeKeys = (keys) => {
      this.checkLock();
      if ((0, import_custom.isEmptyStreamSourceInstance)(keys))
        return false;
      const notFound = Symbol();
      return import_stream.Stream.from(keys).mapPure(this.removeKey, notFound).countNotElement(notFound) > 0;
    };
    this.removeValue = (value, otherwise) => {
      this.checkLock();
      if (!this.context.valueKeyContext.isValidKey(value)) {
        return (0, import_common.OptLazy)(otherwise);
      }
      const token = Symbol();
      const key = this.valueKeyMap.removeKey(value, token);
      if (token === key)
        return (0, import_common.OptLazy)(otherwise);
      this.keyValueMap.removeKey(key);
      this.source = void 0;
      return key;
    };
    // prettier-ignore
    this.removeValues = (values) => {
      this.checkLock();
      if ((0, import_custom.isEmptyStreamSourceInstance)(values))
        return false;
      const notFound = Symbol();
      return import_stream.Stream.from(values).mapPure(this.removeValue, notFound).countNotElement(notFound) > 0;
    };
    this.forEach = (f, state = (0, import_common.TraverseState)()) => {
      this._lock++;
      if (!this.isEmpty && !state.halted) {
        if (void 0 !== this.source)
          this.source.forEach(f, state);
        else
          this.keyValueMap.forEach(f, state);
      }
      this._lock--;
    };
    this.build = () => {
      if (void 0 !== this.source)
        return this.source;
      if (this.size === 0)
        return this.context.empty();
      return this.context.createNonEmptyImpl(
        this.keyValueMap.build().assumeNonEmpty(),
        this.valueKeyMap.build().assumeNonEmpty()
      );
    };
  }
  checkLock() {
    if (this._lock)
      import_base.RimbuError.throwModifiedBuilderWhileLoopingOverItError();
  }
  get keyValueMap() {
    if (void 0 === this._keyValueMap) {
      if (void 0 === this.source) {
        this._keyValueMap = this.context.keyValueContext.builder();
        this._valueKeyMap = this.context.valueKeyContext.builder();
      } else {
        this._keyValueMap = this.source.keyValueMap.toBuilder();
        this._valueKeyMap = this.source.valueKeyMap.toBuilder();
      }
    }
    return this._keyValueMap;
  }
  get valueKeyMap() {
    if (void 0 === this._valueKeyMap) {
      if (void 0 === this.source) {
        this._keyValueMap = this.context.keyValueContext.builder();
        this._valueKeyMap = this.context.valueKeyContext.builder();
      } else {
        this._keyValueMap = this.source.keyValueMap.toBuilder();
        this._valueKeyMap = this.source.valueKeyMap.toBuilder();
      }
    }
    return this._valueKeyMap;
  }
  get size() {
    return this.source?.size ?? this.keyValueMap.size;
  }
  get isEmpty() {
    return this.size === 0;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BiMapBuilder
});
