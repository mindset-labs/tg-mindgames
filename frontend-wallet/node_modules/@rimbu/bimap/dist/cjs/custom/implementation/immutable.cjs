"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/implementation/immutable.mts
var immutable_exports = {};
__export(immutable_exports, {
  BiMapEmpty: () => BiMapEmpty,
  BiMapNonEmptyImpl: () => BiMapNonEmptyImpl
});
module.exports = __toCommonJS(immutable_exports);
var import_map_custom = require("@rimbu/collection-types/map-custom");
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var import_custom = require("@rimbu/stream/custom");
var BiMapEmpty = class extends import_map_custom.EmptyBase {
  constructor(context) {
    super();
    this.context = context;
  }
  get size() {
    return 0;
  }
  get keyValueMap() {
    return this.context.keyValueContext.empty();
  }
  get valueKeyMap() {
    return this.context.valueKeyContext.empty();
  }
  hasKey() {
    return false;
  }
  hasValue() {
    return false;
  }
  getValue(key, otherwise) {
    return (0, import_common.OptLazy)(otherwise);
  }
  getKey(value, otherwise) {
    return (0, import_common.OptLazy)(otherwise);
  }
  set(key, value) {
    return this.addEntry([key, value]);
  }
  addEntry(entry) {
    return new BiMapNonEmptyImpl(
      this.context,
      this.context.keyValueContext.of(entry),
      this.context.valueKeyContext.of([entry[1], entry[0]])
    );
  }
  addEntries(entries) {
    return this.context.from(entries);
  }
  removeKey() {
    return this;
  }
  removeKeyAndGet() {
    return void 0;
  }
  removeKeys() {
    return this;
  }
  removeValue() {
    return this;
  }
  removeValueAndGet() {
    return void 0;
  }
  removeValues() {
    return this;
  }
  updateKeyAtValue() {
    return this;
  }
  updateValueAtKey() {
    return this;
  }
  streamKeys() {
    return import_stream.Stream.empty();
  }
  streamValues() {
    return import_stream.Stream.empty();
  }
  toBuilder() {
    return this.context.builder();
  }
  toString() {
    return `BiMap()`;
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: []
    };
  }
};
var BiMapNonEmptyImpl = class _BiMapNonEmptyImpl extends import_map_custom.NonEmptyBase {
  constructor(context, keyValueMap, valueKeyMap) {
    super();
    this.context = context;
    this.keyValueMap = keyValueMap;
    this.valueKeyMap = valueKeyMap;
  }
  copy(keyValueMap = this.keyValueMap, valueKeyMap = this.valueKeyMap) {
    if (keyValueMap === this.keyValueMap && valueKeyMap === this.valueKeyMap)
      return this;
    return new _BiMapNonEmptyImpl(this.context, keyValueMap, valueKeyMap);
  }
  copyE(keyValueMap = this.keyValueMap, valueKeyMap = this.valueKeyMap) {
    if (keyValueMap.nonEmpty() && valueKeyMap.nonEmpty()) {
      return new _BiMapNonEmptyImpl(this.context, keyValueMap, valueKeyMap);
    }
    return this.context.empty();
  }
  get size() {
    return this.keyValueMap.size;
  }
  asNormal() {
    return this;
  }
  stream() {
    return this.keyValueMap.stream();
  }
  streamKeys() {
    return this.keyValueMap.streamKeys();
  }
  streamValues() {
    return this.valueKeyMap.streamKeys();
  }
  hasKey(key) {
    const token = Symbol();
    return token !== this.getValue(key, token);
  }
  hasValue(value) {
    const token = Symbol();
    return token !== this.getKey(value, token);
  }
  getValue(key, otherwise) {
    return this.keyValueMap.get(key, otherwise);
  }
  getKey(value, otherwise) {
    return this.valueKeyMap.get(value, otherwise);
  }
  set(key, value) {
    return this.addEntry([key, value]);
  }
  addEntry(entry) {
    const [key, value] = entry;
    const removeKeyResult = this.keyValueMap.removeKeyAndGet(key);
    const removeValueResult = this.valueKeyMap.removeKeyAndGet(value);
    if (void 0 === removeKeyResult && void 0 === removeValueResult) {
      return this.copy(
        this.keyValueMap.addEntry(entry),
        this.valueKeyMap.set(value, key)
      );
    }
    if (void 0 !== removeKeyResult && void 0 !== removeValueResult) {
      const [removedKeyValueMap, oldValue] = removeKeyResult;
      const [removedValueKeyMap, oldKey] = removeValueResult;
      if (Object.is(oldKey, key) && Object.is(oldValue, value))
        return this;
      const newKeyValueMap2 = removedKeyValueMap.removeKey(oldKey).addEntry(entry);
      const newValueKeyMap2 = removedValueKeyMap.removeKey(oldValue).set(value, key);
      return this.copy(newKeyValueMap2, newValueKeyMap2);
    }
    const newKeyValueMap = (void 0 === removeValueResult ? this.keyValueMap : this.keyValueMap.removeKey(removeValueResult[1])).addEntry(entry);
    const newValueKeyMap = (void 0 === removeKeyResult ? this.valueKeyMap : this.valueKeyMap.removeKey(removeKeyResult[1])).set(value, key);
    return this.copy(newKeyValueMap, newValueKeyMap);
  }
  addEntries(entries) {
    if ((0, import_custom.isEmptyStreamSourceInstance)(entries))
      return this;
    const builder = this.toBuilder();
    builder.addEntries(entries);
    return builder.build();
  }
  removeKey(key) {
    const removeKeyResult = this.keyValueMap.removeKeyAndGet(key);
    if (void 0 === removeKeyResult)
      return this;
    const [newKeyValueMap, oldValue] = removeKeyResult;
    if (this.size === 1)
      return this.context.empty();
    const newValueKeyMap = this.valueKeyMap.removeKey(oldValue);
    return this.copy(
      newKeyValueMap.assumeNonEmpty(),
      newValueKeyMap.assumeNonEmpty()
    );
  }
  removeKeyAndGet(key) {
    const removeKeyResult = this.keyValueMap.removeKeyAndGet(key);
    if (void 0 === removeKeyResult)
      return void 0;
    const [newKeyValueMap, oldValue] = removeKeyResult;
    if (this.size === 1)
      return [this.context.empty(), oldValue];
    const newValueKeyMap = this.valueKeyMap.removeKey(oldValue);
    return [
      this.copy(
        newKeyValueMap.assumeNonEmpty(),
        newValueKeyMap.assumeNonEmpty()
      ),
      oldValue
    ];
  }
  removeKeys(keys) {
    if ((0, import_custom.isEmptyStreamSourceInstance)(keys))
      return this;
    const builder = this.toBuilder();
    builder.removeKeys(keys);
    return builder.build();
  }
  removeValue(value) {
    const removeResult = this.valueKeyMap.removeKeyAndGet(value);
    if (void 0 === removeResult)
      return this;
    const [newValueKeyMap, oldKey] = removeResult;
    if (this.size === 1)
      return this.context.empty();
    const newKeyValueMap = this.keyValueMap.removeKey(oldKey);
    return this.copy(
      newKeyValueMap.assumeNonEmpty(),
      newValueKeyMap.assumeNonEmpty()
    );
  }
  removeValueAndGet(value) {
    const removeValueResult = this.valueKeyMap.removeKeyAndGet(value);
    if (void 0 === removeValueResult)
      return void 0;
    const [newValueKeyMap, oldKey] = removeValueResult;
    if (this.size === 1)
      return [this.context.empty(), oldKey];
    const newKeyValueMap = this.keyValueMap.removeKey(oldKey);
    return [
      this.copy(
        newKeyValueMap.assumeNonEmpty(),
        newValueKeyMap.assumeNonEmpty()
      ),
      oldKey
    ];
  }
  removeValues(values) {
    if ((0, import_custom.isEmptyStreamSourceInstance)(values))
      return this;
    const builder = this.toBuilder();
    builder.removeValues(values);
    return builder.build();
  }
  updateValueAtKey(key, valueUpdate) {
    const token = Symbol();
    const currentValue = this.getValue(key, token);
    if (token === currentValue)
      return this;
    const newValue = (0, import_common.Update)(currentValue, valueUpdate);
    if (Object.is(newValue, currentValue))
      return this;
    return this.set(key, newValue);
  }
  updateKeyAtValue(keyUpdate, value) {
    const token = Symbol();
    const result = this.getKey(value, token);
    if (token === result)
      return this;
    const newKey = (0, import_common.Update)(result, keyUpdate);
    if (Object.is(newKey, result))
      return this;
    return this.set(newKey, value);
  }
  forEach(f, state = (0, import_common.TraverseState)()) {
    if (state.halted)
      return;
    this.keyValueMap.forEach(f, state);
  }
  filter(pred) {
    const builder = this.context.builder();
    builder.addEntries(this.stream().filter(pred));
    if (builder.size === this.size)
      return this;
    return builder.build();
  }
  toBuilder() {
    return this.context.createBuilder(this);
  }
  toArray() {
    return this.keyValueMap.toArray();
  }
  toString() {
    return this.stream().join({
      start: `BiMap(`,
      sep: ", ",
      end: `)`,
      valueToString: (entry) => `${entry[0]} <-> ${entry[1]}`
    });
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: this.toArray()
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BiMapEmpty,
  BiMapNonEmptyImpl
});
