"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/set-custom/implementation/builder.mts
var builder_exports = {};
__export(builder_exports, {
  HashSetBlockBuilder: () => HashSetBlockBuilder,
  HashSetCollisionBuilder: () => HashSetCollisionBuilder
});
module.exports = __toCommonJS(builder_exports);
var import_base = require("@rimbu/base");
var import_common3 = require("@rimbu/common");
var import_list2 = require("@rimbu/list");
var import_stream2 = require("@rimbu/stream");

// src/common/hasher.mts
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var Hasher;
((Hasher2) => {
  const MAX_STEP_BITS = 6;
  const STRING_INIT = 21;
  const BOOL_TRUE = -37;
  const BOOL_FALSE = -73;
  const OBJ_INIT = 91;
  const UNDEF_VALUE = -31;
  const NULL_VALUE = -41;
  const _anyFlatHasher = createAnyHasher("FLAT");
  const _anyShallowHasher = createAnyHasher("SHALLOW");
  const _anyDeepHasher = createAnyHasher("DEEP");
  function defaultHasher() {
    return _anyShallowHasher;
  }
  Hasher2.defaultHasher = defaultHasher;
  function createStringHasher(maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "string";
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = STRING_INIT;
        for (let i = 0; i < length; i += stepSize) {
          result = (result << 5) - result + value.charCodeAt(i) | 0;
        }
        return result;
      }
    });
  }
  const _stringHasher = createStringHasher(MAX_STEP_BITS);
  function stringHasher() {
    return _stringHasher;
  }
  Hasher2.stringHasher = stringHasher;
  const _anyToStringHasher = Object.freeze({
    isValid(obj) {
      return true;
    },
    hash(value) {
      return _stringHasher.hash(import_common.Eq.convertAnyToString(value));
    }
  });
  function anyToStringHasher(maxStepBits) {
    if (void 0 === maxStepBits)
      return _anyToStringHasher;
    return createStringHasher(maxStepBits);
  }
  Hasher2.anyToStringHasher = anyToStringHasher;
  const _anyJsonStringHasher = Object.freeze({
    isValid(obj) {
      return true;
    },
    hash(value) {
      return _stringHasher.hash(JSON.stringify(value));
    }
  });
  function anyJsonStringHasher() {
    return _anyJsonStringHasher;
  }
  Hasher2.anyJsonStringHasher = anyJsonStringHasher;
  function createStringCaseInsensitiveHasher(maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "string";
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = STRING_INIT;
        for (let i = 0; i < length; i += stepSize) {
          const char = value.charAt(i).toUpperCase();
          result = (result << 5) - result + char.charCodeAt(0) | 0;
        }
        return result;
      }
    });
  }
  const _stringCaseInsensitiveHasher = createStringCaseInsensitiveHasher(MAX_STEP_BITS);
  function stringCaseInsensitiveHasher() {
    return _stringCaseInsensitiveHasher;
  }
  Hasher2.stringCaseInsensitiveHasher = stringCaseInsensitiveHasher;
  function createArrayHasher(itemHasher, maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return Array.isArray(obj);
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = value.length | 0;
        for (let i = 0; i < length; i += stepSize) {
          result = (result << 5) - result + (i + 1) * itemHasher.hash(value[i]) | 0;
        }
        return result;
      }
    });
  }
  const _arrayAnyHasher = createArrayHasher(
    defaultHasher(),
    MAX_STEP_BITS
  );
  function arrayHasher(options) {
    if (void 0 === options)
      return _arrayAnyHasher;
    return createArrayHasher(
      options.itemHasher ?? anyFlatHasher(),
      options.maxStepBits ?? MAX_STEP_BITS
    );
  }
  Hasher2.arrayHasher = arrayHasher;
  function createStreamSourceHasher(itemHasher = defaultHasher(), maxStepBits = MAX_STEP_BITS) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "object" && obj !== null && Symbol.iterator in obj;
      },
      hash(source) {
        const iter = import_stream.Stream.from(source)[Symbol.iterator]();
        let hashItems = [];
        const storeItems = [];
        let skipAmount = 1;
        let skipCount = 0;
        const done = Symbol("done");
        let value;
        let length = 0;
        while (done !== (value = iter.fastNext(done))) {
          length++;
          skipCount++;
          if (skipCount >= skipAmount) {
            storeItems.push(value);
            skipCount = 0;
          }
          if (storeItems.length >= maxSteps) {
            hashItems = storeItems.slice();
            const newLength = maxSteps >>> 1;
            for (let index = 0; index < newLength; index += 1) {
              storeItems[index] = storeItems[index * 2];
            }
            storeItems.length = newLength;
            skipAmount *= 2;
          }
        }
        if (hashItems.length === 0) {
          hashItems = storeItems;
        }
        const itemHash = createArrayHasher(itemHasher, maxStepBits).hash(
          hashItems
        );
        return (itemHash << 5) - itemHash + length | 0;
      }
    });
  }
  const _streamSourceAnyHasher = createStreamSourceHasher(defaultHasher(), MAX_STEP_BITS);
  function streamSourceHasher(options) {
    if (void 0 === options)
      return _streamSourceAnyHasher;
    return createStreamSourceHasher(options.itemHasher, options.maxStepBits);
  }
  Hasher2.streamSourceHasher = streamSourceHasher;
  const MIN_HASH = -Math.pow(2, 31);
  const MAX_HASH = Math.pow(2, 31) - 1;
  const _numberHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "number";
    },
    hash(value) {
      if (Number.isInteger(value)) {
        return value | 0;
      }
      if (Number.isNaN(value)) {
        return MAX_HASH - 1;
      }
      if (value === Number.POSITIVE_INFINITY) {
        return MAX_HASH;
      }
      if (value === Number.NEGATIVE_INFINITY) {
        return MIN_HASH;
      }
      return _anyToStringHasher.hash(value);
    }
  });
  function numberHasher() {
    return _numberHasher;
  }
  Hasher2.numberHasher = numberHasher;
  const _booleanHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "boolean";
    },
    hash(value) {
      return value ? BOOL_TRUE : BOOL_FALSE;
    }
  });
  function booleanHasher() {
    return _booleanHasher;
  }
  Hasher2.booleanHasher = booleanHasher;
  const _bigintHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "bigint";
    },
    hash: _anyToStringHasher.hash
  });
  function bigintHasher() {
    return _bigintHasher;
  }
  Hasher2.bigintHasher = bigintHasher;
  function createValueOfHasher(cls, valueHasher = anyFlatHasher()) {
    return Object.freeze({
      isValid(obj) {
        return obj instanceof cls;
      },
      hash(value) {
        return valueHasher.hash(value.valueOf());
      }
    });
  }
  Hasher2.createValueOfHasher = createValueOfHasher;
  const _BooleanHasher = createValueOfHasher(
    Boolean,
    _booleanHasher
  );
  const _DateHasher = createValueOfHasher(Date, _numberHasher);
  function dateHasher() {
    return _DateHasher;
  }
  Hasher2.dateHasher = dateHasher;
  const _NumberHasher = createValueOfHasher(
    Number,
    _numberHasher
  );
  const _StringHasher = createValueOfHasher(
    String,
    _stringHasher
  );
  const _wrappedHashers = [
    _BooleanHasher,
    _DateHasher,
    _NumberHasher,
    _StringHasher
  ];
  function tryWrappedHasher(value) {
    let i = -1;
    const len = _wrappedHashers.length;
    while (++i < len) {
      const hasher = _wrappedHashers[i];
      if (hasher.isValid(value)) {
        return hasher.hash(value);
      }
    }
    return void 0;
  }
  function createObjectHasher(keyHasher, valueHasher) {
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "object";
      },
      hash(value) {
        if (value === null)
          return NULL_VALUE;
        let result = OBJ_INIT;
        for (const key in value) {
          const keyValue = value[key];
          const keyHash = keyHasher.hash(key);
          const valueHash = valueHasher.hash(keyValue);
          result = result ^ keyHash + valueHash;
        }
        return result;
      }
    });
  }
  const _objectShallowHasher = createObjectHasher(
    anyFlatHasher(),
    anyFlatHasher()
  );
  const _objectDeepHasher = createObjectHasher(
    anyFlatHasher(),
    anyDeepHasher()
  );
  function objectHasher(options) {
    if (void 0 === options)
      return _objectShallowHasher;
    return createObjectHasher(options.keyHasher, options.valueHasher);
  }
  Hasher2.objectHasher = objectHasher;
  function objectShallowHasher() {
    return _objectShallowHasher;
  }
  Hasher2.objectShallowHasher = objectShallowHasher;
  function objectDeepHasher() {
    return _objectDeepHasher;
  }
  Hasher2.objectDeepHasher = objectDeepHasher;
  function createAnyHasher(mode, maxStepBits = MAX_STEP_BITS) {
    return Object.freeze({
      isValid(obj) {
        return true;
      },
      hash(value) {
        const valueType = typeof value;
        switch (valueType) {
          case "undefined":
            return UNDEF_VALUE;
          case "bigint":
            return _bigintHasher.hash(value);
          case "boolean":
            return _booleanHasher.hash(value);
          case "number":
            return _numberHasher.hash(value);
          case "string":
            return _stringHasher.hash(value);
          case "function":
          case "symbol":
            return _anyToStringHasher.hash(value);
          case "object": {
            if (null === value)
              return NULL_VALUE;
            const result = tryWrappedHasher(value);
            if (void 0 !== result)
              return result;
            if (mode !== "FLAT") {
              if (Array.isArray(value)) {
                if (mode === "SHALLOW") {
                  return createArrayHasher(_anyFlatHasher, MAX_STEP_BITS).hash(
                    value
                  );
                }
                return createArrayHasher(this, maxStepBits).hash(value);
              }
              if (_streamSourceAnyHasher.isValid(value)) {
                if (mode === "SHALLOW") {
                  return createStreamSourceHasher(
                    _anyFlatHasher,
                    maxStepBits
                  ).hash(value);
                }
                return createStreamSourceHasher(this, maxStepBits).hash(value);
              }
              if (_objectShallowHasher.isValid(value)) {
                if (mode === "SHALLOW")
                  return _objectShallowHasher.hash(value);
                return createObjectHasher(_anyFlatHasher, this).hash(value);
              }
            }
            return _anyToStringHasher.hash(value);
          }
        }
      }
    });
  }
  function anyFlatHasher() {
    return _anyFlatHasher;
  }
  Hasher2.anyFlatHasher = anyFlatHasher;
  function anyShallowHasher() {
    return _anyShallowHasher;
  }
  Hasher2.anyShallowHasher = anyShallowHasher;
  function anyDeepHasher() {
    return _anyDeepHasher;
  }
  Hasher2.anyDeepHasher = anyDeepHasher;
  function tupleSymmetric(hasher = anyShallowHasher()) {
    return Object.freeze({
      isValid(obj) {
        return Array.isArray(obj) && obj.length === 2 && hasher.isValid(obj[0]) && hasher.isValid(obj[1]);
      },
      hash(value) {
        return hasher.hash(value[0]) + hasher.hash(value[1]) | 0;
      }
    });
  }
  Hasher2.tupleSymmetric = tupleSymmetric;
})(Hasher || (Hasher = {}));

// src/common/hashed-custom.mts
var import_common2 = require("@rimbu/common");
var import_list = require("@rimbu/list");
var BlockBuilderBase = class {
  get isEmpty() {
    return this.size === 0;
  }
  forEach(f, state = (0, import_common2.TraverseState)()) {
    if (this.isEmpty || state.halted)
      return;
    if (void 0 !== this.source)
      return this.source.forEach(f, state);
    const { halt } = state;
    if (void 0 !== this._entries) {
      for (const key in this._entries) {
        f(this._entries[key], state.nextIndex(), halt);
        if (state.halted)
          break;
      }
    }
    if (void 0 !== this._entrySets) {
      for (const key in this._entrySets) {
        this._entrySets[key].forEach(f, state);
        if (state.halted)
          break;
      }
    }
  }
};
var CollisionBuilderBase = class {
  get size() {
    if (void 0 !== this.source)
      return this.source.size;
    return this.entries.length;
  }
  get entries() {
    if (void 0 === this._entries) {
      if (void 0 !== this.source) {
        this._entries = this.source.entries.toBuilder();
      } else {
        this._entries = import_list.List.builder();
      }
    }
    return this._entries;
  }
  forEach(f, state = (0, import_common2.TraverseState)()) {
    if (state.halted)
      return;
    if (void 0 !== this.source) {
      return this.source.forEach(f, state);
    }
    this.entries.forEach(f, state);
  }
};

// src/set-custom/implementation/builder.mts
var HashSetBlockBuilder = class _HashSetBlockBuilder extends BlockBuilderBase {
  constructor(context, source, _entries, _entrySets, size = source?.size ?? 0, level = source?.level ?? 0) {
    super();
    this.context = context;
    this.source = source;
    this._entries = _entries;
    this._entrySets = _entrySets;
    this.size = size;
    this.level = level;
    this._lock = 0;
    // prettier-ignore
    this.has = (value) => {
      if (void 0 !== this.source)
        return this.source.has(value);
      if (!this.context.hasher.isValid(value))
        return false;
      return this.hasInternal(value);
    };
    this.add = (value) => {
      this.checkLock();
      return this.addInternal(value);
    };
    this.addAll = (source) => {
      this.checkLock();
      return import_stream2.Stream.from(source).filterPure(this.add).count() > 0;
    };
    // prettier-ignore
    this.remove = (value) => {
      this.checkLock();
      if (!this.context.hasher.isValid(value))
        return false;
      return this.removeInternal(value);
    };
    // prettier-ignore
    this.removeAll = (values) => {
      this.checkLock();
      return import_stream2.Stream.from(values).filterPure(this.remove).count() > 0;
    };
    this.forEach = (f, state = (0, import_common3.TraverseState)()) => {
      this._lock++;
      super.forEach(f, state);
      this._lock--;
    };
    this.build = () => {
      if (this.size === 0)
        return this.context.empty();
      return this.buildNE();
    };
  }
  checkLock() {
    if (this._lock)
      import_base.RimbuError.throwModifiedBuilderWhileLoopingOverItError();
  }
  prepareMutate() {
    if (void 0 === this._entries) {
      if (void 0 !== this.source) {
        this._entries = null === this.source.entries ? [] : import_base.Arr.copySparse(this.source.entries);
      } else {
        this._entries = [];
      }
    }
    if (void 0 === this._entrySets) {
      if (void 0 !== this.source && null !== this.source.entrySets) {
        this._entrySets = import_base.Arr.mapSparse(
          this.source.entrySets,
          (entrySet) => {
            if (this.context.isHashSetBlock(entrySet)) {
              return new _HashSetBlockBuilder(this.context, entrySet);
            }
            return new HashSetCollisionBuilder(this.context, entrySet);
          }
        );
      } else {
        this._entrySets = [];
      }
    }
  }
  get entries() {
    this.prepareMutate();
    return this._entries;
  }
  get entrySets() {
    this.prepareMutate();
    return this._entrySets;
  }
  hasInternal(value, hash = this.context.hash(value)) {
    if (void 0 !== this.source)
      return this.source.has(value, hash);
    const keyIndex = this.context.getKeyIndex(this.level, hash);
    if (keyIndex in this.entries) {
      return this.context.eq(value, this.entries[keyIndex]);
    }
    if (keyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[keyIndex];
      return currentEntrySet.hasInternal(value, hash);
    }
    return false;
  }
  addInternal(value, hash = this.context.hash(value)) {
    const keyIndex = this.context.getKeyIndex(this.level, hash);
    if (keyIndex in this.entries) {
      const currentEntry = this.entries[keyIndex];
      if (this.context.eq(value, currentEntry))
        return false;
      this.source = void 0;
      this.size++;
      delete this.entries[keyIndex];
      if (this.level < this.context.maxDepth) {
        const newEntrySet2 = new _HashSetBlockBuilder(
          this.context,
          void 0,
          void 0,
          void 0,
          0,
          this.level + 1
        );
        newEntrySet2.addInternal(currentEntry);
        newEntrySet2.addInternal(value, hash);
        this.entrySets[keyIndex] = newEntrySet2;
        return true;
      }
      const newEntries = import_list2.List.builder();
      newEntries.append(currentEntry);
      newEntries.append(value);
      const newEntrySet = new HashSetCollisionBuilder(
        this.context,
        void 0,
        newEntries
      );
      this.entrySets[keyIndex] = newEntrySet;
      return true;
    }
    if (keyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[keyIndex];
      const preSize = currentEntrySet.size;
      const changed = currentEntrySet.addInternal(value, hash);
      if (changed)
        this.source = void 0;
      this.size += currentEntrySet.size - preSize;
      return changed;
    }
    this.source = void 0;
    this.size++;
    this.entries[keyIndex] = value;
    return true;
  }
  removeInternal(value, hash = this.context.hash(value)) {
    const index = this.context.getKeyIndex(this.level, hash);
    if (index in this.entries) {
      const currentValue = this.entries[index];
      if (!this.context.eq(value, currentValue))
        return false;
      this.source = void 0;
      this.size--;
      delete this.entries[index];
      return true;
    }
    if (index in this.entrySets) {
      const entrySet = this.entrySets[index];
      const preSize = entrySet.size;
      if (!entrySet.removeInternal(value, hash)) {
        return false;
      }
      this.source = void 0;
      this.size += entrySet.size - preSize;
      if (entrySet.size > 1)
        return true;
      let first = void 0;
      if (this.context.isHashSetBlockBuilder(entrySet)) {
        for (const i in entrySet.entries) {
          first = entrySet.entries[i];
          break;
        }
      } else {
        first = entrySet.entries.get(0, import_base.RimbuError.throwInvalidStateError);
      }
      delete this.entrySets[index];
      let hasEntrySets = false;
      for (const _ in this.entrySets) {
        hasEntrySets = true;
        break;
      }
      if (!hasEntrySets) {
        this.entrySets.length = 0;
      }
      this.entries[index] = first;
      return true;
    }
    return false;
  }
  buildNE() {
    if (void 0 !== this.source)
      return this.source;
    const entries = this.entries.length === 0 ? null : import_base.Arr.copySparse(this.entries);
    const entrySets = this.entrySets.length === 0 ? null : import_base.Arr.mapSparse(this.entrySets, (entrySet) => entrySet.buildNE());
    return this.context.block(entries, entrySets, this.size, this.level);
  }
};
var HashSetCollisionBuilder = class extends CollisionBuilderBase {
  constructor(context, source, _entries) {
    super();
    this.context = context;
    this.source = source;
    this._entries = _entries;
  }
  hasInternal(value, hash) {
    if (void 0 !== this.source)
      return this.source.has(value, hash);
    let result = false;
    this.entries.forEach((v, _, halt) => {
      if (this.context.eq(v, value)) {
        result = true;
        halt();
      }
    });
    return result;
  }
  addInternal(value) {
    let index = -1;
    this.entries.forEach((v, i, halt) => {
      if (this.context.eq(v, value)) {
        index = i;
        halt();
      }
    });
    if (index < 0) {
      this.source = void 0;
      this.entries.append(value);
      return true;
    }
    const token = Symbol();
    const oldValue = this.entries.set(index, value, token);
    const changed = token === oldValue || !this.context.eq(oldValue, value);
    if (changed)
      this.source = void 0;
    return changed;
  }
  removeInternal(value) {
    let index = -1;
    this.entries.forEach((v, i, halt) => {
      if (this.context.eq(v, value)) {
        index = i;
        halt();
      }
    });
    if (index < 0)
      return false;
    this.source = void 0;
    this.entries.remove(index);
    return true;
  }
  buildNE() {
    return this.source ?? this.context.collision(this.entries.build().assumeNonEmpty());
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HashSetBlockBuilder,
  HashSetCollisionBuilder
});
