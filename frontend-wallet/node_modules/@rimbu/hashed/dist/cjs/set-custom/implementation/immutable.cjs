"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/set-custom/implementation/immutable.mts
var immutable_exports = {};
__export(immutable_exports, {
  HashSetBlock: () => HashSetBlock,
  HashSetCollision: () => HashSetCollision,
  HashSetEmpty: () => HashSetEmpty,
  HashSetNonEmptyBase: () => HashSetNonEmptyBase
});
module.exports = __toCommonJS(immutable_exports);
var import_base = require("@rimbu/base");
var import_set_custom = require("@rimbu/collection-types/set-custom");
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var import_custom = require("@rimbu/stream/custom");
var HashSetEmpty = class extends import_set_custom.EmptyBase {
  constructor(context) {
    super();
    this.context = context;
    this.addAll = context.from;
  }
  has() {
    return false;
  }
  add(value) {
    return this.context.emptyBlock().add(value);
  }
  remove() {
    return this;
  }
  removeAll() {
    return this;
  }
  union(other) {
    if (this.context.isHashSetBlock(other) || this.context.isHashSetCollision(other)) {
      if (other.context === this.context)
        return other;
    }
    return this.context.from(other);
  }
  difference() {
    return this.context.empty();
  }
  intersect() {
    return this.context.empty();
  }
  symDifference(other) {
    return this.union(other);
  }
  toBuilder() {
    return this.context.builder();
  }
  toString() {
    return `HashSet()`;
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: []
    };
  }
};
var HashSetNonEmptyBase = class extends import_set_custom.NonEmptyBase {
  asNormal() {
    return this;
  }
  addAll(values) {
    if ((0, import_custom.isEmptyStreamSourceInstance)(values))
      return this;
    const builder = this.toBuilder();
    builder.addAll(values);
    return builder.build();
  }
  removeAll(values) {
    if ((0, import_custom.isEmptyStreamSourceInstance)(values))
      return this;
    const builder = this.toBuilder();
    builder.removeAll(values);
    return builder.build();
  }
  filter(pred) {
    const builder = this.context.builder();
    builder.addAll(this.stream().filter(pred));
    if (builder.size === this.size)
      return this;
    return builder.build();
  }
  union(other) {
    if (other === this)
      return this;
    if ((0, import_custom.isEmptyStreamSourceInstance)(other))
      return this;
    const builder = this.toBuilder();
    builder.addAll(other);
    return builder.build().assumeNonEmpty();
  }
  difference(other) {
    if (other === this)
      return this.context.empty();
    if ((0, import_custom.isEmptyStreamSourceInstance)(other))
      return this;
    const builder = this.toBuilder();
    builder.removeAll(other);
    return builder.build();
  }
  intersect(other) {
    if (other === this)
      return this;
    if ((0, import_custom.isEmptyStreamSourceInstance)(other))
      return this.context.empty();
    const builder = this.context.builder();
    const it = import_stream.Stream.from(other)[Symbol.iterator]();
    const done = Symbol("Done");
    let value;
    while (done !== (value = it.fastNext(done))) {
      if (this.has(value))
        builder.add(value);
    }
    if (builder.size === this.size)
      return this;
    return builder.build();
  }
  symDifference(other) {
    if (other === this)
      return this.context.empty();
    if ((0, import_custom.isEmptyStreamSourceInstance)(other))
      return this;
    const builder = this.toBuilder();
    import_stream.Stream.from(other).filterNot(builder.remove).forEach(builder.add);
    return builder.build();
  }
  toBuilder() {
    return this.context.createBuilder(this);
  }
  toString() {
    return this.stream().join({ start: "HashSet(", sep: ", ", end: ")" });
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: []
    };
  }
};
var HashSetBlock = class _HashSetBlock extends HashSetNonEmptyBase {
  constructor(context, entries, entrySets, size, level) {
    super();
    this.context = context;
    this.entries = entries;
    this.entrySets = entrySets;
    this.size = size;
    this.level = level;
  }
  copy(entries = this.entries, entrySets = this.entrySets, size = this.size) {
    if (entries === this.entries && entrySets === this.entrySets && size === this.size) {
      return this;
    }
    return new _HashSetBlock(this.context, entries, entrySets, size, this.level);
  }
  stream() {
    if (null !== this.entries) {
      if (null === this.entrySets) {
        return import_stream.Stream.fromObjectValues(this.entries);
      }
      return import_stream.Stream.fromObjectValues(this.entries).concat(
        import_stream.Stream.fromObjectValues(this.entrySets).flatMap(
          (entrySet) => entrySet.stream()
        )
      );
    }
    if (null === this.entrySets) {
      import_base.RimbuError.throwInvalidStateError();
    }
    return import_stream.Stream.fromObjectValues(this.entrySets).flatMap(
      (entrySet) => entrySet.stream()
    );
  }
  has(value, inHash) {
    if (!this.context.hasher.isValid(value))
      return false;
    const hash = inHash ?? this.context.hash(value);
    const atKeyIndex = this.context.getKeyIndex(this.level, hash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const entry = this.entries[atKeyIndex];
      return this.context.eq(entry, value);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const entrySet = this.entrySets[atKeyIndex];
      return entrySet.has(value, hash);
    }
    return false;
  }
  add(value, hash = this.context.hash(value)) {
    const atKeyIndex = this.context.getKeyIndex(this.level, hash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const currentValue = this.entries[atKeyIndex];
      if (this.context.eq(value, currentValue))
        return this;
      let newEntries2 = import_base.Arr.copySparse(this.entries);
      delete newEntries2[atKeyIndex];
      let isEmpty = true;
      for (const _ in newEntries2) {
        isEmpty = false;
        break;
      }
      if (isEmpty)
        newEntries2 = null;
      if (this.level < this.context.maxDepth) {
        const newEntrySet2 = this.context.block(null, null, 0, this.level + 1).add(currentValue).add(value, hash);
        const newEntrySets2 = null === this.entrySets ? [] : import_base.Arr.copySparse(this.entrySets);
        newEntrySets2[atKeyIndex] = newEntrySet2;
        return this.copy(newEntries2, newEntrySets2, this.size + 1);
      }
      const newEntrySet = this.context.collision(
        this.context.listContext.of(currentValue, value)
      );
      const newEntrySets = null === this.entrySets ? [] : import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(newEntries2, newEntrySets, this.size + 1);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[atKeyIndex];
      const newEntrySet = currentEntrySet.add(value, hash);
      if (newEntrySet === currentEntrySet)
        return this;
      const newEntrySets = import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(
        void 0,
        newEntrySets,
        this.size + newEntrySet.size - currentEntrySet.size
      );
    }
    const newEntries = null === this.entries ? [] : import_base.Arr.copySparse(this.entries);
    newEntries[atKeyIndex] = value;
    return this.copy(newEntries, void 0, this.size + 1);
  }
  remove(value, hash) {
    if (!this.context.hasher.isValid(value))
      return this;
    const valueHash = hash ?? this.context.hash(value);
    const atKeyIndex = this.context.getKeyIndex(this.level, valueHash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const currentValue = this.entries[atKeyIndex];
      if (!this.context.eq(currentValue, value))
        return this;
      if (this.size === 1)
        return this.context.empty();
      const newEntries = import_base.Arr.copySparse(this.entries);
      delete newEntries[atKeyIndex];
      for (const _ in newEntries) {
        return this.copy(newEntries, void 0, this.size - 1);
      }
      return this.copy(null, void 0, this.size - 1);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[atKeyIndex];
      const newEntrySet = currentEntrySet.remove(
        value,
        hash
      );
      if (newEntrySet === currentEntrySet)
        return this;
      if (newEntrySet.size === 1) {
        let firstValue = void 0;
        if (this.context.isHashSetBlock(newEntrySet)) {
          for (const key in newEntrySet.entries) {
            firstValue = newEntrySet.entries[key];
            break;
          }
        } else {
          firstValue = newEntrySet.entries.first();
        }
        const newEntries = null === this.entries ? [] : import_base.Arr.copySparse(this.entries);
        newEntries[atKeyIndex] = firstValue;
        const newEntrySets2 = import_base.Arr.copySparse(this.entrySets);
        delete newEntrySets2[atKeyIndex];
        return this.copy(newEntries, newEntrySets2, this.size - 1);
      }
      const newEntrySets = import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(
        void 0,
        newEntrySets,
        this.size - currentEntrySet.size + newEntrySet.size
      );
    }
    return this;
  }
  forEach(f, state = (0, import_common.TraverseState)()) {
    if (state.halted)
      return;
    const { halt } = state;
    if (null !== this.entries) {
      for (const key in this.entries) {
        f(this.entries[key], state.nextIndex(), halt);
        if (state.halted)
          return;
      }
    }
    if (null !== this.entrySets) {
      for (const key in this.entrySets) {
        this.entrySets[key].forEach(f, state);
        if (state.halted)
          return;
      }
    }
  }
  toArray() {
    let result = [];
    if (null !== this.entries) {
      for (const key in this.entries) {
        result.push(this.entries[key]);
      }
    }
    if (null !== this.entrySets) {
      for (const key in this.entrySets) {
        result = result.concat(this.entrySets[key].toArray());
      }
    }
    return result;
  }
};
var HashSetCollision = class _HashSetCollision extends HashSetNonEmptyBase {
  constructor(context, entries) {
    super();
    this.context = context;
    this.entries = entries;
  }
  get size() {
    return this.entries.length;
  }
  copy(entries = this.entries) {
    if (entries === this.entries)
      return this;
    return new _HashSetCollision(this.context, entries);
  }
  stream() {
    return this.entries.stream();
  }
  has(value, inHash) {
    if (!this.context.hasher.isValid(value))
      return false;
    return this.stream().contains(value, void 0, this.context.eq);
  }
  add(value) {
    const currentIndex = this.stream().indexOf(
      value,
      void 0,
      this.context.eq
    );
    if (void 0 === currentIndex) {
      return this.copy(this.entries.append(value));
    }
    return this.copy(this.entries.updateAt(currentIndex, value));
  }
  remove(value, hash) {
    if (!this.context.hasher.isValid(value))
      return this;
    const currentIndex = this.stream().indexOf(
      value,
      void 0,
      this.context.eq
    );
    if (void 0 === currentIndex)
      return this;
    const newEntries = this.entries.remove(currentIndex, 1).assumeNonEmpty();
    return this.copy(newEntries);
  }
  forEach(f, state = (0, import_common.TraverseState)()) {
    if (state.halted)
      return;
    this.entries.forEach(f, state);
  }
  toArray() {
    return this.entries.toArray();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HashSetBlock,
  HashSetCollision,
  HashSetEmpty,
  HashSetNonEmptyBase
});
