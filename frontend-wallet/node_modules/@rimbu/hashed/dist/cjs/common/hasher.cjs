"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/common/hasher.mts
var hasher_exports = {};
__export(hasher_exports, {
  Hasher: () => Hasher
});
module.exports = __toCommonJS(hasher_exports);
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var Hasher;
((Hasher2) => {
  const MAX_STEP_BITS = 6;
  const STRING_INIT = 21;
  const BOOL_TRUE = -37;
  const BOOL_FALSE = -73;
  const OBJ_INIT = 91;
  const UNDEF_VALUE = -31;
  const NULL_VALUE = -41;
  const _anyFlatHasher = createAnyHasher("FLAT");
  const _anyShallowHasher = createAnyHasher("SHALLOW");
  const _anyDeepHasher = createAnyHasher("DEEP");
  function defaultHasher() {
    return _anyShallowHasher;
  }
  Hasher2.defaultHasher = defaultHasher;
  function createStringHasher(maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "string";
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = STRING_INIT;
        for (let i = 0; i < length; i += stepSize) {
          result = (result << 5) - result + value.charCodeAt(i) | 0;
        }
        return result;
      }
    });
  }
  const _stringHasher = createStringHasher(MAX_STEP_BITS);
  function stringHasher() {
    return _stringHasher;
  }
  Hasher2.stringHasher = stringHasher;
  const _anyToStringHasher = Object.freeze({
    isValid(obj) {
      return true;
    },
    hash(value) {
      return _stringHasher.hash(import_common.Eq.convertAnyToString(value));
    }
  });
  function anyToStringHasher(maxStepBits) {
    if (void 0 === maxStepBits)
      return _anyToStringHasher;
    return createStringHasher(maxStepBits);
  }
  Hasher2.anyToStringHasher = anyToStringHasher;
  const _anyJsonStringHasher = Object.freeze({
    isValid(obj) {
      return true;
    },
    hash(value) {
      return _stringHasher.hash(JSON.stringify(value));
    }
  });
  function anyJsonStringHasher() {
    return _anyJsonStringHasher;
  }
  Hasher2.anyJsonStringHasher = anyJsonStringHasher;
  function createStringCaseInsensitiveHasher(maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "string";
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = STRING_INIT;
        for (let i = 0; i < length; i += stepSize) {
          const char = value.charAt(i).toUpperCase();
          result = (result << 5) - result + char.charCodeAt(0) | 0;
        }
        return result;
      }
    });
  }
  const _stringCaseInsensitiveHasher = createStringCaseInsensitiveHasher(MAX_STEP_BITS);
  function stringCaseInsensitiveHasher() {
    return _stringCaseInsensitiveHasher;
  }
  Hasher2.stringCaseInsensitiveHasher = stringCaseInsensitiveHasher;
  function createArrayHasher(itemHasher, maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return Array.isArray(obj);
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = value.length | 0;
        for (let i = 0; i < length; i += stepSize) {
          result = (result << 5) - result + (i + 1) * itemHasher.hash(value[i]) | 0;
        }
        return result;
      }
    });
  }
  const _arrayAnyHasher = createArrayHasher(
    defaultHasher(),
    MAX_STEP_BITS
  );
  function arrayHasher(options) {
    if (void 0 === options)
      return _arrayAnyHasher;
    return createArrayHasher(
      options.itemHasher ?? anyFlatHasher(),
      options.maxStepBits ?? MAX_STEP_BITS
    );
  }
  Hasher2.arrayHasher = arrayHasher;
  function createStreamSourceHasher(itemHasher = defaultHasher(), maxStepBits = MAX_STEP_BITS) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "object" && obj !== null && Symbol.iterator in obj;
      },
      hash(source) {
        const iter = import_stream.Stream.from(source)[Symbol.iterator]();
        let hashItems = [];
        const storeItems = [];
        let skipAmount = 1;
        let skipCount = 0;
        const done = Symbol("done");
        let value;
        let length = 0;
        while (done !== (value = iter.fastNext(done))) {
          length++;
          skipCount++;
          if (skipCount >= skipAmount) {
            storeItems.push(value);
            skipCount = 0;
          }
          if (storeItems.length >= maxSteps) {
            hashItems = storeItems.slice();
            const newLength = maxSteps >>> 1;
            for (let index = 0; index < newLength; index += 1) {
              storeItems[index] = storeItems[index * 2];
            }
            storeItems.length = newLength;
            skipAmount *= 2;
          }
        }
        if (hashItems.length === 0) {
          hashItems = storeItems;
        }
        const itemHash = createArrayHasher(itemHasher, maxStepBits).hash(
          hashItems
        );
        return (itemHash << 5) - itemHash + length | 0;
      }
    });
  }
  const _streamSourceAnyHasher = createStreamSourceHasher(defaultHasher(), MAX_STEP_BITS);
  function streamSourceHasher(options) {
    if (void 0 === options)
      return _streamSourceAnyHasher;
    return createStreamSourceHasher(options.itemHasher, options.maxStepBits);
  }
  Hasher2.streamSourceHasher = streamSourceHasher;
  const MIN_HASH = -Math.pow(2, 31);
  const MAX_HASH = Math.pow(2, 31) - 1;
  const _numberHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "number";
    },
    hash(value) {
      if (Number.isInteger(value)) {
        return value | 0;
      }
      if (Number.isNaN(value)) {
        return MAX_HASH - 1;
      }
      if (value === Number.POSITIVE_INFINITY) {
        return MAX_HASH;
      }
      if (value === Number.NEGATIVE_INFINITY) {
        return MIN_HASH;
      }
      return _anyToStringHasher.hash(value);
    }
  });
  function numberHasher() {
    return _numberHasher;
  }
  Hasher2.numberHasher = numberHasher;
  const _booleanHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "boolean";
    },
    hash(value) {
      return value ? BOOL_TRUE : BOOL_FALSE;
    }
  });
  function booleanHasher() {
    return _booleanHasher;
  }
  Hasher2.booleanHasher = booleanHasher;
  const _bigintHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "bigint";
    },
    hash: _anyToStringHasher.hash
  });
  function bigintHasher() {
    return _bigintHasher;
  }
  Hasher2.bigintHasher = bigintHasher;
  function createValueOfHasher(cls, valueHasher = anyFlatHasher()) {
    return Object.freeze({
      isValid(obj) {
        return obj instanceof cls;
      },
      hash(value) {
        return valueHasher.hash(value.valueOf());
      }
    });
  }
  Hasher2.createValueOfHasher = createValueOfHasher;
  const _BooleanHasher = createValueOfHasher(
    Boolean,
    _booleanHasher
  );
  const _DateHasher = createValueOfHasher(Date, _numberHasher);
  function dateHasher() {
    return _DateHasher;
  }
  Hasher2.dateHasher = dateHasher;
  const _NumberHasher = createValueOfHasher(
    Number,
    _numberHasher
  );
  const _StringHasher = createValueOfHasher(
    String,
    _stringHasher
  );
  const _wrappedHashers = [
    _BooleanHasher,
    _DateHasher,
    _NumberHasher,
    _StringHasher
  ];
  function tryWrappedHasher(value) {
    let i = -1;
    const len = _wrappedHashers.length;
    while (++i < len) {
      const hasher = _wrappedHashers[i];
      if (hasher.isValid(value)) {
        return hasher.hash(value);
      }
    }
    return void 0;
  }
  function createObjectHasher(keyHasher, valueHasher) {
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "object";
      },
      hash(value) {
        if (value === null)
          return NULL_VALUE;
        let result = OBJ_INIT;
        for (const key in value) {
          const keyValue = value[key];
          const keyHash = keyHasher.hash(key);
          const valueHash = valueHasher.hash(keyValue);
          result = result ^ keyHash + valueHash;
        }
        return result;
      }
    });
  }
  const _objectShallowHasher = createObjectHasher(
    anyFlatHasher(),
    anyFlatHasher()
  );
  const _objectDeepHasher = createObjectHasher(
    anyFlatHasher(),
    anyDeepHasher()
  );
  function objectHasher(options) {
    if (void 0 === options)
      return _objectShallowHasher;
    return createObjectHasher(options.keyHasher, options.valueHasher);
  }
  Hasher2.objectHasher = objectHasher;
  function objectShallowHasher() {
    return _objectShallowHasher;
  }
  Hasher2.objectShallowHasher = objectShallowHasher;
  function objectDeepHasher() {
    return _objectDeepHasher;
  }
  Hasher2.objectDeepHasher = objectDeepHasher;
  function createAnyHasher(mode, maxStepBits = MAX_STEP_BITS) {
    return Object.freeze({
      isValid(obj) {
        return true;
      },
      hash(value) {
        const valueType = typeof value;
        switch (valueType) {
          case "undefined":
            return UNDEF_VALUE;
          case "bigint":
            return _bigintHasher.hash(value);
          case "boolean":
            return _booleanHasher.hash(value);
          case "number":
            return _numberHasher.hash(value);
          case "string":
            return _stringHasher.hash(value);
          case "function":
          case "symbol":
            return _anyToStringHasher.hash(value);
          case "object": {
            if (null === value)
              return NULL_VALUE;
            const result = tryWrappedHasher(value);
            if (void 0 !== result)
              return result;
            if (mode !== "FLAT") {
              if (Array.isArray(value)) {
                if (mode === "SHALLOW") {
                  return createArrayHasher(_anyFlatHasher, MAX_STEP_BITS).hash(
                    value
                  );
                }
                return createArrayHasher(this, maxStepBits).hash(value);
              }
              if (_streamSourceAnyHasher.isValid(value)) {
                if (mode === "SHALLOW") {
                  return createStreamSourceHasher(
                    _anyFlatHasher,
                    maxStepBits
                  ).hash(value);
                }
                return createStreamSourceHasher(this, maxStepBits).hash(value);
              }
              if (_objectShallowHasher.isValid(value)) {
                if (mode === "SHALLOW")
                  return _objectShallowHasher.hash(value);
                return createObjectHasher(_anyFlatHasher, this).hash(value);
              }
            }
            return _anyToStringHasher.hash(value);
          }
        }
      }
    });
  }
  function anyFlatHasher() {
    return _anyFlatHasher;
  }
  Hasher2.anyFlatHasher = anyFlatHasher;
  function anyShallowHasher() {
    return _anyShallowHasher;
  }
  Hasher2.anyShallowHasher = anyShallowHasher;
  function anyDeepHasher() {
    return _anyDeepHasher;
  }
  Hasher2.anyDeepHasher = anyDeepHasher;
  function tupleSymmetric(hasher = anyShallowHasher()) {
    return Object.freeze({
      isValid(obj) {
        return Array.isArray(obj) && obj.length === 2 && hasher.isValid(obj[0]) && hasher.isValid(obj[1]);
      },
      hash(value) {
        return hasher.hash(value[0]) + hasher.hash(value[1]) | 0;
      }
    });
  }
  Hasher2.tupleSymmetric = tupleSymmetric;
})(Hasher || (Hasher = {}));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Hasher
});
