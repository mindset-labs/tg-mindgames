"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main/index.mts
var main_exports = {};
__export(main_exports, {
  BlockBuilderBase: () => BlockBuilderBase,
  CollisionBuilderBase: () => CollisionBuilderBase,
  HashMap: () => HashMap,
  HashSet: () => HashSet,
  Hasher: () => Hasher
});
module.exports = __toCommonJS(main_exports);

// src/common/hasher.mts
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var Hasher;
((Hasher2) => {
  const MAX_STEP_BITS = 6;
  const STRING_INIT = 21;
  const BOOL_TRUE = -37;
  const BOOL_FALSE = -73;
  const OBJ_INIT = 91;
  const UNDEF_VALUE = -31;
  const NULL_VALUE = -41;
  const _anyFlatHasher = createAnyHasher("FLAT");
  const _anyShallowHasher = createAnyHasher("SHALLOW");
  const _anyDeepHasher = createAnyHasher("DEEP");
  function defaultHasher() {
    return _anyShallowHasher;
  }
  Hasher2.defaultHasher = defaultHasher;
  function createStringHasher(maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "string";
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = STRING_INIT;
        for (let i = 0; i < length; i += stepSize) {
          result = (result << 5) - result + value.charCodeAt(i) | 0;
        }
        return result;
      }
    });
  }
  const _stringHasher = createStringHasher(MAX_STEP_BITS);
  function stringHasher() {
    return _stringHasher;
  }
  Hasher2.stringHasher = stringHasher;
  const _anyToStringHasher = Object.freeze({
    isValid(obj) {
      return true;
    },
    hash(value) {
      return _stringHasher.hash(import_common.Eq.convertAnyToString(value));
    }
  });
  function anyToStringHasher(maxStepBits) {
    if (void 0 === maxStepBits)
      return _anyToStringHasher;
    return createStringHasher(maxStepBits);
  }
  Hasher2.anyToStringHasher = anyToStringHasher;
  const _anyJsonStringHasher = Object.freeze({
    isValid(obj) {
      return true;
    },
    hash(value) {
      return _stringHasher.hash(JSON.stringify(value));
    }
  });
  function anyJsonStringHasher() {
    return _anyJsonStringHasher;
  }
  Hasher2.anyJsonStringHasher = anyJsonStringHasher;
  function createStringCaseInsensitiveHasher(maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "string";
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = STRING_INIT;
        for (let i = 0; i < length; i += stepSize) {
          const char = value.charAt(i).toUpperCase();
          result = (result << 5) - result + char.charCodeAt(0) | 0;
        }
        return result;
      }
    });
  }
  const _stringCaseInsensitiveHasher = createStringCaseInsensitiveHasher(MAX_STEP_BITS);
  function stringCaseInsensitiveHasher() {
    return _stringCaseInsensitiveHasher;
  }
  Hasher2.stringCaseInsensitiveHasher = stringCaseInsensitiveHasher;
  function createArrayHasher(itemHasher, maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return Array.isArray(obj);
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = value.length | 0;
        for (let i = 0; i < length; i += stepSize) {
          result = (result << 5) - result + (i + 1) * itemHasher.hash(value[i]) | 0;
        }
        return result;
      }
    });
  }
  const _arrayAnyHasher = createArrayHasher(
    defaultHasher(),
    MAX_STEP_BITS
  );
  function arrayHasher(options) {
    if (void 0 === options)
      return _arrayAnyHasher;
    return createArrayHasher(
      options.itemHasher ?? anyFlatHasher(),
      options.maxStepBits ?? MAX_STEP_BITS
    );
  }
  Hasher2.arrayHasher = arrayHasher;
  function createStreamSourceHasher(itemHasher = defaultHasher(), maxStepBits = MAX_STEP_BITS) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "object" && obj !== null && Symbol.iterator in obj;
      },
      hash(source) {
        const iter = import_stream.Stream.from(source)[Symbol.iterator]();
        let hashItems = [];
        const storeItems = [];
        let skipAmount = 1;
        let skipCount = 0;
        const done = Symbol("done");
        let value;
        let length = 0;
        while (done !== (value = iter.fastNext(done))) {
          length++;
          skipCount++;
          if (skipCount >= skipAmount) {
            storeItems.push(value);
            skipCount = 0;
          }
          if (storeItems.length >= maxSteps) {
            hashItems = storeItems.slice();
            const newLength = maxSteps >>> 1;
            for (let index = 0; index < newLength; index += 1) {
              storeItems[index] = storeItems[index * 2];
            }
            storeItems.length = newLength;
            skipAmount *= 2;
          }
        }
        if (hashItems.length === 0) {
          hashItems = storeItems;
        }
        const itemHash = createArrayHasher(itemHasher, maxStepBits).hash(
          hashItems
        );
        return (itemHash << 5) - itemHash + length | 0;
      }
    });
  }
  const _streamSourceAnyHasher = createStreamSourceHasher(defaultHasher(), MAX_STEP_BITS);
  function streamSourceHasher(options) {
    if (void 0 === options)
      return _streamSourceAnyHasher;
    return createStreamSourceHasher(options.itemHasher, options.maxStepBits);
  }
  Hasher2.streamSourceHasher = streamSourceHasher;
  const MIN_HASH = -Math.pow(2, 31);
  const MAX_HASH = Math.pow(2, 31) - 1;
  const _numberHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "number";
    },
    hash(value) {
      if (Number.isInteger(value)) {
        return value | 0;
      }
      if (Number.isNaN(value)) {
        return MAX_HASH - 1;
      }
      if (value === Number.POSITIVE_INFINITY) {
        return MAX_HASH;
      }
      if (value === Number.NEGATIVE_INFINITY) {
        return MIN_HASH;
      }
      return _anyToStringHasher.hash(value);
    }
  });
  function numberHasher() {
    return _numberHasher;
  }
  Hasher2.numberHasher = numberHasher;
  const _booleanHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "boolean";
    },
    hash(value) {
      return value ? BOOL_TRUE : BOOL_FALSE;
    }
  });
  function booleanHasher() {
    return _booleanHasher;
  }
  Hasher2.booleanHasher = booleanHasher;
  const _bigintHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "bigint";
    },
    hash: _anyToStringHasher.hash
  });
  function bigintHasher() {
    return _bigintHasher;
  }
  Hasher2.bigintHasher = bigintHasher;
  function createValueOfHasher(cls, valueHasher = anyFlatHasher()) {
    return Object.freeze({
      isValid(obj) {
        return obj instanceof cls;
      },
      hash(value) {
        return valueHasher.hash(value.valueOf());
      }
    });
  }
  Hasher2.createValueOfHasher = createValueOfHasher;
  const _BooleanHasher = createValueOfHasher(
    Boolean,
    _booleanHasher
  );
  const _DateHasher = createValueOfHasher(Date, _numberHasher);
  function dateHasher() {
    return _DateHasher;
  }
  Hasher2.dateHasher = dateHasher;
  const _NumberHasher = createValueOfHasher(
    Number,
    _numberHasher
  );
  const _StringHasher = createValueOfHasher(
    String,
    _stringHasher
  );
  const _wrappedHashers = [
    _BooleanHasher,
    _DateHasher,
    _NumberHasher,
    _StringHasher
  ];
  function tryWrappedHasher(value) {
    let i = -1;
    const len = _wrappedHashers.length;
    while (++i < len) {
      const hasher = _wrappedHashers[i];
      if (hasher.isValid(value)) {
        return hasher.hash(value);
      }
    }
    return void 0;
  }
  function createObjectHasher(keyHasher, valueHasher) {
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "object";
      },
      hash(value) {
        if (value === null)
          return NULL_VALUE;
        let result = OBJ_INIT;
        for (const key in value) {
          const keyValue = value[key];
          const keyHash = keyHasher.hash(key);
          const valueHash = valueHasher.hash(keyValue);
          result = result ^ keyHash + valueHash;
        }
        return result;
      }
    });
  }
  const _objectShallowHasher = createObjectHasher(
    anyFlatHasher(),
    anyFlatHasher()
  );
  const _objectDeepHasher = createObjectHasher(
    anyFlatHasher(),
    anyDeepHasher()
  );
  function objectHasher(options) {
    if (void 0 === options)
      return _objectShallowHasher;
    return createObjectHasher(options.keyHasher, options.valueHasher);
  }
  Hasher2.objectHasher = objectHasher;
  function objectShallowHasher() {
    return _objectShallowHasher;
  }
  Hasher2.objectShallowHasher = objectShallowHasher;
  function objectDeepHasher() {
    return _objectDeepHasher;
  }
  Hasher2.objectDeepHasher = objectDeepHasher;
  function createAnyHasher(mode, maxStepBits = MAX_STEP_BITS) {
    return Object.freeze({
      isValid(obj) {
        return true;
      },
      hash(value) {
        const valueType = typeof value;
        switch (valueType) {
          case "undefined":
            return UNDEF_VALUE;
          case "bigint":
            return _bigintHasher.hash(value);
          case "boolean":
            return _booleanHasher.hash(value);
          case "number":
            return _numberHasher.hash(value);
          case "string":
            return _stringHasher.hash(value);
          case "function":
          case "symbol":
            return _anyToStringHasher.hash(value);
          case "object": {
            if (null === value)
              return NULL_VALUE;
            const result = tryWrappedHasher(value);
            if (void 0 !== result)
              return result;
            if (mode !== "FLAT") {
              if (Array.isArray(value)) {
                if (mode === "SHALLOW") {
                  return createArrayHasher(_anyFlatHasher, MAX_STEP_BITS).hash(
                    value
                  );
                }
                return createArrayHasher(this, maxStepBits).hash(value);
              }
              if (_streamSourceAnyHasher.isValid(value)) {
                if (mode === "SHALLOW") {
                  return createStreamSourceHasher(
                    _anyFlatHasher,
                    maxStepBits
                  ).hash(value);
                }
                return createStreamSourceHasher(this, maxStepBits).hash(value);
              }
              if (_objectShallowHasher.isValid(value)) {
                if (mode === "SHALLOW")
                  return _objectShallowHasher.hash(value);
                return createObjectHasher(_anyFlatHasher, this).hash(value);
              }
            }
            return _anyToStringHasher.hash(value);
          }
        }
      }
    });
  }
  function anyFlatHasher() {
    return _anyFlatHasher;
  }
  Hasher2.anyFlatHasher = anyFlatHasher;
  function anyShallowHasher() {
    return _anyShallowHasher;
  }
  Hasher2.anyShallowHasher = anyShallowHasher;
  function anyDeepHasher() {
    return _anyDeepHasher;
  }
  Hasher2.anyDeepHasher = anyDeepHasher;
  function tupleSymmetric(hasher = anyShallowHasher()) {
    return Object.freeze({
      isValid(obj) {
        return Array.isArray(obj) && obj.length === 2 && hasher.isValid(obj[0]) && hasher.isValid(obj[1]);
      },
      hash(value) {
        return hasher.hash(value[0]) + hasher.hash(value[1]) | 0;
      }
    });
  }
  Hasher2.tupleSymmetric = tupleSymmetric;
})(Hasher || (Hasher = {}));

// src/common/hashed-custom.mts
var import_common2 = require("@rimbu/common");
var import_list = require("@rimbu/list");
var BlockBuilderBase = class {
  get isEmpty() {
    return this.size === 0;
  }
  forEach(f, state = (0, import_common2.TraverseState)()) {
    if (this.isEmpty || state.halted)
      return;
    if (void 0 !== this.source)
      return this.source.forEach(f, state);
    const { halt } = state;
    if (void 0 !== this._entries) {
      for (const key in this._entries) {
        f(this._entries[key], state.nextIndex(), halt);
        if (state.halted)
          break;
      }
    }
    if (void 0 !== this._entrySets) {
      for (const key in this._entrySets) {
        this._entrySets[key].forEach(f, state);
        if (state.halted)
          break;
      }
    }
  }
};
var CollisionBuilderBase = class {
  get size() {
    if (void 0 !== this.source)
      return this.source.size;
    return this.entries.length;
  }
  get entries() {
    if (void 0 === this._entries) {
      if (void 0 !== this.source) {
        this._entries = this.source.entries.toBuilder();
      } else {
        this._entries = import_list.List.builder();
      }
    }
    return this._entries;
  }
  forEach(f, state = (0, import_common2.TraverseState)()) {
    if (state.halted)
      return;
    if (void 0 !== this.source) {
      return this.source.forEach(f, state);
    }
    this.entries.forEach(f, state);
  }
};

// src/map-custom/implementation/immutable.mts
var import_base = require("@rimbu/base");
var import_map_custom = require("@rimbu/collection-types/map-custom");
var import_common3 = require("@rimbu/common");
var import_stream2 = require("@rimbu/stream");
var import_custom = require("@rimbu/stream/custom");
var HashMapEmpty = class extends import_map_custom.EmptyBase {
  constructor(context) {
    super();
    this.context = context;
  }
  streamKeys() {
    return import_stream2.Stream.empty();
  }
  streamValues() {
    return import_stream2.Stream.empty();
  }
  get(key, otherwise) {
    return (0, import_common3.OptLazy)(otherwise);
  }
  hasKey() {
    return false;
  }
  set(key, value) {
    return this.context.emptyBlock().set(key, value);
  }
  addEntry(entry) {
    return this.context.emptyBlock().addEntry(entry);
  }
  addEntries(entries) {
    return this.context.from(entries);
  }
  removeKeyAndGet() {
    return void 0;
  }
  removeKey() {
    return this;
  }
  removeKeys() {
    return this;
  }
  modifyAt(atKey, options) {
    if (void 0 !== options.ifNew) {
      const value = (0, import_common3.OptLazyOr)(options.ifNew, import_base.Token);
      if (import_base.Token === value)
        return this;
      return this.set(atKey, value);
    }
    return this;
  }
  mapValues() {
    return this;
  }
  updateAt() {
    return this;
  }
  toBuilder() {
    return this.context.builder();
  }
  toString() {
    return `HashMap()`;
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: []
    };
  }
};
var HashMapNonEmptyBase = class extends import_map_custom.NonEmptyBase {
  asNormal() {
    return this;
  }
  streamKeys() {
    return this.stream().map(import_base.Entry.first);
  }
  streamValues() {
    return this.stream().map(import_base.Entry.second);
  }
  hasKey(key) {
    const token = Symbol();
    return token !== this.get(key, token);
  }
  set(key, value) {
    return this.addEntry([key, value]);
  }
  addEntries(entries) {
    if ((0, import_custom.isEmptyStreamSourceInstance)(entries))
      return this;
    const builder = this.toBuilder();
    builder.addEntries(entries);
    return builder.build().assumeNonEmpty();
  }
  removeKeys(keys) {
    if ((0, import_custom.isEmptyStreamSourceInstance)(keys))
      return this;
    const builder = this.toBuilder();
    builder.removeKeys(keys);
    return builder.build();
  }
  updateAt(key, update) {
    if (!this.context.isValidKey(key))
      return this;
    return this.modifyAt(key, {
      ifExists: (value) => (0, import_common3.Update)(value, update)
    });
  }
  removeKey(key) {
    if (!this.context.hasher.isValid(key))
      return this;
    return this.modifyAt(key, {
      ifExists: (_, remove) => remove
    });
  }
  removeKeyAndGet(key) {
    if (!this.context.hasher.isValid(key))
      return void 0;
    const token = Symbol();
    let currentValue = token;
    const newMap = this.modifyAt(key, {
      ifExists: (value, remove) => {
        currentValue = value;
        return remove;
      }
    });
    if (token === currentValue)
      return void 0;
    return [newMap, currentValue];
  }
  filter(pred) {
    const builder = this.context.builder();
    builder.addEntries(this.stream().filter(pred));
    if (builder.size === this.size)
      return this;
    return builder.build();
  }
  toBuilder() {
    return this.context.createBuilder(this);
  }
  toString() {
    return this.stream().join({
      start: "HashMap(",
      sep: ", ",
      end: ")",
      valueToString: (entry) => `${entry[0]} -> ${entry[1]}`
    });
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: this.toArray()
    };
  }
};
var HashMapBlock = class _HashMapBlock extends HashMapNonEmptyBase {
  constructor(context, entries, entrySets, size, level) {
    super();
    this.context = context;
    this.entries = entries;
    this.entrySets = entrySets;
    this.size = size;
    this.level = level;
  }
  copy(entries = this.entries, entrySets = this.entrySets, size = this.size) {
    if (entries === this.entries && entrySets === this.entrySets && size === this.size) {
      return this;
    }
    return new _HashMapBlock(this.context, entries, entrySets, size, this.level);
  }
  stream() {
    if (null !== this.entries) {
      if (null === this.entrySets)
        return import_stream2.Stream.fromObjectValues(this.entries);
      return import_stream2.Stream.fromObjectValues(this.entries).concat(
        import_stream2.Stream.fromObjectValues(this.entrySets).flatMap(
          (entrySet) => entrySet.stream()
        )
      );
    }
    if (null === this.entrySets)
      import_base.RimbuError.throwInvalidStateError();
    return import_stream2.Stream.fromObjectValues(this.entrySets).flatMap(
      (entrySet) => entrySet.stream()
    );
  }
  get(key, otherwise, hash) {
    if (!this.context.hasher.isValid(key))
      return (0, import_common3.OptLazy)(otherwise);
    const keyHash = hash ?? this.context.hash(key);
    const atKeyIndex = this.context.getKeyIndex(this.level, keyHash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const entry = this.entries[atKeyIndex];
      if (this.context.eq(entry[0], key))
        return entry[1];
      return (0, import_common3.OptLazy)(otherwise);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const entrySet = this.entrySets[atKeyIndex];
      return entrySet.get(key, otherwise, keyHash);
    }
    return (0, import_common3.OptLazy)(otherwise);
  }
  addEntry(entry, hash = this.context.hash(entry[0])) {
    const atKeyIndex = this.context.getKeyIndex(this.level, hash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const currentEntry = this.entries[atKeyIndex];
      if (this.context.eq(entry[0], currentEntry[0])) {
        if (Object.is(entry[1], currentEntry[1]))
          return this;
        const newEntries3 = import_base.Arr.copySparse(this.entries);
        newEntries3[atKeyIndex] = entry;
        return this.copy(newEntries3);
      }
      let newEntries2 = import_base.Arr.copySparse(this.entries);
      delete newEntries2[atKeyIndex];
      let isEmpty = true;
      for (const _ in newEntries2) {
        isEmpty = false;
        break;
      }
      if (isEmpty)
        newEntries2 = null;
      if (this.level < this.context.maxDepth) {
        const newEntrySet2 = this.context.block(null, null, 0, this.level + 1).addEntry(currentEntry).addEntry(entry, hash);
        const newEntrySets2 = null === this.entrySets ? [] : import_base.Arr.copySparse(this.entrySets);
        newEntrySets2[atKeyIndex] = newEntrySet2;
        return this.copy(newEntries2, newEntrySets2, this.size + 1);
      }
      const newEntrySet = this.context.collision(
        this.context.listContext.of(currentEntry, entry)
      );
      const newEntrySets = null === this.entrySets ? [] : import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(newEntries2, newEntrySets, this.size + 1);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[atKeyIndex];
      const newEntrySet = currentEntrySet.addEntry(entry, hash);
      if (newEntrySet === currentEntrySet)
        return this;
      const newEntrySets = import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(
        void 0,
        newEntrySets,
        this.size + newEntrySet.size - currentEntrySet.size
      );
    }
    const newEntries = null === this.entries ? [] : import_base.Arr.copySparse(this.entries);
    newEntries[atKeyIndex] = entry;
    return this.copy(newEntries, void 0, this.size + 1);
  }
  modifyAt(atKey, options, atKeyHash = this.context.hash(atKey)) {
    const atKeyIndex = this.context.getKeyIndex(this.level, atKeyHash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const currentEntry = this.entries[atKeyIndex];
      if (this.context.eq(atKey, currentEntry[0])) {
        if (void 0 === options.ifExists)
          return this;
        const currentValue = currentEntry[1];
        const newValue3 = options.ifExists(currentValue, import_base.Token);
        if (Object.is(newValue3, currentValue))
          return this;
        const newEntries3 = import_base.Arr.copySparse(this.entries);
        if (import_base.Token === newValue3) {
          delete newEntries3[atKeyIndex];
          for (const _ in newEntries3) {
            return this.copy(newEntries3, void 0, this.size - 1);
          }
          if (this.size === 1)
            return this.context.empty();
          return this.copy(null, void 0, this.size - 1);
        }
        newEntries3[atKeyIndex] = [atKey, newValue3];
        return this.copy(newEntries3);
      }
      if (void 0 === options.ifNew)
        return this;
      const newValue2 = (0, import_common3.OptLazyOr)(options.ifNew, import_base.Token);
      if (import_base.Token === newValue2)
        return this;
      let newEntries2 = import_base.Arr.copySparse(this.entries);
      delete newEntries2[atKeyIndex];
      let isEmpty = true;
      for (const _ in newEntries2) {
        isEmpty = false;
        break;
      }
      if (isEmpty)
        newEntries2 = null;
      if (this.level < this.context.maxDepth) {
        const newEntrySet2 = this.context.block(null, null, 0, this.level + 1).addEntry(currentEntry).set(atKey, newValue2);
        const newEntrySets2 = null === this.entrySets ? [] : import_base.Arr.copySparse(this.entrySets);
        newEntrySets2[atKeyIndex] = newEntrySet2;
        return this.copy(newEntries2, newEntrySets2, this.size + 1);
      }
      const newEntry2 = [atKey, newValue2];
      const newEntrySet = this.context.collision(
        this.context.listContext.of(currentEntry, newEntry2)
      );
      const newEntrySets = null === this.entrySets ? [] : import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(newEntries2, newEntrySets, this.size + 1);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[atKeyIndex];
      const newEntrySet = currentEntrySet.modifyAt(atKey, options, atKeyHash);
      if (newEntrySet === currentEntrySet)
        return this;
      if (newEntrySet.size === 1) {
        let firstEntry = void 0;
        if (this.context.isHashMapBlock(newEntrySet)) {
          for (const key in newEntrySet.entries) {
            firstEntry = newEntrySet.entries[key];
            break;
          }
        } else {
          firstEntry = newEntrySet.entries.first();
        }
        const newEntries2 = null === this.entries ? [] : import_base.Arr.copySparse(this.entries);
        newEntries2[atKeyIndex] = firstEntry;
        const newEntrySets2 = import_base.Arr.copySparse(this.entrySets);
        delete newEntrySets2[atKeyIndex];
        return this.copy(newEntries2, newEntrySets2, this.size - 1);
      }
      const newEntrySets = import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(
        void 0,
        newEntrySets,
        this.size + newEntrySet.size - currentEntrySet.size
      );
    }
    if (void 0 === options.ifNew)
      return this;
    const newValue = (0, import_common3.OptLazyOr)(options.ifNew, import_base.Token);
    if (import_base.Token === newValue)
      return this;
    const newEntry = [atKey, newValue];
    const newEntries = null === this.entries ? [] : import_base.Arr.copySparse(this.entries);
    newEntries[atKeyIndex] = newEntry;
    return this.copy(newEntries, void 0, this.size + 1);
  }
  forEach(f, state = (0, import_common3.TraverseState)()) {
    if (state.halted)
      return;
    const { halt } = state;
    if (null !== this.entries) {
      for (const key in this.entries) {
        f(this.entries[key], state.nextIndex(), halt);
        if (state.halted)
          return;
      }
    }
    if (null !== this.entrySets) {
      for (const key in this.entrySets) {
        this.entrySets[key].forEach(f, state);
        if (state.halted)
          return;
      }
    }
  }
  mapValues(mapFun) {
    const newEntries = null === this.entries ? null : import_base.Arr.mapSparse(this.entries, (e) => [
      e[0],
      mapFun(e[1], e[0])
    ]);
    const newEntrySets = null === this.entrySets ? null : import_base.Arr.mapSparse(
      this.entrySets,
      (es) => es.mapValues(mapFun)
    );
    return new _HashMapBlock(
      this.context,
      newEntries,
      newEntrySets,
      this.size,
      this.level
    );
  }
  toArray() {
    let result = [];
    if (null !== this.entries) {
      result = import_stream2.Stream.fromObjectValues(this.entries).toArray();
    }
    if (null !== this.entrySets) {
      import_stream2.Stream.fromObjectValues(this.entrySets).forEach(
        (entrySet) => {
          result = result.concat(entrySet.toArray());
        }
      );
    }
    return result;
  }
};
var HashMapCollision = class _HashMapCollision extends HashMapNonEmptyBase {
  constructor(context, entries) {
    super();
    this.context = context;
    this.entries = entries;
  }
  get size() {
    return this.entries.length;
  }
  copy(entries = this.entries) {
    if (entries === this.entries)
      return this;
    return new _HashMapCollision(this.context, entries);
  }
  stream() {
    return this.entries.stream();
  }
  get(key, otherwise, keyHash) {
    if (!this.context.hasher.isValid(key))
      return (0, import_common3.OptLazy)(otherwise);
    const token = Symbol();
    const stream = this.stream();
    const foundEntry = stream.find(
      (entry) => this.context.eq(entry[0], key),
      void 0,
      token
    );
    if (token === foundEntry)
      return (0, import_common3.OptLazy)(otherwise);
    return foundEntry[1];
  }
  addEntry(entry, hash) {
    const currentIndex = this.stream().indexWhere(
      (currentEntry) => this.context.eq(currentEntry[0], entry[0])
    );
    if (void 0 === currentIndex) {
      return this.copy(this.entries.append(entry));
    }
    return this.copy(
      this.entries.updateAt(currentIndex, (currentEntry) => {
        if (Object.is(currentEntry[1], entry[1]))
          return currentEntry;
        return entry;
      })
    );
  }
  modifyAt(atKey, options, atKeyHash) {
    const currentIndex = this.stream().indexWhere(
      (entry) => this.context.eq(entry[0], atKey)
    );
    if (void 0 === currentIndex) {
      if (void 0 === options.ifNew)
        return this;
      const newValue2 = (0, import_common3.OptLazyOr)(options.ifNew, import_base.Token);
      if (import_base.Token === newValue2)
        return this;
      const newEntries2 = this.entries.append([atKey, newValue2]);
      return this.copy(newEntries2);
    }
    if (void 0 === options.ifExists)
      return this;
    const currentEntry = this.entries.get(
      currentIndex,
      import_base.RimbuError.throwInvalidStateError
    );
    const currentValue = currentEntry[1];
    const newValue = options.ifExists(currentValue, import_base.Token);
    if (import_base.Token === newValue) {
      const newEntries2 = this.entries.remove(currentIndex, 1).assumeNonEmpty();
      return this.copy(newEntries2);
    }
    if (Object.is(newValue, currentValue))
      return this;
    const newEntry = [atKey, newValue];
    const newEntries = this.entries.updateAt(currentIndex, newEntry);
    return this.copy(newEntries);
  }
  forEach(f, state) {
    if (state.halted)
      return;
    this.entries.forEach(f, state);
  }
  mapValues(mapFun) {
    const newEntries = this.entries.map((e) => [
      e[0],
      mapFun(e[1], e[0])
    ]);
    return new _HashMapCollision(this.context, newEntries);
  }
  toArray() {
    return this.entries.toArray();
  }
};

// src/map-custom/implementation/builder.mts
var import_base2 = require("@rimbu/base");
var import_common4 = require("@rimbu/common");
var import_list2 = require("@rimbu/list");
var import_stream3 = require("@rimbu/stream");
var import_custom2 = require("@rimbu/stream/custom");
var HashMapBlockBuilder = class _HashMapBlockBuilder extends BlockBuilderBase {
  constructor(context, source, _entries, _entrySets, size = source?.size ?? 0, level = source?.level ?? 0) {
    super();
    this.context = context;
    this.source = source;
    this._entries = _entries;
    this._entrySets = _entrySets;
    this.size = size;
    this.level = level;
    this._lock = 0;
    this.get = (key, otherwise, hash) => {
      if (void 0 !== this.source)
        return this.source.get(key, otherwise);
      if (!this.context.hasher.isValid(key))
        return (0, import_common4.OptLazy)(otherwise);
      const keyHash = hash ?? this.context.hash(key);
      const keyIndex = this.context.getKeyIndex(this.level, keyHash);
      if (keyIndex in this.entries) {
        const currentEntry = this.entries[keyIndex];
        if (this.context.eq(key, currentEntry[0]))
          return currentEntry[1];
        return (0, import_common4.OptLazy)(otherwise);
      }
      if (keyIndex in this.entrySets) {
        const currentEntrySet = this.entrySets[keyIndex];
        return currentEntrySet.get(key, otherwise, keyHash);
      }
      return (0, import_common4.OptLazy)(otherwise);
    };
    // prettier-ignore
    this.hasKey = (key) => {
      const token = Symbol();
      return token !== this.get(key, token);
    };
    this.addEntry = (entry) => {
      this.checkLock();
      return this.addEntryInternal(entry);
    };
    this.addEntries = (source) => {
      this.checkLock();
      if ((0, import_custom2.isEmptyStreamSourceInstance)(source))
        return false;
      return import_stream3.Stream.from(source).filter(this.addEntry).count() > 0;
    };
    this.set = (key, value) => {
      this.checkLock();
      return this.addEntryInternal([key, value]);
    };
    this.modifyAt = (key, options, keyHash = this.context.hash(key)) => {
      this.checkLock();
      const keyIndex = this.context.getKeyIndex(this.level, keyHash);
      if (keyIndex in this.entries) {
        const currentEntry = this.entries[keyIndex];
        const [currentKey, currentValue] = currentEntry;
        if (this.context.eq(key, currentKey)) {
          if (void 0 === options.ifExists)
            return false;
          const newValue3 = options.ifExists(currentValue, import_base2.Token);
          if (Object.is(newValue3, currentValue)) {
            return false;
          }
          this.source = void 0;
          if (import_base2.Token === newValue3) {
            this.size--;
            delete this.entries[keyIndex];
            return true;
          }
          const newEntry = [key, newValue3];
          this.entries[keyIndex] = newEntry;
          return true;
        }
        if (void 0 === options.ifNew)
          return false;
        const newValue2 = (0, import_common4.OptLazyOr)(options.ifNew, import_base2.Token);
        if (import_base2.Token === newValue2)
          return false;
        this.source = void 0;
        this.size++;
        delete this.entries[keyIndex];
        const newEntrySet = this.level < this.context.maxDepth ? new _HashMapBlockBuilder(
          this.context,
          void 0,
          void 0,
          void 0,
          0,
          this.level + 1
        ) : new HashMapCollisionBuilder(this.context);
        newEntrySet.addEntryInternal(currentEntry);
        newEntrySet.addEntryInternal([key, newValue2], keyHash);
        this.entrySets[keyIndex] = newEntrySet;
        return true;
      }
      if (keyIndex in this.entrySets) {
        const entrySet = this.entrySets[keyIndex];
        const preSize = entrySet.size;
        const result = entrySet.modifyAt(key, options, keyHash);
        if (result)
          this.source = void 0;
        this.size += entrySet.size - preSize;
        if (entrySet.size > 1)
          return result;
        let first = void 0;
        if (this.context.isHashMapBlockBuilder(entrySet)) {
          for (const index in entrySet.entries) {
            first = entrySet.entries[index];
            break;
          }
        } else {
          first = entrySet.entries.get(0, import_base2.RimbuError.throwInvalidStateError);
        }
        delete this.entrySets[keyIndex];
        this.entries[keyIndex] = first;
        return true;
      }
      if (void 0 === options.ifNew)
        return false;
      const newValue = (0, import_common4.OptLazyOr)(options.ifNew, import_base2.Token);
      if (import_base2.Token === newValue)
        return false;
      this.source = void 0;
      this.size++;
      this.entries[keyIndex] = [key, newValue];
      return true;
    };
    // prettier-ignore
    this.updateAt = (key, update, otherwise) => {
      let result;
      let found = false;
      this.modifyAt(key, {
        ifExists: (value) => {
          result = value;
          found = true;
          return (0, import_common4.Update)(value, update);
        }
      });
      if (!found)
        return (0, import_common4.OptLazy)(otherwise);
      return result;
    };
    this.removeKey = (key, otherwise) => {
      this.checkLock();
      if (!this.context.hasher.isValid(key))
        return (0, import_common4.OptLazy)(otherwise);
      let removedValue;
      let found = false;
      this.modifyAt(key, {
        ifExists: (currentValue, remove) => {
          removedValue = currentValue;
          found = true;
          return remove;
        }
      });
      if (!found)
        return (0, import_common4.OptLazy)(otherwise);
      return removedValue;
    };
    // prettier-ignore
    this.removeKeys = (keys) => {
      this.checkLock();
      if ((0, import_custom2.isEmptyStreamSourceInstance)(keys))
        return false;
      const notFound = Symbol();
      return import_stream3.Stream.from(keys).mapPure(this.removeKey, notFound).countNotElement(notFound) > 0;
    };
    this.forEach = (f, state = (0, import_common4.TraverseState)()) => {
      this._lock++;
      super.forEach(f, state);
      this._lock--;
    };
    this.build = () => {
      if (this.size === 0)
        return this.context.empty();
      return this.buildNE();
    };
    // prettier-ignore
    this.buildMapValues = (f) => {
      if (this.size === 0) {
        return this.context.empty();
      }
      if (void 0 !== this.source)
        return this.source.mapValues(f);
      const entries = this.entries.length === 0 ? null : import_base2.Arr.mapSparse(this.entries, (e) => [
        e[0],
        f(e[1], e[0])
      ]);
      const entrySets = this.entrySets.length === 0 ? null : import_base2.Arr.mapSparse(
        this.entrySets,
        (entrySet) => entrySet.buildMapValues(f)
      );
      return this.context.block(entries, entrySets, this.size, this.level);
    };
  }
  checkLock() {
    if (this._lock)
      import_base2.RimbuError.throwModifiedBuilderWhileLoopingOverItError();
  }
  prepareMutate() {
    if (void 0 === this._entries) {
      if (void 0 !== this.source) {
        this._entries = null === this.source.entries ? [] : import_base2.Arr.copySparse(this.source.entries);
      } else {
        this._entries = [];
      }
    }
    if (void 0 === this._entrySets) {
      if (void 0 !== this.source) {
        this._entrySets = null === this.source.entrySets ? [] : import_base2.Arr.mapSparse(
          this.source.entrySets,
          (entrySet) => {
            if (this.context.isHashMapBlock(entrySet)) {
              return new _HashMapBlockBuilder(this.context, entrySet);
            }
            return new HashMapCollisionBuilder(this.context, entrySet);
          }
        ) ?? [];
      } else {
        this._entrySets = [];
      }
    }
  }
  get entries() {
    this.prepareMutate();
    return this._entries;
  }
  get entrySets() {
    this.prepareMutate();
    return this._entrySets;
  }
  addEntryInternal(entry, hash = this.context.hash(entry[0])) {
    const keyIndex = this.context.getKeyIndex(this.level, hash);
    if (keyIndex in this.entries) {
      const currentEntry = this.entries[keyIndex];
      if (this.context.eq(entry[0], currentEntry[0])) {
        if (Object.is(entry[1], currentEntry[1]))
          return false;
        this.source = void 0;
        this.entries[keyIndex] = entry;
        return true;
      }
      this.source = void 0;
      this.size++;
      delete this.entries[keyIndex];
      if (this.level < this.context.maxDepth) {
        const newEntrySet2 = new _HashMapBlockBuilder(
          this.context,
          void 0,
          void 0,
          void 0,
          0,
          this.level + 1
        );
        newEntrySet2.addEntryInternal(currentEntry);
        newEntrySet2.addEntryInternal(entry, hash);
        this.entrySets[keyIndex] = newEntrySet2;
        return true;
      }
      const newEntries = import_list2.List.builder();
      newEntries.append(currentEntry);
      newEntries.append(entry);
      const newEntrySet = new HashMapCollisionBuilder(
        this.context,
        void 0,
        newEntries
      );
      this.entrySets[keyIndex] = newEntrySet;
      return true;
    }
    if (keyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[keyIndex];
      const preSize = currentEntrySet.size;
      const changed = currentEntrySet.addEntryInternal(entry, hash);
      if (changed)
        this.source = void 0;
      this.size += currentEntrySet.size - preSize;
      return changed;
    }
    this.source = void 0;
    this.size++;
    this.entries[keyIndex] = entry;
    return true;
  }
  buildNE() {
    if (void 0 !== this.source)
      return this.source;
    const entries = this.entries.length === 0 ? null : import_base2.Arr.copySparse(this.entries);
    const entrySets = this.entrySets.length === 0 ? null : import_base2.Arr.mapSparse(this.entrySets, (entrySet) => entrySet.buildNE());
    return this.context.block(entries, entrySets, this.size, this.level);
  }
};
var HashMapCollisionBuilder = class extends CollisionBuilderBase {
  constructor(context, source, _entries) {
    super();
    this.context = context;
    this.source = source;
    this._entries = _entries;
  }
  get(key, otherwise, hash) {
    if (!this.context.hasher.isValid(key))
      return (0, import_common4.OptLazy)(otherwise);
    if (void 0 !== this.source)
      return this.source.get(key, otherwise);
    const token = Symbol();
    let result = token;
    this.entries.forEach((e, _, halt) => {
      if (this.context.eq(key, e[0])) {
        result = e[1];
        halt();
      }
    });
    if (token === result)
      return (0, import_common4.OptLazy)(otherwise);
    return result;
  }
  addEntryInternal(entry) {
    let index = -1;
    this.entries.forEach((e, i, halt) => {
      if (this.context.eq(e[0], entry[0])) {
        index = i;
        halt();
      }
    });
    if (index < 0) {
      this.source = void 0;
      this.entries.append(entry);
      return true;
    }
    const oldEntry = this.entries.updateAt(
      index,
      (currentEntry) => {
        if (Object.is(currentEntry[1], entry[1]))
          return currentEntry;
        return entry;
      }
    );
    const changed = void 0 === oldEntry || !Object.is(oldEntry[1], entry[1]) || !Object.is(oldEntry[0], entry[0]);
    if (changed) {
      this.source = void 0;
    }
    return changed;
  }
  set(key, value) {
    return this.addEntryInternal([key, value]);
  }
  modifyAt(atKey, options) {
    let index = -1;
    let foundEntry = void 0;
    this.entries.forEach((e, i, halt) => {
      if (this.context.eq(e[0], atKey)) {
        index = i;
        foundEntry = e;
        halt();
      }
    });
    if (void 0 === foundEntry) {
      if (void 0 === options.ifNew)
        return false;
      const newValue2 = (0, import_common4.OptLazyOr)(options.ifNew, import_base2.Token);
      if (import_base2.Token === newValue2)
        return false;
      this.source = void 0;
      this.entries.append([atKey, newValue2]);
      return true;
    }
    if (void 0 === options.ifExists)
      return false;
    const newValue = options.ifExists(foundEntry[1], import_base2.Token);
    if (Object.is(newValue, foundEntry[1]))
      return false;
    if (import_base2.Token === newValue) {
      this.source = void 0;
      this.entries.remove(index);
      return true;
    }
    const result = this.entries.set(index, [atKey, newValue]);
    const changed = void 0 !== result;
    if (changed)
      this.source = void 0;
    return changed;
  }
  buildNE() {
    if (void 0 !== this.source)
      return this.source;
    return this.context.collision(this.entries.build().assumeNonEmpty());
  }
  buildMapValues(f) {
    if (void 0 !== this.source)
      return this.source.mapValues(f);
    return this.context.collision(
      this.entries.buildMap((entry) => [
        entry[0],
        f(entry[1], entry[0])
      ]).assumeNonEmpty()
    );
  }
};

// src/map-custom/implementation/context.mts
var import_map_custom2 = require("@rimbu/collection-types/map-custom");
var import_common6 = require("@rimbu/common");
var import_list3 = require("@rimbu/list");
var HashMapContext = class extends import_map_custom2.RMapBase.ContextBase {
  constructor(hasher, eq, blockSizeBits, listContext) {
    super();
    this.hasher = hasher;
    this.eq = eq;
    this.blockSizeBits = blockSizeBits;
    this.listContext = listContext;
    this.typeTag = "HashMap";
    this.builder = () => {
      return new HashMapBlockBuilder(this);
    };
    this.blockCapacity = 1 << blockSizeBits;
    this.blockMask = this.blockCapacity - 1;
    this.maxDepth = Math.ceil(32 / blockSizeBits);
    this._empty = Object.freeze(new HashMapEmpty(this));
    this._emptyBlock = Object.freeze(new HashMapBlock(this, null, null, 0, 0));
  }
  hash(value) {
    return this.hasher.hash(value);
  }
  getKeyIndex(level, hash) {
    const shift = this.blockSizeBits * level;
    return hash >>> shift & this.blockMask;
  }
  isNonEmptyInstance(source) {
    return source instanceof HashMapNonEmptyBase;
  }
  createBuilder(source) {
    return new HashMapBlockBuilder(
      this,
      source
    );
  }
  isValidKey(key) {
    return this.hasher.isValid(key);
  }
  emptyBlock() {
    return this._emptyBlock;
  }
  block(entries, entrySets, size, level) {
    return new HashMapBlock(this, entries, entrySets, size, level);
  }
  collision(entries) {
    return new HashMapCollision(this, entries);
  }
  isHashMapBlock(obj) {
    return obj instanceof HashMapBlock;
  }
  isHashMapBlockBuilder(obj) {
    return obj instanceof HashMapBlockBuilder;
  }
};
function createHashMapContext(options) {
  return Object.freeze(
    new HashMapContext(
      options?.hasher ?? Hasher.defaultHasher(),
      options?.eq ?? import_common6.Eq.defaultEq(),
      options?.blockSizeBits ?? 5,
      options?.listContext ?? import_list3.List.defaultContext()
    )
  );
}

// src/map/interface/index.mts
var _defaultContext = createHashMapContext();
var HashMap = Object.freeze({
  ..._defaultContext,
  createContext: createHashMapContext,
  defaultContext() {
    return _defaultContext;
  }
});

// src/set-custom/implementation/immutable.mts
var import_base3 = require("@rimbu/base");
var import_set_custom = require("@rimbu/collection-types/set-custom");
var import_common8 = require("@rimbu/common");
var import_stream4 = require("@rimbu/stream");
var import_custom3 = require("@rimbu/stream/custom");
var HashSetEmpty = class extends import_set_custom.EmptyBase {
  constructor(context) {
    super();
    this.context = context;
    this.addAll = context.from;
  }
  has() {
    return false;
  }
  add(value) {
    return this.context.emptyBlock().add(value);
  }
  remove() {
    return this;
  }
  removeAll() {
    return this;
  }
  union(other) {
    if (this.context.isHashSetBlock(other) || this.context.isHashSetCollision(other)) {
      if (other.context === this.context)
        return other;
    }
    return this.context.from(other);
  }
  difference() {
    return this.context.empty();
  }
  intersect() {
    return this.context.empty();
  }
  symDifference(other) {
    return this.union(other);
  }
  toBuilder() {
    return this.context.builder();
  }
  toString() {
    return `HashSet()`;
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: []
    };
  }
};
var HashSetNonEmptyBase = class extends import_set_custom.NonEmptyBase {
  asNormal() {
    return this;
  }
  addAll(values) {
    if ((0, import_custom3.isEmptyStreamSourceInstance)(values))
      return this;
    const builder = this.toBuilder();
    builder.addAll(values);
    return builder.build();
  }
  removeAll(values) {
    if ((0, import_custom3.isEmptyStreamSourceInstance)(values))
      return this;
    const builder = this.toBuilder();
    builder.removeAll(values);
    return builder.build();
  }
  filter(pred) {
    const builder = this.context.builder();
    builder.addAll(this.stream().filter(pred));
    if (builder.size === this.size)
      return this;
    return builder.build();
  }
  union(other) {
    if (other === this)
      return this;
    if ((0, import_custom3.isEmptyStreamSourceInstance)(other))
      return this;
    const builder = this.toBuilder();
    builder.addAll(other);
    return builder.build().assumeNonEmpty();
  }
  difference(other) {
    if (other === this)
      return this.context.empty();
    if ((0, import_custom3.isEmptyStreamSourceInstance)(other))
      return this;
    const builder = this.toBuilder();
    builder.removeAll(other);
    return builder.build();
  }
  intersect(other) {
    if (other === this)
      return this;
    if ((0, import_custom3.isEmptyStreamSourceInstance)(other))
      return this.context.empty();
    const builder = this.context.builder();
    const it = import_stream4.Stream.from(other)[Symbol.iterator]();
    const done = Symbol("Done");
    let value;
    while (done !== (value = it.fastNext(done))) {
      if (this.has(value))
        builder.add(value);
    }
    if (builder.size === this.size)
      return this;
    return builder.build();
  }
  symDifference(other) {
    if (other === this)
      return this.context.empty();
    if ((0, import_custom3.isEmptyStreamSourceInstance)(other))
      return this;
    const builder = this.toBuilder();
    import_stream4.Stream.from(other).filterNot(builder.remove).forEach(builder.add);
    return builder.build();
  }
  toBuilder() {
    return this.context.createBuilder(this);
  }
  toString() {
    return this.stream().join({ start: "HashSet(", sep: ", ", end: ")" });
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: []
    };
  }
};
var HashSetBlock = class _HashSetBlock extends HashSetNonEmptyBase {
  constructor(context, entries, entrySets, size, level) {
    super();
    this.context = context;
    this.entries = entries;
    this.entrySets = entrySets;
    this.size = size;
    this.level = level;
  }
  copy(entries = this.entries, entrySets = this.entrySets, size = this.size) {
    if (entries === this.entries && entrySets === this.entrySets && size === this.size) {
      return this;
    }
    return new _HashSetBlock(this.context, entries, entrySets, size, this.level);
  }
  stream() {
    if (null !== this.entries) {
      if (null === this.entrySets) {
        return import_stream4.Stream.fromObjectValues(this.entries);
      }
      return import_stream4.Stream.fromObjectValues(this.entries).concat(
        import_stream4.Stream.fromObjectValues(this.entrySets).flatMap(
          (entrySet) => entrySet.stream()
        )
      );
    }
    if (null === this.entrySets) {
      import_base3.RimbuError.throwInvalidStateError();
    }
    return import_stream4.Stream.fromObjectValues(this.entrySets).flatMap(
      (entrySet) => entrySet.stream()
    );
  }
  has(value, inHash) {
    if (!this.context.hasher.isValid(value))
      return false;
    const hash = inHash ?? this.context.hash(value);
    const atKeyIndex = this.context.getKeyIndex(this.level, hash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const entry = this.entries[atKeyIndex];
      return this.context.eq(entry, value);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const entrySet = this.entrySets[atKeyIndex];
      return entrySet.has(value, hash);
    }
    return false;
  }
  add(value, hash = this.context.hash(value)) {
    const atKeyIndex = this.context.getKeyIndex(this.level, hash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const currentValue = this.entries[atKeyIndex];
      if (this.context.eq(value, currentValue))
        return this;
      let newEntries2 = import_base3.Arr.copySparse(this.entries);
      delete newEntries2[atKeyIndex];
      let isEmpty = true;
      for (const _ in newEntries2) {
        isEmpty = false;
        break;
      }
      if (isEmpty)
        newEntries2 = null;
      if (this.level < this.context.maxDepth) {
        const newEntrySet2 = this.context.block(null, null, 0, this.level + 1).add(currentValue).add(value, hash);
        const newEntrySets2 = null === this.entrySets ? [] : import_base3.Arr.copySparse(this.entrySets);
        newEntrySets2[atKeyIndex] = newEntrySet2;
        return this.copy(newEntries2, newEntrySets2, this.size + 1);
      }
      const newEntrySet = this.context.collision(
        this.context.listContext.of(currentValue, value)
      );
      const newEntrySets = null === this.entrySets ? [] : import_base3.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(newEntries2, newEntrySets, this.size + 1);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[atKeyIndex];
      const newEntrySet = currentEntrySet.add(value, hash);
      if (newEntrySet === currentEntrySet)
        return this;
      const newEntrySets = import_base3.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(
        void 0,
        newEntrySets,
        this.size + newEntrySet.size - currentEntrySet.size
      );
    }
    const newEntries = null === this.entries ? [] : import_base3.Arr.copySparse(this.entries);
    newEntries[atKeyIndex] = value;
    return this.copy(newEntries, void 0, this.size + 1);
  }
  remove(value, hash) {
    if (!this.context.hasher.isValid(value))
      return this;
    const valueHash = hash ?? this.context.hash(value);
    const atKeyIndex = this.context.getKeyIndex(this.level, valueHash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const currentValue = this.entries[atKeyIndex];
      if (!this.context.eq(currentValue, value))
        return this;
      if (this.size === 1)
        return this.context.empty();
      const newEntries = import_base3.Arr.copySparse(this.entries);
      delete newEntries[atKeyIndex];
      for (const _ in newEntries) {
        return this.copy(newEntries, void 0, this.size - 1);
      }
      return this.copy(null, void 0, this.size - 1);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[atKeyIndex];
      const newEntrySet = currentEntrySet.remove(
        value,
        hash
      );
      if (newEntrySet === currentEntrySet)
        return this;
      if (newEntrySet.size === 1) {
        let firstValue = void 0;
        if (this.context.isHashSetBlock(newEntrySet)) {
          for (const key in newEntrySet.entries) {
            firstValue = newEntrySet.entries[key];
            break;
          }
        } else {
          firstValue = newEntrySet.entries.first();
        }
        const newEntries = null === this.entries ? [] : import_base3.Arr.copySparse(this.entries);
        newEntries[atKeyIndex] = firstValue;
        const newEntrySets2 = import_base3.Arr.copySparse(this.entrySets);
        delete newEntrySets2[atKeyIndex];
        return this.copy(newEntries, newEntrySets2, this.size - 1);
      }
      const newEntrySets = import_base3.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(
        void 0,
        newEntrySets,
        this.size - currentEntrySet.size + newEntrySet.size
      );
    }
    return this;
  }
  forEach(f, state = (0, import_common8.TraverseState)()) {
    if (state.halted)
      return;
    const { halt } = state;
    if (null !== this.entries) {
      for (const key in this.entries) {
        f(this.entries[key], state.nextIndex(), halt);
        if (state.halted)
          return;
      }
    }
    if (null !== this.entrySets) {
      for (const key in this.entrySets) {
        this.entrySets[key].forEach(f, state);
        if (state.halted)
          return;
      }
    }
  }
  toArray() {
    let result = [];
    if (null !== this.entries) {
      for (const key in this.entries) {
        result.push(this.entries[key]);
      }
    }
    if (null !== this.entrySets) {
      for (const key in this.entrySets) {
        result = result.concat(this.entrySets[key].toArray());
      }
    }
    return result;
  }
};
var HashSetCollision = class _HashSetCollision extends HashSetNonEmptyBase {
  constructor(context, entries) {
    super();
    this.context = context;
    this.entries = entries;
  }
  get size() {
    return this.entries.length;
  }
  copy(entries = this.entries) {
    if (entries === this.entries)
      return this;
    return new _HashSetCollision(this.context, entries);
  }
  stream() {
    return this.entries.stream();
  }
  has(value, inHash) {
    if (!this.context.hasher.isValid(value))
      return false;
    return this.stream().contains(value, void 0, this.context.eq);
  }
  add(value) {
    const currentIndex = this.stream().indexOf(
      value,
      void 0,
      this.context.eq
    );
    if (void 0 === currentIndex) {
      return this.copy(this.entries.append(value));
    }
    return this.copy(this.entries.updateAt(currentIndex, value));
  }
  remove(value, hash) {
    if (!this.context.hasher.isValid(value))
      return this;
    const currentIndex = this.stream().indexOf(
      value,
      void 0,
      this.context.eq
    );
    if (void 0 === currentIndex)
      return this;
    const newEntries = this.entries.remove(currentIndex, 1).assumeNonEmpty();
    return this.copy(newEntries);
  }
  forEach(f, state = (0, import_common8.TraverseState)()) {
    if (state.halted)
      return;
    this.entries.forEach(f, state);
  }
  toArray() {
    return this.entries.toArray();
  }
};

// src/set-custom/implementation/builder.mts
var import_base4 = require("@rimbu/base");
var import_common9 = require("@rimbu/common");
var import_list4 = require("@rimbu/list");
var import_stream5 = require("@rimbu/stream");
var HashSetBlockBuilder = class _HashSetBlockBuilder extends BlockBuilderBase {
  constructor(context, source, _entries, _entrySets, size = source?.size ?? 0, level = source?.level ?? 0) {
    super();
    this.context = context;
    this.source = source;
    this._entries = _entries;
    this._entrySets = _entrySets;
    this.size = size;
    this.level = level;
    this._lock = 0;
    // prettier-ignore
    this.has = (value) => {
      if (void 0 !== this.source)
        return this.source.has(value);
      if (!this.context.hasher.isValid(value))
        return false;
      return this.hasInternal(value);
    };
    this.add = (value) => {
      this.checkLock();
      return this.addInternal(value);
    };
    this.addAll = (source) => {
      this.checkLock();
      return import_stream5.Stream.from(source).filterPure(this.add).count() > 0;
    };
    // prettier-ignore
    this.remove = (value) => {
      this.checkLock();
      if (!this.context.hasher.isValid(value))
        return false;
      return this.removeInternal(value);
    };
    // prettier-ignore
    this.removeAll = (values) => {
      this.checkLock();
      return import_stream5.Stream.from(values).filterPure(this.remove).count() > 0;
    };
    this.forEach = (f, state = (0, import_common9.TraverseState)()) => {
      this._lock++;
      super.forEach(f, state);
      this._lock--;
    };
    this.build = () => {
      if (this.size === 0)
        return this.context.empty();
      return this.buildNE();
    };
  }
  checkLock() {
    if (this._lock)
      import_base4.RimbuError.throwModifiedBuilderWhileLoopingOverItError();
  }
  prepareMutate() {
    if (void 0 === this._entries) {
      if (void 0 !== this.source) {
        this._entries = null === this.source.entries ? [] : import_base4.Arr.copySparse(this.source.entries);
      } else {
        this._entries = [];
      }
    }
    if (void 0 === this._entrySets) {
      if (void 0 !== this.source && null !== this.source.entrySets) {
        this._entrySets = import_base4.Arr.mapSparse(
          this.source.entrySets,
          (entrySet) => {
            if (this.context.isHashSetBlock(entrySet)) {
              return new _HashSetBlockBuilder(this.context, entrySet);
            }
            return new HashSetCollisionBuilder(this.context, entrySet);
          }
        );
      } else {
        this._entrySets = [];
      }
    }
  }
  get entries() {
    this.prepareMutate();
    return this._entries;
  }
  get entrySets() {
    this.prepareMutate();
    return this._entrySets;
  }
  hasInternal(value, hash = this.context.hash(value)) {
    if (void 0 !== this.source)
      return this.source.has(value, hash);
    const keyIndex = this.context.getKeyIndex(this.level, hash);
    if (keyIndex in this.entries) {
      return this.context.eq(value, this.entries[keyIndex]);
    }
    if (keyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[keyIndex];
      return currentEntrySet.hasInternal(value, hash);
    }
    return false;
  }
  addInternal(value, hash = this.context.hash(value)) {
    const keyIndex = this.context.getKeyIndex(this.level, hash);
    if (keyIndex in this.entries) {
      const currentEntry = this.entries[keyIndex];
      if (this.context.eq(value, currentEntry))
        return false;
      this.source = void 0;
      this.size++;
      delete this.entries[keyIndex];
      if (this.level < this.context.maxDepth) {
        const newEntrySet2 = new _HashSetBlockBuilder(
          this.context,
          void 0,
          void 0,
          void 0,
          0,
          this.level + 1
        );
        newEntrySet2.addInternal(currentEntry);
        newEntrySet2.addInternal(value, hash);
        this.entrySets[keyIndex] = newEntrySet2;
        return true;
      }
      const newEntries = import_list4.List.builder();
      newEntries.append(currentEntry);
      newEntries.append(value);
      const newEntrySet = new HashSetCollisionBuilder(
        this.context,
        void 0,
        newEntries
      );
      this.entrySets[keyIndex] = newEntrySet;
      return true;
    }
    if (keyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[keyIndex];
      const preSize = currentEntrySet.size;
      const changed = currentEntrySet.addInternal(value, hash);
      if (changed)
        this.source = void 0;
      this.size += currentEntrySet.size - preSize;
      return changed;
    }
    this.source = void 0;
    this.size++;
    this.entries[keyIndex] = value;
    return true;
  }
  removeInternal(value, hash = this.context.hash(value)) {
    const index = this.context.getKeyIndex(this.level, hash);
    if (index in this.entries) {
      const currentValue = this.entries[index];
      if (!this.context.eq(value, currentValue))
        return false;
      this.source = void 0;
      this.size--;
      delete this.entries[index];
      return true;
    }
    if (index in this.entrySets) {
      const entrySet = this.entrySets[index];
      const preSize = entrySet.size;
      if (!entrySet.removeInternal(value, hash)) {
        return false;
      }
      this.source = void 0;
      this.size += entrySet.size - preSize;
      if (entrySet.size > 1)
        return true;
      let first = void 0;
      if (this.context.isHashSetBlockBuilder(entrySet)) {
        for (const i in entrySet.entries) {
          first = entrySet.entries[i];
          break;
        }
      } else {
        first = entrySet.entries.get(0, import_base4.RimbuError.throwInvalidStateError);
      }
      delete this.entrySets[index];
      let hasEntrySets = false;
      for (const _ in this.entrySets) {
        hasEntrySets = true;
        break;
      }
      if (!hasEntrySets) {
        this.entrySets.length = 0;
      }
      this.entries[index] = first;
      return true;
    }
    return false;
  }
  buildNE() {
    if (void 0 !== this.source)
      return this.source;
    const entries = this.entries.length === 0 ? null : import_base4.Arr.copySparse(this.entries);
    const entrySets = this.entrySets.length === 0 ? null : import_base4.Arr.mapSparse(this.entrySets, (entrySet) => entrySet.buildNE());
    return this.context.block(entries, entrySets, this.size, this.level);
  }
};
var HashSetCollisionBuilder = class extends CollisionBuilderBase {
  constructor(context, source, _entries) {
    super();
    this.context = context;
    this.source = source;
    this._entries = _entries;
  }
  hasInternal(value, hash) {
    if (void 0 !== this.source)
      return this.source.has(value, hash);
    let result = false;
    this.entries.forEach((v, _, halt) => {
      if (this.context.eq(v, value)) {
        result = true;
        halt();
      }
    });
    return result;
  }
  addInternal(value) {
    let index = -1;
    this.entries.forEach((v, i, halt) => {
      if (this.context.eq(v, value)) {
        index = i;
        halt();
      }
    });
    if (index < 0) {
      this.source = void 0;
      this.entries.append(value);
      return true;
    }
    const token = Symbol();
    const oldValue = this.entries.set(index, value, token);
    const changed = token === oldValue || !this.context.eq(oldValue, value);
    if (changed)
      this.source = void 0;
    return changed;
  }
  removeInternal(value) {
    let index = -1;
    this.entries.forEach((v, i, halt) => {
      if (this.context.eq(v, value)) {
        index = i;
        halt();
      }
    });
    if (index < 0)
      return false;
    this.source = void 0;
    this.entries.remove(index);
    return true;
  }
  buildNE() {
    return this.source ?? this.context.collision(this.entries.build().assumeNonEmpty());
  }
};

// src/set-custom/implementation/context.mts
var import_set_custom2 = require("@rimbu/collection-types/set-custom");
var import_common11 = require("@rimbu/common");
var import_list5 = require("@rimbu/list");
var HashSetContext = class extends import_set_custom2.RSetBase.ContextBase {
  constructor(hasher, eq, blockSizeBits, listContext) {
    super();
    this.hasher = hasher;
    this.eq = eq;
    this.blockSizeBits = blockSizeBits;
    this.listContext = listContext;
    this.typeTag = "HashSet";
    this.builder = () => {
      return new HashSetBlockBuilder(this);
    };
    this.blockCapacity = 1 << blockSizeBits;
    this.blockMask = this.blockCapacity - 1;
    this.maxDepth = Math.ceil(32 / blockSizeBits);
    this._empty = Object.freeze(new HashSetEmpty(this));
    this._emptyBlock = Object.freeze(new HashSetBlock(this, null, null, 0, 0));
  }
  isNonEmptyInstance(source) {
    return source instanceof HashSetNonEmptyBase;
  }
  hash(value) {
    return this.hasher.hash(value);
  }
  getKeyIndex(level, hash) {
    const shift = this.blockSizeBits * level;
    return hash >>> shift & this.blockMask;
  }
  emptyBlock() {
    return this._emptyBlock;
  }
  isValidValue(value) {
    return this.hasher.isValid(value);
  }
  createBuilder(source) {
    return new HashSetBlockBuilder(this, source);
  }
  block(entries, entrySets, size, level) {
    return new HashSetBlock(
      this,
      entries,
      entrySets,
      size,
      level
    );
  }
  collision(entries) {
    return new HashSetCollision(this, entries);
  }
  isHashSetBlock(obj) {
    return obj instanceof HashSetBlock;
  }
  isHashSetCollision(obj) {
    return obj instanceof HashSetCollision;
  }
  isHashSetBlockBuilder(obj) {
    return obj instanceof HashSetBlockBuilder;
  }
};
function createHashSetContext(options) {
  return Object.freeze(
    new HashSetContext(
      options?.hasher ?? Hasher.defaultHasher(),
      options?.eq ?? import_common11.Eq.defaultEq(),
      options?.blockSizeBits ?? 5,
      options?.listContext ?? import_list5.List.defaultContext()
    )
  );
}

// src/set/interface/index.mts
var _defaultContext2 = createHashSetContext();
var HashSet = Object.freeze({
  ..._defaultContext2,
  createContext: createHashSetContext,
  defaultContext() {
    return _defaultContext2;
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BlockBuilderBase,
  CollisionBuilderBase,
  HashMap,
  HashSet,
  Hasher
});
