"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/map-custom/implementation/builder.mts
var builder_exports = {};
__export(builder_exports, {
  HashMapBlockBuilder: () => HashMapBlockBuilder,
  HashMapCollisionBuilder: () => HashMapCollisionBuilder
});
module.exports = __toCommonJS(builder_exports);
var import_base = require("@rimbu/base");
var import_common3 = require("@rimbu/common");
var import_list2 = require("@rimbu/list");
var import_stream2 = require("@rimbu/stream");
var import_custom = require("@rimbu/stream/custom");

// src/common/hasher.mts
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var Hasher;
((Hasher2) => {
  const MAX_STEP_BITS = 6;
  const STRING_INIT = 21;
  const BOOL_TRUE = -37;
  const BOOL_FALSE = -73;
  const OBJ_INIT = 91;
  const UNDEF_VALUE = -31;
  const NULL_VALUE = -41;
  const _anyFlatHasher = createAnyHasher("FLAT");
  const _anyShallowHasher = createAnyHasher("SHALLOW");
  const _anyDeepHasher = createAnyHasher("DEEP");
  function defaultHasher() {
    return _anyShallowHasher;
  }
  Hasher2.defaultHasher = defaultHasher;
  function createStringHasher(maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "string";
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = STRING_INIT;
        for (let i = 0; i < length; i += stepSize) {
          result = (result << 5) - result + value.charCodeAt(i) | 0;
        }
        return result;
      }
    });
  }
  const _stringHasher = createStringHasher(MAX_STEP_BITS);
  function stringHasher() {
    return _stringHasher;
  }
  Hasher2.stringHasher = stringHasher;
  const _anyToStringHasher = Object.freeze({
    isValid(obj) {
      return true;
    },
    hash(value) {
      return _stringHasher.hash(import_common.Eq.convertAnyToString(value));
    }
  });
  function anyToStringHasher(maxStepBits) {
    if (void 0 === maxStepBits)
      return _anyToStringHasher;
    return createStringHasher(maxStepBits);
  }
  Hasher2.anyToStringHasher = anyToStringHasher;
  const _anyJsonStringHasher = Object.freeze({
    isValid(obj) {
      return true;
    },
    hash(value) {
      return _stringHasher.hash(JSON.stringify(value));
    }
  });
  function anyJsonStringHasher() {
    return _anyJsonStringHasher;
  }
  Hasher2.anyJsonStringHasher = anyJsonStringHasher;
  function createStringCaseInsensitiveHasher(maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "string";
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = STRING_INIT;
        for (let i = 0; i < length; i += stepSize) {
          const char = value.charAt(i).toUpperCase();
          result = (result << 5) - result + char.charCodeAt(0) | 0;
        }
        return result;
      }
    });
  }
  const _stringCaseInsensitiveHasher = createStringCaseInsensitiveHasher(MAX_STEP_BITS);
  function stringCaseInsensitiveHasher() {
    return _stringCaseInsensitiveHasher;
  }
  Hasher2.stringCaseInsensitiveHasher = stringCaseInsensitiveHasher;
  function createArrayHasher(itemHasher, maxStepBits) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return Array.isArray(obj);
      },
      hash(value) {
        const length = Math.min(value.length, maxSteps);
        const stepSize = Math.max(1, value.length >>> maxStepBits);
        let result = value.length | 0;
        for (let i = 0; i < length; i += stepSize) {
          result = (result << 5) - result + (i + 1) * itemHasher.hash(value[i]) | 0;
        }
        return result;
      }
    });
  }
  const _arrayAnyHasher = createArrayHasher(
    defaultHasher(),
    MAX_STEP_BITS
  );
  function arrayHasher(options) {
    if (void 0 === options)
      return _arrayAnyHasher;
    return createArrayHasher(
      options.itemHasher ?? anyFlatHasher(),
      options.maxStepBits ?? MAX_STEP_BITS
    );
  }
  Hasher2.arrayHasher = arrayHasher;
  function createStreamSourceHasher(itemHasher = defaultHasher(), maxStepBits = MAX_STEP_BITS) {
    const maxSteps = 1 << maxStepBits;
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "object" && obj !== null && Symbol.iterator in obj;
      },
      hash(source) {
        const iter = import_stream.Stream.from(source)[Symbol.iterator]();
        let hashItems = [];
        const storeItems = [];
        let skipAmount = 1;
        let skipCount = 0;
        const done = Symbol("done");
        let value;
        let length = 0;
        while (done !== (value = iter.fastNext(done))) {
          length++;
          skipCount++;
          if (skipCount >= skipAmount) {
            storeItems.push(value);
            skipCount = 0;
          }
          if (storeItems.length >= maxSteps) {
            hashItems = storeItems.slice();
            const newLength = maxSteps >>> 1;
            for (let index = 0; index < newLength; index += 1) {
              storeItems[index] = storeItems[index * 2];
            }
            storeItems.length = newLength;
            skipAmount *= 2;
          }
        }
        if (hashItems.length === 0) {
          hashItems = storeItems;
        }
        const itemHash = createArrayHasher(itemHasher, maxStepBits).hash(
          hashItems
        );
        return (itemHash << 5) - itemHash + length | 0;
      }
    });
  }
  const _streamSourceAnyHasher = createStreamSourceHasher(defaultHasher(), MAX_STEP_BITS);
  function streamSourceHasher(options) {
    if (void 0 === options)
      return _streamSourceAnyHasher;
    return createStreamSourceHasher(options.itemHasher, options.maxStepBits);
  }
  Hasher2.streamSourceHasher = streamSourceHasher;
  const MIN_HASH = -Math.pow(2, 31);
  const MAX_HASH = Math.pow(2, 31) - 1;
  const _numberHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "number";
    },
    hash(value) {
      if (Number.isInteger(value)) {
        return value | 0;
      }
      if (Number.isNaN(value)) {
        return MAX_HASH - 1;
      }
      if (value === Number.POSITIVE_INFINITY) {
        return MAX_HASH;
      }
      if (value === Number.NEGATIVE_INFINITY) {
        return MIN_HASH;
      }
      return _anyToStringHasher.hash(value);
    }
  });
  function numberHasher() {
    return _numberHasher;
  }
  Hasher2.numberHasher = numberHasher;
  const _booleanHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "boolean";
    },
    hash(value) {
      return value ? BOOL_TRUE : BOOL_FALSE;
    }
  });
  function booleanHasher() {
    return _booleanHasher;
  }
  Hasher2.booleanHasher = booleanHasher;
  const _bigintHasher = Object.freeze({
    isValid(obj) {
      return typeof obj === "bigint";
    },
    hash: _anyToStringHasher.hash
  });
  function bigintHasher() {
    return _bigintHasher;
  }
  Hasher2.bigintHasher = bigintHasher;
  function createValueOfHasher(cls, valueHasher = anyFlatHasher()) {
    return Object.freeze({
      isValid(obj) {
        return obj instanceof cls;
      },
      hash(value) {
        return valueHasher.hash(value.valueOf());
      }
    });
  }
  Hasher2.createValueOfHasher = createValueOfHasher;
  const _BooleanHasher = createValueOfHasher(
    Boolean,
    _booleanHasher
  );
  const _DateHasher = createValueOfHasher(Date, _numberHasher);
  function dateHasher() {
    return _DateHasher;
  }
  Hasher2.dateHasher = dateHasher;
  const _NumberHasher = createValueOfHasher(
    Number,
    _numberHasher
  );
  const _StringHasher = createValueOfHasher(
    String,
    _stringHasher
  );
  const _wrappedHashers = [
    _BooleanHasher,
    _DateHasher,
    _NumberHasher,
    _StringHasher
  ];
  function tryWrappedHasher(value) {
    let i = -1;
    const len = _wrappedHashers.length;
    while (++i < len) {
      const hasher = _wrappedHashers[i];
      if (hasher.isValid(value)) {
        return hasher.hash(value);
      }
    }
    return void 0;
  }
  function createObjectHasher(keyHasher, valueHasher) {
    return Object.freeze({
      isValid(obj) {
        return typeof obj === "object";
      },
      hash(value) {
        if (value === null)
          return NULL_VALUE;
        let result = OBJ_INIT;
        for (const key in value) {
          const keyValue = value[key];
          const keyHash = keyHasher.hash(key);
          const valueHash = valueHasher.hash(keyValue);
          result = result ^ keyHash + valueHash;
        }
        return result;
      }
    });
  }
  const _objectShallowHasher = createObjectHasher(
    anyFlatHasher(),
    anyFlatHasher()
  );
  const _objectDeepHasher = createObjectHasher(
    anyFlatHasher(),
    anyDeepHasher()
  );
  function objectHasher(options) {
    if (void 0 === options)
      return _objectShallowHasher;
    return createObjectHasher(options.keyHasher, options.valueHasher);
  }
  Hasher2.objectHasher = objectHasher;
  function objectShallowHasher() {
    return _objectShallowHasher;
  }
  Hasher2.objectShallowHasher = objectShallowHasher;
  function objectDeepHasher() {
    return _objectDeepHasher;
  }
  Hasher2.objectDeepHasher = objectDeepHasher;
  function createAnyHasher(mode, maxStepBits = MAX_STEP_BITS) {
    return Object.freeze({
      isValid(obj) {
        return true;
      },
      hash(value) {
        const valueType = typeof value;
        switch (valueType) {
          case "undefined":
            return UNDEF_VALUE;
          case "bigint":
            return _bigintHasher.hash(value);
          case "boolean":
            return _booleanHasher.hash(value);
          case "number":
            return _numberHasher.hash(value);
          case "string":
            return _stringHasher.hash(value);
          case "function":
          case "symbol":
            return _anyToStringHasher.hash(value);
          case "object": {
            if (null === value)
              return NULL_VALUE;
            const result = tryWrappedHasher(value);
            if (void 0 !== result)
              return result;
            if (mode !== "FLAT") {
              if (Array.isArray(value)) {
                if (mode === "SHALLOW") {
                  return createArrayHasher(_anyFlatHasher, MAX_STEP_BITS).hash(
                    value
                  );
                }
                return createArrayHasher(this, maxStepBits).hash(value);
              }
              if (_streamSourceAnyHasher.isValid(value)) {
                if (mode === "SHALLOW") {
                  return createStreamSourceHasher(
                    _anyFlatHasher,
                    maxStepBits
                  ).hash(value);
                }
                return createStreamSourceHasher(this, maxStepBits).hash(value);
              }
              if (_objectShallowHasher.isValid(value)) {
                if (mode === "SHALLOW")
                  return _objectShallowHasher.hash(value);
                return createObjectHasher(_anyFlatHasher, this).hash(value);
              }
            }
            return _anyToStringHasher.hash(value);
          }
        }
      }
    });
  }
  function anyFlatHasher() {
    return _anyFlatHasher;
  }
  Hasher2.anyFlatHasher = anyFlatHasher;
  function anyShallowHasher() {
    return _anyShallowHasher;
  }
  Hasher2.anyShallowHasher = anyShallowHasher;
  function anyDeepHasher() {
    return _anyDeepHasher;
  }
  Hasher2.anyDeepHasher = anyDeepHasher;
  function tupleSymmetric(hasher = anyShallowHasher()) {
    return Object.freeze({
      isValid(obj) {
        return Array.isArray(obj) && obj.length === 2 && hasher.isValid(obj[0]) && hasher.isValid(obj[1]);
      },
      hash(value) {
        return hasher.hash(value[0]) + hasher.hash(value[1]) | 0;
      }
    });
  }
  Hasher2.tupleSymmetric = tupleSymmetric;
})(Hasher || (Hasher = {}));

// src/common/hashed-custom.mts
var import_common2 = require("@rimbu/common");
var import_list = require("@rimbu/list");
var BlockBuilderBase = class {
  get isEmpty() {
    return this.size === 0;
  }
  forEach(f, state = (0, import_common2.TraverseState)()) {
    if (this.isEmpty || state.halted)
      return;
    if (void 0 !== this.source)
      return this.source.forEach(f, state);
    const { halt } = state;
    if (void 0 !== this._entries) {
      for (const key in this._entries) {
        f(this._entries[key], state.nextIndex(), halt);
        if (state.halted)
          break;
      }
    }
    if (void 0 !== this._entrySets) {
      for (const key in this._entrySets) {
        this._entrySets[key].forEach(f, state);
        if (state.halted)
          break;
      }
    }
  }
};
var CollisionBuilderBase = class {
  get size() {
    if (void 0 !== this.source)
      return this.source.size;
    return this.entries.length;
  }
  get entries() {
    if (void 0 === this._entries) {
      if (void 0 !== this.source) {
        this._entries = this.source.entries.toBuilder();
      } else {
        this._entries = import_list.List.builder();
      }
    }
    return this._entries;
  }
  forEach(f, state = (0, import_common2.TraverseState)()) {
    if (state.halted)
      return;
    if (void 0 !== this.source) {
      return this.source.forEach(f, state);
    }
    this.entries.forEach(f, state);
  }
};

// src/map-custom/implementation/builder.mts
var HashMapBlockBuilder = class _HashMapBlockBuilder extends BlockBuilderBase {
  constructor(context, source, _entries, _entrySets, size = source?.size ?? 0, level = source?.level ?? 0) {
    super();
    this.context = context;
    this.source = source;
    this._entries = _entries;
    this._entrySets = _entrySets;
    this.size = size;
    this.level = level;
    this._lock = 0;
    this.get = (key, otherwise, hash) => {
      if (void 0 !== this.source)
        return this.source.get(key, otherwise);
      if (!this.context.hasher.isValid(key))
        return (0, import_common3.OptLazy)(otherwise);
      const keyHash = hash ?? this.context.hash(key);
      const keyIndex = this.context.getKeyIndex(this.level, keyHash);
      if (keyIndex in this.entries) {
        const currentEntry = this.entries[keyIndex];
        if (this.context.eq(key, currentEntry[0]))
          return currentEntry[1];
        return (0, import_common3.OptLazy)(otherwise);
      }
      if (keyIndex in this.entrySets) {
        const currentEntrySet = this.entrySets[keyIndex];
        return currentEntrySet.get(key, otherwise, keyHash);
      }
      return (0, import_common3.OptLazy)(otherwise);
    };
    // prettier-ignore
    this.hasKey = (key) => {
      const token = Symbol();
      return token !== this.get(key, token);
    };
    this.addEntry = (entry) => {
      this.checkLock();
      return this.addEntryInternal(entry);
    };
    this.addEntries = (source) => {
      this.checkLock();
      if ((0, import_custom.isEmptyStreamSourceInstance)(source))
        return false;
      return import_stream2.Stream.from(source).filter(this.addEntry).count() > 0;
    };
    this.set = (key, value) => {
      this.checkLock();
      return this.addEntryInternal([key, value]);
    };
    this.modifyAt = (key, options, keyHash = this.context.hash(key)) => {
      this.checkLock();
      const keyIndex = this.context.getKeyIndex(this.level, keyHash);
      if (keyIndex in this.entries) {
        const currentEntry = this.entries[keyIndex];
        const [currentKey, currentValue] = currentEntry;
        if (this.context.eq(key, currentKey)) {
          if (void 0 === options.ifExists)
            return false;
          const newValue3 = options.ifExists(currentValue, import_base.Token);
          if (Object.is(newValue3, currentValue)) {
            return false;
          }
          this.source = void 0;
          if (import_base.Token === newValue3) {
            this.size--;
            delete this.entries[keyIndex];
            return true;
          }
          const newEntry = [key, newValue3];
          this.entries[keyIndex] = newEntry;
          return true;
        }
        if (void 0 === options.ifNew)
          return false;
        const newValue2 = (0, import_common3.OptLazyOr)(options.ifNew, import_base.Token);
        if (import_base.Token === newValue2)
          return false;
        this.source = void 0;
        this.size++;
        delete this.entries[keyIndex];
        const newEntrySet = this.level < this.context.maxDepth ? new _HashMapBlockBuilder(
          this.context,
          void 0,
          void 0,
          void 0,
          0,
          this.level + 1
        ) : new HashMapCollisionBuilder(this.context);
        newEntrySet.addEntryInternal(currentEntry);
        newEntrySet.addEntryInternal([key, newValue2], keyHash);
        this.entrySets[keyIndex] = newEntrySet;
        return true;
      }
      if (keyIndex in this.entrySets) {
        const entrySet = this.entrySets[keyIndex];
        const preSize = entrySet.size;
        const result = entrySet.modifyAt(key, options, keyHash);
        if (result)
          this.source = void 0;
        this.size += entrySet.size - preSize;
        if (entrySet.size > 1)
          return result;
        let first = void 0;
        if (this.context.isHashMapBlockBuilder(entrySet)) {
          for (const index in entrySet.entries) {
            first = entrySet.entries[index];
            break;
          }
        } else {
          first = entrySet.entries.get(0, import_base.RimbuError.throwInvalidStateError);
        }
        delete this.entrySets[keyIndex];
        this.entries[keyIndex] = first;
        return true;
      }
      if (void 0 === options.ifNew)
        return false;
      const newValue = (0, import_common3.OptLazyOr)(options.ifNew, import_base.Token);
      if (import_base.Token === newValue)
        return false;
      this.source = void 0;
      this.size++;
      this.entries[keyIndex] = [key, newValue];
      return true;
    };
    // prettier-ignore
    this.updateAt = (key, update, otherwise) => {
      let result;
      let found = false;
      this.modifyAt(key, {
        ifExists: (value) => {
          result = value;
          found = true;
          return (0, import_common3.Update)(value, update);
        }
      });
      if (!found)
        return (0, import_common3.OptLazy)(otherwise);
      return result;
    };
    this.removeKey = (key, otherwise) => {
      this.checkLock();
      if (!this.context.hasher.isValid(key))
        return (0, import_common3.OptLazy)(otherwise);
      let removedValue;
      let found = false;
      this.modifyAt(key, {
        ifExists: (currentValue, remove) => {
          removedValue = currentValue;
          found = true;
          return remove;
        }
      });
      if (!found)
        return (0, import_common3.OptLazy)(otherwise);
      return removedValue;
    };
    // prettier-ignore
    this.removeKeys = (keys) => {
      this.checkLock();
      if ((0, import_custom.isEmptyStreamSourceInstance)(keys))
        return false;
      const notFound = Symbol();
      return import_stream2.Stream.from(keys).mapPure(this.removeKey, notFound).countNotElement(notFound) > 0;
    };
    this.forEach = (f, state = (0, import_common3.TraverseState)()) => {
      this._lock++;
      super.forEach(f, state);
      this._lock--;
    };
    this.build = () => {
      if (this.size === 0)
        return this.context.empty();
      return this.buildNE();
    };
    // prettier-ignore
    this.buildMapValues = (f) => {
      if (this.size === 0) {
        return this.context.empty();
      }
      if (void 0 !== this.source)
        return this.source.mapValues(f);
      const entries = this.entries.length === 0 ? null : import_base.Arr.mapSparse(this.entries, (e) => [
        e[0],
        f(e[1], e[0])
      ]);
      const entrySets = this.entrySets.length === 0 ? null : import_base.Arr.mapSparse(
        this.entrySets,
        (entrySet) => entrySet.buildMapValues(f)
      );
      return this.context.block(entries, entrySets, this.size, this.level);
    };
  }
  checkLock() {
    if (this._lock)
      import_base.RimbuError.throwModifiedBuilderWhileLoopingOverItError();
  }
  prepareMutate() {
    if (void 0 === this._entries) {
      if (void 0 !== this.source) {
        this._entries = null === this.source.entries ? [] : import_base.Arr.copySparse(this.source.entries);
      } else {
        this._entries = [];
      }
    }
    if (void 0 === this._entrySets) {
      if (void 0 !== this.source) {
        this._entrySets = null === this.source.entrySets ? [] : import_base.Arr.mapSparse(
          this.source.entrySets,
          (entrySet) => {
            if (this.context.isHashMapBlock(entrySet)) {
              return new _HashMapBlockBuilder(this.context, entrySet);
            }
            return new HashMapCollisionBuilder(this.context, entrySet);
          }
        ) ?? [];
      } else {
        this._entrySets = [];
      }
    }
  }
  get entries() {
    this.prepareMutate();
    return this._entries;
  }
  get entrySets() {
    this.prepareMutate();
    return this._entrySets;
  }
  addEntryInternal(entry, hash = this.context.hash(entry[0])) {
    const keyIndex = this.context.getKeyIndex(this.level, hash);
    if (keyIndex in this.entries) {
      const currentEntry = this.entries[keyIndex];
      if (this.context.eq(entry[0], currentEntry[0])) {
        if (Object.is(entry[1], currentEntry[1]))
          return false;
        this.source = void 0;
        this.entries[keyIndex] = entry;
        return true;
      }
      this.source = void 0;
      this.size++;
      delete this.entries[keyIndex];
      if (this.level < this.context.maxDepth) {
        const newEntrySet2 = new _HashMapBlockBuilder(
          this.context,
          void 0,
          void 0,
          void 0,
          0,
          this.level + 1
        );
        newEntrySet2.addEntryInternal(currentEntry);
        newEntrySet2.addEntryInternal(entry, hash);
        this.entrySets[keyIndex] = newEntrySet2;
        return true;
      }
      const newEntries = import_list2.List.builder();
      newEntries.append(currentEntry);
      newEntries.append(entry);
      const newEntrySet = new HashMapCollisionBuilder(
        this.context,
        void 0,
        newEntries
      );
      this.entrySets[keyIndex] = newEntrySet;
      return true;
    }
    if (keyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[keyIndex];
      const preSize = currentEntrySet.size;
      const changed = currentEntrySet.addEntryInternal(entry, hash);
      if (changed)
        this.source = void 0;
      this.size += currentEntrySet.size - preSize;
      return changed;
    }
    this.source = void 0;
    this.size++;
    this.entries[keyIndex] = entry;
    return true;
  }
  buildNE() {
    if (void 0 !== this.source)
      return this.source;
    const entries = this.entries.length === 0 ? null : import_base.Arr.copySparse(this.entries);
    const entrySets = this.entrySets.length === 0 ? null : import_base.Arr.mapSparse(this.entrySets, (entrySet) => entrySet.buildNE());
    return this.context.block(entries, entrySets, this.size, this.level);
  }
};
var HashMapCollisionBuilder = class extends CollisionBuilderBase {
  constructor(context, source, _entries) {
    super();
    this.context = context;
    this.source = source;
    this._entries = _entries;
  }
  get(key, otherwise, hash) {
    if (!this.context.hasher.isValid(key))
      return (0, import_common3.OptLazy)(otherwise);
    if (void 0 !== this.source)
      return this.source.get(key, otherwise);
    const token = Symbol();
    let result = token;
    this.entries.forEach((e, _, halt) => {
      if (this.context.eq(key, e[0])) {
        result = e[1];
        halt();
      }
    });
    if (token === result)
      return (0, import_common3.OptLazy)(otherwise);
    return result;
  }
  addEntryInternal(entry) {
    let index = -1;
    this.entries.forEach((e, i, halt) => {
      if (this.context.eq(e[0], entry[0])) {
        index = i;
        halt();
      }
    });
    if (index < 0) {
      this.source = void 0;
      this.entries.append(entry);
      return true;
    }
    const oldEntry = this.entries.updateAt(
      index,
      (currentEntry) => {
        if (Object.is(currentEntry[1], entry[1]))
          return currentEntry;
        return entry;
      }
    );
    const changed = void 0 === oldEntry || !Object.is(oldEntry[1], entry[1]) || !Object.is(oldEntry[0], entry[0]);
    if (changed) {
      this.source = void 0;
    }
    return changed;
  }
  set(key, value) {
    return this.addEntryInternal([key, value]);
  }
  modifyAt(atKey, options) {
    let index = -1;
    let foundEntry = void 0;
    this.entries.forEach((e, i, halt) => {
      if (this.context.eq(e[0], atKey)) {
        index = i;
        foundEntry = e;
        halt();
      }
    });
    if (void 0 === foundEntry) {
      if (void 0 === options.ifNew)
        return false;
      const newValue2 = (0, import_common3.OptLazyOr)(options.ifNew, import_base.Token);
      if (import_base.Token === newValue2)
        return false;
      this.source = void 0;
      this.entries.append([atKey, newValue2]);
      return true;
    }
    if (void 0 === options.ifExists)
      return false;
    const newValue = options.ifExists(foundEntry[1], import_base.Token);
    if (Object.is(newValue, foundEntry[1]))
      return false;
    if (import_base.Token === newValue) {
      this.source = void 0;
      this.entries.remove(index);
      return true;
    }
    const result = this.entries.set(index, [atKey, newValue]);
    const changed = void 0 !== result;
    if (changed)
      this.source = void 0;
    return changed;
  }
  buildNE() {
    if (void 0 !== this.source)
      return this.source;
    return this.context.collision(this.entries.build().assumeNonEmpty());
  }
  buildMapValues(f) {
    if (void 0 !== this.source)
      return this.source.mapValues(f);
    return this.context.collision(
      this.entries.buildMap((entry) => [
        entry[0],
        f(entry[1], entry[0])
      ]).assumeNonEmpty()
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HashMapBlockBuilder,
  HashMapCollisionBuilder
});
