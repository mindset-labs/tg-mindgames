"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/map-custom/implementation/immutable.mts
var immutable_exports = {};
__export(immutable_exports, {
  HashMapBlock: () => HashMapBlock,
  HashMapCollision: () => HashMapCollision,
  HashMapEmpty: () => HashMapEmpty,
  HashMapNonEmptyBase: () => HashMapNonEmptyBase
});
module.exports = __toCommonJS(immutable_exports);
var import_base = require("@rimbu/base");
var import_map_custom = require("@rimbu/collection-types/map-custom");
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var import_custom = require("@rimbu/stream/custom");
var HashMapEmpty = class extends import_map_custom.EmptyBase {
  constructor(context) {
    super();
    this.context = context;
  }
  streamKeys() {
    return import_stream.Stream.empty();
  }
  streamValues() {
    return import_stream.Stream.empty();
  }
  get(key, otherwise) {
    return (0, import_common.OptLazy)(otherwise);
  }
  hasKey() {
    return false;
  }
  set(key, value) {
    return this.context.emptyBlock().set(key, value);
  }
  addEntry(entry) {
    return this.context.emptyBlock().addEntry(entry);
  }
  addEntries(entries) {
    return this.context.from(entries);
  }
  removeKeyAndGet() {
    return void 0;
  }
  removeKey() {
    return this;
  }
  removeKeys() {
    return this;
  }
  modifyAt(atKey, options) {
    if (void 0 !== options.ifNew) {
      const value = (0, import_common.OptLazyOr)(options.ifNew, import_base.Token);
      if (import_base.Token === value)
        return this;
      return this.set(atKey, value);
    }
    return this;
  }
  mapValues() {
    return this;
  }
  updateAt() {
    return this;
  }
  toBuilder() {
    return this.context.builder();
  }
  toString() {
    return `HashMap()`;
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: []
    };
  }
};
var HashMapNonEmptyBase = class extends import_map_custom.NonEmptyBase {
  asNormal() {
    return this;
  }
  streamKeys() {
    return this.stream().map(import_base.Entry.first);
  }
  streamValues() {
    return this.stream().map(import_base.Entry.second);
  }
  hasKey(key) {
    const token = Symbol();
    return token !== this.get(key, token);
  }
  set(key, value) {
    return this.addEntry([key, value]);
  }
  addEntries(entries) {
    if ((0, import_custom.isEmptyStreamSourceInstance)(entries))
      return this;
    const builder = this.toBuilder();
    builder.addEntries(entries);
    return builder.build().assumeNonEmpty();
  }
  removeKeys(keys) {
    if ((0, import_custom.isEmptyStreamSourceInstance)(keys))
      return this;
    const builder = this.toBuilder();
    builder.removeKeys(keys);
    return builder.build();
  }
  updateAt(key, update) {
    if (!this.context.isValidKey(key))
      return this;
    return this.modifyAt(key, {
      ifExists: (value) => (0, import_common.Update)(value, update)
    });
  }
  removeKey(key) {
    if (!this.context.hasher.isValid(key))
      return this;
    return this.modifyAt(key, {
      ifExists: (_, remove) => remove
    });
  }
  removeKeyAndGet(key) {
    if (!this.context.hasher.isValid(key))
      return void 0;
    const token = Symbol();
    let currentValue = token;
    const newMap = this.modifyAt(key, {
      ifExists: (value, remove) => {
        currentValue = value;
        return remove;
      }
    });
    if (token === currentValue)
      return void 0;
    return [newMap, currentValue];
  }
  filter(pred) {
    const builder = this.context.builder();
    builder.addEntries(this.stream().filter(pred));
    if (builder.size === this.size)
      return this;
    return builder.build();
  }
  toBuilder() {
    return this.context.createBuilder(this);
  }
  toString() {
    return this.stream().join({
      start: "HashMap(",
      sep: ", ",
      end: ")",
      valueToString: (entry) => `${entry[0]} -> ${entry[1]}`
    });
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: this.toArray()
    };
  }
};
var HashMapBlock = class _HashMapBlock extends HashMapNonEmptyBase {
  constructor(context, entries, entrySets, size, level) {
    super();
    this.context = context;
    this.entries = entries;
    this.entrySets = entrySets;
    this.size = size;
    this.level = level;
  }
  copy(entries = this.entries, entrySets = this.entrySets, size = this.size) {
    if (entries === this.entries && entrySets === this.entrySets && size === this.size) {
      return this;
    }
    return new _HashMapBlock(this.context, entries, entrySets, size, this.level);
  }
  stream() {
    if (null !== this.entries) {
      if (null === this.entrySets)
        return import_stream.Stream.fromObjectValues(this.entries);
      return import_stream.Stream.fromObjectValues(this.entries).concat(
        import_stream.Stream.fromObjectValues(this.entrySets).flatMap(
          (entrySet) => entrySet.stream()
        )
      );
    }
    if (null === this.entrySets)
      import_base.RimbuError.throwInvalidStateError();
    return import_stream.Stream.fromObjectValues(this.entrySets).flatMap(
      (entrySet) => entrySet.stream()
    );
  }
  get(key, otherwise, hash) {
    if (!this.context.hasher.isValid(key))
      return (0, import_common.OptLazy)(otherwise);
    const keyHash = hash ?? this.context.hash(key);
    const atKeyIndex = this.context.getKeyIndex(this.level, keyHash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const entry = this.entries[atKeyIndex];
      if (this.context.eq(entry[0], key))
        return entry[1];
      return (0, import_common.OptLazy)(otherwise);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const entrySet = this.entrySets[atKeyIndex];
      return entrySet.get(key, otherwise, keyHash);
    }
    return (0, import_common.OptLazy)(otherwise);
  }
  addEntry(entry, hash = this.context.hash(entry[0])) {
    const atKeyIndex = this.context.getKeyIndex(this.level, hash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const currentEntry = this.entries[atKeyIndex];
      if (this.context.eq(entry[0], currentEntry[0])) {
        if (Object.is(entry[1], currentEntry[1]))
          return this;
        const newEntries3 = import_base.Arr.copySparse(this.entries);
        newEntries3[atKeyIndex] = entry;
        return this.copy(newEntries3);
      }
      let newEntries2 = import_base.Arr.copySparse(this.entries);
      delete newEntries2[atKeyIndex];
      let isEmpty = true;
      for (const _ in newEntries2) {
        isEmpty = false;
        break;
      }
      if (isEmpty)
        newEntries2 = null;
      if (this.level < this.context.maxDepth) {
        const newEntrySet2 = this.context.block(null, null, 0, this.level + 1).addEntry(currentEntry).addEntry(entry, hash);
        const newEntrySets2 = null === this.entrySets ? [] : import_base.Arr.copySparse(this.entrySets);
        newEntrySets2[atKeyIndex] = newEntrySet2;
        return this.copy(newEntries2, newEntrySets2, this.size + 1);
      }
      const newEntrySet = this.context.collision(
        this.context.listContext.of(currentEntry, entry)
      );
      const newEntrySets = null === this.entrySets ? [] : import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(newEntries2, newEntrySets, this.size + 1);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[atKeyIndex];
      const newEntrySet = currentEntrySet.addEntry(entry, hash);
      if (newEntrySet === currentEntrySet)
        return this;
      const newEntrySets = import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(
        void 0,
        newEntrySets,
        this.size + newEntrySet.size - currentEntrySet.size
      );
    }
    const newEntries = null === this.entries ? [] : import_base.Arr.copySparse(this.entries);
    newEntries[atKeyIndex] = entry;
    return this.copy(newEntries, void 0, this.size + 1);
  }
  modifyAt(atKey, options, atKeyHash = this.context.hash(atKey)) {
    const atKeyIndex = this.context.getKeyIndex(this.level, atKeyHash);
    if (null !== this.entries && atKeyIndex in this.entries) {
      const currentEntry = this.entries[atKeyIndex];
      if (this.context.eq(atKey, currentEntry[0])) {
        if (void 0 === options.ifExists)
          return this;
        const currentValue = currentEntry[1];
        const newValue3 = options.ifExists(currentValue, import_base.Token);
        if (Object.is(newValue3, currentValue))
          return this;
        const newEntries3 = import_base.Arr.copySparse(this.entries);
        if (import_base.Token === newValue3) {
          delete newEntries3[atKeyIndex];
          for (const _ in newEntries3) {
            return this.copy(newEntries3, void 0, this.size - 1);
          }
          if (this.size === 1)
            return this.context.empty();
          return this.copy(null, void 0, this.size - 1);
        }
        newEntries3[atKeyIndex] = [atKey, newValue3];
        return this.copy(newEntries3);
      }
      if (void 0 === options.ifNew)
        return this;
      const newValue2 = (0, import_common.OptLazyOr)(options.ifNew, import_base.Token);
      if (import_base.Token === newValue2)
        return this;
      let newEntries2 = import_base.Arr.copySparse(this.entries);
      delete newEntries2[atKeyIndex];
      let isEmpty = true;
      for (const _ in newEntries2) {
        isEmpty = false;
        break;
      }
      if (isEmpty)
        newEntries2 = null;
      if (this.level < this.context.maxDepth) {
        const newEntrySet2 = this.context.block(null, null, 0, this.level + 1).addEntry(currentEntry).set(atKey, newValue2);
        const newEntrySets2 = null === this.entrySets ? [] : import_base.Arr.copySparse(this.entrySets);
        newEntrySets2[atKeyIndex] = newEntrySet2;
        return this.copy(newEntries2, newEntrySets2, this.size + 1);
      }
      const newEntry2 = [atKey, newValue2];
      const newEntrySet = this.context.collision(
        this.context.listContext.of(currentEntry, newEntry2)
      );
      const newEntrySets = null === this.entrySets ? [] : import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(newEntries2, newEntrySets, this.size + 1);
    }
    if (null !== this.entrySets && atKeyIndex in this.entrySets) {
      const currentEntrySet = this.entrySets[atKeyIndex];
      const newEntrySet = currentEntrySet.modifyAt(atKey, options, atKeyHash);
      if (newEntrySet === currentEntrySet)
        return this;
      if (newEntrySet.size === 1) {
        let firstEntry = void 0;
        if (this.context.isHashMapBlock(newEntrySet)) {
          for (const key in newEntrySet.entries) {
            firstEntry = newEntrySet.entries[key];
            break;
          }
        } else {
          firstEntry = newEntrySet.entries.first();
        }
        const newEntries2 = null === this.entries ? [] : import_base.Arr.copySparse(this.entries);
        newEntries2[atKeyIndex] = firstEntry;
        const newEntrySets2 = import_base.Arr.copySparse(this.entrySets);
        delete newEntrySets2[atKeyIndex];
        return this.copy(newEntries2, newEntrySets2, this.size - 1);
      }
      const newEntrySets = import_base.Arr.copySparse(this.entrySets);
      newEntrySets[atKeyIndex] = newEntrySet;
      return this.copy(
        void 0,
        newEntrySets,
        this.size + newEntrySet.size - currentEntrySet.size
      );
    }
    if (void 0 === options.ifNew)
      return this;
    const newValue = (0, import_common.OptLazyOr)(options.ifNew, import_base.Token);
    if (import_base.Token === newValue)
      return this;
    const newEntry = [atKey, newValue];
    const newEntries = null === this.entries ? [] : import_base.Arr.copySparse(this.entries);
    newEntries[atKeyIndex] = newEntry;
    return this.copy(newEntries, void 0, this.size + 1);
  }
  forEach(f, state = (0, import_common.TraverseState)()) {
    if (state.halted)
      return;
    const { halt } = state;
    if (null !== this.entries) {
      for (const key in this.entries) {
        f(this.entries[key], state.nextIndex(), halt);
        if (state.halted)
          return;
      }
    }
    if (null !== this.entrySets) {
      for (const key in this.entrySets) {
        this.entrySets[key].forEach(f, state);
        if (state.halted)
          return;
      }
    }
  }
  mapValues(mapFun) {
    const newEntries = null === this.entries ? null : import_base.Arr.mapSparse(this.entries, (e) => [
      e[0],
      mapFun(e[1], e[0])
    ]);
    const newEntrySets = null === this.entrySets ? null : import_base.Arr.mapSparse(
      this.entrySets,
      (es) => es.mapValues(mapFun)
    );
    return new _HashMapBlock(
      this.context,
      newEntries,
      newEntrySets,
      this.size,
      this.level
    );
  }
  toArray() {
    let result = [];
    if (null !== this.entries) {
      result = import_stream.Stream.fromObjectValues(this.entries).toArray();
    }
    if (null !== this.entrySets) {
      import_stream.Stream.fromObjectValues(this.entrySets).forEach(
        (entrySet) => {
          result = result.concat(entrySet.toArray());
        }
      );
    }
    return result;
  }
};
var HashMapCollision = class _HashMapCollision extends HashMapNonEmptyBase {
  constructor(context, entries) {
    super();
    this.context = context;
    this.entries = entries;
  }
  get size() {
    return this.entries.length;
  }
  copy(entries = this.entries) {
    if (entries === this.entries)
      return this;
    return new _HashMapCollision(this.context, entries);
  }
  stream() {
    return this.entries.stream();
  }
  get(key, otherwise, keyHash) {
    if (!this.context.hasher.isValid(key))
      return (0, import_common.OptLazy)(otherwise);
    const token = Symbol();
    const stream = this.stream();
    const foundEntry = stream.find(
      (entry) => this.context.eq(entry[0], key),
      void 0,
      token
    );
    if (token === foundEntry)
      return (0, import_common.OptLazy)(otherwise);
    return foundEntry[1];
  }
  addEntry(entry, hash) {
    const currentIndex = this.stream().indexWhere(
      (currentEntry) => this.context.eq(currentEntry[0], entry[0])
    );
    if (void 0 === currentIndex) {
      return this.copy(this.entries.append(entry));
    }
    return this.copy(
      this.entries.updateAt(currentIndex, (currentEntry) => {
        if (Object.is(currentEntry[1], entry[1]))
          return currentEntry;
        return entry;
      })
    );
  }
  modifyAt(atKey, options, atKeyHash) {
    const currentIndex = this.stream().indexWhere(
      (entry) => this.context.eq(entry[0], atKey)
    );
    if (void 0 === currentIndex) {
      if (void 0 === options.ifNew)
        return this;
      const newValue2 = (0, import_common.OptLazyOr)(options.ifNew, import_base.Token);
      if (import_base.Token === newValue2)
        return this;
      const newEntries2 = this.entries.append([atKey, newValue2]);
      return this.copy(newEntries2);
    }
    if (void 0 === options.ifExists)
      return this;
    const currentEntry = this.entries.get(
      currentIndex,
      import_base.RimbuError.throwInvalidStateError
    );
    const currentValue = currentEntry[1];
    const newValue = options.ifExists(currentValue, import_base.Token);
    if (import_base.Token === newValue) {
      const newEntries2 = this.entries.remove(currentIndex, 1).assumeNonEmpty();
      return this.copy(newEntries2);
    }
    if (Object.is(newValue, currentValue))
      return this;
    const newEntry = [atKey, newValue];
    const newEntries = this.entries.updateAt(currentIndex, newEntry);
    return this.copy(newEntries);
  }
  forEach(f, state) {
    if (state.halted)
      return;
    this.entries.forEach(f, state);
  }
  mapValues(mapFun) {
    const newEntries = this.entries.map((e) => [
      e[0],
      mapFun(e[1], e[0])
    ]);
    return new _HashMapCollision(this.context, newEntries);
  }
  toArray() {
    return this.entries.toArray();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HashMapBlock,
  HashMapCollision,
  HashMapEmpty,
  HashMapNonEmptyBase
});
