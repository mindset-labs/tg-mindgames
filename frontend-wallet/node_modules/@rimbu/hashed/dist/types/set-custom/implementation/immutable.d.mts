import { EmptyBase, NonEmptyBase } from '@rimbu/collection-types/set-custom';
import { type ArrayNonEmpty, type RelatedTo, type ToJSON, TraverseState } from '@rimbu/common';
import type { List } from '@rimbu/list';
import { Stream, type StreamSource } from '@rimbu/stream';
import type { HashSet } from '@rimbu/hashed/set';
import type { HashSetContext } from '@rimbu/hashed/set-custom';
export declare class HashSetEmpty<T = any> extends EmptyBase implements HashSet<T> {
    readonly context: HashSetContext<T>;
    readonly addAll: any;
    constructor(context: HashSetContext<T>);
    has(): false;
    add(value: T): HashSet.NonEmpty<T>;
    remove(): this;
    removeAll(): this;
    union(other: StreamSource<T>): HashSet<T> | any;
    difference(): HashSet<T>;
    intersect(): HashSet<T>;
    symDifference(other: StreamSource<T>): HashSet<T>;
    toBuilder(): HashSet.Builder<T>;
    toString(): string;
    toJSON(): ToJSON<T[]>;
}
export declare abstract class HashSetNonEmptyBase<T> extends NonEmptyBase<T> implements HashSet.NonEmpty<T> {
    abstract get context(): HashSetContext<T>;
    abstract get size(): number;
    abstract stream(): Stream.NonEmpty<T>;
    abstract forEach(f: (value: T, index: number, halt: () => void) => void, traverseState?: TraverseState): void;
    abstract has<U>(value: RelatedTo<T, U>): boolean;
    abstract add(value: T): HashSetNonEmptyBase<T>;
    abstract remove<U>(value: RelatedTo<T, U>): HashSet<T>;
    abstract toArray(): ArrayNonEmpty<T>;
    asNormal(): this;
    addAll(values: StreamSource<T>): HashSet.NonEmpty<T>;
    removeAll(values: StreamSource<T>): HashSet<T>;
    filter(pred: (value: T, index: number, halt: () => void) => boolean): HashSet<T>;
    union(other: StreamSource<T>): HashSet.NonEmpty<T>;
    difference(other: StreamSource<T>): HashSet<T>;
    intersect(other: StreamSource<T>): HashSet<T>;
    symDifference(other: StreamSource<T>): HashSet<T>;
    toBuilder(): HashSet.Builder<T>;
    toString(): string;
    toJSON(): ToJSON<T[]>;
}
export type SetEntrySet<T> = HashSetBlock<T> | HashSetCollision<T>;
export declare class HashSetBlock<T> extends HashSetNonEmptyBase<T> {
    readonly context: HashSetContext<T>;
    readonly entries: readonly T[] | null;
    readonly entrySets: readonly SetEntrySet<T>[] | null;
    readonly size: number;
    readonly level: number;
    constructor(context: HashSetContext<T>, entries: readonly T[] | null, entrySets: readonly SetEntrySet<T>[] | null, size: number, level: number);
    copy(entries?: readonly T[] | null, entrySets?: readonly SetEntrySet<T>[] | null, size?: number): HashSetBlock<T>;
    stream(): Stream.NonEmpty<T>;
    has<U>(value: RelatedTo<T, U>, inHash?: number): boolean;
    add(value: T, hash?: number): HashSetBlock<T>;
    remove<U>(value: RelatedTo<T, U>, hash?: number): HashSet<T>;
    forEach(f: (entry: T, index: number, halt: () => void) => void, state?: TraverseState): void;
    toArray(): ArrayNonEmpty<T>;
}
export declare class HashSetCollision<T> extends HashSetNonEmptyBase<T> {
    readonly context: HashSetContext<T>;
    readonly entries: List.NonEmpty<T>;
    constructor(context: HashSetContext<T>, entries: List.NonEmpty<T>);
    get size(): number;
    copy(entries?: List.NonEmpty<T>): HashSetCollision<T>;
    stream(): Stream.NonEmpty<T>;
    has<U>(value: RelatedTo<T, U>, inHash?: number): boolean;
    add(value: T): HashSetCollision<T>;
    remove<U>(value: RelatedTo<T, U>, hash?: number): HashSet<T>;
    forEach(f: (entry: T, index: number, halt: () => void) => void, state?: TraverseState): void;
    toArray(): ArrayNonEmpty<T>;
}
