import { type RelatedTo, TraverseState } from '@rimbu/common';
import { List } from '@rimbu/list';
import { type StreamSource } from '@rimbu/stream';
import type { HashSet } from '@rimbu/hashed/set';
import type { HashSetBlock, HashSetCollision, HashSetContext } from '@rimbu/hashed/set-custom';
import { BlockBuilderBase, CollisionBuilderBase } from '@rimbu/hashed/common';
export type SetBlockBuilderEntry<T> = HashSetBlockBuilder<T> | HashSetCollisionBuilder<T>;
export declare class HashSetBlockBuilder<T> extends BlockBuilderBase<T> implements HashSet.Builder<T> {
    readonly context: HashSetContext<T>;
    source?: HashSetBlock<T> | undefined;
    _entries?: T[] | undefined;
    _entrySets?: SetBlockBuilderEntry<T>[] | undefined;
    size: number;
    level: number;
    constructor(context: HashSetContext<T>, source?: HashSetBlock<T> | undefined, _entries?: T[] | undefined, _entrySets?: SetBlockBuilderEntry<T>[] | undefined, size?: number, level?: number);
    _lock: number;
    checkLock(): void;
    prepareMutate(): void;
    get entries(): T[];
    get entrySets(): SetBlockBuilderEntry<T>[];
    has: <U>(value: RelatedTo<T, U>) => boolean;
    hasInternal(value: T, hash?: number): boolean;
    add: (value: T) => boolean;
    addAll: (source: StreamSource<T>) => boolean;
    addInternal(value: T, hash?: number): boolean;
    remove: <ST>(value: ST) => boolean;
    removeAll: <ST>(values: StreamSource<ST>) => boolean;
    removeInternal(value: T, hash?: number): boolean;
    forEach: (f: (value: T, index: number, halt: () => void) => void, state?: TraverseState) => void;
    build: () => HashSet<T>;
    buildNE(): HashSetBlock<T>;
}
export declare class HashSetCollisionBuilder<T> extends CollisionBuilderBase<T> {
    readonly context: HashSetContext<T>;
    source?: HashSetCollision<T> | undefined;
    _entries?: List.Builder<T> | undefined;
    constructor(context: HashSetContext<T>, source?: HashSetCollision<T> | undefined, _entries?: List.Builder<T> | undefined);
    hasInternal(value: T, hash?: number): boolean;
    addInternal(value: T): boolean;
    removeInternal(value: T): boolean;
    buildNE(): HashSetCollision<T>;
}
