import { RSetBase } from '@rimbu/collection-types/set-custom';
import { Eq } from '@rimbu/common';
import { List } from '@rimbu/list';
import type { StreamSource } from '@rimbu/stream';
import type { HashSet } from '@rimbu/hashed/set';
import type { SetBlockBuilderEntry, SetEntrySet } from '@rimbu/hashed/set-custom';
import { Hasher } from '../../common/index.mjs';
import { HashSetBlock, HashSetCollision, HashSetBlockBuilder } from '@rimbu/hashed/set-custom';
export declare class HashSetContext<UT> extends RSetBase.ContextBase<UT, HashSet.Types> implements HashSet.Context<UT> {
    readonly hasher: Hasher<UT>;
    readonly eq: Eq<UT>;
    readonly blockSizeBits: number;
    readonly listContext: List.Context;
    readonly blockCapacity: number;
    readonly blockMask: number;
    readonly maxDepth: number;
    readonly _empty: HashSet<any>;
    readonly _emptyBlock: HashSetBlock<any>;
    constructor(hasher: Hasher<UT>, eq: Eq<UT>, blockSizeBits: number, listContext: List.Context);
    readonly typeTag = "HashSet";
    isNonEmptyInstance(source: any): source is any;
    hash(value: UT): number;
    getKeyIndex(level: number, hash: number): number;
    emptyBlock(): HashSetBlock<UT>;
    isValidValue(value: unknown): value is UT;
    readonly builder: <T extends UT>() => HashSet.Builder<T>;
    createBuilder<T extends UT>(source?: HashSet.NonEmpty<T>): HashSet.Builder<T>;
    block(entries: readonly UT[] | null, entrySets: SetEntrySet<UT>[] | null, size: number, level: number): HashSetBlock<UT>;
    collision(entries: List.NonEmpty<UT>): HashSetCollision<UT>;
    isHashSetBlock<T>(obj: SetEntrySet<T> | StreamSource<T>): obj is HashSetBlock<T>;
    isHashSetCollision<T>(obj: SetEntrySet<T> | StreamSource<T>): obj is HashSetCollision<T>;
    isHashSetBlockBuilder<T>(obj: SetBlockBuilderEntry<T>): obj is HashSetBlockBuilder<T>;
}
export declare function createHashSetContext<UT>(options?: {
    hasher?: Hasher<UT>;
    eq?: Eq<UT>;
    blockSizeBits?: number;
    listContext?: List.Context;
}): HashSet.Context<UT>;
