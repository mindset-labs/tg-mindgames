import { Token } from '@rimbu/base';
import { OptLazy, OptLazyOr, TraverseState, Update, type RelatedTo } from '@rimbu/common';
import { List } from '@rimbu/list';
import { type StreamSource } from '@rimbu/stream';
import { BlockBuilderBase, CollisionBuilderBase } from '@rimbu/hashed/common';
import type { HashMap } from '@rimbu/hashed/map';
import type { HashMapBlock, HashMapCollision, HashMapContext } from '@rimbu/hashed/map-custom';
export type MapBlockBuilderEntry<K, V> = HashMapBlockBuilder<K, V> | HashMapCollisionBuilder<K, V>;
export declare class HashMapBlockBuilder<K, V> extends BlockBuilderBase<readonly [K, V]> implements HashMap.Builder<K, V> {
    readonly context: HashMapContext<K>;
    source?: HashMapBlock<K, V> | undefined;
    _entries?: (readonly [K, V])[] | undefined;
    _entrySets?: MapBlockBuilderEntry<K, V>[] | undefined;
    size: number;
    level: number;
    constructor(context: HashMapContext<K>, source?: HashMapBlock<K, V> | undefined, _entries?: (readonly [K, V])[] | undefined, _entrySets?: MapBlockBuilderEntry<K, V>[] | undefined, size?: number, level?: number);
    _lock: number;
    checkLock(): void;
    prepareMutate(): void;
    get entries(): (readonly [K, V])[];
    get entrySets(): MapBlockBuilderEntry<K, V>[];
    get: <UK, O>(key: RelatedTo<K, UK>, otherwise?: OptLazy<O> | undefined, hash?: number) => V | O;
    hasKey: <UK>(key: RelatedTo<K, UK>) => boolean;
    addEntry: (entry: readonly [K, V]) => boolean;
    addEntries: (source: StreamSource<readonly [K, V]>) => boolean;
    addEntryInternal(entry: readonly [K, V], hash?: number): boolean;
    set: (key: K, value: V) => boolean;
    modifyAt: (key: K, options: {
        ifNew?: OptLazyOr<V, Token>;
        ifExists?: (currentValue: V, remove: Token) => V | Token;
    }, keyHash?: number) => boolean;
    updateAt: <O>(key: K, update: Update<V>, otherwise?: OptLazy<O> | undefined) => V | O;
    removeKey: <UK, O>(key: RelatedTo<K, UK>, otherwise?: OptLazy<O> | undefined) => V | O;
    removeKeys: <UK>(keys: StreamSource<RelatedTo<K, UK>>) => boolean;
    forEach: (f: (entry: readonly [K, V], index: number, halt: () => void) => void, state?: TraverseState) => void;
    build: () => HashMap<K, V>;
    buildNE(): HashMapBlock<K, V>;
    buildMapValues: <V2>(f: (value: V, key: K) => V2) => HashMap<K, V2>;
}
export declare class HashMapCollisionBuilder<K, V> extends CollisionBuilderBase<readonly [K, V]> {
    readonly context: HashMapContext<K>;
    source?: HashMapCollision<K, V> | undefined;
    _entries?: List.Builder<readonly [K, V]> | undefined;
    constructor(context: HashMapContext<K>, source?: HashMapCollision<K, V> | undefined, _entries?: List.Builder<readonly [K, V]> | undefined);
    get<UK, O>(key: RelatedTo<K, UK>, otherwise?: OptLazy<O>, hash?: number): V | O;
    addEntryInternal(entry: readonly [K, V]): boolean;
    set(key: K, value: V): boolean;
    modifyAt(atKey: K, options: {
        ifNew?: OptLazyOr<V, Token>;
        ifExists?: (currentEntry: V, remove: Token) => V | Token;
    }): boolean;
    buildNE(): HashMapCollision<K, V>;
    buildMapValues<V2>(f: (value: V, key: K) => V2): HashMap<K, V2>;
}
