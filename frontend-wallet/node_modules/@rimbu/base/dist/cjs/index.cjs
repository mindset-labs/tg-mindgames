"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// src/index.mts
var src_exports = {};
__export(src_exports, {
  Arr: () => arr_exports,
  Entry: () => entry_exports,
  RimbuError: () => rimbu_error_exports,
  Token: () => Token,
  isIterable: () => isIterable,
  isPlainObj: () => isPlainObj
});
module.exports = __toCommonJS(src_exports);

// src/arr.mts
var arr_exports = {};
__export(arr_exports, {
  append: () => append,
  concat: () => concat,
  copySparse: () => copySparse,
  forEach: () => forEach,
  init: () => init,
  insert: () => insert,
  last: () => last,
  map: () => map,
  mapSparse: () => mapSparse,
  mod: () => mod,
  prepend: () => prepend,
  reverse: () => reverse,
  reverseMap: () => reverseMap,
  splice: () => splice,
  tail: () => tail,
  update: () => update
});
var import_common = require("@rimbu/common");
function append(array, value) {
  const clone = array.slice();
  clone.push(value);
  return clone;
}
function concat(first2, second2) {
  if (first2.length === 0)
    return second2;
  if (second2.length === 0)
    return first2;
  return first2.concat(second2);
}
function reverse(array, start = 0, end = array.length - 1) {
  const length = end - start + 1;
  const res = [];
  let arrayIndex = start - 1;
  let resIndex = length - 1;
  while (++arrayIndex <= end)
    res[resIndex--] = array[arrayIndex];
  return res;
}
function forEach(array, f, state = (0, import_common.TraverseState)(), reversed = false) {
  if (state.halted)
    return;
  const { halt } = state;
  if (reversed) {
    let i = array.length;
    while (!state.halted && --i >= 0) {
      f(array[i], state.nextIndex(), halt);
    }
  } else {
    const length = array.length;
    let i = -1;
    while (!state.halted && ++i < length) {
      f(array[i], state.nextIndex(), halt);
    }
  }
}
function map(array, f, indexOffset = 0) {
  const result = [];
  let index = indexOffset;
  let i = -1;
  const length = array.length;
  while (++i < length) {
    result[i] = f(array[i], index++);
  }
  return result;
}
function reverseMap(array, f, indexOffset = 0) {
  const result = [];
  let index = indexOffset;
  let arrayIndex = array.length;
  let resultIndex = 0;
  while (--arrayIndex >= 0)
    result[resultIndex++] = f(array[arrayIndex], index++);
  return result;
}
function prepend(array, value) {
  const clone = array.slice();
  clone.unshift(value);
  return clone;
}
function last(arr) {
  return arr[arr.length - 1];
}
function update(arr, index, updater) {
  if (index < 0 || index >= arr.length)
    return arr;
  const curValue = arr[index];
  const newValue = (0, import_common.Update)(curValue, updater);
  if (Object.is(newValue, curValue))
    return arr;
  const newArr = arr.slice();
  newArr[index] = newValue;
  return newArr;
}
function mod(arr, index, f) {
  if (index < 0 || index >= arr.length)
    return arr;
  const curValue = arr[index];
  const newValue = f(curValue);
  if (Object.is(newValue, curValue))
    return arr;
  const newArr = arr.slice();
  newArr[index] = newValue;
  return newArr;
}
function insert(arr, index, value) {
  const clone = arr.slice();
  clone.splice(index, 0, value);
  return clone;
}
function tail(arr) {
  return arr.slice(1);
}
function init(arr) {
  return arr.slice(0, arr.length - 1);
}
function splice(arr, start, deleteCount, ...items) {
  const clone = arr.slice();
  clone.splice(start, deleteCount, ...items);
  return clone;
}
function copySparse(arr) {
  const clone = [];
  for (const key in arr) {
    clone[key] = arr[key];
  }
  return clone;
}
function mapSparse(arr, f) {
  const result = Array(arr.length);
  for (const key in arr) {
    result[key] = f(arr[key], key);
  }
  return result;
}

// src/entry.mts
var entry_exports = {};
__export(entry_exports, {
  first: () => first,
  second: () => second
});
function first(entry) {
  return entry[0];
}
function second(entry) {
  return entry[1];
}

// src/rimbu-error.mts
var rimbu_error_exports = {};
__export(rimbu_error_exports, {
  EmptyCollectionAssumedNonEmptyError: () => EmptyCollectionAssumedNonEmptyError,
  InvalidStateError: () => InvalidStateError,
  InvalidUsageError: () => InvalidUsageError,
  ModifiedBuilderWhileLoopingOverItError: () => ModifiedBuilderWhileLoopingOverItError,
  throwEmptyCollectionAssumedNonEmptyError: () => throwEmptyCollectionAssumedNonEmptyError,
  throwInvalidStateError: () => throwInvalidStateError,
  throwInvalidUsageError: () => throwInvalidUsageError,
  throwModifiedBuilderWhileLoopingOverItError: () => throwModifiedBuilderWhileLoopingOverItError
});
var import_common2 = require("@rimbu/common");
var EmptyCollectionAssumedNonEmptyError = class extends import_common2.ErrBase.CustomError {
  constructor() {
    super("empty collection was assumbed to be non-empty");
  }
};
var ModifiedBuilderWhileLoopingOverItError = class extends import_common2.ErrBase.CustomError {
  constructor() {
    super("an attempt was made to modify a builder while looping over it");
  }
};
var InvalidStateError = class extends import_common2.ErrBase.CustomError {
  constructor() {
    super(
      "something happend that shouldn't happen, please consider creating an issue"
    );
  }
};
var InvalidUsageError = class extends import_common2.ErrBase.CustomError {
};
function throwEmptyCollectionAssumedNonEmptyError() {
  throw new EmptyCollectionAssumedNonEmptyError();
}
function throwModifiedBuilderWhileLoopingOverItError() {
  throw new ModifiedBuilderWhileLoopingOverItError();
}
function throwInvalidStateError() {
  throw new InvalidStateError();
}
function throwInvalidUsageError(msg) {
  throw new InvalidUsageError(msg);
}

// src/plain-object.mts
function isPlainObj(obj) {
  return typeof obj === "object" && null !== obj && (obj.constructor === Object || !(obj.constructor instanceof Function)) && !(Symbol.iterator in obj) && !(Symbol.asyncIterator in obj);
}
function isIterable(obj) {
  return obj !== null && typeof obj === "object" && Symbol.iterator in obj;
}

// src/token.mts
var Token = Symbol("Token");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Arr,
  Entry,
  RimbuError,
  Token,
  isIterable,
  isPlainObj
});
