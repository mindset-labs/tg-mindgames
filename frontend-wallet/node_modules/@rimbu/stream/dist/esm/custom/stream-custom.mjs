var _a;
import { RimbuError } from '@rimbu/base';
import { Comp, Eq, ErrBase, IndexRange, OptLazy, Range, Reducer, TraverseState, } from '@rimbu/common';
import { AlwaysIterator, AppendIterator, ArrayIterator, ArrayReverseIterator, CollectIterator, ConcatIterator, DistinctPreviousIterator, DropIterator, DropWhileIterator, FilterApplyIterator, FilterIterator, FilterPureIterator, FlatMapIterator, IndexedIterator, IndicesOfIterator, IndicesWhereIterator, IntersperseIterator, MapApplyIterator, MapIterator, MapPureIterator, PrependIterator, RandomIntIterator, RandomIterator, RangeDownIterator, RangeUpIterator, ReduceAllIterator, ReduceIterator, RepeatIterator, SplitOnIterator, SplitWhereIterator, TakeIterator, TakeWhileIterator, UnfoldIterator, WindowIterator, ZipAllWithItererator, ZipWithIterator, emptyFastIterator, isFastIterator, } from '@rimbu/stream/custom';
function* yieldObjKeys(obj) {
    for (const key in obj) {
        yield key;
    }
}
function* yieldObjValues(obj) {
    for (const key in obj) {
        yield obj[key];
    }
}
function* yieldObjEntries(obj) {
    for (const key in obj) {
        yield [key, obj[key]];
    }
}
export class StreamBase {
    stream() {
        return this;
    }
    equals(other, eq = Eq.objectIs) {
        const it1 = this[Symbol.iterator]();
        const it2 = fromStreamSource(other)[Symbol.iterator]();
        const done = Symbol('Done');
        while (true) {
            const v1 = it1.fastNext(done);
            const v2 = it2.fastNext(done);
            if (done === v1 || done === v2)
                return Object.is(v1, v2);
            if (!eq(v1, v2))
                return false;
        }
    }
    assumeNonEmpty() {
        return this;
    }
    asNormal() {
        return this;
    }
    prepend(value) {
        return new PrependStream(this, value).assumeNonEmpty();
    }
    append(value) {
        return new AppendStream(this, value).assumeNonEmpty();
    }
    forEach(f, state = TraverseState()) {
        if (state.halted)
            return;
        const done = Symbol('Done');
        let value;
        const iterator = this[Symbol.iterator]();
        const { halt } = state;
        while (!state.halted && done !== (value = iterator.fastNext(done))) {
            f(value, state.nextIndex(), halt);
        }
    }
    forEachPure(f, ...args) {
        const done = Symbol('Done');
        let value;
        const iterator = this[Symbol.iterator]();
        while (done !== (value = iterator.fastNext(done))) {
            f(value, ...args);
        }
    }
    indexed(startIndex = 0) {
        return new IndexedStream(this, startIndex);
    }
    map(mapFun) {
        return new MapStream(this, mapFun);
    }
    mapPure(mapFun, ...args) {
        return new MapPureStream(this, mapFun, args);
    }
    flatMap(flatMapFun) {
        return new FlatMapStream(this, flatMapFun);
    }
    flatZip(flatMapFun) {
        return this.flatMap((value, index, halt) => fromStreamSource(flatMapFun(value, index, halt)).map((result) => [
            value,
            result,
        ]));
    }
    transform(transformer) {
        return StreamConstructorsImpl.flatten(this.reduceStream(transformer));
    }
    filter(pred) {
        return new FilterStream(this, pred);
    }
    filterNot(pred) {
        return new FilterStream(this, pred, true);
    }
    filterPure(pred, ...args) {
        return new FilterPureStream(this, pred, args);
    }
    filterNotPure(pred, ...args) {
        return new FilterPureStream(this, pred, args, true);
    }
    collect(collectFun) {
        return new CollectStream(this, collectFun);
    }
    first(otherwise) {
        return this[Symbol.iterator]().fastNext(otherwise);
    }
    last(otherwise) {
        const done = Symbol('Done');
        let value;
        let lastValue = done;
        const iterator = this[Symbol.iterator]();
        while (done !== (value = iterator.fastNext(done))) {
            lastValue = value;
        }
        if (done === lastValue)
            return OptLazy(otherwise);
        return lastValue;
    }
    single(otherwise) {
        const iterator = this[Symbol.iterator]();
        const done = Symbol('Done');
        const value = iterator.fastNext(done);
        if (done !== value) {
            if (done === iterator.fastNext(done)) {
                return value;
            }
        }
        return OptLazy(otherwise);
    }
    count() {
        let result = 0;
        const done = Symbol('Done');
        const iterator = this[Symbol.iterator]();
        while (done !== iterator.fastNext(done))
            result++;
        return result;
    }
    countElement(value, eq = Eq.objectIs) {
        let result = 0;
        const done = Symbol('Done');
        const iterator = this[Symbol.iterator]();
        let current;
        while (done !== (current = iterator.fastNext(done))) {
            if (eq(value, current))
                result++;
        }
        return result;
    }
    countNotElement(value, eq = Eq.objectIs) {
        let result = 0;
        const done = Symbol('Done');
        const iterator = this[Symbol.iterator]();
        let current;
        while (done !== (current = iterator.fastNext(done))) {
            if (!eq(value, current))
                result++;
        }
        return result;
    }
    find(pred, occurrance = 1, otherwise) {
        if (occurrance <= 0)
            return OptLazy(otherwise);
        const done = Symbol('Done');
        const iterator = this[Symbol.iterator]();
        let value;
        let remain = occurrance;
        let index = 0;
        while (done !== (value = iterator.fastNext(done))) {
            if (pred(value, index++) && --remain <= 0)
                return value;
        }
        return OptLazy(otherwise);
    }
    elementAt(index, otherwise) {
        if (index < 0)
            return OptLazy(otherwise);
        const done = Symbol('Done');
        const iterator = this[Symbol.iterator]();
        let value;
        let i = 0;
        while (i <= index && done !== (value = iterator.fastNext(done))) {
            if (i === index)
                return value;
            i++;
        }
        return OptLazy(otherwise);
    }
    indicesWhere(pred) {
        return new IndicesWhereStream(this, pred);
    }
    indicesOf(searchValue, eq = Eq.objectIs) {
        return new IndicesOfStream(this, searchValue, eq);
    }
    indexWhere(pred, occurrance = 1) {
        if (occurrance <= 0)
            return undefined;
        const done = Symbol('Done');
        let value;
        const iterator = this[Symbol.iterator]();
        let index = 0;
        let occ = 0;
        while (done !== (value = iterator.fastNext(done))) {
            const i = index++;
            if (pred(value, i)) {
                occ++;
                if (occ >= occurrance)
                    return i;
            }
        }
        return undefined;
    }
    indexOf(searchValue, occurrance = 1, eq = Eq.objectIs) {
        if (occurrance <= 0)
            return undefined;
        const done = Symbol('Done');
        let value;
        const iterator = this[Symbol.iterator]();
        let index = 0;
        let occ = 0;
        while (done !== (value = iterator.fastNext(done))) {
            const i = index++;
            if (eq(value, searchValue)) {
                occ++;
                if (occ >= occurrance)
                    return i;
            }
        }
        return undefined;
    }
    some(pred) {
        return undefined !== this.indexWhere(pred);
    }
    every(pred) {
        const iterator = this[Symbol.iterator]();
        const done = Symbol('Done');
        let value;
        let index = 0;
        while (done !== (value = iterator.fastNext(done))) {
            if (!pred(value, index++))
                return false;
        }
        return true;
    }
    contains(searchValue, amount = 1, eq) {
        if (amount <= 0)
            return true;
        return undefined !== this.indexOf(searchValue, amount, eq);
    }
    containsSlice(source, eq = Eq.objectIs) {
        const iterator = this[Symbol.iterator]();
        const sourceStream = fromStreamSource(source);
        let sourceIterator = sourceStream[Symbol.iterator]();
        const done = Symbol('Done');
        while (true) {
            const sourceValue = sourceIterator.fastNext(done);
            if (done === sourceValue)
                return true;
            const value = iterator.fastNext(done);
            if (done === value)
                return false;
            if (!eq(sourceValue, value)) {
                sourceIterator = sourceStream[Symbol.iterator]();
            }
        }
    }
    takeWhile(pred) {
        return new TakeWhileStream(this, pred);
    }
    dropWhile(pred) {
        return new DropWhileStream(this, pred);
    }
    take(amount) {
        if (amount <= 0)
            return emptyStream;
        return new TakeStream(this, amount);
    }
    drop(amount) {
        if (amount <= 0)
            return this;
        return new DropStream(this, amount);
    }
    repeat(amount) {
        if (undefined !== amount && amount <= 1)
            return this;
        return new FromStream(() => new RepeatIterator(this, amount));
    }
    concat(...others) {
        if (others.every(isEmptyStreamSourceInstance)) {
            return this.assumeNonEmpty();
        }
        return new ConcatStream(this, others).assumeNonEmpty();
    }
    min(otherwise) {
        return this.minBy(Comp.defaultComp().compare, otherwise);
    }
    minBy(compare, otherwise) {
        const done = Symbol('Done');
        const iterator = this[Symbol.iterator]();
        let result = iterator.fastNext(done);
        if (done === result)
            return OptLazy(otherwise);
        let value;
        while (done !== (value = iterator.fastNext(done))) {
            if (compare(value, result) < 0)
                result = value;
        }
        return result;
    }
    max(otherwise) {
        return this.maxBy(Comp.defaultComp().compare, otherwise);
    }
    maxBy(compare, otherwise) {
        const done = Symbol('Done');
        const iterator = this[Symbol.iterator]();
        let result = iterator.fastNext(done);
        if (done === result)
            return OptLazy(otherwise);
        let value;
        while (done !== (value = iterator.fastNext(done))) {
            if (compare(value, result) > 0)
                result = value;
        }
        return result;
    }
    intersperse(sep) {
        if (isEmptyStreamSourceInstance(sep))
            return this;
        const sepStream = fromStreamSource(sep);
        return new IntersperseStream(this, sepStream);
    }
    join({ sep = '', start = '', end = '', valueToString = String, ifEmpty = undefined, } = {}) {
        const done = Symbol('Done');
        const iterator = this[Symbol.iterator]();
        let value = iterator.fastNext(done);
        if (done === value) {
            if (undefined !== ifEmpty)
                return ifEmpty;
            return start.concat(end);
        }
        let result = start.concat(valueToString(value));
        while (done !== (value = iterator.fastNext(done))) {
            result = result.concat(sep, valueToString(value));
        }
        return result.concat(end);
    }
    mkGroup({ sep = emptyStream, start = emptyStream, end = emptyStream, } = {}) {
        return fromStreamSource(start).concat(this.intersperse(sep), end);
    }
    splitWhere(pred) {
        return new SplitWhereStream(this, pred);
    }
    splitOn(sepElem, eq = Eq.objectIs) {
        return new SplitOnStream(this, sepElem, eq);
    }
    distinctPrevious(eq = Eq.objectIs) {
        return new DistinctPreviousStream(this, eq);
    }
    window(windowSize, skipAmount = windowSize, collector = Reducer.toArray()) {
        return new WindowStream(this, windowSize, skipAmount, collector);
    }
    fold(init, next) {
        return this.reduce(Reducer.createOutput(init, next));
    }
    foldStream(init, next) {
        return this.reduceStream(Reducer.createOutput(init, next));
    }
    reduce(reducer) {
        let halted = false;
        function halt() {
            halted = true;
        }
        let index = 0;
        const next = reducer.next;
        let state = OptLazy(reducer.init);
        const done = Symbol('Done');
        let value;
        const iter = this[Symbol.iterator]();
        while (!halted && done !== (value = iter.fastNext(done))) {
            state = next(state, value, index++, halt);
        }
        return reducer.stateToResult(state);
    }
    reduceStream(reducer) {
        return new ReduceStream(this, reducer);
    }
    reduceAll(...reducers) {
        const state = reducers.map((d) => OptLazy(d.init));
        const iteratorsDone = state.map((_, i) => () => {
            iteratorsDone[i] = null;
        });
        const iter = this[Symbol.iterator]();
        const length = reducers.length;
        const done = Symbol('Done');
        let value;
        let index = 0;
        while (done !== (value = iter.fastNext(done))) {
            let i = -1;
            let anyNotDone = false;
            while (++i < length) {
                const halt = iteratorsDone[i];
                if (null !== halt) {
                    anyNotDone = true;
                    state[i] = reducers[i].next(state[i], value, index, halt);
                }
            }
            if (!anyNotDone)
                break;
            index++;
        }
        return state.map((s, i) => reducers[i].stateToResult(s));
    }
    reduceAllStream(...reducers) {
        return new ReduceAllStream(this, reducers);
    }
    toArray() {
        const iterator = this[Symbol.iterator]();
        const result = [];
        const done = Symbol('Done');
        let value;
        while (done !== (value = iterator.fastNext(done))) {
            result.push(value);
        }
        return result;
    }
    toString() {
        return `Stream(...<potentially empty>)`;
    }
    toJSON() {
        return {
            dataType: 'Stream',
            value: this.toArray(),
        };
    }
}
export class FromStream extends StreamBase {
    constructor(createIterator) {
        super();
        this[_a] = undefined;
        this[Symbol.iterator] = createIterator;
    }
}
_a = Symbol.iterator;
class PrependStream extends StreamBase {
    constructor(source, item) {
        super();
        this.source = source;
        this.item = item;
    }
    [Symbol.iterator]() {
        return new PrependIterator(this.source[Symbol.iterator](), this.item);
    }
    first() {
        return OptLazy(this.item);
    }
    last() {
        return this.source.last(this.item);
    }
    count() {
        return this.source.count() + 1;
    }
    forEach(f, state = TraverseState()) {
        if (state.halted)
            return;
        f(OptLazy(this.item), state.nextIndex(), state.halt);
        if (state.halted)
            return;
        this.source.forEach(f, state);
    }
}
class AppendStream extends StreamBase {
    constructor(source, item) {
        super();
        this.source = source;
        this.item = item;
    }
    [Symbol.iterator]() {
        return new AppendIterator(this.source[Symbol.iterator](), this.item);
    }
    first() {
        return this.source.first(this.item);
    }
    last() {
        return OptLazy(this.item);
    }
    count() {
        return this.source.count() + 1;
    }
    forEach(f, state = TraverseState()) {
        if (state.halted)
            return;
        this.source.forEach(f, state);
        if (state.halted)
            return;
        f(OptLazy(this.item), state.nextIndex(), state.halt);
    }
}
class IndexedStream extends StreamBase {
    constructor(source, startIndex) {
        super();
        this.source = source;
        this.startIndex = startIndex;
    }
    [Symbol.iterator]() {
        return new IndexedIterator(this.source[Symbol.iterator](), this.startIndex);
    }
    count() {
        return this.source.count();
    }
}
class MapStream extends StreamBase {
    constructor(source, mapFun) {
        super();
        this.source = source;
        this.mapFun = mapFun;
    }
    [Symbol.iterator]() {
        return new MapIterator(this.source[Symbol.iterator](), this.mapFun);
    }
    first(otherwise) {
        const done = Symbol('Done');
        const value = this.source.first(done);
        if (done === value)
            return OptLazy(otherwise);
        return this.mapFun(value, 0);
    }
    last(otherwise) {
        const done = Symbol('Done');
        const value = this.source.last(done);
        if (done === value)
            return OptLazy(otherwise);
        return this.mapFun(value, 0);
    }
    count() {
        return this.source.count();
    }
    elementAt(index, otherwise) {
        const done = Symbol('Done');
        const value = this.source.elementAt(index, done);
        if (done === value)
            return OptLazy(otherwise);
        return this.mapFun(value, index);
    }
    map(mapFun) {
        return new MapStream(this.source, (value, index) => mapFun(this.mapFun(value, index), index));
    }
}
class MapPureStream extends StreamBase {
    constructor(source, mapFun, args) {
        super();
        this.source = source;
        this.mapFun = mapFun;
        this.args = args;
    }
    [Symbol.iterator]() {
        return new MapPureIterator(this.source[Symbol.iterator](), this.mapFun, this.args);
    }
    first(otherwise) {
        const done = Symbol('Done');
        const value = this.source.first(done);
        if (done === value)
            return OptLazy(otherwise);
        return this.mapFun(value, ...this.args);
    }
    last(otherwise) {
        const done = Symbol('Done');
        const value = this.source.last(done);
        if (done === value)
            return OptLazy(otherwise);
        return this.mapFun(value, ...this.args);
    }
    count() {
        return this.source.count();
    }
    elementAt(index, otherwise) {
        const done = Symbol('Done');
        const value = this.source.elementAt(index, done);
        if (done === value)
            return OptLazy(otherwise);
        return this.mapFun(value, ...this.args);
    }
}
class FlatMapStream extends StreamBase {
    constructor(source, flatmapFun) {
        super();
        this.source = source;
        this.flatmapFun = flatmapFun;
    }
    [Symbol.iterator]() {
        return new FlatMapIterator(this.source, this.flatmapFun, streamSourceHelpers);
    }
}
class ConcatStream extends StreamBase {
    constructor(source, otherSources) {
        super();
        this.source = source;
        this.otherSources = otherSources;
    }
    [Symbol.iterator]() {
        return new ConcatIterator(this.source, this.otherSources, streamSourceHelpers);
    }
    forEach(f, state = TraverseState()) {
        if (state.halted)
            return;
        this.source.forEach(f, state);
        let sourceIndex = -1;
        const sources = this.otherSources;
        const length = sources.length;
        while (!state.halted && ++sourceIndex < length) {
            const source = sources[sourceIndex];
            if (!isEmptyStreamSourceInstance(source)) {
                fromStreamSource(source).forEach(f, state);
            }
        }
    }
    last(otherwise) {
        const sources = this.otherSources;
        let sourceIndex = sources.length;
        while (--sourceIndex >= 0) {
            const source = sources[sourceIndex];
            if (!isEmptyStreamSourceInstance(source)) {
                const done = Symbol('Done');
                const value = fromStreamSource(source).last(done);
                if (done !== value)
                    return value;
            }
        }
        return this.source.last(otherwise);
    }
    count() {
        let result = this.source.count();
        const sources = this.otherSources;
        const length = sources.length;
        let sourceIndex = -1;
        while (++sourceIndex < length) {
            const source = sources[sourceIndex];
            if (!isEmptyStreamSourceInstance(source)) {
                result += fromStreamSource(source).count();
            }
        }
        return result;
    }
    concat(...others2) {
        return new ConcatStream(this.source, this.otherSources.concat(others2));
    }
    toArray() {
        let result = this.source.toArray();
        let sourceIndex = -1;
        const sources = this.otherSources;
        const length = sources.length;
        while (++sourceIndex < length) {
            const source = sources[sourceIndex];
            if (!isEmptyStreamSourceInstance(source)) {
                result = result.concat(fromStreamSource(source).toArray());
            }
        }
        return result;
    }
}
class FilterStream extends StreamBase {
    constructor(source, pred, invert = false) {
        super();
        this.source = source;
        this.pred = pred;
        this.invert = invert;
    }
    [Symbol.iterator]() {
        return new FilterIterator(this.source[Symbol.iterator](), this.pred, this.invert);
    }
    filter(pred) {
        return new FilterStream(this.source, (v, i, halt) => this.pred(v, i, halt) && pred(v, i, halt));
    }
}
class FilterPureStream extends StreamBase {
    constructor(source, pred, args, invert = false) {
        super();
        this.source = source;
        this.pred = pred;
        this.args = args;
        this.invert = invert;
    }
    [Symbol.iterator]() {
        return new FilterPureIterator(this.source[Symbol.iterator](), this.pred, this.args, this.invert);
    }
}
class CollectStream extends StreamBase {
    constructor(source, collectFun) {
        super();
        this.source = source;
        this.collectFun = collectFun;
    }
    [Symbol.iterator]() {
        return new CollectIterator(this.source[Symbol.iterator](), this.collectFun);
    }
}
class IndicesWhereStream extends StreamBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
    }
    [Symbol.iterator]() {
        return new IndicesWhereIterator(this.source[Symbol.iterator](), this.pred);
    }
}
class IndicesOfStream extends StreamBase {
    constructor(source, searchValue, eq) {
        super();
        this.source = source;
        this.searchValue = searchValue;
        this.eq = eq;
    }
    [Symbol.iterator]() {
        return new IndicesOfIterator(this.source[Symbol.iterator](), this.searchValue, this.eq);
    }
}
class TakeWhileStream extends StreamBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
    }
    [Symbol.iterator]() {
        return new TakeWhileIterator(this.source[Symbol.iterator](), this.pred);
    }
}
class DropWhileStream extends StreamBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
    }
    [Symbol.iterator]() {
        return new DropWhileIterator(this.source[Symbol.iterator](), this.pred);
    }
}
class TakeStream extends StreamBase {
    constructor(source, amount) {
        super();
        this.source = source;
        this.amount = amount;
    }
    [Symbol.iterator]() {
        return new TakeIterator(this.source[Symbol.iterator](), this.amount);
    }
    take(amount) {
        if (amount === this.amount)
            return this;
        return this.source.take(amount);
    }
}
class DropStream extends StreamBase {
    constructor(source, amount) {
        super();
        this.source = source;
        this.amount = amount;
    }
    [Symbol.iterator]() {
        return new DropIterator(this.source[Symbol.iterator](), this.amount);
    }
    drop(amount) {
        if (amount <= 0)
            return this;
        return this.source.drop(this.amount + amount);
    }
}
class IntersperseStream extends StreamBase {
    constructor(source, sepStream) {
        super();
        this.source = source;
        this.sepStream = sepStream;
    }
    [Symbol.iterator]() {
        return new IntersperseIterator(this.source[Symbol.iterator](), this.sepStream);
    }
}
class SplitWhereStream extends StreamBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
    }
    [Symbol.iterator]() {
        return new SplitWhereIterator(this.source[Symbol.iterator](), this.pred);
    }
}
class SplitOnStream extends StreamBase {
    constructor(source, sepElem, eq) {
        super();
        this.source = source;
        this.sepElem = sepElem;
        this.eq = eq;
    }
    [Symbol.iterator]() {
        return new SplitOnIterator(this.source[Symbol.iterator](), this.sepElem, this.eq);
    }
}
class ReduceStream extends StreamBase {
    constructor(source, reducerDef) {
        super();
        this.source = source;
        this.reducerDef = reducerDef;
    }
    [Symbol.iterator]() {
        return new ReduceIterator(this.source[Symbol.iterator](), this.reducerDef);
    }
}
class ReduceAllStream extends StreamBase {
    constructor(source, reducers) {
        super();
        this.source = source;
        this.reducers = reducers;
    }
    [Symbol.iterator]() {
        return new ReduceAllIterator(this.source[Symbol.iterator](), this.reducers);
    }
}
class SlowIteratorAdapter {
    constructor(source) {
        this.source = source;
    }
    next() {
        return this.source.next();
    }
    fastNext(otherwise) {
        const result = this.source.next();
        if (result.done)
            return OptLazy(otherwise);
        return result.value;
    }
}
export class FromIterable extends StreamBase {
    constructor(iterable) {
        super();
        this.iterable = iterable;
    }
    [Symbol.iterator]() {
        const iterator = this.iterable[Symbol.iterator]();
        if (isFastIterator(iterator))
            return iterator;
        return new SlowIteratorAdapter(iterator);
    }
}
class EmptyStream extends StreamBase {
    [Symbol.iterator]() {
        return emptyFastIterator;
    }
    stream() {
        return this;
    }
    assumeNonEmpty() {
        RimbuError.throwEmptyCollectionAssumedNonEmptyError();
    }
    equals(other) {
        const done = Symbol('Done');
        return done === fromStreamSource(other)[Symbol.iterator]().fastNext(done);
    }
    prepend(value) {
        return StreamConstructorsImpl.of(OptLazy(value));
    }
    append(value) {
        return StreamConstructorsImpl.of(OptLazy(value));
    }
    forEach() {
        //
    }
    forEachPure() {
        //
    }
    indexed() {
        return this;
    }
    map() {
        return this;
    }
    mapPure() {
        return this;
    }
    flatMap() {
        return this;
    }
    flatZip() {
        return this;
    }
    transform(transformer) {
        return StreamConstructorsImpl.from(transformer.stateToResult(OptLazy(transformer.init)));
    }
    filter() {
        return this;
    }
    filterNot() {
        return this;
    }
    filterPure() {
        return this;
    }
    filterNotPure() {
        return this;
    }
    collect() {
        return this;
    }
    first(otherwise) {
        return OptLazy(otherwise);
    }
    last(otherwise) {
        return OptLazy(otherwise);
    }
    single(otherwise) {
        return OptLazy(otherwise);
    }
    count() {
        return 0;
    }
    countElement() {
        return 0;
    }
    countNotElement() {
        return 0;
    }
    find(pred, occurrance, otherwise) {
        return OptLazy(otherwise);
    }
    elementAt(index, otherwise) {
        return OptLazy(otherwise);
    }
    indicesWhere() {
        return this;
    }
    indicesOf() {
        return this;
    }
    indexWhere() {
        return undefined;
    }
    indexOf() {
        return undefined;
    }
    some() {
        return false;
    }
    every() {
        return true;
    }
    contains() {
        return false;
    }
    containsSlice() {
        return false;
    }
    takeWhile() {
        return this;
    }
    dropWhile() {
        return this;
    }
    take() {
        return this;
    }
    drop() {
        return this;
    }
    repeat() {
        return this;
    }
    concat(...others) {
        if (others.every(isEmptyStreamSourceInstance))
            return this;
        const [source1, source2, ...sources] = others;
        if (undefined === source2)
            return source1;
        return fromStreamSource(source1).concat(source2, ...sources);
    }
    min(otherwise) {
        return OptLazy(otherwise);
    }
    minBy(compare, otherwise) {
        return OptLazy(otherwise);
    }
    max(otherwise) {
        return OptLazy(otherwise);
    }
    maxBy(compare, otherwise) {
        return OptLazy(otherwise);
    }
    intersperse() {
        return this;
    }
    join({ start = '', end = '', ifEmpty = undefined } = {}) {
        if (undefined !== ifEmpty)
            return ifEmpty;
        return start.concat(end);
    }
    mkGroup({ start = emptyStream, end = emptyStream, } = {}) {
        return fromStreamSource(start).concat(end);
    }
    splitOn() {
        return this;
    }
    splitWhere() {
        return this;
    }
    distinctPrevious() {
        return this;
    }
    window() {
        return this;
    }
    fold(init) {
        return OptLazy(init);
    }
    foldStream() {
        return this;
    }
    reduce(reducer) {
        return reducer.stateToResult(OptLazy(reducer.init));
    }
    reduceStream() {
        return this;
    }
    reduceAll(...reducers) {
        return reducers.map((p) => p.stateToResult(OptLazy(p.init)));
    }
    reduceAllStream() {
        return this;
    }
    toArray() {
        return [];
    }
    toString() {
        return `Stream(<empty>)`;
    }
    toJSON() {
        return {
            dataType: 'Stream',
            value: [],
        };
    }
}
export class ArrayStream extends StreamBase {
    constructor(array, startIndex = 0, endIndex = array.length - 1, reversed = false) {
        super();
        this.array = array;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.reversed = reversed;
        this.length = endIndex - startIndex + 1;
    }
    [Symbol.iterator]() {
        if (!this.reversed) {
            return new ArrayIterator(this.array, this.startIndex, this.endIndex);
        }
        return new ArrayReverseIterator(this.array, this.startIndex, this.endIndex);
    }
    forEach(f, state = TraverseState()) {
        const startIndex = this.startIndex;
        const endIndex = this.endIndex;
        const array = this.array;
        const { halt } = state;
        if (!this.reversed) {
            let i = this.startIndex - 1;
            while (!state.halted && ++i <= endIndex) {
                f(array[i], state.nextIndex(), halt);
            }
        }
        else {
            let i = endIndex + 1;
            while (!state.halted && --i >= startIndex) {
                f(array[i], state.nextIndex(), halt);
            }
        }
    }
    first(otherwise) {
        if (this.length <= 0)
            return OptLazy(otherwise);
        if (!this.reversed)
            return this.array[this.startIndex];
        return this.array[this.endIndex];
    }
    last(otherwise) {
        if (this.length <= 0)
            return OptLazy(otherwise);
        if (!this.reversed)
            return this.array[this.endIndex];
        return this.array[this.startIndex];
    }
    count() {
        return this.endIndex - this.startIndex + 1;
    }
    find(pred, occurrance = 1, otherwise) {
        const startIndex = this.startIndex;
        const endIndex = this.endIndex;
        const array = this.array;
        let remain = occurrance;
        let index = 0;
        if (!this.reversed) {
            let i = startIndex - 1;
            while (++i <= endIndex) {
                const value = array[i];
                if (pred(value, index++) && --remain <= 0)
                    return value;
            }
        }
        else {
            let i = endIndex + 1;
            while (--i >= startIndex) {
                const value = array[i];
                if (pred(value, index++) && --remain <= 0)
                    return value;
            }
        }
        return OptLazy(otherwise);
    }
    elementAt(index, otherwise) {
        if (index < 0 || index >= this.length)
            return OptLazy(otherwise);
        if (!this.reversed)
            return this.array[index + this.startIndex];
        return this.array[this.endIndex - index];
    }
    some(pred) {
        const startIndex = this.startIndex;
        const endIndex = this.endIndex;
        const array = this.array;
        let index = 0;
        if (!this.reversed) {
            let i = this.startIndex - 1;
            while (++i <= endIndex) {
                const value = array[i];
                if (pred(value, index++))
                    return true;
            }
        }
        else {
            let i = this.endIndex + 1;
            while (--i >= startIndex) {
                const value = array[i];
                if (pred(value, index++))
                    return true;
            }
        }
        return false;
    }
    every(pred) {
        const startIndex = this.startIndex;
        const endIndex = this.endIndex;
        const array = this.array;
        let index = 0;
        if (!this.reversed) {
            let i = startIndex - 1;
            while (++i <= endIndex) {
                const value = array[i];
                if (!pred(value, index++))
                    return false;
            }
        }
        else {
            let i = endIndex + 1;
            while (--i >= startIndex) {
                const value = array[i];
                if (!pred(value, index++))
                    return false;
            }
        }
        return true;
    }
    indexOf(searchValue, occurrance = 1, eq = Object.is) {
        if (occurrance <= 0)
            return undefined;
        let remain = occurrance;
        const startIndex = this.startIndex;
        const endIndex = this.endIndex;
        const array = this.array;
        if (!this.reversed) {
            let i = startIndex - 1;
            while (++i <= endIndex) {
                if (eq(array[i], searchValue) && --remain <= 0)
                    return i - startIndex;
            }
        }
        else {
            let i = endIndex + 1;
            while (--i >= startIndex) {
                if (eq(array[i], searchValue) && --remain <= 0)
                    return endIndex - i;
            }
        }
        return undefined;
    }
    contains(searchValue, amount = 1, eq = Object.is) {
        if (amount <= 0)
            return true;
        return undefined !== this.indexOf(searchValue, amount, eq);
    }
    take(amount) {
        if (amount <= 0)
            return emptyStream;
        if (amount >= this.length)
            return this;
        if (!this.reversed) {
            return new ArrayStream(this.array, this.startIndex, this.startIndex + amount - 1, this.reversed);
        }
        return new ArrayStream(this.array, this.endIndex - (amount - 1), this.endIndex, this.reversed);
    }
    drop(amount) {
        if (amount <= 0)
            return this;
        if (amount >= this.length)
            return emptyStream;
        if (!this.reversed) {
            return new ArrayStream(this.array, this.startIndex + amount, this.endIndex, this.reversed);
        }
        return new ArrayStream(this.array, this.startIndex, this.endIndex - amount, this.reversed);
    }
    toArray() {
        const array = this.array;
        if (typeof array === 'string') {
            return super.toArray();
        }
        if (this.reversed)
            return super.toArray();
        return array.slice(this.startIndex, this.endIndex + 1);
    }
}
export class AlwaysStream extends StreamBase {
    constructor(value) {
        super();
        this.value = value;
    }
    [Symbol.iterator]() {
        return new AlwaysIterator(this.value);
    }
    first() {
        return this.value;
    }
    append() {
        return this;
    }
    forEach(f, state) {
        const s = state ?? TraverseState();
        const value = this.value;
        while (!s.halted) {
            f(value, s.nextIndex(), s.halt);
        }
    }
    last() {
        return this.value;
    }
    elementAt() {
        return this.value;
    }
    repeat() {
        return this;
    }
    concat() {
        return this.assumeNonEmpty();
    }
    min() {
        return this.value;
    }
    minBy() {
        return this.value;
    }
    max() {
        return this.value;
    }
    maxBy() {
        return this.value;
    }
}
export class MapApplyStream extends StreamBase {
    constructor(source, f, args) {
        super();
        this.source = source;
        this.f = f;
        this.args = args;
    }
    [Symbol.iterator]() {
        return new MapApplyIterator(this.source, this.f, this.args, streamSourceHelpers);
    }
}
export class FilterApplyStream extends StreamBase {
    constructor(source, pred, args, invert = false) {
        super();
        this.source = source;
        this.pred = pred;
        this.args = args;
        this.invert = invert;
    }
    [Symbol.iterator]() {
        return new FilterApplyIterator(this.source, this.pred, this.args, this.invert, streamSourceHelpers);
    }
}
export class RangeStream extends StreamBase {
    constructor(start, end, delta = 1) {
        super();
        this.start = start;
        this.end = end;
        this.delta = delta;
    }
    [Symbol.iterator]() {
        if (this.delta >= 0) {
            return new RangeUpIterator(this.start, this.end, this.delta);
        }
        return new RangeDownIterator(this.start, this.end, this.delta);
    }
}
export class DistinctPreviousStream extends StreamBase {
    constructor(source, eq) {
        super();
        this.source = source;
        this.eq = eq;
    }
    [Symbol.iterator]() {
        return new DistinctPreviousIterator(this.source[Symbol.iterator](), this.eq);
    }
}
export class WindowStream extends StreamBase {
    constructor(source, windowSize, skipAmount, collector) {
        super();
        this.source = source;
        this.windowSize = windowSize;
        this.skipAmount = skipAmount;
        this.collector = collector;
    }
    [Symbol.iterator]() {
        return new WindowIterator(this.source[Symbol.iterator](), this.windowSize, this.skipAmount, this.collector);
    }
}
export const emptyStream = Object.freeze(new EmptyStream());
export function isStream(obj) {
    return obj instanceof StreamBase;
}
export const fromStreamSource = (source) => {
    if (undefined === source || isEmptyStreamSourceInstance(source))
        return emptyStream;
    if (isStream(source))
        return source;
    if (typeof source === 'object' && `stream` in source)
        return source.stream();
    if (Array.isArray(source)) {
        if (source.length <= 0)
            return emptyStream;
        return new ArrayStream(source);
    }
    return new FromIterable(source);
};
/**
 * Returns true if the given `source` StreamSource is known to be empty.
 * @param source - a StreamSource
 * @note
 * If this function returns false, it does not guarantee that the Stream is not empty. It only
 * means that it is not known if it is empty.
 */
export function isEmptyStreamSourceInstance(source) {
    if (source === '')
        return true;
    if (typeof source === 'object') {
        if (source === emptyStream)
            return true;
        if (`length` in source && source.length === 0)
            return true;
        if (`size` in source && source.size === 0)
            return true;
        if (`isEmpty` in source && source.isEmpty === true)
            return true;
    }
    return false;
}
const streamSourceHelpers = {
    fromStreamSource,
    isEmptyStreamSourceInstance,
};
export const StreamConstructorsImpl = Object.freeze({
    empty() {
        return emptyStream;
    },
    of(...values) {
        return fromStreamSource(values);
    },
    from(...sources) {
        const [first, ...rest] = sources;
        if (rest.length <= 0) {
            return fromStreamSource(first);
        }
        const [rest1, ...restOther] = rest;
        return fromStreamSource(first).concat(rest1, ...restOther);
    },
    fromArray(array, range, reversed = false) {
        if (array.length === 0)
            return emptyStream;
        if (undefined === range) {
            return new ArrayStream(array, undefined, undefined, reversed);
        }
        const result = IndexRange.getIndicesFor(range, array.length);
        if (result === 'empty') {
            return emptyStream;
        }
        if (result === 'all') {
            return new ArrayStream(array, undefined, undefined, reversed);
        }
        return new ArrayStream(array, result[0], result[1], reversed);
    },
    fromObjectKeys(obj) {
        return StreamConstructorsImpl.from(yieldObjKeys(obj));
    },
    fromObjectValues(obj) {
        return StreamConstructorsImpl.from(yieldObjValues(obj));
    },
    fromObject(obj) {
        return StreamConstructorsImpl.from(yieldObjEntries(obj));
    },
    fromString(source, range, reversed = false) {
        return StreamConstructorsImpl.fromArray(source, range, reversed);
    },
    always(value) {
        return new AlwaysStream(value);
    },
    applyForEach(source, f, ...args) {
        const iter = StreamConstructorsImpl.from(source)[Symbol.iterator]();
        const done = Symbol();
        let values;
        while (done !== (values = iter.fastNext(done))) {
            f(...values, ...args);
        }
    },
    applyMap(source, mapFun, ...args) {
        return new MapApplyStream(source, mapFun, args);
    },
    applyFilter(source, pred, ...args) {
        return new FilterApplyStream(source, pred, args);
    },
    range(range, delta = 1) {
        if (undefined !== range.amount) {
            if (range.amount <= 0)
                return emptyStream;
            let startIndex = 0;
            if (undefined !== range.start) {
                if (Array.isArray(range.start)) {
                    startIndex = range.start[0];
                    if (!range.start[1])
                        startIndex++;
                }
                else
                    startIndex = range.start;
            }
            const endIndex = startIndex + range.amount - 1;
            return new RangeStream(startIndex, endIndex, delta);
        }
        const { start, end } = Range.getNormalizedRange(range);
        let startIndex = 0;
        let endIndex = undefined;
        if (undefined !== start) {
            startIndex = start[0];
            if (!start[1])
                startIndex++;
        }
        if (undefined !== end) {
            endIndex = end[0];
            if (!end[1])
                endIndex--;
        }
        if (undefined !== endIndex) {
            if (delta > 0 && endIndex < startIndex)
                return emptyStream;
            else if (delta < 0 && startIndex <= endIndex)
                return emptyStream;
        }
        return new RangeStream(startIndex, endIndex, delta);
    },
    random() {
        return new FromStream(() => new RandomIterator());
    },
    randomInt(min, max) {
        if (min >= max)
            ErrBase.msg('min should be smaller than max');
        return new FromStream(() => new RandomIntIterator(min, max));
    },
    unfold(init, next) {
        return new FromStream(() => new UnfoldIterator(init, next));
    },
    zipWith(...sources) {
        return (zipFun) => {
            if (sources.some(isEmptyStreamSourceInstance)) {
                return emptyStream;
            }
            return new FromStream(() => new ZipWithIterator(sources, zipFun, streamSourceHelpers));
        };
    },
    zip(...sources) {
        return StreamConstructorsImpl.zipWith(...sources)(Array);
    },
    zipAllWith(...sources) {
        return (fillValue, zipFun) => {
            if (sources.every(isEmptyStreamSourceInstance)) {
                return emptyStream;
            }
            return new FromStream(() => new ZipAllWithItererator(fillValue, sources, zipFun, streamSourceHelpers));
        };
    },
    zipAll(fillValue, ...sources) {
        return StreamConstructorsImpl.zipAllWith(...sources)(fillValue, Array);
    },
    flatten(source) {
        return fromStreamSource(source).flatMap((s) => s);
    },
    unzip(source, length) {
        if (isEmptyStreamSourceInstance(source)) {
            return StreamConstructorsImpl.of(emptyStream).repeat(length).toArray();
        }
        const result = [];
        let i = -1;
        while (++i < length) {
            const index = i;
            result[i] = source.map((t) => t[index]);
        }
        return result;
    },
});
//# sourceMappingURL=stream-custom.mjs.map