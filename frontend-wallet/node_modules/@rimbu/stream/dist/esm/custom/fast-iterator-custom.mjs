import { Token } from '@rimbu/base';
import { CollectFun, OptLazy, TraverseState, } from '@rimbu/common';
export const fixedDoneIteratorResult = Object.freeze({
    done: true,
    value: undefined,
});
export const emptyFastIterator = Object.freeze({
    fastNext(otherwise) {
        return OptLazy(otherwise);
    },
    next() {
        return fixedDoneIteratorResult;
    },
});
export function isFastIterator(iterator) {
    return `fastNext` in iterator;
}
/**
 * A base class for `FastIterator` instances, that takes implements the default `next`
 * function based on the abstract `fastNext` function.
 */
export class FastIteratorBase {
    next() {
        const done = Symbol('Done');
        const value = this.fastNext(done);
        if (done === value)
            return fixedDoneIteratorResult;
        return { value, done: false };
    }
}
export class FlatMapIterator extends FastIteratorBase {
    constructor(source, flatMapFun, streamSourceHelpers) {
        super();
        this.source = source;
        this.flatMapFun = flatMapFun;
        this.streamSourceHelpers = streamSourceHelpers;
        this.state = TraverseState();
        this.done = false;
        this.currentIterator = null;
        this.iterator = this.source[Symbol.iterator]();
    }
    fastNext(otherwise) {
        const state = this.state;
        if (state.halted || this.done)
            return OptLazy(otherwise);
        const done = Symbol('Done');
        let nextValue;
        while (null === this.currentIterator ||
            done === (nextValue = this.currentIterator.fastNext(done))) {
            const nextIter = this.iterator.fastNext(done);
            if (done === nextIter) {
                this.done = true;
                return OptLazy(otherwise);
            }
            const nextSource = this.flatMapFun(nextIter, state.nextIndex(), state.halt);
            this.currentIterator = this.streamSourceHelpers
                .fromStreamSource(nextSource)[Symbol.iterator]();
        }
        return nextValue;
    }
}
export class ConcatIterator extends FastIteratorBase {
    constructor(source, otherSources, streamSourceHelpers) {
        super();
        this.source = source;
        this.otherSources = otherSources;
        this.streamSourceHelpers = streamSourceHelpers;
        this.sourceIndex = 0;
        this.iterator = source[Symbol.iterator]();
    }
    fastNext(otherwise) {
        const done = Symbol('Done');
        let value;
        const length = this.otherSources.length;
        const { streamSourceHelpers } = this;
        while (done === (value = this.iterator.fastNext(done))) {
            if (this.sourceIndex >= length)
                return OptLazy(otherwise);
            let nextSource = this.otherSources[this.sourceIndex++];
            while (streamSourceHelpers.isEmptyStreamSourceInstance(nextSource)) {
                if (this.sourceIndex >= length)
                    return OptLazy(otherwise);
                nextSource = this.otherSources[this.sourceIndex++];
            }
            this.iterator = streamSourceHelpers
                .fromStreamSource(nextSource)[Symbol.iterator]();
        }
        return value;
    }
}
export class FilterIterator extends FastIteratorBase {
    constructor(source, pred, invert) {
        super();
        this.source = source;
        this.pred = pred;
        this.invert = invert;
        this.state = TraverseState();
    }
    fastNext(otherwise) {
        const state = this.state;
        if (state.halted)
            return OptLazy(otherwise);
        const done = Symbol('Done');
        let value;
        const source = this.source;
        const pred = this.pred;
        const halt = state.halt;
        if (this.invert) {
            while (!state.halted && done !== (value = source.fastNext(done))) {
                if (!pred(value, state.nextIndex(), halt))
                    return value;
            }
        }
        else {
            while (!state.halted && done !== (value = source.fastNext(done))) {
                if (pred(value, state.nextIndex(), halt))
                    return value;
            }
        }
        return OptLazy(otherwise);
    }
}
export class FilterPureIterator extends FastIteratorBase {
    constructor(source, pred, args, invert) {
        super();
        this.source = source;
        this.pred = pred;
        this.args = args;
        this.invert = invert;
    }
    fastNext(otherwise) {
        const done = Symbol('Done');
        let value;
        const source = this.source;
        const pred = this.pred;
        const args = this.args;
        if (this.invert) {
            while (done !== (value = source.fastNext(done))) {
                if (!pred(value, ...args))
                    return value;
            }
        }
        else {
            while (done !== (value = source.fastNext(done))) {
                if (pred(value, ...args))
                    return value;
            }
        }
        return OptLazy(otherwise);
    }
}
export class CollectIterator extends FastIteratorBase {
    constructor(source, collectFun) {
        super();
        this.source = source;
        this.collectFun = collectFun;
        this.state = TraverseState();
    }
    fastNext(otherwise) {
        const state = this.state;
        if (state.halted)
            return OptLazy(otherwise);
        const { halt } = state;
        const done = Symbol('Done');
        let value;
        const source = this.source;
        const collectFun = this.collectFun;
        while (!state.halted && done !== (value = source.fastNext(done))) {
            const result = collectFun(value, state.nextIndex(), CollectFun.Skip, halt);
            if (CollectFun.Skip === result)
                continue;
            return result;
        }
        return OptLazy(otherwise);
    }
}
export class IndicesWhereIterator extends FastIteratorBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
        this.index = 0;
    }
    fastNext(otherwise) {
        const done = Symbol('Done');
        let value;
        const source = this.source;
        const pred = this.pred;
        while (done !== (value = source.fastNext(done))) {
            if (pred(value))
                return this.index++;
            this.index++;
        }
        return OptLazy(otherwise);
    }
}
export class IndicesOfIterator extends FastIteratorBase {
    constructor(source, searchValue, eq) {
        super();
        this.source = source;
        this.searchValue = searchValue;
        this.eq = eq;
        this.index = 0;
    }
    fastNext(otherwise) {
        const done = Symbol('Done');
        let value;
        const source = this.source;
        const searchValue = this.searchValue;
        const eq = this.eq;
        while (done !== (value = source.fastNext(done))) {
            if (eq(searchValue, value))
                return this.index++;
            this.index++;
        }
        return OptLazy(otherwise);
    }
}
export class TakeWhileIterator extends FastIteratorBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
        this.isDone = false;
        this.index = 0;
    }
    fastNext(otherwise) {
        const done = Symbol('Done');
        if (this.isDone)
            return OptLazy(otherwise);
        const next = this.source.fastNext(done);
        if (done === next) {
            this.isDone = true;
            return OptLazy(otherwise);
        }
        if (this.pred(next, this.index++))
            return next;
        this.isDone = true;
        return OptLazy(otherwise);
    }
}
export class DropWhileIterator extends FastIteratorBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
        this.pass = false;
        this.index = 0;
    }
    fastNext(otherwise) {
        const source = this.source;
        if (this.pass)
            return source.fastNext(otherwise);
        const done = Symbol('Done');
        let value;
        while (done !== (value = source.fastNext(done))) {
            this.pass = !this.pred(value, this.index++);
            if (this.pass)
                return value;
        }
        return OptLazy(otherwise);
    }
}
export class TakeIterator extends FastIteratorBase {
    constructor(source, amount) {
        super();
        this.source = source;
        this.amount = amount;
        this.i = 0;
    }
    fastNext(otherwise) {
        if (this.i++ >= this.amount)
            return OptLazy(otherwise);
        return this.source.fastNext(otherwise);
    }
}
export class DropIterator extends FastIteratorBase {
    constructor(source, amount) {
        super();
        this.source = source;
        this.amount = amount;
        this.remain = amount;
    }
    fastNext(otherwise) {
        const source = this.source;
        if (this.remain <= 0)
            return source.fastNext(otherwise);
        const done = Symbol('Done');
        let value;
        while (done !== (value = source.fastNext(done))) {
            if (this.remain-- <= 0)
                return value;
        }
        return OptLazy(otherwise);
    }
}
export class RepeatIterator extends FastIteratorBase {
    constructor(source, amount) {
        super();
        this.source = source;
        this.amount = amount;
        this.isEmpty = true;
        this.iterator = source[Symbol.iterator]();
        this.remain = amount;
    }
    fastNext(otherwise) {
        const done = Symbol('Done');
        let value = this.iterator.fastNext(done);
        if (done !== value) {
            this.isEmpty = false;
            return value;
        }
        if (this.isEmpty)
            return OptLazy(otherwise);
        if (undefined !== this.remain) {
            this.remain--;
            if (this.remain <= 0)
                return OptLazy(otherwise);
        }
        this.iterator = this.source[Symbol.iterator]();
        value = this.iterator.fastNext(done);
        if (done === value)
            return OptLazy(otherwise);
        return value;
    }
}
export class IntersperseIterator extends FastIteratorBase {
    constructor(source, sepStream) {
        super();
        this.source = source;
        this.sepStream = sepStream;
        this.isInitialized = false;
    }
    fastNext(otherwise) {
        const done = Symbol('Done');
        if (undefined !== this.sepIterator) {
            const sepNext = this.sepIterator.fastNext(done);
            if (done !== sepNext)
                return sepNext;
            this.sepIterator = undefined;
        }
        if (this.isInitialized) {
            const newNextValue = this.source.fastNext(done);
            if (done === newNextValue) {
                this.isInitialized = false;
                return this.nextValue;
            }
            const currentNextValue = this.nextValue;
            this.nextValue = newNextValue;
            this.sepIterator = this.sepStream[Symbol.iterator]();
            return currentNextValue;
        }
        const nextValue = this.source.fastNext(done);
        if (done === nextValue)
            return OptLazy(otherwise);
        const newNextValue = this.source.fastNext(done);
        if (done === newNextValue)
            return nextValue;
        this.nextValue = newNextValue;
        this.isInitialized = true;
        this.sepIterator = this.sepStream[Symbol.iterator]();
        return nextValue;
    }
}
export class SplitWhereIterator extends FastIteratorBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
        this.index = 0;
    }
    fastNext(otherwise) {
        const result = [];
        const source = this.source;
        const done = Symbol('Done');
        let value;
        const pred = this.pred;
        const startIndex = this.index;
        while (done !== (value = source.fastNext(done))) {
            if (pred(value, this.index++))
                return result;
            result.push(value);
        }
        if (startIndex === this.index)
            return OptLazy(otherwise);
        return result;
    }
}
export class SplitOnIterator extends FastIteratorBase {
    constructor(source, sepElem, eq) {
        super();
        this.source = source;
        this.sepElem = sepElem;
        this.eq = eq;
    }
    fastNext(otherwise) {
        const result = [];
        const source = this.source;
        const done = Symbol('Done');
        let value;
        let processed = false;
        const eq = this.eq;
        const sepElem = this.sepElem;
        while (done !== (value = source.fastNext(done))) {
            processed = true;
            if (eq(value, sepElem))
                return result;
            result.push(value);
        }
        if (!processed)
            return OptLazy(otherwise);
        return result;
    }
}
export class ReduceIterator extends FastIteratorBase {
    constructor(source, reducer) {
        super();
        this.source = source;
        this.reducer = reducer;
        this.halted = false;
        this.index = 0;
        this.halt = () => {
            this.halted = true;
        };
        this.state = OptLazy(reducer.init);
    }
    fastNext(otherwise) {
        if (this.halted)
            return OptLazy(otherwise);
        const done = Symbol('Done');
        const value = this.source.fastNext(done);
        if (done === value)
            return OptLazy(otherwise);
        const reducer = this.reducer;
        this.state = reducer.next(this.state, value, this.index++, this.halt);
        return reducer.stateToResult(this.state);
    }
}
export class ReduceAllIterator extends FastIteratorBase {
    constructor(source, reducers) {
        super();
        this.source = source;
        this.reducers = reducers;
        this.halted = false;
        this.index = 0;
        this.isDone = false;
        this.state = reducers.map((d) => OptLazy(d.init));
        this.done = this.state.map((_, i) => () => {
            this.done[i] = null;
        });
    }
    fastNext(otherwise) {
        if (this.halted || this.isDone)
            return OptLazy(otherwise);
        const done = Symbol('Done');
        const value = this.source.fastNext(done);
        if (done === value)
            return OptLazy(otherwise);
        const reducers = this.reducers;
        const length = reducers.length;
        let i = -1;
        let anyNotDone = false;
        while (++i < length) {
            const halt = this.done[i];
            if (null !== halt) {
                anyNotDone = true;
                const reducer = reducers[i];
                this.state[i] = reducer.next(this.state[i], value, this.index, halt);
            }
        }
        this.isDone = !anyNotDone;
        if (!anyNotDone)
            return OptLazy(otherwise);
        this.index++;
        return this.state.map((s, i) => reducers[i].stateToResult(s));
    }
}
export class ArrayIterator extends FastIteratorBase {
    constructor(array, startIndex, endIndex) {
        super();
        this.array = array;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.i = startIndex;
    }
    fastNext(otherwise) {
        if (this.i > this.endIndex)
            return OptLazy(otherwise);
        return this.array[this.i++];
    }
}
export class ArrayReverseIterator extends FastIteratorBase {
    constructor(array, startIndex, endIndex) {
        super();
        this.array = array;
        this.startIndex = startIndex;
        this.i = endIndex;
    }
    fastNext(otherwise) {
        if (this.i < this.startIndex)
            return OptLazy(otherwise);
        return this.array[this.i--];
    }
}
export class AlwaysIterator extends FastIteratorBase {
    constructor(value) {
        super();
        this.value = value;
    }
    fastNext() {
        return this.value;
    }
}
export class MapApplyIterator extends FastIteratorBase {
    constructor(source, f, args, streamSourceHelpers) {
        super();
        this.f = f;
        this.args = args;
        this.iter = streamSourceHelpers.fromStreamSource(source)[Symbol.iterator]();
    }
    fastNext(otherwise) {
        const done = Symbol();
        const next = this.iter.fastNext(done);
        const args = this.args;
        if (done === next)
            return OptLazy(otherwise);
        return this.f(...next, ...args);
    }
}
export class FilterApplyIterator extends FastIteratorBase {
    constructor(source, pred, args, invert, streamSourceHelpers) {
        super();
        this.pred = pred;
        this.args = args;
        this.invert = invert;
        this.iter = streamSourceHelpers.fromStreamSource(source)[Symbol.iterator]();
    }
    fastNext(otherwise) {
        const done = Symbol();
        let next;
        const pred = this.pred;
        const iter = this.iter;
        const args = this.args;
        if (this.invert) {
            while (done !== (next = iter.fastNext(done))) {
                if (!pred(...next, ...args))
                    return next;
            }
        }
        else {
            while (done !== (next = iter.fastNext(done))) {
                if (pred(...next, ...args))
                    return next;
            }
        }
        return OptLazy(otherwise);
    }
}
export class RangeUpIterator extends FastIteratorBase {
    constructor(start = 0, end, delta) {
        super();
        this.start = start;
        this.end = end;
        this.delta = delta;
        this.state = start;
    }
    fastNext(otherwise) {
        if (undefined !== this.end) {
            if (this.state > this.end) {
                return OptLazy(otherwise);
            }
        }
        const currentState = this.state;
        this.state += this.delta;
        return currentState;
    }
}
export class RangeDownIterator extends FastIteratorBase {
    constructor(start = 0, end, delta) {
        super();
        this.start = start;
        this.end = end;
        this.delta = delta;
        this.state = start;
    }
    fastNext(otherwise) {
        if (undefined !== this.end) {
            if (this.state < this.end) {
                return OptLazy(otherwise);
            }
        }
        const currentState = this.state;
        this.state += this.delta;
        return currentState;
    }
}
export class RandomIterator extends FastIteratorBase {
    fastNext() {
        return Math.random();
    }
}
export class RandomIntIterator extends FastIteratorBase {
    constructor(min, max) {
        super();
        this.min = min;
        this.max = max;
        this.width = max - min;
    }
    fastNext() {
        return this.min + Math.round(Math.random() * this.width);
    }
}
export class UnfoldIterator extends FastIteratorBase {
    constructor(init, getNext) {
        super();
        this.getNext = getNext;
        this.index = 0;
        this.current = init;
    }
    fastNext(otherwise) {
        const current = this.current;
        if (Token === current)
            return OptLazy(otherwise);
        if (this.index === 0) {
            this.index++;
            return current;
        }
        const next = this.getNext(current, this.index++, Token);
        this.current = next;
        if (Token === next)
            return OptLazy(otherwise);
        return next;
    }
}
export class ZipWithIterator extends FastIteratorBase {
    constructor(iterables, zipFun, streamSourceHelpers) {
        super();
        this.iterables = iterables;
        this.zipFun = zipFun;
        this.sources = iterables.map((source) => streamSourceHelpers.fromStreamSource(source)[Symbol.iterator]());
    }
    fastNext(otherwise) {
        const result = [];
        let sourceIndex = -1;
        const sources = this.sources;
        const done = Symbol('Done');
        while (++sourceIndex < sources.length) {
            const value = sources[sourceIndex].fastNext(done);
            if (done === value)
                return OptLazy(otherwise);
            result.push(value);
        }
        return this.zipFun(...result);
    }
}
export class ZipAllWithItererator extends FastIteratorBase {
    constructor(fillValue, iters, zipFun, streamSourceHelpers) {
        super();
        this.fillValue = fillValue;
        this.iters = iters;
        this.zipFun = zipFun;
        this.allDone = false;
        this.sources = iters.map((o) => streamSourceHelpers.fromStreamSource(o)[Symbol.iterator]());
    }
    fastNext(otherwise) {
        if (this.allDone)
            return OptLazy(otherwise);
        const result = [];
        let sourceIndex = -1;
        const sources = this.sources;
        const done = Symbol('Done');
        let anyNotDone = false;
        const fillValue = this.fillValue;
        while (++sourceIndex < sources.length) {
            const value = sources[sourceIndex].fastNext(done);
            if (done === value) {
                result.push(OptLazy(fillValue));
            }
            else {
                anyNotDone = true;
                result.push(value);
            }
        }
        if (!anyNotDone) {
            this.allDone = true;
            return OptLazy(otherwise);
        }
        return this.zipFun(...result);
    }
}
export class PrependIterator extends FastIteratorBase {
    constructor(source, item) {
        super();
        this.source = source;
        this.item = item;
        this.prependDone = false;
    }
    fastNext(otherwise) {
        if (this.prependDone)
            return this.source.fastNext(otherwise);
        this.prependDone = true;
        return OptLazy(this.item);
    }
}
export class AppendIterator extends FastIteratorBase {
    constructor(source, item) {
        super();
        this.source = source;
        this.item = item;
        this.appendDone = false;
    }
    fastNext(otherwise) {
        if (this.appendDone)
            return OptLazy(otherwise);
        const done = Symbol('Done');
        const value = this.source.fastNext(done);
        if (done !== value)
            return value;
        this.appendDone = true;
        return OptLazy(this.item);
    }
}
export class IndexedIterator extends FastIteratorBase {
    constructor(source, startIndex = 0) {
        super();
        this.source = source;
        this.startIndex = startIndex;
        this.index = startIndex;
    }
    fastNext(otherwise) {
        const done = Symbol('Done');
        const value = this.source.fastNext(done);
        if (done === value)
            return OptLazy(otherwise);
        return [this.index++, value];
    }
}
export class MapIterator extends FastIteratorBase {
    constructor(source, mapFun) {
        super();
        this.source = source;
        this.mapFun = mapFun;
        this.state = TraverseState();
    }
    fastNext(otherwise) {
        const state = this.state;
        if (state.halted)
            return OptLazy(otherwise);
        const done = Symbol('Done');
        const next = this.source.fastNext(done);
        if (done === next)
            return OptLazy(otherwise);
        return this.mapFun(next, state.nextIndex());
    }
}
export class MapPureIterator extends FastIteratorBase {
    constructor(source, mapFun, args) {
        super();
        this.source = source;
        this.mapFun = mapFun;
        this.args = args;
    }
    fastNext(otherwise) {
        const done = Symbol('Done');
        const next = this.source.fastNext(done);
        if (done === next)
            return OptLazy(otherwise);
        return this.mapFun(next, ...this.args);
    }
}
export class DistinctPreviousIterator extends FastIteratorBase {
    constructor(source, eq) {
        super();
        this.source = source;
        this.eq = eq;
        this.previous = [];
    }
    fastNext(otherwise) {
        const done = Symbol('Done');
        let next;
        const source = this.source;
        const previous = this.previous;
        while (done !== (next = source.fastNext(done))) {
            previous.push(next);
            if (previous.length === 1) {
                return next;
            }
            const prev = previous.shift();
            if (!this.eq(prev, next)) {
                return next;
            }
        }
        return OptLazy(otherwise);
    }
}
export class WindowIterator extends FastIteratorBase {
    constructor(source, windowSize, skipAmount, collector) {
        super();
        this.source = source;
        this.windowSize = windowSize;
        this.skipAmount = skipAmount;
        this.collector = collector;
        this.state = new Set();
        this.index = 0;
    }
    fastNext(otherwise) {
        const source = this.source;
        const collector = this.collector;
        const windowSize = this.windowSize;
        const skipAmount = this.skipAmount;
        const done = Symbol('Done');
        const state = this.state;
        let next;
        let result = done;
        while (done !== (next = source.fastNext(done))) {
            for (const current of state) {
                current.result = collector.next(current.result, next, current.size, current.halt);
                current.size++;
                if (current.size >= windowSize || current.halted) {
                    result = collector.stateToResult(current.result);
                    state.delete(current);
                }
            }
            if (this.index % skipAmount === 0) {
                const newState = {
                    result: OptLazy(collector.init),
                    size: 1,
                    halted: false,
                    halt() {
                        this.halted = true;
                    },
                };
                newState.result = collector.next(OptLazy(collector.init), next, 0, newState.halt);
                state.add(newState);
            }
            this.index++;
            if (done !== result) {
                return result;
            }
        }
        return OptLazy(otherwise);
    }
}
//# sourceMappingURL=fast-iterator-custom.mjs.map