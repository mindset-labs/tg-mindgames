import { Token } from '@rimbu/base';
import { AsyncOptLazy, CollectFun, TraverseState, } from '@rimbu/common';
import { closeIters, } from '@rimbu/stream/async-custom';
export const fixedDoneAsyncIteratorResult = Object.freeze(Promise.resolve(Object.freeze({
    done: true,
    value: undefined,
})));
export function isAsyncFastIterator(iterator) {
    return `fastNext` in iterator;
}
export const emptyAsyncFastIterator = Object.freeze({
    fastNext(otherwise) {
        return AsyncOptLazy.toMaybePromise(otherwise);
    },
    next() {
        return fixedDoneAsyncIteratorResult;
    },
});
export class AsyncFastIteratorBase {
    async next() {
        const done = Symbol('Done');
        const value = await this.fastNext(done);
        if (done === value)
            return fixedDoneAsyncIteratorResult;
        return { value, done: false };
    }
}
export class AsyncOfIterator extends AsyncFastIteratorBase {
    constructor(values) {
        super();
        this.values = values;
        this.index = 0;
    }
    fastNext(otherwise) {
        const index = this.index;
        const values = this.values;
        if (index >= values.length)
            return AsyncOptLazy.toMaybePromise(otherwise);
        return AsyncOptLazy.toMaybePromise(values[this.index++]);
    }
}
export class FromResourceIterator extends AsyncFastIteratorBase {
    constructor(open, createSource, close, asyncStreamSourceHelpers) {
        super();
        this.open = open;
        this.createSource = createSource;
        this.close = close;
        this.asyncStreamSourceHelpers = asyncStreamSourceHelpers;
        this.return = async () => {
            if (this.resource)
                await close(this.resource);
            await this.iterator?.return?.();
        };
    }
    async fastNext(otherwise) {
        if (undefined === this.iterator) {
            const resource = await this.open();
            this.resource = resource;
            const source = await this.createSource(resource);
            this.iterator = this.asyncStreamSourceHelpers
                .fromAsyncStreamSource(source)[Symbol.asyncIterator]();
        }
        return this.iterator.fastNext(async () => {
            await this.return?.();
            return AsyncOptLazy.toMaybePromise(otherwise);
        });
    }
}
export class AsyncUnfoldIterator extends AsyncFastIteratorBase {
    constructor(init, getNext) {
        super();
        this.getNext = getNext;
        this.index = 0;
        this.current = init;
    }
    async fastNext(otherwise) {
        const current = this.current;
        if (Token === current)
            return AsyncOptLazy.toMaybePromise(otherwise);
        if (this.index === 0) {
            this.index++;
            return current;
        }
        const next = await this.getNext(current, this.index++, Token);
        this.current = next;
        if (Token === next)
            return AsyncOptLazy.toMaybePromise(otherwise);
        return next;
    }
}
export class AsyncZipWithIterator extends AsyncFastIteratorBase {
    constructor(iterables, zipFun, asyncStreamSourceHelpers) {
        super();
        this.iterables = iterables;
        this.zipFun = zipFun;
        this.asyncStreamSourceHelpers = asyncStreamSourceHelpers;
        this.sources = iterables.map((source) => this.asyncStreamSourceHelpers
            .fromAsyncStreamSource(source)[Symbol.asyncIterator]());
        this.sourcesToClose = new Set(this.sources);
        this.return = () => closeIters(...this.sourcesToClose);
    }
    async fastNext(otherwise) {
        const sources = this.sources;
        const done = Symbol('Done');
        const result = await Promise.all(sources.map((source) => source.fastNext(() => {
            this.sourcesToClose.delete(source);
            return done;
        })));
        if (this.sourcesToClose.size !== sources.length) {
            await closeIters(this);
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        return this.zipFun(...result);
    }
}
export class AsyncZipAllWithItererator extends AsyncFastIteratorBase {
    constructor(fillValue, iters, zipFun, asyncStreamSourceHelpers) {
        super();
        this.fillValue = fillValue;
        this.iters = iters;
        this.zipFun = zipFun;
        this.asyncStreamSourceHelpers = asyncStreamSourceHelpers;
        this.sources = iters.map((o) => this.asyncStreamSourceHelpers
            .fromAsyncStreamSource(o)[Symbol.asyncIterator]());
        this.sourcesToClose = new Set(this.sources);
        this.return = () => closeIters(...this.sourcesToClose);
    }
    async fastNext(otherwise) {
        if (this.sourcesToClose.size === 0) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const sources = this.sources;
        const fillValue = this.fillValue;
        const result = await Promise.all(sources.map((source) => {
            if (this.sourcesToClose.has(source)) {
                return source.fastNext(() => {
                    this.sourcesToClose.delete(source);
                    return AsyncOptLazy.toMaybePromise(fillValue);
                });
            }
            return AsyncOptLazy.toMaybePromise(fillValue);
        }));
        if (this.sourcesToClose.size === 0) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        return this.zipFun(...result);
    }
}
export class FromAsyncIterator {
    constructor(source, close) {
        this.source = source;
        if (source.return && close) {
            this.return = () => Promise.all([source.return?.(), close?.()]);
        }
        else if (source.return) {
            this.return = () => source.return?.();
        }
        else if (close) {
            this.return = close;
        }
    }
    next() {
        return this.source.next();
    }
    async fastNext(otherwise) {
        const result = await this.source.next();
        if (result.done) {
            await closeIters(this);
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        return result.value;
    }
}
export class FromIterator extends AsyncFastIteratorBase {
    constructor(iterator, close) {
        super();
        this.iterator = iterator;
        if (close !== undefined) {
            this.return = close;
        }
    }
    async fastNext(otherwise) {
        const result = this.iterator.next();
        if (result.done) {
            await closeIters(this);
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        return result.value;
    }
}
export class FromPromise extends AsyncFastIteratorBase {
    constructor(promise, asyncStreamSourceHelpers, close) {
        super();
        this.promise = promise;
        this.asyncStreamSourceHelpers = asyncStreamSourceHelpers;
        this.return = async () => {
            if (close)
                await close?.();
            if (this.iterator)
                await this.iterator.return?.();
        };
    }
    async fastNext(otherwise) {
        if (this.iterator === undefined) {
            const source = await this.promise();
            this.iterator = this.asyncStreamSourceHelpers
                .fromAsyncStreamSource(source)[Symbol.asyncIterator]();
        }
        return this.iterator.fastNext(otherwise);
    }
}
export class AsyncLiveIterator extends AsyncFastIteratorBase {
    constructor(maxSize) {
        super();
        this.maxSize = maxSize;
        this.queue = [];
        this.submit = (value) => {
            if (this.halted) {
                return;
            }
            this.queue.unshift(value);
            if (this.queue.length > this.maxSize) {
                this.queue.length = this.maxSize;
            }
            this.wakeUp?.();
        };
        this.halted = false;
        this.close = () => {
            this.halted = true;
            this.wakeUp?.();
        };
    }
    async fastNext(otherwise) {
        const { queue } = this;
        if (queue.length > 0) {
            const item = queue.pop();
            return item;
        }
        if (this.halted) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const waitPromise = new Promise((res) => {
            this.wakeUp = res;
        });
        await waitPromise;
        this.wakeUp = undefined;
        return this.fastNext(otherwise);
    }
}
export class AsyncPrependIterator extends AsyncFastIteratorBase {
    constructor(source, item) {
        super();
        this.source = source;
        this.item = item;
        this.prependDone = false;
        this.return = async () => {
            if (this.prependDone)
                return closeIters(this.source);
        };
    }
    fastNext(otherwise) {
        if (this.prependDone) {
            return this.source.fastNext(otherwise);
        }
        this.prependDone = true;
        return AsyncOptLazy.toMaybePromise(this.item);
    }
}
export class AsyncAppendIterator extends AsyncFastIteratorBase {
    constructor(source, item) {
        super();
        this.source = source;
        this.item = item;
        this.appendDone = false;
        this.return = async () => {
            if (!this.appendDone)
                return closeIters(source);
        };
    }
    async fastNext(otherwise) {
        if (this.appendDone)
            return AsyncOptLazy.toMaybePromise(otherwise);
        const done = Symbol('Done');
        const value = await this.source.fastNext(done);
        if (done !== value)
            return value;
        this.appendDone = true;
        return AsyncOptLazy.toMaybePromise(this.item);
    }
}
export class AsyncIndexedIterator extends AsyncFastIteratorBase {
    constructor(source, startIndex = 0) {
        super();
        this.source = source;
        this.startIndex = startIndex;
        this.index = startIndex;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const done = Symbol('Done');
        const value = await this.source.fastNext(done);
        if (done === value) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        return [this.index++, value];
    }
}
export class AsyncMapIterator extends AsyncFastIteratorBase {
    constructor(source, mapFun) {
        super();
        this.source = source;
        this.mapFun = mapFun;
        this.state = TraverseState();
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const state = this.state;
        const done = Symbol('Done');
        const next = await this.source.fastNext(done);
        if (done === next) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        return this.mapFun(next, state.nextIndex());
    }
}
export class AsyncMapPureIterator extends AsyncFastIteratorBase {
    constructor(source, mapFun, args) {
        super();
        this.source = source;
        this.mapFun = mapFun;
        this.args = args;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const done = Symbol('Done');
        const next = await this.source.fastNext(done);
        if (done === next)
            return AsyncOptLazy.toMaybePromise(otherwise);
        return this.mapFun(next, ...this.args);
    }
}
export class AsyncFlatMapIterator extends AsyncFastIteratorBase {
    constructor(source, flatMapFun, asyncStreamSourceHelpers) {
        super();
        this.source = source;
        this.flatMapFun = flatMapFun;
        this.asyncStreamSourceHelpers = asyncStreamSourceHelpers;
        this.state = TraverseState();
        this.done = false;
        this.currentIterator = null;
        this.iterator = this.source[Symbol.asyncIterator]();
        this.return = () => closeIters(this.currentIterator, this.iterator);
    }
    async fastNext(otherwise) {
        const state = this.state;
        if (state.halted || this.done) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const done = Symbol('Done');
        let nextValue;
        const { asyncStreamSourceHelpers } = this;
        while (null === this.currentIterator ||
            done === (nextValue = await this.currentIterator.fastNext(done))) {
            const nextIter = await this.iterator.fastNext(done);
            if (done === nextIter) {
                this.done = true;
                return AsyncOptLazy.toMaybePromise(otherwise);
            }
            const nextSource = this.flatMapFun(nextIter, state.nextIndex(), state.halt);
            const currentIterator = asyncStreamSourceHelpers
                .fromAsyncStreamSource(nextSource)[Symbol.asyncIterator]();
            this.currentIterator = currentIterator;
        }
        return nextValue;
    }
}
export class AsyncConcatIterator extends AsyncFastIteratorBase {
    constructor(source, otherSources, asyncStreamSourceHelpers) {
        super();
        this.source = source;
        this.otherSources = otherSources;
        this.asyncStreamSourceHelpers = asyncStreamSourceHelpers;
        this.sourceIndex = 0;
        this.iterator = source[Symbol.asyncIterator]();
        this.return = () => closeIters(this.iterator);
    }
    async fastNext(otherwise) {
        const done = Symbol('Done');
        let value;
        const length = this.otherSources.length;
        const { asyncStreamSourceHelpers } = this;
        while (done === (value = await this.iterator.fastNext(done))) {
            if (this.sourceIndex >= length) {
                return AsyncOptLazy.toMaybePromise(otherwise);
            }
            let nextSource = this.otherSources[this.sourceIndex++];
            while (asyncStreamSourceHelpers.isEmptyAsyncStreamSourceInstance(nextSource)) {
                if (this.sourceIndex >= length) {
                    return AsyncOptLazy.toMaybePromise(otherwise);
                }
                nextSource = this.otherSources[this.sourceIndex++];
            }
            this.iterator = asyncStreamSourceHelpers
                .fromAsyncStreamSource(nextSource)[Symbol.asyncIterator]();
        }
        return value;
    }
}
export class AsyncIntersperseIterator extends AsyncFastIteratorBase {
    constructor(source, sepStream) {
        super();
        this.source = source;
        this.sepStream = sepStream;
        this.isInitialized = false;
        this.isDone = false;
        this.return = async () => {
            if (!this.isDone)
                return closeIters(this.sepIterator, this.source);
        };
    }
    async fastNext(otherwise) {
        if (this.isDone) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const done = Symbol('Done');
        if (undefined !== this.sepIterator) {
            const sepNext = await this.sepIterator.fastNext(done);
            if (done !== sepNext)
                return sepNext;
            this.sepIterator = undefined;
        }
        if (this.isInitialized) {
            const newNextValue = await this.source.fastNext(done);
            if (done === newNextValue) {
                this.isDone = true;
                return this.nextValue;
            }
            const currentNextValue = this.nextValue;
            this.nextValue = newNextValue;
            this.sepIterator = this.sepStream[Symbol.asyncIterator]();
            return currentNextValue;
        }
        const nextValue = await this.source.fastNext(done);
        if (done === nextValue) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const newNextValue = await this.source.fastNext(done);
        if (done === newNextValue) {
            return nextValue;
        }
        this.nextValue = newNextValue;
        this.isInitialized = true;
        this.sepIterator = this.sepStream[Symbol.asyncIterator]();
        return nextValue;
    }
}
export class AsyncFilterIterator extends AsyncFastIteratorBase {
    constructor(source, pred, invert) {
        super();
        this.source = source;
        this.pred = pred;
        this.invert = invert;
        this.state = TraverseState();
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const state = this.state;
        if (state.halted) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const done = Symbol('Done');
        let value;
        const source = this.source;
        const pred = this.pred;
        const halt = state.halt;
        const invert = this.invert;
        while (!state.halted && done !== (value = await source.fastNext(done))) {
            const cond = await pred(value, state.nextIndex(), halt);
            if (cond !== invert)
                return value;
        }
        if (state.halted && done !== value) {
            await closeIters(this);
        }
        return AsyncOptLazy.toMaybePromise(otherwise);
    }
}
export class AsyncFilterPureIterator extends AsyncFastIteratorBase {
    constructor(source, pred, args, invert) {
        super();
        this.source = source;
        this.pred = pred;
        this.args = args;
        this.invert = invert;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const done = Symbol('Done');
        let value;
        const source = this.source;
        const pred = this.pred;
        const args = this.args;
        const invert = this.invert;
        while (done !== (value = await source.fastNext(done))) {
            const cond = await pred(value, ...args);
            if (cond !== invert)
                return value;
        }
        return AsyncOptLazy.toMaybePromise(otherwise);
    }
}
export class AsyncCollectIterator extends AsyncFastIteratorBase {
    constructor(source, collectFun) {
        super();
        this.source = source;
        this.collectFun = collectFun;
        this.state = TraverseState();
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const state = this.state;
        if (state.halted) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const { halt } = state;
        const done = Symbol('Done');
        let value;
        const source = this.source;
        const collectFun = this.collectFun;
        try {
            while (!state.halted && done !== (value = await source.fastNext(done))) {
                const result = await collectFun(value, state.nextIndex(), CollectFun.Skip, halt);
                if (CollectFun.Skip === result)
                    continue;
                return result;
            }
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        finally {
            if (state.halted && done !== value) {
                await closeIters(this);
            }
        }
    }
}
export class AsyncIndicesWhereIterator extends AsyncFastIteratorBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
        this.index = 0;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const done = Symbol('Done');
        let value;
        const source = this.source;
        const pred = this.pred;
        while (done !== (value = await source.fastNext(done))) {
            const cond = await pred(value);
            if (cond) {
                return this.index++;
            }
            this.index++;
        }
        return AsyncOptLazy.toMaybePromise(otherwise);
    }
}
export class AsyncIndicesOfIterator extends AsyncFastIteratorBase {
    constructor(source, searchValue, eq) {
        super();
        this.source = source;
        this.searchValue = searchValue;
        this.eq = eq;
        this.index = 0;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const done = Symbol('Done');
        let value;
        const source = this.source;
        const searchValue = this.searchValue;
        const eq = this.eq;
        while (done !== (value = await source.fastNext(done))) {
            if (eq(searchValue, value))
                return this.index++;
            this.index++;
        }
        return AsyncOptLazy.toMaybePromise(otherwise);
    }
}
export class AsyncTakeWhileIterator extends AsyncFastIteratorBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
        this.isDone = false;
        this.index = 0;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        if (this.isDone)
            return AsyncOptLazy.toMaybePromise(otherwise);
        const done = Symbol('Done');
        const next = await this.source.fastNext(done);
        if (done === next) {
            this.isDone = true;
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        if (await this.pred(next, this.index++))
            return next;
        this.isDone = true;
        await closeIters(this);
        return AsyncOptLazy.toMaybePromise(otherwise);
    }
}
export class AsyncDropWhileIterator extends AsyncFastIteratorBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
        this.pass = false;
        this.index = 0;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const source = this.source;
        if (this.pass)
            return source.fastNext(otherwise);
        const done = Symbol('Done');
        let value;
        while (done !== (value = await source.fastNext(done))) {
            this.pass = !(await this.pred(value, this.index++));
            if (this.pass)
                return value;
        }
        return AsyncOptLazy.toMaybePromise(otherwise);
    }
}
export class AsyncTakeIterator extends AsyncFastIteratorBase {
    constructor(source, amount) {
        super();
        this.source = source;
        this.amount = amount;
        this.i = 0;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        if (this.i++ >= this.amount) {
            await closeIters(this);
            this.return = undefined;
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        return this.source.fastNext(otherwise);
    }
}
export class AsyncDropIterator extends AsyncFastIteratorBase {
    constructor(source, amount) {
        super();
        this.source = source;
        this.amount = amount;
        this.return = () => closeIters(source);
        this.remain = amount;
    }
    async fastNext(otherwise) {
        const source = this.source;
        if (this.remain <= 0)
            return source.fastNext(otherwise);
        const done = Symbol('Done');
        let value;
        while (done !== (value = await source.fastNext(done))) {
            if (this.remain-- <= 0) {
                return value;
            }
        }
        return AsyncOptLazy.toMaybePromise(otherwise);
    }
}
export class AsyncRepeatIterator extends AsyncFastIteratorBase {
    constructor(source, amount) {
        super();
        this.source = source;
        this.amount = amount;
        this.isEmpty = true;
        this.iterator = source[Symbol.asyncIterator]();
        this.return = () => closeIters(this.iterator);
        this.remain = amount;
    }
    async fastNext(otherwise) {
        const done = Symbol('Done');
        const iterator = this.iterator;
        let value = await iterator.fastNext(done);
        if (done !== value) {
            this.isEmpty = false;
            return value;
        }
        if (this.isEmpty) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        if (undefined !== this.remain) {
            this.remain--;
            if (this.remain <= 0) {
                return AsyncOptLazy.toMaybePromise(otherwise);
            }
        }
        this.iterator = this.source[Symbol.asyncIterator]();
        value = await this.iterator.fastNext(done);
        if (done === value) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        return value;
    }
}
export class AsyncSplitWhereIterator extends AsyncFastIteratorBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
        this.index = 0;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const startIndex = this.index;
        if (startIndex < 0) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const result = [];
        const source = this.source;
        const done = Symbol('Done');
        let value;
        const pred = this.pred;
        while (done !== (value = await source.fastNext(done))) {
            if (await pred(value, this.index++))
                return result;
            result.push(value);
        }
        this.return = undefined;
        if (startIndex === this.index) {
            this.index = -1;
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        this.index = -1;
        return result;
    }
}
export class AsyncFoldIterator extends AsyncFastIteratorBase {
    constructor(source, init, getNext) {
        super();
        this.source = source;
        this.init = init;
        this.getNext = getNext;
        this.isInitialized = false;
        this.state = TraverseState();
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        if (!this.isInitialized) {
            this.current = await AsyncOptLazy.toMaybePromise(this.init);
            this.isInitialized = true;
        }
        const state = this.state;
        if (state.halted) {
            await closeIters(this);
            this.return = undefined;
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const done = Symbol('done');
        const value = await this.source.fastNext(done);
        if (done === value) {
            this.return = undefined;
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        this.current = await this.getNext(this.current, value, state.nextIndex(), state.halt);
        return this.current;
    }
}
export class AsyncSplitOnIterator extends AsyncFastIteratorBase {
    constructor(source, sepElem, eq) {
        super();
        this.source = source;
        this.sepElem = sepElem;
        this.eq = eq;
        this.isDone = false;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        if (this.isDone) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const result = [];
        const source = this.source;
        const done = Symbol('Done');
        let value;
        let processed = false;
        const eq = this.eq;
        const sepElem = this.sepElem;
        while (done !== (value = await source.fastNext(done))) {
            processed = true;
            if (eq(value, sepElem))
                return result;
            result.push(value);
        }
        this.return = undefined;
        this.isDone = true;
        if (!processed)
            return AsyncOptLazy.toMaybePromise(otherwise);
        return result;
    }
}
export class AsyncReduceIterator extends AsyncFastIteratorBase {
    constructor(source, reducer) {
        super();
        this.source = source;
        this.reducer = reducer;
        this.traverseState = TraverseState();
        this.isInitialized = false;
        this.isDone = false;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        if (this.isDone) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const done = Symbol('Done');
        const value = await this.source.fastNext(done);
        if (done === value) {
            this.isDone = true;
            this.return = undefined;
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const reducer = this.reducer;
        if (!this.isInitialized) {
            this.state = await AsyncOptLazy.toMaybePromise(reducer.init);
            this.isInitialized = true;
        }
        const traverseState = this.traverseState;
        try {
            this.state = await reducer.next(this.state, value, traverseState.nextIndex(), traverseState.halt);
        }
        catch (err) {
            this.isDone = true;
            await closeIters(this);
            this.return = undefined;
            await reducer.onClose?.(this.state, err);
            throw err;
        }
        if (traverseState.halted) {
            this.isDone = true;
            await closeIters(this);
            this.return = undefined;
            await reducer.onClose?.(this.state);
        }
        return reducer.stateToResult(this.state);
    }
}
export class AsyncReduceAllIterator extends AsyncFastIteratorBase {
    constructor(source, reducers) {
        super();
        this.source = source;
        this.reducers = reducers;
        this.index = 0;
        this.isDone = false;
        this.reducersToClose = new Set(reducers);
        this.return = async () => {
            await closeIters(source);
            const state = this.state;
            if (state) {
                await Promise.all([...this.reducersToClose].map((reducer, index) => reducer.onClose?.(state[index], this.err)));
            }
        };
    }
    async fastNext(otherwise) {
        const reducers = this.reducers;
        if (undefined === this.state) {
            this.state = await Promise.all(reducers.map((d) => AsyncOptLazy.toMaybePromise(d.init)));
        }
        if (this.isDone) {
            await closeIters(this);
            this.return = undefined;
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const done = Symbol('Done');
        const value = await this.source.fastNext(done);
        if (done === value) {
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        const state = this.state;
        this.state = await Promise.all(reducers.map((red, i) => {
            const st = state[i];
            if (!this.reducersToClose.has(red)) {
                return st;
            }
            try {
                return red.next(st, value, this.index, async () => {
                    this.reducersToClose.delete(red);
                    await red.onClose?.(st);
                    return st;
                });
            }
            catch (e) {
                this.err = e;
            }
            return undefined;
        }));
        this.index++;
        this.isDone = this.reducersToClose.size === 0 || undefined !== this.err;
        if (this.isDone) {
            await closeIters(this);
            this.return = undefined;
            return AsyncOptLazy.toMaybePromise(otherwise);
        }
        return Promise.all(this.state.map((s, i) => reducers[i].stateToResult(s)));
    }
}
export class AsyncDistinctPreviousIterator extends AsyncFastIteratorBase {
    constructor(source, eq) {
        super();
        this.source = source;
        this.eq = eq;
        this.previous = [];
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const done = Symbol('Done');
        let next;
        const source = this.source;
        const previous = this.previous;
        while (done !== (next = await source.fastNext(done))) {
            previous.push(next);
            if (previous.length === 1) {
                return next;
            }
            const prev = previous.shift();
            if (!this.eq(prev, next)) {
                return next;
            }
        }
        return AsyncOptLazy.toMaybePromise(otherwise);
    }
}
export class AsyncWindowIterator extends AsyncFastIteratorBase {
    constructor(source, windowSize, skipAmount, collector) {
        super();
        this.source = source;
        this.windowSize = windowSize;
        this.skipAmount = skipAmount;
        this.collector = collector;
        this.state = new Set();
        this.index = 0;
        this.return = () => closeIters(source);
    }
    async fastNext(otherwise) {
        const source = this.source;
        const collector = this.collector;
        const windowSize = this.windowSize;
        const skipAmount = this.skipAmount;
        const done = Symbol('Done');
        const state = this.state;
        let next;
        let result = done;
        while (done !== (next = await source.fastNext(done))) {
            for (const current of state) {
                current.result = await collector.next(current.result, next, current.size, current.halt);
                current.size++;
                if (current.size >= windowSize || current.halted) {
                    result = await collector.stateToResult(current.result);
                    state.delete(current);
                }
            }
            if (this.index % skipAmount === 0) {
                const newState = {
                    result: await AsyncOptLazy.toMaybePromise(collector.init),
                    size: 1,
                    halted: false,
                    halt() {
                        this.halted = true;
                    },
                };
                newState.result = await collector.next(AsyncOptLazy.toMaybePromise(collector.init), next, 0, newState.halt);
                state.add(newState);
            }
            this.index++;
            if (done !== result) {
                return result;
            }
        }
        return AsyncOptLazy.toMaybePromise(otherwise);
    }
}
//# sourceMappingURL=async-fast-iterator-base.mjs.map