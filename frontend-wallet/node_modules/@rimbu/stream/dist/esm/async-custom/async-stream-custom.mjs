var _a;
import { RimbuError } from '@rimbu/base';
import { AsyncOptLazy, AsyncReducer, Comp, Eq, TraverseState, } from '@rimbu/common';
import { AsyncAppendIterator, AsyncCollectIterator, AsyncConcatIterator, AsyncDistinctPreviousIterator, AsyncDropIterator, AsyncDropWhileIterator, AsyncFilterIterator, AsyncFilterPureIterator, AsyncFlatMapIterator, AsyncFoldIterator, AsyncIndexedIterator, AsyncIndicesOfIterator, AsyncIndicesWhereIterator, AsyncIntersperseIterator, AsyncLiveIterator, AsyncMapIterator, AsyncMapPureIterator, AsyncOfIterator, AsyncPrependIterator, AsyncReduceAllIterator, AsyncReduceIterator, AsyncRepeatIterator, AsyncSplitOnIterator, AsyncSplitWhereIterator, AsyncTakeIterator, AsyncTakeWhileIterator, AsyncUnfoldIterator, AsyncWindowIterator, AsyncZipAllWithItererator, AsyncZipWithIterator, FromAsyncIterator, FromIterator, FromPromise, FromResourceIterator, closeIters, emptyAsyncFastIterator, isAsyncFastIterator, } from '@rimbu/stream/async-custom';
import { isEmptyStreamSourceInstance } from '@rimbu/stream/custom';
import { Stream } from '@rimbu/stream';
export class AsyncStreamBase {
    asyncStream() {
        return this;
    }
    async equals(other, eq = Eq.objectIs) {
        const it1 = this[Symbol.asyncIterator]();
        const it2 = fromAsyncStreamSource(other)[Symbol.asyncIterator]();
        const done = Symbol('Done');
        while (true) {
            const [v1, v2] = await Promise.all([
                it1.fastNext(done),
                it2.fastNext(done),
            ]);
            if (done === v1) {
                if (done === v2)
                    return true;
                await closeIters(it2);
                return false;
            }
            if (done === v2) {
                await closeIters(it1);
                return false;
            }
            if (!eq(v1, v2)) {
                await closeIters(it1, it2);
                return false;
            }
        }
    }
    assumeNonEmpty() {
        return this;
    }
    asNormal() {
        return this;
    }
    prepend(value) {
        return new AsyncPrependStream(this, value).assumeNonEmpty();
    }
    append(value) {
        return new AsyncAppendStream(this, value).assumeNonEmpty();
    }
    async forEach(f, state = TraverseState()) {
        if (state.halted)
            return;
        const done = Symbol('Done');
        let value;
        const iterator = this[Symbol.asyncIterator]();
        const { halt } = state;
        try {
            while (!state.halted &&
                done !== (value = await iterator.fastNext(done))) {
                await f(value, state.nextIndex(), halt);
            }
        }
        finally {
            if (done !== value)
                await closeIters(iterator);
        }
    }
    async forEachPure(f, ...args) {
        const done = Symbol('Done');
        let value;
        const iterator = this[Symbol.asyncIterator]();
        try {
            while (done !== (value = await iterator.fastNext(done))) {
                await f(value, ...args);
            }
        }
        catch (e) {
            await closeIters(iterator);
            throw e;
        }
    }
    indexed(startIndex = 0) {
        return new AsyncIndexedStream(this, startIndex);
    }
    map(mapFun) {
        return new AsyncMapStream(this, mapFun);
    }
    mapPure(mapFun, ...args) {
        return new AsyncMapPureStream(this, mapFun, args);
    }
    flatMap(flatMapFun) {
        return new AsyncFlatMapStream(this, flatMapFun);
    }
    flatZip(flatMapFun) {
        return this.flatMap((value, index, halt) => fromAsyncStreamSource(flatMapFun(value, index, halt)).map((result) => [
            value,
            result,
        ]));
    }
    transform(transformer) {
        return AsyncStreamConstructorsImpl.flatten(this.reduceStream(transformer));
    }
    filter(pred) {
        return new AsyncFilterStream(this, pred);
    }
    filterNot(pred) {
        return new AsyncFilterStream(this, pred, true);
    }
    filterPure(pred, ...args) {
        return new AsyncFilterPureStream(this, pred, args);
    }
    filterNotPure(pred, ...args) {
        return new AsyncFilterPureStream(this, pred, args, true);
    }
    collect(collectFun) {
        return new AsyncCollectStream(this, collectFun);
    }
    async first(otherwise) {
        const done = Symbol('done');
        const iter = this[Symbol.asyncIterator]();
        const value = await iter.fastNext(done);
        if (done === value) {
            return AsyncOptLazy.toPromise(otherwise);
        }
        await closeIters(iter);
        return value;
    }
    async last(otherwise) {
        const done = Symbol('Done');
        let value;
        let lastValue = done;
        const iterator = this[Symbol.asyncIterator]();
        while (done !== (value = await iterator.fastNext(done))) {
            lastValue = value;
        }
        if (done === lastValue)
            return AsyncOptLazy.toPromise(otherwise);
        return lastValue;
    }
    async single(otherwise) {
        const iterator = this[Symbol.asyncIterator]();
        const done = Symbol('Done');
        const value = await iterator.fastNext(done);
        if (done !== value) {
            if (done === (await iterator.fastNext(done))) {
                return value;
            }
        }
        await closeIters(iterator);
        return AsyncOptLazy.toPromise(otherwise);
    }
    async count() {
        let result = 0;
        const done = Symbol('Done');
        const iterator = this[Symbol.asyncIterator]();
        try {
            while (done !== (await iterator.fastNext(done)))
                result++;
            return result;
        }
        catch (e) {
            await closeIters(iterator);
            throw e;
        }
    }
    async countElement(value, eq = Eq.objectIs) {
        let result = 0;
        const done = Symbol('Done');
        const iterator = this[Symbol.asyncIterator]();
        let current;
        try {
            while (done !== (current = await iterator.fastNext(done))) {
                if (eq(value, current))
                    result++;
            }
            return result;
        }
        finally {
            if (done !== current)
                await closeIters(iterator);
        }
    }
    async countNotElement(value, eq = Eq.objectIs) {
        let result = 0;
        const done = Symbol('Done');
        const iterator = this[Symbol.asyncIterator]();
        let current;
        try {
            while (done !== (current = await iterator.fastNext(done))) {
                if (!eq(value, current))
                    result++;
            }
            return result;
        }
        finally {
            if (done !== current)
                await closeIters(iterator);
        }
    }
    async find(pred, occurrance = 1, otherwise) {
        if (occurrance <= 0)
            return AsyncOptLazy.toPromise(otherwise);
        const done = Symbol('Done');
        const iterator = this[Symbol.asyncIterator]();
        let value;
        let remain = occurrance;
        let index = 0;
        try {
            while (done !== (value = await iterator.fastNext(done))) {
                const cond = await pred(value, index++);
                if (cond && --remain <= 0) {
                    return value;
                }
            }
            return AsyncOptLazy.toPromise(otherwise);
        }
        finally {
            if (done !== value)
                await closeIters(iterator);
        }
    }
    async elementAt(index, otherwise) {
        if (index < 0)
            return AsyncOptLazy.toPromise(otherwise);
        const done = Symbol('Done');
        const iterator = this[Symbol.asyncIterator]();
        let value;
        let i = 0;
        try {
            while (i <= index && done !== (value = await iterator.fastNext(done))) {
                if (i === index) {
                    return value;
                }
                i++;
            }
            return AsyncOptLazy.toPromise(otherwise);
        }
        finally {
            if (done !== value)
                await closeIters(iterator);
        }
    }
    indicesWhere(pred) {
        return new AsyncIndicesWhereStream(this, pred);
    }
    indicesOf(searchValue, eq = Eq.objectIs) {
        return new AsyncIndicesOfStream(this, searchValue, eq);
    }
    async indexWhere(pred, occurrance = 1) {
        if (occurrance <= 0)
            return undefined;
        const done = Symbol('Done');
        let value;
        const iterator = this[Symbol.asyncIterator]();
        let index = 0;
        let occ = 0;
        try {
            while (done !== (value = await iterator.fastNext(done))) {
                const i = index++;
                const cond = await pred(value, i);
                if (cond) {
                    occ++;
                    if (occ >= occurrance) {
                        return i;
                    }
                }
            }
            return undefined;
        }
        finally {
            if (done !== value)
                await closeIters(iterator);
        }
    }
    async indexOf(searchValue, occurrance = 1, eq = Eq.objectIs) {
        if (occurrance <= 0)
            return undefined;
        const done = Symbol('Done');
        let value;
        const iterator = this[Symbol.asyncIterator]();
        let index = 0;
        let occ = 0;
        try {
            while (done !== (value = await iterator.fastNext(done))) {
                const i = index++;
                if (eq(value, searchValue)) {
                    occ++;
                    if (occ >= occurrance) {
                        return i;
                    }
                }
            }
            return undefined;
        }
        finally {
            if (done !== value)
                await closeIters(iterator);
        }
    }
    async some(pred) {
        return undefined !== (await this.indexWhere(pred));
    }
    async every(pred) {
        const iterator = this[Symbol.asyncIterator]();
        const done = Symbol('Done');
        let value;
        let index = 0;
        try {
            while (done !== (value = await iterator.fastNext(done))) {
                const cond = await pred(value, index++);
                if (!cond) {
                    return false;
                }
            }
            return true;
        }
        finally {
            if (done !== value)
                await closeIters(iterator);
        }
    }
    async contains(searchValue, amount = 1, eq) {
        if (amount <= 0)
            return true;
        return undefined !== (await this.indexOf(searchValue, amount, eq));
    }
    async containsSlice(source, eq = Eq.objectIs) {
        const iterator = this[Symbol.asyncIterator]();
        const sourceStream = fromAsyncStreamSource(source);
        let sourceIterator = sourceStream[Symbol.asyncIterator]();
        const done = Symbol('Done');
        while (true) {
            const sourceValue = await sourceIterator.fastNext(done);
            if (done === sourceValue) {
                await closeIters(iterator);
                return true;
            }
            const value = await iterator.fastNext(done);
            if (done === value) {
                return false;
            }
            if (!eq(sourceValue, value)) {
                sourceIterator = sourceStream[Symbol.asyncIterator]();
            }
        }
    }
    takeWhile(pred) {
        return new AsyncTakeWhileStream(this, pred);
    }
    dropWhile(pred) {
        return new AsyncDropWhileStream(this, pred);
    }
    take(amount) {
        if (amount <= 0)
            return emptyAsyncStream;
        return new AsyncTakeStream(this, amount);
    }
    drop(amount) {
        if (amount <= 0)
            return this;
        return new AsyncDropStream(this, amount);
    }
    repeat(amount) {
        if (undefined !== amount && amount <= 1) {
            return this;
        }
        return new AsyncFromStream(() => new AsyncRepeatIterator(this, amount));
    }
    concat(...others) {
        if (others.every(isEmptyAsyncStreamSourceInstance))
            return this;
        return new AsyncConcatStream(this, others);
    }
    min(otherwise) {
        return this.minBy(Comp.defaultComp().compare, otherwise);
    }
    async minBy(compare, otherwise) {
        const done = Symbol('Done');
        const iterator = this[Symbol.asyncIterator]();
        let result;
        let value;
        try {
            result = await iterator.fastNext(done);
            if (done === result)
                return AsyncOptLazy.toPromise(otherwise);
            while (done !== (value = await iterator.fastNext(done))) {
                if (compare(value, result) < 0)
                    result = value;
            }
            return result;
        }
        finally {
            if (done !== result && done !== value)
                await closeIters(iterator);
        }
    }
    max(otherwise) {
        return this.maxBy(Comp.defaultComp().compare, otherwise);
    }
    async maxBy(compare, otherwise) {
        const done = Symbol('Done');
        const iterator = this[Symbol.asyncIterator]();
        let result;
        let value;
        try {
            result = await iterator.fastNext(done);
            if (done === result)
                return AsyncOptLazy.toPromise(otherwise);
            while (done !== (value = await iterator.fastNext(done))) {
                if (compare(value, result) > 0)
                    result = value;
            }
            return result;
        }
        finally {
            if (done !== result && done !== value)
                await closeIters(iterator);
        }
    }
    intersperse(sep) {
        if (isEmptyAsyncStreamSourceInstance(sep))
            return this;
        const sepStream = fromAsyncStreamSource(sep);
        return new AsyncIntersperseStream(this, sepStream);
    }
    async join({ sep = '', start = '', end = '', valueToString = String, ifEmpty = undefined, } = {}) {
        const done = Symbol('Done');
        const iterator = this[Symbol.asyncIterator]();
        let value = await iterator.fastNext(done);
        try {
            if (done === value) {
                if (undefined !== ifEmpty)
                    return ifEmpty;
                return start.concat(end);
            }
            let result = start.concat(valueToString(value));
            while (done !== (value = await iterator.fastNext(done))) {
                result = result.concat(sep, valueToString(value));
            }
            return result.concat(end);
        }
        finally {
            if (done !== value)
                await closeIters(iterator);
        }
    }
    mkGroup({ sep = emptyAsyncStream, start = emptyAsyncStream, end = emptyAsyncStream, } = {}) {
        return fromAsyncStreamSource(start).concat(this.intersperse(sep), end);
    }
    splitWhere(pred) {
        return new AsyncSplitWhereStream(this, pred);
    }
    splitOn(sepElem, eq = Eq.objectIs) {
        return new AsyncSplitOnStream(this, sepElem, eq);
    }
    distinctPrevious(eq = Eq.objectIs) {
        return new AsyncDistinctPreviousStream(this, eq);
    }
    window(windowSize, skipAmount = windowSize, collector = AsyncReducer.toArray()) {
        return new AsyncWindowStream(this, windowSize, skipAmount, collector);
    }
    async fold(init, next) {
        let current = await AsyncOptLazy.toMaybePromise(init);
        const state = TraverseState();
        const done = Symbol('done');
        const iterator = this[Symbol.asyncIterator]();
        let value;
        try {
            while (!state.halted &&
                done !== (value = await iterator.fastNext(done))) {
                current = await next(current, value, state.nextIndex(), state.halt);
            }
            return current;
        }
        finally {
            if (done !== value)
                await closeIters(iterator);
        }
    }
    foldStream(init, next) {
        return new AsyncFromStream(() => new AsyncFoldIterator(this[Symbol.asyncIterator](), init, next));
    }
    async reduce(reducer) {
        const traverseState = TraverseState();
        const next = reducer.next;
        let state = await AsyncOptLazy.toMaybePromise(reducer.init);
        const done = Symbol('Done');
        let value;
        const iter = this[Symbol.asyncIterator]();
        try {
            while (!traverseState.halted &&
                done !== (value = await iter.fastNext(done))) {
                state = await next(state, value, traverseState.nextIndex(), traverseState.halt);
            }
        }
        catch (err) {
            await reducer.onClose?.(state, err);
            throw err;
        }
        finally {
            if (done !== value)
                await closeIters(iter);
        }
        await reducer.onClose?.(state);
        return reducer.stateToResult(state);
    }
    reduceStream(reducer) {
        return new AsyncReduceStream(this, reducer);
    }
    async reduceAll(...reducers) {
        let state = await Promise.all(reducers.map((d) => AsyncOptLazy.toMaybePromise(d.init)));
        const reducersToClose = new Set(reducers);
        const iter = this[Symbol.asyncIterator]();
        const done = Symbol('Done');
        let value;
        let index = 0;
        let err;
        try {
            while (done !== (value = await iter.fastNext(done))) {
                const v = value;
                state = await Promise.all(reducers.map((red, i) => {
                    const st = state[i];
                    if (!reducersToClose.has(red))
                        return st;
                    return red.next(st, v, index, async () => {
                        reducersToClose.delete(red);
                        await red.onClose?.(st);
                        return st;
                    });
                }));
                if (reducersToClose.size === 0) {
                    break;
                }
                index++;
            }
            return await Promise.all(state.map((s, i) => reducers[i].stateToResult(s)));
        }
        catch (e) {
            err = e;
        }
        finally {
            if (done !== value)
                await closeIters(iter);
            await Promise.all([...reducersToClose].map((r, i) => r.onClose?.(state[i], err)));
        }
        if (err)
            throw err;
    }
    reduceAllStream(...reducers) {
        return new AsyncReduceAllStream(this, reducers);
    }
    async toArray() {
        const iterator = this[Symbol.asyncIterator]();
        const result = [];
        const done = Symbol('Done');
        let value;
        try {
            while (done !== (value = await iterator.fastNext(done))) {
                result.push(value);
            }
            return result;
        }
        finally {
            if (done !== value)
                await closeIters(iterator);
        }
    }
    toString() {
        return `AsyncStream(...<potentially empty>)`;
    }
    async toJSON() {
        return {
            dataType: 'AsyncStream',
            value: await this.toArray(),
        };
    }
}
export class AsyncFromStream extends AsyncStreamBase {
    constructor(createIterator) {
        super();
        this[_a] = undefined;
        this[Symbol.asyncIterator] = createIterator;
    }
}
_a = Symbol.asyncIterator;
class AsyncPrependStream extends AsyncStreamBase {
    constructor(source, item) {
        super();
        this.source = source;
        this.item = item;
    }
    [Symbol.asyncIterator]() {
        return new AsyncPrependIterator(this.source[Symbol.asyncIterator](), this.item);
    }
    async first() {
        return AsyncOptLazy.toPromise(this.item);
    }
    async last() {
        return this.source.last(this.item);
    }
    async count() {
        return (await this.source.count()) + 1;
    }
}
class AsyncAppendStream extends AsyncStreamBase {
    constructor(source, item) {
        super();
        this.source = source;
        this.item = item;
    }
    [Symbol.asyncIterator]() {
        return new AsyncAppendIterator(this.source[Symbol.asyncIterator](), this.item);
    }
    first() {
        return this.source.first(this.item);
    }
    async last() {
        return AsyncOptLazy.toPromise(this.item);
    }
    async count() {
        return (await this.source.count()) + 1;
    }
}
class AsyncIndexedStream extends AsyncStreamBase {
    constructor(source, startIndex) {
        super();
        this.source = source;
        this.startIndex = startIndex;
    }
    [Symbol.asyncIterator]() {
        return new AsyncIndexedIterator(this.source[Symbol.asyncIterator](), this.startIndex);
    }
    count() {
        return this.source.count();
    }
}
class AsyncMapStream extends AsyncStreamBase {
    constructor(source, mapFun) {
        super();
        this.source = source;
        this.mapFun = mapFun;
    }
    [Symbol.asyncIterator]() {
        return new AsyncMapIterator(this.source[Symbol.asyncIterator](), this.mapFun);
    }
    async first(otherwise) {
        const done = Symbol('Done');
        const value = await this.source.first(done);
        if (done === value)
            return AsyncOptLazy.toPromise(otherwise);
        return this.mapFun(value, 0);
    }
    async last(otherwise) {
        const done = Symbol('Done');
        const value = await this.source.last(done);
        if (done === value)
            return AsyncOptLazy.toPromise(otherwise);
        return this.mapFun(value, 0);
    }
    async count() {
        return this.source.count();
    }
    async elementAt(index, otherwise) {
        const done = Symbol('Done');
        const value = await this.source.elementAt(index, done);
        if (done === value)
            return AsyncOptLazy.toPromise(otherwise);
        return this.mapFun(value, index);
    }
    map(mapFun) {
        return new AsyncMapStream(this.source, async (value, index) => mapFun(await this.mapFun(value, index), index));
    }
}
class AsyncMapPureStream extends AsyncStreamBase {
    constructor(source, mapFun, args) {
        super();
        this.source = source;
        this.mapFun = mapFun;
        this.args = args;
    }
    [Symbol.asyncIterator]() {
        return new AsyncMapPureIterator(this.source[Symbol.asyncIterator](), this.mapFun, this.args);
    }
    async first(otherwise) {
        const done = Symbol('Done');
        const value = await this.source.first(done);
        if (done === value)
            return AsyncOptLazy.toPromise(otherwise);
        return this.mapFun(value, ...this.args);
    }
    async last(otherwise) {
        const done = Symbol('Done');
        const value = await this.source.last(done);
        if (done === value)
            return AsyncOptLazy.toPromise(otherwise);
        return this.mapFun(value, ...this.args);
    }
    async count() {
        return this.source.count();
    }
    async elementAt(index, otherwise) {
        const done = Symbol('Done');
        const value = await this.source.elementAt(index, done);
        if (done === value)
            return AsyncOptLazy.toPromise(otherwise);
        return this.mapFun(value, ...this.args);
    }
}
class AsyncFlatMapStream extends AsyncStreamBase {
    constructor(source, flatmapFun) {
        super();
        this.source = source;
        this.flatmapFun = flatmapFun;
    }
    [Symbol.asyncIterator]() {
        return new AsyncFlatMapIterator(this.source, this.flatmapFun, asyncStreamSourceHelpers);
    }
}
class AsyncConcatStream extends AsyncStreamBase {
    constructor(source, others) {
        super();
        this.source = source;
        this.others = others;
    }
    [Symbol.asyncIterator]() {
        return new AsyncConcatIterator(this.source, this.others, asyncStreamSourceHelpers);
    }
}
class AsyncIntersperseStream extends AsyncStreamBase {
    constructor(source, sepStream) {
        super();
        this.source = source;
        this.sepStream = sepStream;
    }
    [Symbol.asyncIterator]() {
        return new AsyncIntersperseIterator(this.source[Symbol.asyncIterator](), this.sepStream);
    }
}
class AsyncFilterStream extends AsyncStreamBase {
    constructor(source, pred, invert = false) {
        super();
        this.source = source;
        this.pred = pred;
        this.invert = invert;
    }
    [Symbol.asyncIterator]() {
        return new AsyncFilterIterator(this.source[Symbol.asyncIterator](), this.pred, this.invert);
    }
    filter(pred) {
        return new AsyncFilterStream(this.source, async (v, i, halt) => (await this.pred(v, i, halt)) && (await pred(v, i, halt)));
    }
}
class AsyncFilterPureStream extends AsyncStreamBase {
    constructor(source, pred, args, invert = false) {
        super();
        this.source = source;
        this.pred = pred;
        this.args = args;
        this.invert = invert;
    }
    [Symbol.asyncIterator]() {
        return new AsyncFilterPureIterator(this.source[Symbol.asyncIterator](), this.pred, this.args, this.invert);
    }
}
class AsyncCollectStream extends AsyncStreamBase {
    constructor(source, collectFun) {
        super();
        this.source = source;
        this.collectFun = collectFun;
    }
    [Symbol.asyncIterator]() {
        return new AsyncCollectIterator(this.source[Symbol.asyncIterator](), this.collectFun);
    }
}
class AsyncIndicesWhereStream extends AsyncStreamBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
    }
    [Symbol.asyncIterator]() {
        return new AsyncIndicesWhereIterator(this.source[Symbol.asyncIterator](), this.pred);
    }
}
class AsyncIndicesOfStream extends AsyncStreamBase {
    constructor(source, searchValue, eq) {
        super();
        this.source = source;
        this.searchValue = searchValue;
        this.eq = eq;
    }
    [Symbol.asyncIterator]() {
        return new AsyncIndicesOfIterator(this.source[Symbol.asyncIterator](), this.searchValue, this.eq);
    }
}
class AsyncTakeWhileStream extends AsyncStreamBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
    }
    [Symbol.asyncIterator]() {
        return new AsyncTakeWhileIterator(this.source[Symbol.asyncIterator](), this.pred);
    }
}
class AsyncDropWhileStream extends AsyncStreamBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
    }
    [Symbol.asyncIterator]() {
        return new AsyncDropWhileIterator(this.source[Symbol.asyncIterator](), this.pred);
    }
}
class AsyncTakeStream extends AsyncStreamBase {
    constructor(source, amount) {
        super();
        this.source = source;
        this.amount = amount;
    }
    [Symbol.asyncIterator]() {
        return new AsyncTakeIterator(this.source[Symbol.asyncIterator](), this.amount);
    }
    take(amount) {
        if (amount === this.amount)
            return this;
        return this.source.take(amount);
    }
}
class AsyncDropStream extends AsyncStreamBase {
    constructor(source, amount) {
        super();
        this.source = source;
        this.amount = amount;
    }
    [Symbol.asyncIterator]() {
        return new AsyncDropIterator(this.source[Symbol.asyncIterator](), this.amount);
    }
    drop(amount) {
        if (amount <= 0)
            return this;
        return this.source.drop(this.amount + amount);
    }
}
class AsyncSplitWhereStream extends AsyncStreamBase {
    constructor(source, pred) {
        super();
        this.source = source;
        this.pred = pred;
    }
    [Symbol.asyncIterator]() {
        return new AsyncSplitWhereIterator(this.source[Symbol.asyncIterator](), this.pred);
    }
}
class AsyncSplitOnStream extends AsyncStreamBase {
    constructor(source, sepElem, eq) {
        super();
        this.source = source;
        this.sepElem = sepElem;
        this.eq = eq;
    }
    [Symbol.asyncIterator]() {
        return new AsyncSplitOnIterator(this.source[Symbol.asyncIterator](), this.sepElem, this.eq);
    }
}
class AsyncDistinctPreviousStream extends AsyncStreamBase {
    constructor(source, eq) {
        super();
        this.source = source;
        this.eq = eq;
    }
    [Symbol.asyncIterator]() {
        return new AsyncDistinctPreviousIterator(this.source[Symbol.asyncIterator](), this.eq);
    }
}
class AsyncWindowStream extends AsyncStreamBase {
    constructor(source, windowSize, skipAmount, collector) {
        super();
        this.source = source;
        this.windowSize = windowSize;
        this.skipAmount = skipAmount;
        this.collector = collector;
    }
    [Symbol.asyncIterator]() {
        return new AsyncWindowIterator(this.source[Symbol.asyncIterator](), this.windowSize, this.skipAmount, this.collector);
    }
}
class AsyncReduceStream extends AsyncStreamBase {
    constructor(source, reducerDef) {
        super();
        this.source = source;
        this.reducerDef = reducerDef;
    }
    [Symbol.asyncIterator]() {
        return new AsyncReduceIterator(this.source[Symbol.asyncIterator](), this.reducerDef);
    }
}
class AsyncReduceAllStream extends AsyncStreamBase {
    constructor(source, reducers) {
        super();
        this.source = source;
        this.reducers = reducers;
    }
    [Symbol.asyncIterator]() {
        return new AsyncReduceAllIterator(this.source[Symbol.asyncIterator](), this.reducers);
    }
}
export class AsyncOfStream extends AsyncStreamBase {
    constructor(values) {
        super();
        this.values = values;
    }
    [Symbol.asyncIterator]() {
        return new AsyncOfIterator(this.values);
    }
}
export function isAsyncStream(obj) {
    return obj instanceof AsyncStreamBase;
}
class AsyncEmptyStream extends AsyncStreamBase {
    [Symbol.asyncIterator]() {
        return emptyAsyncFastIterator;
    }
    asyncStream() {
        return this;
    }
    async equals(other) {
        if (other === this)
            return true;
        const done = Symbol('done');
        return (done ===
            fromAsyncStreamSource(other)[Symbol.asyncIterator]().fastNext(done));
    }
    prepend(value) {
        return AsyncStreamConstructorsImpl.of(value);
    }
    append(value) {
        return AsyncStreamConstructorsImpl.of(value);
    }
    assumeNonEmpty() {
        RimbuError.throwEmptyCollectionAssumedNonEmptyError();
    }
    async forEach() {
        //
    }
    async forEachPure() {
        //
    }
    indexed() {
        return this;
    }
    map() {
        return this;
    }
    mapPure() {
        return this;
    }
    flatMap() {
        return this;
    }
    flatZip() {
        return this;
    }
    transform(transformer) {
        return AsyncStreamConstructorsImpl.from(async () => await transformer.stateToResult(await AsyncOptLazy.toMaybePromise(transformer.init)));
    }
    filter() {
        return this;
    }
    filterNot() {
        return this;
    }
    filterPure() {
        return this;
    }
    filterNotPure() {
        return this;
    }
    collect() {
        return this;
    }
    first(otherwise) {
        return AsyncOptLazy.toPromise(otherwise);
    }
    last(otherwise) {
        return AsyncOptLazy.toPromise(otherwise);
    }
    single(otherwise) {
        return AsyncOptLazy.toPromise(otherwise);
    }
    async count() {
        return 0;
    }
    async countElement() {
        return 0;
    }
    async countNotElement() {
        return 0;
    }
    find(pred, occurrance, otherwise) {
        return AsyncOptLazy.toPromise(otherwise);
    }
    elementAt(index, otherwise) {
        return AsyncOptLazy.toPromise(otherwise);
    }
    indicesWhere() {
        return this;
    }
    indicesOf() {
        return this;
    }
    async indexWhere() {
        return undefined;
    }
    async indexOf() {
        return undefined;
    }
    async some() {
        return false;
    }
    async every() {
        return true;
    }
    async contains() {
        return false;
    }
    async containsSlice() {
        return false;
    }
    takeWhile() {
        return this;
    }
    dropWhile() {
        return this;
    }
    take() {
        return this;
    }
    drop() {
        return this;
    }
    repeat() {
        return this;
    }
    concat(...others) {
        if (others.every(isEmptyAsyncStreamSourceInstance))
            return this;
        const [source1, source2, ...sources] = others;
        if (undefined === source2)
            return source1;
        return fromAsyncStreamSource(source1).concat(source2, ...sources);
    }
    min(otherwise) {
        return AsyncOptLazy.toPromise(otherwise);
    }
    minBy(compare, otherwise) {
        return AsyncOptLazy.toPromise(otherwise);
    }
    max(otherwise) {
        return AsyncOptLazy.toPromise(otherwise);
    }
    maxBy(compare, otherwise) {
        return AsyncOptLazy.toPromise(otherwise);
    }
    intersperse() {
        return this;
    }
    async join({ start = '', end = '', ifEmpty = undefined, } = {}) {
        if (undefined !== ifEmpty)
            return ifEmpty;
        return start.concat(end);
    }
    mkGroup({ start = emptyAsyncStream, end = emptyAsyncStream, } = {}) {
        return fromAsyncStreamSource(start).concat(end);
    }
    splitOn() {
        return this;
    }
    splitWhere() {
        return this;
    }
    distinctPrevious() {
        return this;
    }
    window() {
        return this;
    }
    fold(init) {
        return AsyncOptLazy.toPromise(init);
    }
    foldStream() {
        return this;
    }
    async reduce(reducer) {
        return reducer.stateToResult(await AsyncOptLazy.toPromise(reducer.init));
    }
    reduceStream() {
        return this;
    }
    reduceAll(...reducers) {
        return Promise.all(reducers.map(async (p) => p.stateToResult(await AsyncOptLazy.toMaybePromise(p.init))));
    }
    reduceAllStream() {
        return this;
    }
    async toArray() {
        return [];
    }
    toString() {
        return `AsyncStream(<empty>)`;
    }
    async toJSON() {
        return {
            dataType: 'AsyncStream',
            value: [],
        };
    }
}
export class FromSource extends AsyncStreamBase {
    constructor(source, close) {
        super();
        this.source = source;
        this.close = close;
    }
    [Symbol.asyncIterator]() {
        return asyncStreamSourceToIterator(this.source, this.close);
    }
}
export class FromResource extends AsyncStreamBase {
    constructor(open, createSource, close) {
        super();
        this.open = open;
        this.createSource = createSource;
        this.close = close;
    }
    [Symbol.asyncIterator]() {
        return new FromResourceIterator(this.open, this.createSource, this.close, asyncStreamSourceHelpers);
    }
}
export const emptyAsyncStream = Object.freeze(new AsyncEmptyStream());
export function isEmptyAsyncStreamSourceInstance(source) {
    return (source === emptyAsyncStream ||
        isEmptyStreamSourceInstance(source));
}
export function asyncStreamSourceToIterator(source, close) {
    if (source instanceof Function) {
        return new FromPromise(source, asyncStreamSourceHelpers, close);
    }
    if (isEmptyAsyncStreamSourceInstance(source)) {
        return emptyAsyncFastIterator;
    }
    if (typeof source === 'string') {
        return new FromIterator(source[Symbol.iterator](), close);
    }
    if (typeof source === 'object') {
        if (Symbol.asyncIterator in source) {
            const iterator = source[Symbol.asyncIterator]();
            if (isAsyncFastIterator(iterator)) {
                if (undefined === close) {
                    return iterator;
                }
                if (undefined === iterator.return) {
                    iterator.return = close;
                    return iterator;
                }
                const oldReturn = iterator.return;
                iterator.return = () => Promise.all([oldReturn, close]);
                return iterator;
            }
            return new FromAsyncIterator(iterator, close);
        }
        if (`asyncStream` in source) {
            return asyncStreamSourceToIterator(source.asyncStream(), close);
        }
        if (Symbol.iterator in source) {
            return new FromIterator(source[Symbol.iterator](), close);
        }
    }
    throw Error('unknown async stream source');
}
// prettier-ignore
export const fromAsyncStreamSource = (source) => {
    if (undefined === source)
        return emptyAsyncStream;
    if (isAsyncStream(source))
        return source;
    if (isEmptyAsyncStreamSourceInstance(source))
        return emptyAsyncStream;
    return new FromSource(source);
};
const asyncStreamSourceHelpers = {
    fromAsyncStreamSource,
    isEmptyAsyncStreamSourceInstance,
};
export const AsyncStreamConstructorsImpl = Object.freeze({
    of(...values) {
        return new AsyncOfStream(values);
    },
    from(...sources) {
        const [first, ...rest] = sources;
        if (rest.length <= 0) {
            return fromAsyncStreamSource(first);
        }
        const [rest1, ...restOther] = rest;
        return fromAsyncStreamSource(first).concat(rest1, ...restOther);
    },
    fromResource(open, createSource, close) {
        return new FromResource(open, createSource, close);
    },
    live(maxSize = 100) {
        const listenerIterators = new Set();
        let closed = false;
        function subscribe(iter) {
            if (closed) {
                iter.close();
                return;
            }
            listenerIterators.add(iter);
        }
        function submit(value) {
            if (closed) {
                return;
            }
            for (const listenerIterator of listenerIterators) {
                listenerIterator.submit(value);
            }
        }
        function close() {
            if (closed) {
                return;
            }
            closed = true;
            for (const listener of listenerIterators) {
                listener.close();
            }
            listenerIterators.clear();
        }
        const stream = new AsyncFromStream(() => {
            if (closed) {
                return emptyAsyncFastIterator;
            }
            const iter = new AsyncLiveIterator(maxSize);
            subscribe(iter);
            return iter;
        });
        return [{ submit, close }, stream];
    },
    zipWith(...sources) {
        return (zipFun) => {
            if (sources.some(isEmptyAsyncStreamSourceInstance)) {
                return emptyAsyncStream;
            }
            return new AsyncFromStream(() => new AsyncZipWithIterator(sources, zipFun, asyncStreamSourceHelpers));
        };
    },
    zip(...sources) {
        return AsyncStreamConstructorsImpl.zipWith(...sources)(Array);
    },
    zipAllWith(...sources) {
        return (fillValue, zipFun) => {
            if (sources.every(isEmptyAsyncStreamSourceInstance)) {
                return emptyAsyncStream;
            }
            return new AsyncFromStream(() => new AsyncZipAllWithItererator(fillValue, sources, zipFun, asyncStreamSourceHelpers));
        };
    },
    zipAll(fillValue, ...sources) {
        return AsyncStreamConstructorsImpl.zipAllWith(...sources)(fillValue, Array);
    },
    flatten(source) {
        return AsyncStreamConstructorsImpl.from(source).flatMap((s) => s);
    },
    unzip(source, length) {
        if (isEmptyAsyncStreamSourceInstance(source)) {
            return Stream.of(emptyAsyncStream).repeat(length).toArray();
        }
        const result = [];
        let i = -1;
        while (++i < length) {
            const index = i;
            result[i] = source.map((t) => t[index]);
        }
        return result;
    },
    empty() {
        return emptyAsyncStream;
    },
    always(value) {
        return AsyncStreamConstructorsImpl.of(value).repeat();
    },
    unfold(init, next) {
        return new AsyncFromStream(() => new AsyncUnfoldIterator(init, next));
    },
});
//# sourceMappingURL=async-stream-custom.mjs.map