import { AsyncOptLazy, AsyncReducer, Eq } from '@rimbu/common';
import { AsyncStream } from '@rimbu/stream/async';
export var AsyncTransformer;
(function (AsyncTransformer) {
    /**
     * Returns an async transformer that produces windows/collections of `windowSize` size, each
     * window starting `skipAmount` of elements after the previous, and optionally collected
     * by a custom reducer.
     * @typeparam T - the input element type
     * @typeparam R - the window type
     * @param windowSize - the amount of elements for each window
     * @param skipAmount - (default: `windowSize`) the amount of elements between the start of each window
     * @param collector - (default: Reducer.toArray()) the reducer to use to convert elements to windows
     * @example
     * ```ts
     * await AsyncStream.of(1, 2, 3, 4, 5, 6)
     *   .transform(AsyncTransformer.window(3))
     *   .toArray()
     * // => [[1, 2, 3], [4, 5, 6]]
     * ```
     */
    AsyncTransformer.window = (windowSize, skipAmount = windowSize, collector = AsyncReducer.toArray()) => {
        return AsyncReducer.create(() => new Set(), async (state, elem, index) => {
            for (const current of state) {
                if (current.size >= windowSize || current.halted) {
                    state.delete(current);
                }
                current.result = await collector.next(current.result, elem, current.size, current.halt);
                current.size++;
            }
            if (index % skipAmount === 0) {
                const newState = {
                    result: await AsyncOptLazy.toMaybePromise(collector.init),
                    size: 1,
                    halted: false,
                    halt() {
                        this.halted = true;
                    },
                };
                newState.result = collector.next(await AsyncOptLazy.toMaybePromise(collector.init), elem, 0, newState.halt);
                state.add(newState);
            }
            return state;
        }, (current) => {
            return AsyncStream.from(current)
                .collect((v, _, skip) => v.size === windowSize
                ? AsyncStream.of(collector.stateToResult(v.result))
                : skip)
                .first(AsyncStream.empty());
        });
    };
    /**
     * Returns an async transformer that returns only those elements from the input that are different to previous element
     * according to the optionally given `eq` function.
     * @param eq - (default: `Eq.objectIs`) the equality testing function
     * @example
     * ```ts
     * await AsyncStream.of(1, 1, 2, 3, 2, 2)
     *   .transform(AsyncTransformer.distinctPrevious())
     *   .toArray()
     * // => [1, 2, 3, 2]
     * ```
     */
    function distinctPrevious(eq = Eq.objectIs) {
        return AsyncReducer.create(() => [], (current, elem) => {
            current.push(elem);
            if (current.length > 2) {
                current.shift();
            }
            return current;
        }, (state) => {
            if (state.length > 0) {
                if (state.length === 1) {
                    return AsyncStream.of(state[0]);
                }
                if (!eq(state[0], state[1])) {
                    return AsyncStream.of(state[1]);
                }
            }
            return AsyncStream.empty();
        });
    }
    AsyncTransformer.distinctPrevious = distinctPrevious;
})(AsyncTransformer || (AsyncTransformer = {}));
//# sourceMappingURL=async-transformer.mjs.map