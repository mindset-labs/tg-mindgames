"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/async/index.mts
var async_exports = {};
__export(async_exports, {
  AsyncStream: () => AsyncStream,
  AsyncTransformer: () => AsyncTransformer
});
module.exports = __toCommonJS(async_exports);

// src/async-custom/utils.mts
async function closeIters(...iters) {
  await Promise.all(
    iters.map((i) => {
      i?.return?.();
    })
  );
}

// src/async-custom/async-fast-iterator-base.mts
var import_base = require("@rimbu/base");
var import_common = require("@rimbu/common");
var fixedDoneAsyncIteratorResult = Object.freeze(
  Promise.resolve(
    Object.freeze({
      done: true,
      value: void 0
    })
  )
);
function isAsyncFastIterator(iterator) {
  return `fastNext` in iterator;
}
var emptyAsyncFastIterator = Object.freeze({
  fastNext(otherwise) {
    return import_common.AsyncOptLazy.toMaybePromise(otherwise);
  },
  next() {
    return fixedDoneAsyncIteratorResult;
  }
});
var AsyncFastIteratorBase = class {
  async next() {
    const done = Symbol("Done");
    const value = await this.fastNext(done);
    if (done === value)
      return fixedDoneAsyncIteratorResult;
    return { value, done: false };
  }
};
var AsyncOfIterator = class extends AsyncFastIteratorBase {
  constructor(values) {
    super();
    this.values = values;
    this.index = 0;
  }
  fastNext(otherwise) {
    const index = this.index;
    const values = this.values;
    if (index >= values.length)
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    return import_common.AsyncOptLazy.toMaybePromise(values[this.index++]);
  }
};
var FromResourceIterator = class extends AsyncFastIteratorBase {
  constructor(open, createSource, close, asyncStreamSourceHelpers2) {
    super();
    this.open = open;
    this.createSource = createSource;
    this.close = close;
    this.asyncStreamSourceHelpers = asyncStreamSourceHelpers2;
    this.return = async () => {
      if (this.resource)
        await close(this.resource);
      await this.iterator?.return?.();
    };
  }
  async fastNext(otherwise) {
    if (void 0 === this.iterator) {
      const resource = await this.open();
      this.resource = resource;
      const source = await this.createSource(resource);
      this.iterator = this.asyncStreamSourceHelpers.fromAsyncStreamSource(source)[Symbol.asyncIterator]();
    }
    return this.iterator.fastNext(async () => {
      await this.return?.();
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    });
  }
};
var AsyncUnfoldIterator = class extends AsyncFastIteratorBase {
  constructor(init, getNext) {
    super();
    this.getNext = getNext;
    this.index = 0;
    this.current = init;
  }
  async fastNext(otherwise) {
    const current = this.current;
    if (import_base.Token === current)
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    if (this.index === 0) {
      this.index++;
      return current;
    }
    const next = await this.getNext(current, this.index++, import_base.Token);
    this.current = next;
    if (import_base.Token === next)
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    return next;
  }
};
var AsyncZipWithIterator = class extends AsyncFastIteratorBase {
  constructor(iterables, zipFun, asyncStreamSourceHelpers2) {
    super();
    this.iterables = iterables;
    this.zipFun = zipFun;
    this.asyncStreamSourceHelpers = asyncStreamSourceHelpers2;
    this.sources = iterables.map(
      (source) => this.asyncStreamSourceHelpers.fromAsyncStreamSource(source)[Symbol.asyncIterator]()
    );
    this.sourcesToClose = new Set(this.sources);
    this.return = () => closeIters(...this.sourcesToClose);
  }
  async fastNext(otherwise) {
    const sources = this.sources;
    const done = Symbol("Done");
    const result = await Promise.all(
      sources.map(
        (source) => source.fastNext(() => {
          this.sourcesToClose.delete(source);
          return done;
        })
      )
    );
    if (this.sourcesToClose.size !== sources.length) {
      await closeIters(this);
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    return this.zipFun(...result);
  }
};
var AsyncZipAllWithItererator = class extends AsyncFastIteratorBase {
  constructor(fillValue, iters, zipFun, asyncStreamSourceHelpers2) {
    super();
    this.fillValue = fillValue;
    this.iters = iters;
    this.zipFun = zipFun;
    this.asyncStreamSourceHelpers = asyncStreamSourceHelpers2;
    this.sources = iters.map(
      (o) => this.asyncStreamSourceHelpers.fromAsyncStreamSource(o)[Symbol.asyncIterator]()
    );
    this.sourcesToClose = new Set(this.sources);
    this.return = () => closeIters(...this.sourcesToClose);
  }
  async fastNext(otherwise) {
    if (this.sourcesToClose.size === 0) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const sources = this.sources;
    const fillValue = this.fillValue;
    const result = await Promise.all(
      sources.map((source) => {
        if (this.sourcesToClose.has(source)) {
          return source.fastNext(() => {
            this.sourcesToClose.delete(source);
            return import_common.AsyncOptLazy.toMaybePromise(fillValue);
          });
        }
        return import_common.AsyncOptLazy.toMaybePromise(fillValue);
      })
    );
    if (this.sourcesToClose.size === 0) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    return this.zipFun(...result);
  }
};
var FromAsyncIterator = class {
  constructor(source, close) {
    this.source = source;
    if (source.return && close) {
      this.return = () => Promise.all([source.return?.(), close?.()]);
    } else if (source.return) {
      this.return = () => source.return?.();
    } else if (close) {
      this.return = close;
    }
  }
  next() {
    return this.source.next();
  }
  async fastNext(otherwise) {
    const result = await this.source.next();
    if (result.done) {
      await closeIters(this);
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    return result.value;
  }
};
var FromIterator = class extends AsyncFastIteratorBase {
  constructor(iterator, close) {
    super();
    this.iterator = iterator;
    if (close !== void 0) {
      this.return = close;
    }
  }
  async fastNext(otherwise) {
    const result = this.iterator.next();
    if (result.done) {
      await closeIters(this);
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    return result.value;
  }
};
var FromPromise = class extends AsyncFastIteratorBase {
  constructor(promise, asyncStreamSourceHelpers2, close) {
    super();
    this.promise = promise;
    this.asyncStreamSourceHelpers = asyncStreamSourceHelpers2;
    this.return = async () => {
      if (close)
        await close?.();
      if (this.iterator)
        await this.iterator.return?.();
    };
  }
  async fastNext(otherwise) {
    if (this.iterator === void 0) {
      const source = await this.promise();
      this.iterator = this.asyncStreamSourceHelpers.fromAsyncStreamSource(source)[Symbol.asyncIterator]();
    }
    return this.iterator.fastNext(otherwise);
  }
};
var AsyncLiveIterator = class extends AsyncFastIteratorBase {
  constructor(maxSize) {
    super();
    this.maxSize = maxSize;
    this.queue = [];
    this.submit = (value) => {
      if (this.halted) {
        return;
      }
      this.queue.unshift(value);
      if (this.queue.length > this.maxSize) {
        this.queue.length = this.maxSize;
      }
      this.wakeUp?.();
    };
    this.halted = false;
    this.close = () => {
      this.halted = true;
      this.wakeUp?.();
    };
  }
  async fastNext(otherwise) {
    const { queue } = this;
    if (queue.length > 0) {
      const item = queue.pop();
      return item;
    }
    if (this.halted) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const waitPromise = new Promise((res) => {
      this.wakeUp = res;
    });
    await waitPromise;
    this.wakeUp = void 0;
    return this.fastNext(otherwise);
  }
};
var AsyncPrependIterator = class extends AsyncFastIteratorBase {
  constructor(source, item) {
    super();
    this.source = source;
    this.item = item;
    this.prependDone = false;
    this.return = async () => {
      if (this.prependDone)
        return closeIters(this.source);
    };
  }
  fastNext(otherwise) {
    if (this.prependDone) {
      return this.source.fastNext(otherwise);
    }
    this.prependDone = true;
    return import_common.AsyncOptLazy.toMaybePromise(this.item);
  }
};
var AsyncAppendIterator = class extends AsyncFastIteratorBase {
  constructor(source, item) {
    super();
    this.source = source;
    this.item = item;
    this.appendDone = false;
    this.return = async () => {
      if (!this.appendDone)
        return closeIters(source);
    };
  }
  async fastNext(otherwise) {
    if (this.appendDone)
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    const done = Symbol("Done");
    const value = await this.source.fastNext(done);
    if (done !== value)
      return value;
    this.appendDone = true;
    return import_common.AsyncOptLazy.toMaybePromise(this.item);
  }
};
var AsyncIndexedIterator = class extends AsyncFastIteratorBase {
  constructor(source, startIndex = 0) {
    super();
    this.source = source;
    this.startIndex = startIndex;
    this.index = startIndex;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const done = Symbol("Done");
    const value = await this.source.fastNext(done);
    if (done === value) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    return [this.index++, value];
  }
};
var AsyncMapIterator = class extends AsyncFastIteratorBase {
  constructor(source, mapFun) {
    super();
    this.source = source;
    this.mapFun = mapFun;
    this.state = (0, import_common.TraverseState)();
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const state = this.state;
    const done = Symbol("Done");
    const next = await this.source.fastNext(done);
    if (done === next) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    return this.mapFun(next, state.nextIndex());
  }
};
var AsyncMapPureIterator = class extends AsyncFastIteratorBase {
  constructor(source, mapFun, args) {
    super();
    this.source = source;
    this.mapFun = mapFun;
    this.args = args;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const done = Symbol("Done");
    const next = await this.source.fastNext(done);
    if (done === next)
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    return this.mapFun(next, ...this.args);
  }
};
var AsyncFlatMapIterator = class extends AsyncFastIteratorBase {
  constructor(source, flatMapFun, asyncStreamSourceHelpers2) {
    super();
    this.source = source;
    this.flatMapFun = flatMapFun;
    this.asyncStreamSourceHelpers = asyncStreamSourceHelpers2;
    this.state = (0, import_common.TraverseState)();
    this.done = false;
    this.currentIterator = null;
    this.iterator = this.source[Symbol.asyncIterator]();
    this.return = () => closeIters(this.currentIterator, this.iterator);
  }
  async fastNext(otherwise) {
    const state = this.state;
    if (state.halted || this.done) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const done = Symbol("Done");
    let nextValue;
    const { asyncStreamSourceHelpers: asyncStreamSourceHelpers2 } = this;
    while (null === this.currentIterator || done === (nextValue = await this.currentIterator.fastNext(done))) {
      const nextIter = await this.iterator.fastNext(done);
      if (done === nextIter) {
        this.done = true;
        return import_common.AsyncOptLazy.toMaybePromise(otherwise);
      }
      const nextSource = this.flatMapFun(
        nextIter,
        state.nextIndex(),
        state.halt
      );
      const currentIterator = asyncStreamSourceHelpers2.fromAsyncStreamSource(nextSource)[Symbol.asyncIterator]();
      this.currentIterator = currentIterator;
    }
    return nextValue;
  }
};
var AsyncConcatIterator = class extends AsyncFastIteratorBase {
  constructor(source, otherSources, asyncStreamSourceHelpers2) {
    super();
    this.source = source;
    this.otherSources = otherSources;
    this.asyncStreamSourceHelpers = asyncStreamSourceHelpers2;
    this.sourceIndex = 0;
    this.iterator = source[Symbol.asyncIterator]();
    this.return = () => closeIters(this.iterator);
  }
  async fastNext(otherwise) {
    const done = Symbol("Done");
    let value;
    const length = this.otherSources.length;
    const { asyncStreamSourceHelpers: asyncStreamSourceHelpers2 } = this;
    while (done === (value = await this.iterator.fastNext(done))) {
      if (this.sourceIndex >= length) {
        return import_common.AsyncOptLazy.toMaybePromise(otherwise);
      }
      let nextSource = this.otherSources[this.sourceIndex++];
      while (asyncStreamSourceHelpers2.isEmptyAsyncStreamSourceInstance(nextSource)) {
        if (this.sourceIndex >= length) {
          return import_common.AsyncOptLazy.toMaybePromise(otherwise);
        }
        nextSource = this.otherSources[this.sourceIndex++];
      }
      this.iterator = asyncStreamSourceHelpers2.fromAsyncStreamSource(nextSource)[Symbol.asyncIterator]();
    }
    return value;
  }
};
var AsyncIntersperseIterator = class extends AsyncFastIteratorBase {
  constructor(source, sepStream) {
    super();
    this.source = source;
    this.sepStream = sepStream;
    this.isInitialized = false;
    this.isDone = false;
    this.return = async () => {
      if (!this.isDone)
        return closeIters(this.sepIterator, this.source);
    };
  }
  async fastNext(otherwise) {
    if (this.isDone) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const done = Symbol("Done");
    if (void 0 !== this.sepIterator) {
      const sepNext = await this.sepIterator.fastNext(done);
      if (done !== sepNext)
        return sepNext;
      this.sepIterator = void 0;
    }
    if (this.isInitialized) {
      const newNextValue2 = await this.source.fastNext(done);
      if (done === newNextValue2) {
        this.isDone = true;
        return this.nextValue;
      }
      const currentNextValue = this.nextValue;
      this.nextValue = newNextValue2;
      this.sepIterator = this.sepStream[Symbol.asyncIterator]();
      return currentNextValue;
    }
    const nextValue = await this.source.fastNext(done);
    if (done === nextValue) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const newNextValue = await this.source.fastNext(done);
    if (done === newNextValue) {
      return nextValue;
    }
    this.nextValue = newNextValue;
    this.isInitialized = true;
    this.sepIterator = this.sepStream[Symbol.asyncIterator]();
    return nextValue;
  }
};
var AsyncFilterIterator = class extends AsyncFastIteratorBase {
  constructor(source, pred, invert) {
    super();
    this.source = source;
    this.pred = pred;
    this.invert = invert;
    this.state = (0, import_common.TraverseState)();
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const state = this.state;
    if (state.halted) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const done = Symbol("Done");
    let value;
    const source = this.source;
    const pred = this.pred;
    const halt = state.halt;
    const invert = this.invert;
    while (!state.halted && done !== (value = await source.fastNext(done))) {
      const cond = await pred(value, state.nextIndex(), halt);
      if (cond !== invert)
        return value;
    }
    if (state.halted && done !== value) {
      await closeIters(this);
    }
    return import_common.AsyncOptLazy.toMaybePromise(otherwise);
  }
};
var AsyncFilterPureIterator = class extends AsyncFastIteratorBase {
  constructor(source, pred, args, invert) {
    super();
    this.source = source;
    this.pred = pred;
    this.args = args;
    this.invert = invert;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const done = Symbol("Done");
    let value;
    const source = this.source;
    const pred = this.pred;
    const args = this.args;
    const invert = this.invert;
    while (done !== (value = await source.fastNext(done))) {
      const cond = await pred(value, ...args);
      if (cond !== invert)
        return value;
    }
    return import_common.AsyncOptLazy.toMaybePromise(otherwise);
  }
};
var AsyncCollectIterator = class extends AsyncFastIteratorBase {
  constructor(source, collectFun) {
    super();
    this.source = source;
    this.collectFun = collectFun;
    this.state = (0, import_common.TraverseState)();
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const state = this.state;
    if (state.halted) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const { halt } = state;
    const done = Symbol("Done");
    let value;
    const source = this.source;
    const collectFun = this.collectFun;
    try {
      while (!state.halted && done !== (value = await source.fastNext(done))) {
        const result = await collectFun(
          value,
          state.nextIndex(),
          import_common.CollectFun.Skip,
          halt
        );
        if (import_common.CollectFun.Skip === result)
          continue;
        return result;
      }
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    } finally {
      if (state.halted && done !== value) {
        await closeIters(this);
      }
    }
  }
};
var AsyncIndicesWhereIterator = class extends AsyncFastIteratorBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
    this.index = 0;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const done = Symbol("Done");
    let value;
    const source = this.source;
    const pred = this.pred;
    while (done !== (value = await source.fastNext(done))) {
      const cond = await pred(value);
      if (cond) {
        return this.index++;
      }
      this.index++;
    }
    return import_common.AsyncOptLazy.toMaybePromise(otherwise);
  }
};
var AsyncIndicesOfIterator = class extends AsyncFastIteratorBase {
  constructor(source, searchValue, eq) {
    super();
    this.source = source;
    this.searchValue = searchValue;
    this.eq = eq;
    this.index = 0;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const done = Symbol("Done");
    let value;
    const source = this.source;
    const searchValue = this.searchValue;
    const eq = this.eq;
    while (done !== (value = await source.fastNext(done))) {
      if (eq(searchValue, value))
        return this.index++;
      this.index++;
    }
    return import_common.AsyncOptLazy.toMaybePromise(otherwise);
  }
};
var AsyncTakeWhileIterator = class extends AsyncFastIteratorBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
    this.isDone = false;
    this.index = 0;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    if (this.isDone)
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    const done = Symbol("Done");
    const next = await this.source.fastNext(done);
    if (done === next) {
      this.isDone = true;
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    if (await this.pred(next, this.index++))
      return next;
    this.isDone = true;
    await closeIters(this);
    return import_common.AsyncOptLazy.toMaybePromise(otherwise);
  }
};
var AsyncDropWhileIterator = class extends AsyncFastIteratorBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
    this.pass = false;
    this.index = 0;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const source = this.source;
    if (this.pass)
      return source.fastNext(otherwise);
    const done = Symbol("Done");
    let value;
    while (done !== (value = await source.fastNext(done))) {
      this.pass = !await this.pred(value, this.index++);
      if (this.pass)
        return value;
    }
    return import_common.AsyncOptLazy.toMaybePromise(otherwise);
  }
};
var AsyncTakeIterator = class extends AsyncFastIteratorBase {
  constructor(source, amount) {
    super();
    this.source = source;
    this.amount = amount;
    this.i = 0;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    if (this.i++ >= this.amount) {
      await closeIters(this);
      this.return = void 0;
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    return this.source.fastNext(otherwise);
  }
};
var AsyncDropIterator = class extends AsyncFastIteratorBase {
  constructor(source, amount) {
    super();
    this.source = source;
    this.amount = amount;
    this.return = () => closeIters(source);
    this.remain = amount;
  }
  async fastNext(otherwise) {
    const source = this.source;
    if (this.remain <= 0)
      return source.fastNext(otherwise);
    const done = Symbol("Done");
    let value;
    while (done !== (value = await source.fastNext(done))) {
      if (this.remain-- <= 0) {
        return value;
      }
    }
    return import_common.AsyncOptLazy.toMaybePromise(otherwise);
  }
};
var AsyncRepeatIterator = class extends AsyncFastIteratorBase {
  constructor(source, amount) {
    super();
    this.source = source;
    this.amount = amount;
    this.isEmpty = true;
    this.iterator = source[Symbol.asyncIterator]();
    this.return = () => closeIters(this.iterator);
    this.remain = amount;
  }
  async fastNext(otherwise) {
    const done = Symbol("Done");
    const iterator = this.iterator;
    let value = await iterator.fastNext(done);
    if (done !== value) {
      this.isEmpty = false;
      return value;
    }
    if (this.isEmpty) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    if (void 0 !== this.remain) {
      this.remain--;
      if (this.remain <= 0) {
        return import_common.AsyncOptLazy.toMaybePromise(otherwise);
      }
    }
    this.iterator = this.source[Symbol.asyncIterator]();
    value = await this.iterator.fastNext(done);
    if (done === value) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    return value;
  }
};
var AsyncSplitWhereIterator = class extends AsyncFastIteratorBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
    this.index = 0;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const startIndex = this.index;
    if (startIndex < 0) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const result = [];
    const source = this.source;
    const done = Symbol("Done");
    let value;
    const pred = this.pred;
    while (done !== (value = await source.fastNext(done))) {
      if (await pred(value, this.index++))
        return result;
      result.push(value);
    }
    this.return = void 0;
    if (startIndex === this.index) {
      this.index = -1;
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    this.index = -1;
    return result;
  }
};
var AsyncFoldIterator = class extends AsyncFastIteratorBase {
  constructor(source, init, getNext) {
    super();
    this.source = source;
    this.init = init;
    this.getNext = getNext;
    this.isInitialized = false;
    this.state = (0, import_common.TraverseState)();
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    if (!this.isInitialized) {
      this.current = await import_common.AsyncOptLazy.toMaybePromise(this.init);
      this.isInitialized = true;
    }
    const state = this.state;
    if (state.halted) {
      await closeIters(this);
      this.return = void 0;
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const done = Symbol("done");
    const value = await this.source.fastNext(done);
    if (done === value) {
      this.return = void 0;
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    this.current = await this.getNext(
      this.current,
      value,
      state.nextIndex(),
      state.halt
    );
    return this.current;
  }
};
var AsyncSplitOnIterator = class extends AsyncFastIteratorBase {
  constructor(source, sepElem, eq) {
    super();
    this.source = source;
    this.sepElem = sepElem;
    this.eq = eq;
    this.isDone = false;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    if (this.isDone) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const result = [];
    const source = this.source;
    const done = Symbol("Done");
    let value;
    let processed = false;
    const eq = this.eq;
    const sepElem = this.sepElem;
    while (done !== (value = await source.fastNext(done))) {
      processed = true;
      if (eq(value, sepElem))
        return result;
      result.push(value);
    }
    this.return = void 0;
    this.isDone = true;
    if (!processed)
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    return result;
  }
};
var AsyncReduceIterator = class extends AsyncFastIteratorBase {
  constructor(source, reducer) {
    super();
    this.source = source;
    this.reducer = reducer;
    this.traverseState = (0, import_common.TraverseState)();
    this.isInitialized = false;
    this.isDone = false;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    if (this.isDone) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const done = Symbol("Done");
    const value = await this.source.fastNext(done);
    if (done === value) {
      this.isDone = true;
      this.return = void 0;
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const reducer = this.reducer;
    if (!this.isInitialized) {
      this.state = await import_common.AsyncOptLazy.toMaybePromise(reducer.init);
      this.isInitialized = true;
    }
    const traverseState = this.traverseState;
    try {
      this.state = await reducer.next(
        this.state,
        value,
        traverseState.nextIndex(),
        traverseState.halt
      );
    } catch (err) {
      this.isDone = true;
      await closeIters(this);
      this.return = void 0;
      await reducer.onClose?.(this.state, err);
      throw err;
    }
    if (traverseState.halted) {
      this.isDone = true;
      await closeIters(this);
      this.return = void 0;
      await reducer.onClose?.(this.state);
    }
    return reducer.stateToResult(this.state);
  }
};
var AsyncReduceAllIterator = class extends AsyncFastIteratorBase {
  constructor(source, reducers) {
    super();
    this.source = source;
    this.reducers = reducers;
    this.index = 0;
    this.isDone = false;
    this.reducersToClose = new Set(reducers);
    this.return = async () => {
      await closeIters(source);
      const state = this.state;
      if (state) {
        await Promise.all(
          [...this.reducersToClose].map(
            (reducer, index) => reducer.onClose?.(state[index], this.err)
          )
        );
      }
    };
  }
  async fastNext(otherwise) {
    const reducers = this.reducers;
    if (void 0 === this.state) {
      this.state = await Promise.all(
        reducers.map((d) => import_common.AsyncOptLazy.toMaybePromise(d.init))
      );
    }
    if (this.isDone) {
      await closeIters(this);
      this.return = void 0;
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const done = Symbol("Done");
    const value = await this.source.fastNext(done);
    if (done === value) {
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    const state = this.state;
    this.state = await Promise.all(
      reducers.map((red, i) => {
        const st = state[i];
        if (!this.reducersToClose.has(red)) {
          return st;
        }
        try {
          return red.next(st, value, this.index, async () => {
            this.reducersToClose.delete(red);
            await red.onClose?.(st);
            return st;
          });
        } catch (e) {
          this.err = e;
        }
        return void 0;
      })
    );
    this.index++;
    this.isDone = this.reducersToClose.size === 0 || void 0 !== this.err;
    if (this.isDone) {
      await closeIters(this);
      this.return = void 0;
      return import_common.AsyncOptLazy.toMaybePromise(otherwise);
    }
    return Promise.all(
      this.state.map((s, i) => reducers[i].stateToResult(s))
    );
  }
};
var AsyncDistinctPreviousIterator = class extends AsyncFastIteratorBase {
  constructor(source, eq) {
    super();
    this.source = source;
    this.eq = eq;
    this.previous = [];
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const done = Symbol("Done");
    let next;
    const source = this.source;
    const previous = this.previous;
    while (done !== (next = await source.fastNext(done))) {
      previous.push(next);
      if (previous.length === 1) {
        return next;
      }
      const prev = previous.shift();
      if (!this.eq(prev, next)) {
        return next;
      }
    }
    return import_common.AsyncOptLazy.toMaybePromise(otherwise);
  }
};
var AsyncWindowIterator = class extends AsyncFastIteratorBase {
  constructor(source, windowSize, skipAmount, collector) {
    super();
    this.source = source;
    this.windowSize = windowSize;
    this.skipAmount = skipAmount;
    this.collector = collector;
    this.state = /* @__PURE__ */ new Set();
    this.index = 0;
    this.return = () => closeIters(source);
  }
  async fastNext(otherwise) {
    const source = this.source;
    const collector = this.collector;
    const windowSize = this.windowSize;
    const skipAmount = this.skipAmount;
    const done = Symbol("Done");
    const state = this.state;
    let next;
    let result = done;
    while (done !== (next = await source.fastNext(done))) {
      for (const current of state) {
        current.result = await collector.next(
          current.result,
          next,
          current.size,
          current.halt
        );
        current.size++;
        if (current.size >= windowSize || current.halted) {
          result = await collector.stateToResult(current.result);
          state.delete(current);
        }
      }
      if (this.index % skipAmount === 0) {
        const newState = {
          result: await import_common.AsyncOptLazy.toMaybePromise(collector.init),
          size: 1,
          halted: false,
          halt() {
            this.halted = true;
          }
        };
        newState.result = await collector.next(
          import_common.AsyncOptLazy.toMaybePromise(collector.init),
          next,
          0,
          newState.halt
        );
        state.add(newState);
      }
      this.index++;
      if (done !== result) {
        return result;
      }
    }
    return import_common.AsyncOptLazy.toMaybePromise(otherwise);
  }
};

// src/async-custom/async-stream-custom.mts
var import_base4 = require("@rimbu/base");
var import_common5 = require("@rimbu/common");

// src/custom/fast-iterator-custom.mts
var import_base2 = require("@rimbu/base");
var import_common2 = require("@rimbu/common");
var fixedDoneIteratorResult = Object.freeze({
  done: true,
  value: void 0
});
var emptyFastIterator = Object.freeze({
  fastNext(otherwise) {
    return (0, import_common2.OptLazy)(otherwise);
  },
  next() {
    return fixedDoneIteratorResult;
  }
});
function isFastIterator(iterator) {
  return `fastNext` in iterator;
}
var FastIteratorBase = class {
  next() {
    const done = Symbol("Done");
    const value = this.fastNext(done);
    if (done === value)
      return fixedDoneIteratorResult;
    return { value, done: false };
  }
};
var FlatMapIterator = class extends FastIteratorBase {
  constructor(source, flatMapFun, streamSourceHelpers2) {
    super();
    this.source = source;
    this.flatMapFun = flatMapFun;
    this.streamSourceHelpers = streamSourceHelpers2;
    this.state = (0, import_common2.TraverseState)();
    this.done = false;
    this.currentIterator = null;
    this.iterator = this.source[Symbol.iterator]();
  }
  fastNext(otherwise) {
    const state = this.state;
    if (state.halted || this.done)
      return (0, import_common2.OptLazy)(otherwise);
    const done = Symbol("Done");
    let nextValue;
    while (null === this.currentIterator || done === (nextValue = this.currentIterator.fastNext(done))) {
      const nextIter = this.iterator.fastNext(done);
      if (done === nextIter) {
        this.done = true;
        return (0, import_common2.OptLazy)(otherwise);
      }
      const nextSource = this.flatMapFun(
        nextIter,
        state.nextIndex(),
        state.halt
      );
      this.currentIterator = this.streamSourceHelpers.fromStreamSource(nextSource)[Symbol.iterator]();
    }
    return nextValue;
  }
};
var ConcatIterator = class extends FastIteratorBase {
  constructor(source, otherSources, streamSourceHelpers2) {
    super();
    this.source = source;
    this.otherSources = otherSources;
    this.streamSourceHelpers = streamSourceHelpers2;
    this.sourceIndex = 0;
    this.iterator = source[Symbol.iterator]();
  }
  fastNext(otherwise) {
    const done = Symbol("Done");
    let value;
    const length = this.otherSources.length;
    const { streamSourceHelpers: streamSourceHelpers2 } = this;
    while (done === (value = this.iterator.fastNext(done))) {
      if (this.sourceIndex >= length)
        return (0, import_common2.OptLazy)(otherwise);
      let nextSource = this.otherSources[this.sourceIndex++];
      while (streamSourceHelpers2.isEmptyStreamSourceInstance(nextSource)) {
        if (this.sourceIndex >= length)
          return (0, import_common2.OptLazy)(otherwise);
        nextSource = this.otherSources[this.sourceIndex++];
      }
      this.iterator = streamSourceHelpers2.fromStreamSource(nextSource)[Symbol.iterator]();
    }
    return value;
  }
};
var FilterIterator = class extends FastIteratorBase {
  constructor(source, pred, invert) {
    super();
    this.source = source;
    this.pred = pred;
    this.invert = invert;
    this.state = (0, import_common2.TraverseState)();
  }
  fastNext(otherwise) {
    const state = this.state;
    if (state.halted)
      return (0, import_common2.OptLazy)(otherwise);
    const done = Symbol("Done");
    let value;
    const source = this.source;
    const pred = this.pred;
    const halt = state.halt;
    if (this.invert) {
      while (!state.halted && done !== (value = source.fastNext(done))) {
        if (!pred(value, state.nextIndex(), halt))
          return value;
      }
    } else {
      while (!state.halted && done !== (value = source.fastNext(done))) {
        if (pred(value, state.nextIndex(), halt))
          return value;
      }
    }
    return (0, import_common2.OptLazy)(otherwise);
  }
};
var FilterPureIterator = class extends FastIteratorBase {
  constructor(source, pred, args, invert) {
    super();
    this.source = source;
    this.pred = pred;
    this.args = args;
    this.invert = invert;
  }
  fastNext(otherwise) {
    const done = Symbol("Done");
    let value;
    const source = this.source;
    const pred = this.pred;
    const args = this.args;
    if (this.invert) {
      while (done !== (value = source.fastNext(done))) {
        if (!pred(value, ...args))
          return value;
      }
    } else {
      while (done !== (value = source.fastNext(done))) {
        if (pred(value, ...args))
          return value;
      }
    }
    return (0, import_common2.OptLazy)(otherwise);
  }
};
var CollectIterator = class extends FastIteratorBase {
  constructor(source, collectFun) {
    super();
    this.source = source;
    this.collectFun = collectFun;
    this.state = (0, import_common2.TraverseState)();
  }
  fastNext(otherwise) {
    const state = this.state;
    if (state.halted)
      return (0, import_common2.OptLazy)(otherwise);
    const { halt } = state;
    const done = Symbol("Done");
    let value;
    const source = this.source;
    const collectFun = this.collectFun;
    while (!state.halted && done !== (value = source.fastNext(done))) {
      const result = collectFun(
        value,
        state.nextIndex(),
        import_common2.CollectFun.Skip,
        halt
      );
      if (import_common2.CollectFun.Skip === result)
        continue;
      return result;
    }
    return (0, import_common2.OptLazy)(otherwise);
  }
};
var IndicesWhereIterator = class extends FastIteratorBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
    this.index = 0;
  }
  fastNext(otherwise) {
    const done = Symbol("Done");
    let value;
    const source = this.source;
    const pred = this.pred;
    while (done !== (value = source.fastNext(done))) {
      if (pred(value))
        return this.index++;
      this.index++;
    }
    return (0, import_common2.OptLazy)(otherwise);
  }
};
var IndicesOfIterator = class extends FastIteratorBase {
  constructor(source, searchValue, eq) {
    super();
    this.source = source;
    this.searchValue = searchValue;
    this.eq = eq;
    this.index = 0;
  }
  fastNext(otherwise) {
    const done = Symbol("Done");
    let value;
    const source = this.source;
    const searchValue = this.searchValue;
    const eq = this.eq;
    while (done !== (value = source.fastNext(done))) {
      if (eq(searchValue, value))
        return this.index++;
      this.index++;
    }
    return (0, import_common2.OptLazy)(otherwise);
  }
};
var TakeWhileIterator = class extends FastIteratorBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
    this.isDone = false;
    this.index = 0;
  }
  fastNext(otherwise) {
    const done = Symbol("Done");
    if (this.isDone)
      return (0, import_common2.OptLazy)(otherwise);
    const next = this.source.fastNext(done);
    if (done === next) {
      this.isDone = true;
      return (0, import_common2.OptLazy)(otherwise);
    }
    if (this.pred(next, this.index++))
      return next;
    this.isDone = true;
    return (0, import_common2.OptLazy)(otherwise);
  }
};
var DropWhileIterator = class extends FastIteratorBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
    this.pass = false;
    this.index = 0;
  }
  fastNext(otherwise) {
    const source = this.source;
    if (this.pass)
      return source.fastNext(otherwise);
    const done = Symbol("Done");
    let value;
    while (done !== (value = source.fastNext(done))) {
      this.pass = !this.pred(value, this.index++);
      if (this.pass)
        return value;
    }
    return (0, import_common2.OptLazy)(otherwise);
  }
};
var TakeIterator = class extends FastIteratorBase {
  constructor(source, amount) {
    super();
    this.source = source;
    this.amount = amount;
    this.i = 0;
  }
  fastNext(otherwise) {
    if (this.i++ >= this.amount)
      return (0, import_common2.OptLazy)(otherwise);
    return this.source.fastNext(otherwise);
  }
};
var DropIterator = class extends FastIteratorBase {
  constructor(source, amount) {
    super();
    this.source = source;
    this.amount = amount;
    this.remain = amount;
  }
  fastNext(otherwise) {
    const source = this.source;
    if (this.remain <= 0)
      return source.fastNext(otherwise);
    const done = Symbol("Done");
    let value;
    while (done !== (value = source.fastNext(done))) {
      if (this.remain-- <= 0)
        return value;
    }
    return (0, import_common2.OptLazy)(otherwise);
  }
};
var RepeatIterator = class extends FastIteratorBase {
  constructor(source, amount) {
    super();
    this.source = source;
    this.amount = amount;
    this.isEmpty = true;
    this.iterator = source[Symbol.iterator]();
    this.remain = amount;
  }
  fastNext(otherwise) {
    const done = Symbol("Done");
    let value = this.iterator.fastNext(done);
    if (done !== value) {
      this.isEmpty = false;
      return value;
    }
    if (this.isEmpty)
      return (0, import_common2.OptLazy)(otherwise);
    if (void 0 !== this.remain) {
      this.remain--;
      if (this.remain <= 0)
        return (0, import_common2.OptLazy)(otherwise);
    }
    this.iterator = this.source[Symbol.iterator]();
    value = this.iterator.fastNext(done);
    if (done === value)
      return (0, import_common2.OptLazy)(otherwise);
    return value;
  }
};
var IntersperseIterator = class extends FastIteratorBase {
  constructor(source, sepStream) {
    super();
    this.source = source;
    this.sepStream = sepStream;
    this.isInitialized = false;
  }
  fastNext(otherwise) {
    const done = Symbol("Done");
    if (void 0 !== this.sepIterator) {
      const sepNext = this.sepIterator.fastNext(done);
      if (done !== sepNext)
        return sepNext;
      this.sepIterator = void 0;
    }
    if (this.isInitialized) {
      const newNextValue2 = this.source.fastNext(done);
      if (done === newNextValue2) {
        this.isInitialized = false;
        return this.nextValue;
      }
      const currentNextValue = this.nextValue;
      this.nextValue = newNextValue2;
      this.sepIterator = this.sepStream[Symbol.iterator]();
      return currentNextValue;
    }
    const nextValue = this.source.fastNext(done);
    if (done === nextValue)
      return (0, import_common2.OptLazy)(otherwise);
    const newNextValue = this.source.fastNext(done);
    if (done === newNextValue)
      return nextValue;
    this.nextValue = newNextValue;
    this.isInitialized = true;
    this.sepIterator = this.sepStream[Symbol.iterator]();
    return nextValue;
  }
};
var SplitWhereIterator = class extends FastIteratorBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
    this.index = 0;
  }
  fastNext(otherwise) {
    const result = [];
    const source = this.source;
    const done = Symbol("Done");
    let value;
    const pred = this.pred;
    const startIndex = this.index;
    while (done !== (value = source.fastNext(done))) {
      if (pred(value, this.index++))
        return result;
      result.push(value);
    }
    if (startIndex === this.index)
      return (0, import_common2.OptLazy)(otherwise);
    return result;
  }
};
var SplitOnIterator = class extends FastIteratorBase {
  constructor(source, sepElem, eq) {
    super();
    this.source = source;
    this.sepElem = sepElem;
    this.eq = eq;
  }
  fastNext(otherwise) {
    const result = [];
    const source = this.source;
    const done = Symbol("Done");
    let value;
    let processed = false;
    const eq = this.eq;
    const sepElem = this.sepElem;
    while (done !== (value = source.fastNext(done))) {
      processed = true;
      if (eq(value, sepElem))
        return result;
      result.push(value);
    }
    if (!processed)
      return (0, import_common2.OptLazy)(otherwise);
    return result;
  }
};
var ReduceIterator = class extends FastIteratorBase {
  constructor(source, reducer) {
    super();
    this.source = source;
    this.reducer = reducer;
    this.halted = false;
    this.index = 0;
    this.halt = () => {
      this.halted = true;
    };
    this.state = (0, import_common2.OptLazy)(reducer.init);
  }
  fastNext(otherwise) {
    if (this.halted)
      return (0, import_common2.OptLazy)(otherwise);
    const done = Symbol("Done");
    const value = this.source.fastNext(done);
    if (done === value)
      return (0, import_common2.OptLazy)(otherwise);
    const reducer = this.reducer;
    this.state = reducer.next(this.state, value, this.index++, this.halt);
    return reducer.stateToResult(this.state);
  }
};
var ReduceAllIterator = class extends FastIteratorBase {
  constructor(source, reducers) {
    super();
    this.source = source;
    this.reducers = reducers;
    this.halted = false;
    this.index = 0;
    this.isDone = false;
    this.state = reducers.map((d) => (0, import_common2.OptLazy)(d.init));
    this.done = this.state.map((_, i) => () => {
      this.done[i] = null;
    });
  }
  fastNext(otherwise) {
    if (this.halted || this.isDone)
      return (0, import_common2.OptLazy)(otherwise);
    const done = Symbol("Done");
    const value = this.source.fastNext(done);
    if (done === value)
      return (0, import_common2.OptLazy)(otherwise);
    const reducers = this.reducers;
    const length = reducers.length;
    let i = -1;
    let anyNotDone = false;
    while (++i < length) {
      const halt = this.done[i];
      if (null !== halt) {
        anyNotDone = true;
        const reducer = reducers[i];
        this.state[i] = reducer.next(this.state[i], value, this.index, halt);
      }
    }
    this.isDone = !anyNotDone;
    if (!anyNotDone)
      return (0, import_common2.OptLazy)(otherwise);
    this.index++;
    return this.state.map(
      (s, i2) => reducers[i2].stateToResult(s)
    );
  }
};
var ArrayIterator = class extends FastIteratorBase {
  constructor(array, startIndex, endIndex) {
    super();
    this.array = array;
    this.startIndex = startIndex;
    this.endIndex = endIndex;
    this.i = startIndex;
  }
  fastNext(otherwise) {
    if (this.i > this.endIndex)
      return (0, import_common2.OptLazy)(otherwise);
    return this.array[this.i++];
  }
};
var ArrayReverseIterator = class extends FastIteratorBase {
  constructor(array, startIndex, endIndex) {
    super();
    this.array = array;
    this.startIndex = startIndex;
    this.i = endIndex;
  }
  fastNext(otherwise) {
    if (this.i < this.startIndex)
      return (0, import_common2.OptLazy)(otherwise);
    return this.array[this.i--];
  }
};
var AlwaysIterator = class extends FastIteratorBase {
  constructor(value) {
    super();
    this.value = value;
  }
  fastNext() {
    return this.value;
  }
};
var MapApplyIterator = class extends FastIteratorBase {
  constructor(source, f, args, streamSourceHelpers2) {
    super();
    this.f = f;
    this.args = args;
    this.iter = streamSourceHelpers2.fromStreamSource(source)[Symbol.iterator]();
  }
  fastNext(otherwise) {
    const done = Symbol();
    const next = this.iter.fastNext(done);
    const args = this.args;
    if (done === next)
      return (0, import_common2.OptLazy)(otherwise);
    return this.f(...next, ...args);
  }
};
var FilterApplyIterator = class extends FastIteratorBase {
  constructor(source, pred, args, invert, streamSourceHelpers2) {
    super();
    this.pred = pred;
    this.args = args;
    this.invert = invert;
    this.iter = streamSourceHelpers2.fromStreamSource(source)[Symbol.iterator]();
  }
  fastNext(otherwise) {
    const done = Symbol();
    let next;
    const pred = this.pred;
    const iter = this.iter;
    const args = this.args;
    if (this.invert) {
      while (done !== (next = iter.fastNext(done))) {
        if (!pred(...next, ...args))
          return next;
      }
    } else {
      while (done !== (next = iter.fastNext(done))) {
        if (pred(...next, ...args))
          return next;
      }
    }
    return (0, import_common2.OptLazy)(otherwise);
  }
};
var RangeUpIterator = class extends FastIteratorBase {
  constructor(start = 0, end, delta) {
    super();
    this.start = start;
    this.end = end;
    this.delta = delta;
    this.state = start;
  }
  fastNext(otherwise) {
    if (void 0 !== this.end) {
      if (this.state > this.end) {
        return (0, import_common2.OptLazy)(otherwise);
      }
    }
    const currentState = this.state;
    this.state += this.delta;
    return currentState;
  }
};
var RangeDownIterator = class extends FastIteratorBase {
  constructor(start = 0, end, delta) {
    super();
    this.start = start;
    this.end = end;
    this.delta = delta;
    this.state = start;
  }
  fastNext(otherwise) {
    if (void 0 !== this.end) {
      if (this.state < this.end) {
        return (0, import_common2.OptLazy)(otherwise);
      }
    }
    const currentState = this.state;
    this.state += this.delta;
    return currentState;
  }
};
var RandomIterator = class extends FastIteratorBase {
  fastNext() {
    return Math.random();
  }
};
var RandomIntIterator = class extends FastIteratorBase {
  constructor(min, max) {
    super();
    this.min = min;
    this.max = max;
    this.width = max - min;
  }
  fastNext() {
    return this.min + Math.round(Math.random() * this.width);
  }
};
var UnfoldIterator = class extends FastIteratorBase {
  constructor(init, getNext) {
    super();
    this.getNext = getNext;
    this.index = 0;
    this.current = init;
  }
  fastNext(otherwise) {
    const current = this.current;
    if (import_base2.Token === current)
      return (0, import_common2.OptLazy)(otherwise);
    if (this.index === 0) {
      this.index++;
      return current;
    }
    const next = this.getNext(current, this.index++, import_base2.Token);
    this.current = next;
    if (import_base2.Token === next)
      return (0, import_common2.OptLazy)(otherwise);
    return next;
  }
};
var ZipWithIterator = class extends FastIteratorBase {
  constructor(iterables, zipFun, streamSourceHelpers2) {
    super();
    this.iterables = iterables;
    this.zipFun = zipFun;
    this.sources = iterables.map(
      (source) => streamSourceHelpers2.fromStreamSource(source)[Symbol.iterator]()
    );
  }
  fastNext(otherwise) {
    const result = [];
    let sourceIndex = -1;
    const sources = this.sources;
    const done = Symbol("Done");
    while (++sourceIndex < sources.length) {
      const value = sources[sourceIndex].fastNext(done);
      if (done === value)
        return (0, import_common2.OptLazy)(otherwise);
      result.push(value);
    }
    return this.zipFun(...result);
  }
};
var ZipAllWithItererator = class extends FastIteratorBase {
  constructor(fillValue, iters, zipFun, streamSourceHelpers2) {
    super();
    this.fillValue = fillValue;
    this.iters = iters;
    this.zipFun = zipFun;
    this.allDone = false;
    this.sources = iters.map(
      (o) => streamSourceHelpers2.fromStreamSource(o)[Symbol.iterator]()
    );
  }
  fastNext(otherwise) {
    if (this.allDone)
      return (0, import_common2.OptLazy)(otherwise);
    const result = [];
    let sourceIndex = -1;
    const sources = this.sources;
    const done = Symbol("Done");
    let anyNotDone = false;
    const fillValue = this.fillValue;
    while (++sourceIndex < sources.length) {
      const value = sources[sourceIndex].fastNext(done);
      if (done === value) {
        result.push((0, import_common2.OptLazy)(fillValue));
      } else {
        anyNotDone = true;
        result.push(value);
      }
    }
    if (!anyNotDone) {
      this.allDone = true;
      return (0, import_common2.OptLazy)(otherwise);
    }
    return this.zipFun(...result);
  }
};
var PrependIterator = class extends FastIteratorBase {
  constructor(source, item) {
    super();
    this.source = source;
    this.item = item;
    this.prependDone = false;
  }
  fastNext(otherwise) {
    if (this.prependDone)
      return this.source.fastNext(otherwise);
    this.prependDone = true;
    return (0, import_common2.OptLazy)(this.item);
  }
};
var AppendIterator = class extends FastIteratorBase {
  constructor(source, item) {
    super();
    this.source = source;
    this.item = item;
    this.appendDone = false;
  }
  fastNext(otherwise) {
    if (this.appendDone)
      return (0, import_common2.OptLazy)(otherwise);
    const done = Symbol("Done");
    const value = this.source.fastNext(done);
    if (done !== value)
      return value;
    this.appendDone = true;
    return (0, import_common2.OptLazy)(this.item);
  }
};
var IndexedIterator = class extends FastIteratorBase {
  constructor(source, startIndex = 0) {
    super();
    this.source = source;
    this.startIndex = startIndex;
    this.index = startIndex;
  }
  fastNext(otherwise) {
    const done = Symbol("Done");
    const value = this.source.fastNext(done);
    if (done === value)
      return (0, import_common2.OptLazy)(otherwise);
    return [this.index++, value];
  }
};
var MapIterator = class extends FastIteratorBase {
  constructor(source, mapFun) {
    super();
    this.source = source;
    this.mapFun = mapFun;
    this.state = (0, import_common2.TraverseState)();
  }
  fastNext(otherwise) {
    const state = this.state;
    if (state.halted)
      return (0, import_common2.OptLazy)(otherwise);
    const done = Symbol("Done");
    const next = this.source.fastNext(done);
    if (done === next)
      return (0, import_common2.OptLazy)(otherwise);
    return this.mapFun(next, state.nextIndex());
  }
};
var MapPureIterator = class extends FastIteratorBase {
  constructor(source, mapFun, args) {
    super();
    this.source = source;
    this.mapFun = mapFun;
    this.args = args;
  }
  fastNext(otherwise) {
    const done = Symbol("Done");
    const next = this.source.fastNext(done);
    if (done === next)
      return (0, import_common2.OptLazy)(otherwise);
    return this.mapFun(next, ...this.args);
  }
};
var DistinctPreviousIterator = class extends FastIteratorBase {
  constructor(source, eq) {
    super();
    this.source = source;
    this.eq = eq;
    this.previous = [];
  }
  fastNext(otherwise) {
    const done = Symbol("Done");
    let next;
    const source = this.source;
    const previous = this.previous;
    while (done !== (next = source.fastNext(done))) {
      previous.push(next);
      if (previous.length === 1) {
        return next;
      }
      const prev = previous.shift();
      if (!this.eq(prev, next)) {
        return next;
      }
    }
    return (0, import_common2.OptLazy)(otherwise);
  }
};
var WindowIterator = class extends FastIteratorBase {
  constructor(source, windowSize, skipAmount, collector) {
    super();
    this.source = source;
    this.windowSize = windowSize;
    this.skipAmount = skipAmount;
    this.collector = collector;
    this.state = /* @__PURE__ */ new Set();
    this.index = 0;
  }
  fastNext(otherwise) {
    const source = this.source;
    const collector = this.collector;
    const windowSize = this.windowSize;
    const skipAmount = this.skipAmount;
    const done = Symbol("Done");
    const state = this.state;
    let next;
    let result = done;
    while (done !== (next = source.fastNext(done))) {
      for (const current of state) {
        current.result = collector.next(
          current.result,
          next,
          current.size,
          current.halt
        );
        current.size++;
        if (current.size >= windowSize || current.halted) {
          result = collector.stateToResult(current.result);
          state.delete(current);
        }
      }
      if (this.index % skipAmount === 0) {
        const newState = {
          result: (0, import_common2.OptLazy)(collector.init),
          size: 1,
          halted: false,
          halt() {
            this.halted = true;
          }
        };
        newState.result = collector.next(
          (0, import_common2.OptLazy)(collector.init),
          next,
          0,
          newState.halt
        );
        state.add(newState);
      }
      this.index++;
      if (done !== result) {
        return result;
      }
    }
    return (0, import_common2.OptLazy)(otherwise);
  }
};

// src/custom/stream-custom.mts
var import_base3 = require("@rimbu/base");
var import_common3 = require("@rimbu/common");
function* yieldObjKeys(obj) {
  for (const key in obj) {
    yield key;
  }
}
function* yieldObjValues(obj) {
  for (const key in obj) {
    yield obj[key];
  }
}
function* yieldObjEntries(obj) {
  for (const key in obj) {
    yield [key, obj[key]];
  }
}
var StreamBase = class {
  stream() {
    return this;
  }
  equals(other, eq = import_common3.Eq.objectIs) {
    const it1 = this[Symbol.iterator]();
    const it2 = fromStreamSource(other)[Symbol.iterator]();
    const done = Symbol("Done");
    while (true) {
      const v1 = it1.fastNext(done);
      const v2 = it2.fastNext(done);
      if (done === v1 || done === v2)
        return Object.is(v1, v2);
      if (!eq(v1, v2))
        return false;
    }
  }
  assumeNonEmpty() {
    return this;
  }
  asNormal() {
    return this;
  }
  prepend(value) {
    return new PrependStream(this, value).assumeNonEmpty();
  }
  append(value) {
    return new AppendStream(this, value).assumeNonEmpty();
  }
  forEach(f, state = (0, import_common3.TraverseState)()) {
    if (state.halted)
      return;
    const done = Symbol("Done");
    let value;
    const iterator = this[Symbol.iterator]();
    const { halt } = state;
    while (!state.halted && done !== (value = iterator.fastNext(done))) {
      f(value, state.nextIndex(), halt);
    }
  }
  forEachPure(f, ...args) {
    const done = Symbol("Done");
    let value;
    const iterator = this[Symbol.iterator]();
    while (done !== (value = iterator.fastNext(done))) {
      f(value, ...args);
    }
  }
  indexed(startIndex = 0) {
    return new IndexedStream(this, startIndex);
  }
  map(mapFun) {
    return new MapStream(this, mapFun);
  }
  mapPure(mapFun, ...args) {
    return new MapPureStream(this, mapFun, args);
  }
  flatMap(flatMapFun) {
    return new FlatMapStream(this, flatMapFun);
  }
  flatZip(flatMapFun) {
    return this.flatMap(
      (value, index, halt) => fromStreamSource(flatMapFun(value, index, halt)).map((result) => [
        value,
        result
      ])
    );
  }
  transform(transformer) {
    return StreamConstructorsImpl.flatten(this.reduceStream(transformer));
  }
  filter(pred) {
    return new FilterStream(this, pred);
  }
  filterNot(pred) {
    return new FilterStream(this, pred, true);
  }
  filterPure(pred, ...args) {
    return new FilterPureStream(this, pred, args);
  }
  filterNotPure(pred, ...args) {
    return new FilterPureStream(this, pred, args, true);
  }
  collect(collectFun) {
    return new CollectStream(this, collectFun);
  }
  first(otherwise) {
    return this[Symbol.iterator]().fastNext(otherwise);
  }
  last(otherwise) {
    const done = Symbol("Done");
    let value;
    let lastValue = done;
    const iterator = this[Symbol.iterator]();
    while (done !== (value = iterator.fastNext(done))) {
      lastValue = value;
    }
    if (done === lastValue)
      return (0, import_common3.OptLazy)(otherwise);
    return lastValue;
  }
  single(otherwise) {
    const iterator = this[Symbol.iterator]();
    const done = Symbol("Done");
    const value = iterator.fastNext(done);
    if (done !== value) {
      if (done === iterator.fastNext(done)) {
        return value;
      }
    }
    return (0, import_common3.OptLazy)(otherwise);
  }
  count() {
    let result = 0;
    const done = Symbol("Done");
    const iterator = this[Symbol.iterator]();
    while (done !== iterator.fastNext(done))
      result++;
    return result;
  }
  countElement(value, eq = import_common3.Eq.objectIs) {
    let result = 0;
    const done = Symbol("Done");
    const iterator = this[Symbol.iterator]();
    let current;
    while (done !== (current = iterator.fastNext(done))) {
      if (eq(value, current))
        result++;
    }
    return result;
  }
  countNotElement(value, eq = import_common3.Eq.objectIs) {
    let result = 0;
    const done = Symbol("Done");
    const iterator = this[Symbol.iterator]();
    let current;
    while (done !== (current = iterator.fastNext(done))) {
      if (!eq(value, current))
        result++;
    }
    return result;
  }
  find(pred, occurrance = 1, otherwise) {
    if (occurrance <= 0)
      return (0, import_common3.OptLazy)(otherwise);
    const done = Symbol("Done");
    const iterator = this[Symbol.iterator]();
    let value;
    let remain = occurrance;
    let index = 0;
    while (done !== (value = iterator.fastNext(done))) {
      if (pred(value, index++) && --remain <= 0)
        return value;
    }
    return (0, import_common3.OptLazy)(otherwise);
  }
  elementAt(index, otherwise) {
    if (index < 0)
      return (0, import_common3.OptLazy)(otherwise);
    const done = Symbol("Done");
    const iterator = this[Symbol.iterator]();
    let value;
    let i = 0;
    while (i <= index && done !== (value = iterator.fastNext(done))) {
      if (i === index)
        return value;
      i++;
    }
    return (0, import_common3.OptLazy)(otherwise);
  }
  indicesWhere(pred) {
    return new IndicesWhereStream(this, pred);
  }
  indicesOf(searchValue, eq = import_common3.Eq.objectIs) {
    return new IndicesOfStream(this, searchValue, eq);
  }
  indexWhere(pred, occurrance = 1) {
    if (occurrance <= 0)
      return void 0;
    const done = Symbol("Done");
    let value;
    const iterator = this[Symbol.iterator]();
    let index = 0;
    let occ = 0;
    while (done !== (value = iterator.fastNext(done))) {
      const i = index++;
      if (pred(value, i)) {
        occ++;
        if (occ >= occurrance)
          return i;
      }
    }
    return void 0;
  }
  indexOf(searchValue, occurrance = 1, eq = import_common3.Eq.objectIs) {
    if (occurrance <= 0)
      return void 0;
    const done = Symbol("Done");
    let value;
    const iterator = this[Symbol.iterator]();
    let index = 0;
    let occ = 0;
    while (done !== (value = iterator.fastNext(done))) {
      const i = index++;
      if (eq(value, searchValue)) {
        occ++;
        if (occ >= occurrance)
          return i;
      }
    }
    return void 0;
  }
  some(pred) {
    return void 0 !== this.indexWhere(pred);
  }
  every(pred) {
    const iterator = this[Symbol.iterator]();
    const done = Symbol("Done");
    let value;
    let index = 0;
    while (done !== (value = iterator.fastNext(done))) {
      if (!pred(value, index++))
        return false;
    }
    return true;
  }
  contains(searchValue, amount = 1, eq) {
    if (amount <= 0)
      return true;
    return void 0 !== this.indexOf(searchValue, amount, eq);
  }
  containsSlice(source, eq = import_common3.Eq.objectIs) {
    const iterator = this[Symbol.iterator]();
    const sourceStream = fromStreamSource(source);
    let sourceIterator = sourceStream[Symbol.iterator]();
    const done = Symbol("Done");
    while (true) {
      const sourceValue = sourceIterator.fastNext(done);
      if (done === sourceValue)
        return true;
      const value = iterator.fastNext(done);
      if (done === value)
        return false;
      if (!eq(sourceValue, value)) {
        sourceIterator = sourceStream[Symbol.iterator]();
      }
    }
  }
  takeWhile(pred) {
    return new TakeWhileStream(this, pred);
  }
  dropWhile(pred) {
    return new DropWhileStream(this, pred);
  }
  take(amount) {
    if (amount <= 0)
      return emptyStream;
    return new TakeStream(this, amount);
  }
  drop(amount) {
    if (amount <= 0)
      return this;
    return new DropStream(this, amount);
  }
  repeat(amount) {
    if (void 0 !== amount && amount <= 1)
      return this;
    return new FromStream(() => new RepeatIterator(this, amount));
  }
  concat(...others) {
    if (others.every(isEmptyStreamSourceInstance)) {
      return this.assumeNonEmpty();
    }
    return new ConcatStream(this, others).assumeNonEmpty();
  }
  min(otherwise) {
    return this.minBy(import_common3.Comp.defaultComp().compare, otherwise);
  }
  minBy(compare, otherwise) {
    const done = Symbol("Done");
    const iterator = this[Symbol.iterator]();
    let result = iterator.fastNext(done);
    if (done === result)
      return (0, import_common3.OptLazy)(otherwise);
    let value;
    while (done !== (value = iterator.fastNext(done))) {
      if (compare(value, result) < 0)
        result = value;
    }
    return result;
  }
  max(otherwise) {
    return this.maxBy(import_common3.Comp.defaultComp().compare, otherwise);
  }
  maxBy(compare, otherwise) {
    const done = Symbol("Done");
    const iterator = this[Symbol.iterator]();
    let result = iterator.fastNext(done);
    if (done === result)
      return (0, import_common3.OptLazy)(otherwise);
    let value;
    while (done !== (value = iterator.fastNext(done))) {
      if (compare(value, result) > 0)
        result = value;
    }
    return result;
  }
  intersperse(sep) {
    if (isEmptyStreamSourceInstance(sep))
      return this;
    const sepStream = fromStreamSource(sep);
    return new IntersperseStream(this, sepStream);
  }
  join({
    sep = "",
    start = "",
    end = "",
    valueToString = String,
    ifEmpty = void 0
  } = {}) {
    const done = Symbol("Done");
    const iterator = this[Symbol.iterator]();
    let value = iterator.fastNext(done);
    if (done === value) {
      if (void 0 !== ifEmpty)
        return ifEmpty;
      return start.concat(end);
    }
    let result = start.concat(valueToString(value));
    while (done !== (value = iterator.fastNext(done))) {
      result = result.concat(sep, valueToString(value));
    }
    return result.concat(end);
  }
  mkGroup({
    sep = emptyStream,
    start = emptyStream,
    end = emptyStream
  } = {}) {
    return fromStreamSource(start).concat(this.intersperse(sep), end);
  }
  splitWhere(pred) {
    return new SplitWhereStream(this, pred);
  }
  splitOn(sepElem, eq = import_common3.Eq.objectIs) {
    return new SplitOnStream(this, sepElem, eq);
  }
  distinctPrevious(eq = import_common3.Eq.objectIs) {
    return new DistinctPreviousStream(this, eq);
  }
  window(windowSize, skipAmount = windowSize, collector = import_common3.Reducer.toArray()) {
    return new WindowStream(this, windowSize, skipAmount, collector);
  }
  fold(init, next) {
    return this.reduce(import_common3.Reducer.createOutput(init, next));
  }
  foldStream(init, next) {
    return this.reduceStream(import_common3.Reducer.createOutput(init, next));
  }
  reduce(reducer) {
    let halted = false;
    function halt() {
      halted = true;
    }
    let index = 0;
    const next = reducer.next;
    let state = (0, import_common3.OptLazy)(reducer.init);
    const done = Symbol("Done");
    let value;
    const iter = this[Symbol.iterator]();
    while (!halted && done !== (value = iter.fastNext(done))) {
      state = next(state, value, index++, halt);
    }
    return reducer.stateToResult(state);
  }
  reduceStream(reducer) {
    return new ReduceStream(this, reducer);
  }
  reduceAll(...reducers) {
    const state = reducers.map((d) => (0, import_common3.OptLazy)(d.init));
    const iteratorsDone = state.map(
      (_, i) => () => {
        iteratorsDone[i] = null;
      }
    );
    const iter = this[Symbol.iterator]();
    const length = reducers.length;
    const done = Symbol("Done");
    let value;
    let index = 0;
    while (done !== (value = iter.fastNext(done))) {
      let i = -1;
      let anyNotDone = false;
      while (++i < length) {
        const halt = iteratorsDone[i];
        if (null !== halt) {
          anyNotDone = true;
          state[i] = reducers[i].next(state[i], value, index, halt);
        }
      }
      if (!anyNotDone)
        break;
      index++;
    }
    return state.map((s, i) => reducers[i].stateToResult(s));
  }
  reduceAllStream(...reducers) {
    return new ReduceAllStream(this, reducers);
  }
  toArray() {
    const iterator = this[Symbol.iterator]();
    const result = [];
    const done = Symbol("Done");
    let value;
    while (done !== (value = iterator.fastNext(done))) {
      result.push(value);
    }
    return result;
  }
  toString() {
    return `Stream(...<potentially empty>)`;
  }
  toJSON() {
    return {
      dataType: "Stream",
      value: this.toArray()
    };
  }
};
var _a;
var FromStream = class extends StreamBase {
  constructor(createIterator) {
    super();
    this[_a] = void 0;
    this[Symbol.iterator] = createIterator;
  }
};
_a = Symbol.iterator;
var PrependStream = class extends StreamBase {
  constructor(source, item) {
    super();
    this.source = source;
    this.item = item;
  }
  [Symbol.iterator]() {
    return new PrependIterator(this.source[Symbol.iterator](), this.item);
  }
  first() {
    return (0, import_common3.OptLazy)(this.item);
  }
  last() {
    return this.source.last(this.item);
  }
  count() {
    return this.source.count() + 1;
  }
  forEach(f, state = (0, import_common3.TraverseState)()) {
    if (state.halted)
      return;
    f((0, import_common3.OptLazy)(this.item), state.nextIndex(), state.halt);
    if (state.halted)
      return;
    this.source.forEach(f, state);
  }
};
var AppendStream = class extends StreamBase {
  constructor(source, item) {
    super();
    this.source = source;
    this.item = item;
  }
  [Symbol.iterator]() {
    return new AppendIterator(this.source[Symbol.iterator](), this.item);
  }
  first() {
    return this.source.first(this.item);
  }
  last() {
    return (0, import_common3.OptLazy)(this.item);
  }
  count() {
    return this.source.count() + 1;
  }
  forEach(f, state = (0, import_common3.TraverseState)()) {
    if (state.halted)
      return;
    this.source.forEach(f, state);
    if (state.halted)
      return;
    f((0, import_common3.OptLazy)(this.item), state.nextIndex(), state.halt);
  }
};
var IndexedStream = class extends StreamBase {
  constructor(source, startIndex) {
    super();
    this.source = source;
    this.startIndex = startIndex;
  }
  [Symbol.iterator]() {
    return new IndexedIterator(
      this.source[Symbol.iterator](),
      this.startIndex
    );
  }
  count() {
    return this.source.count();
  }
};
var MapStream = class _MapStream extends StreamBase {
  constructor(source, mapFun) {
    super();
    this.source = source;
    this.mapFun = mapFun;
  }
  [Symbol.iterator]() {
    return new MapIterator(this.source[Symbol.iterator](), this.mapFun);
  }
  first(otherwise) {
    const done = Symbol("Done");
    const value = this.source.first(done);
    if (done === value)
      return (0, import_common3.OptLazy)(otherwise);
    return this.mapFun(value, 0);
  }
  last(otherwise) {
    const done = Symbol("Done");
    const value = this.source.last(done);
    if (done === value)
      return (0, import_common3.OptLazy)(otherwise);
    return this.mapFun(value, 0);
  }
  count() {
    return this.source.count();
  }
  elementAt(index, otherwise) {
    const done = Symbol("Done");
    const value = this.source.elementAt(index, done);
    if (done === value)
      return (0, import_common3.OptLazy)(otherwise);
    return this.mapFun(value, index);
  }
  map(mapFun) {
    return new _MapStream(
      this.source,
      (value, index) => mapFun(this.mapFun(value, index), index)
    );
  }
};
var MapPureStream = class extends StreamBase {
  constructor(source, mapFun, args) {
    super();
    this.source = source;
    this.mapFun = mapFun;
    this.args = args;
  }
  [Symbol.iterator]() {
    return new MapPureIterator(
      this.source[Symbol.iterator](),
      this.mapFun,
      this.args
    );
  }
  first(otherwise) {
    const done = Symbol("Done");
    const value = this.source.first(done);
    if (done === value)
      return (0, import_common3.OptLazy)(otherwise);
    return this.mapFun(value, ...this.args);
  }
  last(otherwise) {
    const done = Symbol("Done");
    const value = this.source.last(done);
    if (done === value)
      return (0, import_common3.OptLazy)(otherwise);
    return this.mapFun(value, ...this.args);
  }
  count() {
    return this.source.count();
  }
  elementAt(index, otherwise) {
    const done = Symbol("Done");
    const value = this.source.elementAt(index, done);
    if (done === value)
      return (0, import_common3.OptLazy)(otherwise);
    return this.mapFun(value, ...this.args);
  }
};
var FlatMapStream = class extends StreamBase {
  constructor(source, flatmapFun) {
    super();
    this.source = source;
    this.flatmapFun = flatmapFun;
  }
  [Symbol.iterator]() {
    return new FlatMapIterator(
      this.source,
      this.flatmapFun,
      streamSourceHelpers
    );
  }
};
var ConcatStream = class _ConcatStream extends StreamBase {
  constructor(source, otherSources) {
    super();
    this.source = source;
    this.otherSources = otherSources;
  }
  [Symbol.iterator]() {
    return new ConcatIterator(
      this.source,
      this.otherSources,
      streamSourceHelpers
    );
  }
  forEach(f, state = (0, import_common3.TraverseState)()) {
    if (state.halted)
      return;
    this.source.forEach(f, state);
    let sourceIndex = -1;
    const sources = this.otherSources;
    const length = sources.length;
    while (!state.halted && ++sourceIndex < length) {
      const source = sources[sourceIndex];
      if (!isEmptyStreamSourceInstance(source)) {
        fromStreamSource(source).forEach(f, state);
      }
    }
  }
  last(otherwise) {
    const sources = this.otherSources;
    let sourceIndex = sources.length;
    while (--sourceIndex >= 0) {
      const source = sources[sourceIndex];
      if (!isEmptyStreamSourceInstance(source)) {
        const done = Symbol("Done");
        const value = fromStreamSource(source).last(done);
        if (done !== value)
          return value;
      }
    }
    return this.source.last(otherwise);
  }
  count() {
    let result = this.source.count();
    const sources = this.otherSources;
    const length = sources.length;
    let sourceIndex = -1;
    while (++sourceIndex < length) {
      const source = sources[sourceIndex];
      if (!isEmptyStreamSourceInstance(source)) {
        result += fromStreamSource(source).count();
      }
    }
    return result;
  }
  concat(...others2) {
    return new _ConcatStream(
      this.source,
      this.otherSources.concat(others2)
    );
  }
  toArray() {
    let result = this.source.toArray();
    let sourceIndex = -1;
    const sources = this.otherSources;
    const length = sources.length;
    while (++sourceIndex < length) {
      const source = sources[sourceIndex];
      if (!isEmptyStreamSourceInstance(source)) {
        result = result.concat(fromStreamSource(source).toArray());
      }
    }
    return result;
  }
};
var FilterStream = class _FilterStream extends StreamBase {
  constructor(source, pred, invert = false) {
    super();
    this.source = source;
    this.pred = pred;
    this.invert = invert;
  }
  [Symbol.iterator]() {
    return new FilterIterator(
      this.source[Symbol.iterator](),
      this.pred,
      this.invert
    );
  }
  filter(pred) {
    return new _FilterStream(
      this.source,
      (v, i, halt) => this.pred(v, i, halt) && pred(v, i, halt)
    );
  }
};
var FilterPureStream = class extends StreamBase {
  constructor(source, pred, args, invert = false) {
    super();
    this.source = source;
    this.pred = pred;
    this.args = args;
    this.invert = invert;
  }
  [Symbol.iterator]() {
    return new FilterPureIterator(
      this.source[Symbol.iterator](),
      this.pred,
      this.args,
      this.invert
    );
  }
};
var CollectStream = class extends StreamBase {
  constructor(source, collectFun) {
    super();
    this.source = source;
    this.collectFun = collectFun;
  }
  [Symbol.iterator]() {
    return new CollectIterator(
      this.source[Symbol.iterator](),
      this.collectFun
    );
  }
};
var IndicesWhereStream = class extends StreamBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
  }
  [Symbol.iterator]() {
    return new IndicesWhereIterator(
      this.source[Symbol.iterator](),
      this.pred
    );
  }
};
var IndicesOfStream = class extends StreamBase {
  constructor(source, searchValue, eq) {
    super();
    this.source = source;
    this.searchValue = searchValue;
    this.eq = eq;
  }
  [Symbol.iterator]() {
    return new IndicesOfIterator(
      this.source[Symbol.iterator](),
      this.searchValue,
      this.eq
    );
  }
};
var TakeWhileStream = class extends StreamBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
  }
  [Symbol.iterator]() {
    return new TakeWhileIterator(this.source[Symbol.iterator](), this.pred);
  }
};
var DropWhileStream = class extends StreamBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
  }
  [Symbol.iterator]() {
    return new DropWhileIterator(this.source[Symbol.iterator](), this.pred);
  }
};
var TakeStream = class extends StreamBase {
  constructor(source, amount) {
    super();
    this.source = source;
    this.amount = amount;
  }
  [Symbol.iterator]() {
    return new TakeIterator(this.source[Symbol.iterator](), this.amount);
  }
  take(amount) {
    if (amount === this.amount)
      return this;
    return this.source.take(amount);
  }
};
var DropStream = class extends StreamBase {
  constructor(source, amount) {
    super();
    this.source = source;
    this.amount = amount;
  }
  [Symbol.iterator]() {
    return new DropIterator(this.source[Symbol.iterator](), this.amount);
  }
  drop(amount) {
    if (amount <= 0)
      return this;
    return this.source.drop(this.amount + amount);
  }
};
var IntersperseStream = class extends StreamBase {
  constructor(source, sepStream) {
    super();
    this.source = source;
    this.sepStream = sepStream;
  }
  [Symbol.iterator]() {
    return new IntersperseIterator(
      this.source[Symbol.iterator](),
      this.sepStream
    );
  }
};
var SplitWhereStream = class extends StreamBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
  }
  [Symbol.iterator]() {
    return new SplitWhereIterator(this.source[Symbol.iterator](), this.pred);
  }
};
var SplitOnStream = class extends StreamBase {
  constructor(source, sepElem, eq) {
    super();
    this.source = source;
    this.sepElem = sepElem;
    this.eq = eq;
  }
  [Symbol.iterator]() {
    return new SplitOnIterator(
      this.source[Symbol.iterator](),
      this.sepElem,
      this.eq
    );
  }
};
var ReduceStream = class extends StreamBase {
  constructor(source, reducerDef) {
    super();
    this.source = source;
    this.reducerDef = reducerDef;
  }
  [Symbol.iterator]() {
    return new ReduceIterator(
      this.source[Symbol.iterator](),
      this.reducerDef
    );
  }
};
var ReduceAllStream = class extends StreamBase {
  constructor(source, reducers) {
    super();
    this.source = source;
    this.reducers = reducers;
  }
  [Symbol.iterator]() {
    return new ReduceAllIterator(
      this.source[Symbol.iterator](),
      this.reducers
    );
  }
};
var SlowIteratorAdapter = class {
  constructor(source) {
    this.source = source;
  }
  next() {
    return this.source.next();
  }
  fastNext(otherwise) {
    const result = this.source.next();
    if (result.done)
      return (0, import_common3.OptLazy)(otherwise);
    return result.value;
  }
};
var FromIterable = class extends StreamBase {
  constructor(iterable) {
    super();
    this.iterable = iterable;
  }
  [Symbol.iterator]() {
    const iterator = this.iterable[Symbol.iterator]();
    if (isFastIterator(iterator))
      return iterator;
    return new SlowIteratorAdapter(iterator);
  }
};
var EmptyStream = class extends StreamBase {
  [Symbol.iterator]() {
    return emptyFastIterator;
  }
  stream() {
    return this;
  }
  assumeNonEmpty() {
    import_base3.RimbuError.throwEmptyCollectionAssumedNonEmptyError();
  }
  equals(other) {
    const done = Symbol("Done");
    return done === fromStreamSource(other)[Symbol.iterator]().fastNext(done);
  }
  prepend(value) {
    return StreamConstructorsImpl.of((0, import_common3.OptLazy)(value));
  }
  append(value) {
    return StreamConstructorsImpl.of((0, import_common3.OptLazy)(value));
  }
  forEach() {
  }
  forEachPure() {
  }
  indexed() {
    return this;
  }
  map() {
    return this;
  }
  mapPure() {
    return this;
  }
  flatMap() {
    return this;
  }
  flatZip() {
    return this;
  }
  transform(transformer) {
    return StreamConstructorsImpl.from(
      transformer.stateToResult((0, import_common3.OptLazy)(transformer.init))
    );
  }
  filter() {
    return this;
  }
  filterNot() {
    return this;
  }
  filterPure() {
    return this;
  }
  filterNotPure() {
    return this;
  }
  collect() {
    return this;
  }
  first(otherwise) {
    return (0, import_common3.OptLazy)(otherwise);
  }
  last(otherwise) {
    return (0, import_common3.OptLazy)(otherwise);
  }
  single(otherwise) {
    return (0, import_common3.OptLazy)(otherwise);
  }
  count() {
    return 0;
  }
  countElement() {
    return 0;
  }
  countNotElement() {
    return 0;
  }
  find(pred, occurrance, otherwise) {
    return (0, import_common3.OptLazy)(otherwise);
  }
  elementAt(index, otherwise) {
    return (0, import_common3.OptLazy)(otherwise);
  }
  indicesWhere() {
    return this;
  }
  indicesOf() {
    return this;
  }
  indexWhere() {
    return void 0;
  }
  indexOf() {
    return void 0;
  }
  some() {
    return false;
  }
  every() {
    return true;
  }
  contains() {
    return false;
  }
  containsSlice() {
    return false;
  }
  takeWhile() {
    return this;
  }
  dropWhile() {
    return this;
  }
  take() {
    return this;
  }
  drop() {
    return this;
  }
  repeat() {
    return this;
  }
  concat(...others) {
    if (others.every(isEmptyStreamSourceInstance))
      return this;
    const [source1, source2, ...sources] = others;
    if (void 0 === source2)
      return source1;
    return fromStreamSource(source1).concat(source2, ...sources);
  }
  min(otherwise) {
    return (0, import_common3.OptLazy)(otherwise);
  }
  minBy(compare, otherwise) {
    return (0, import_common3.OptLazy)(otherwise);
  }
  max(otherwise) {
    return (0, import_common3.OptLazy)(otherwise);
  }
  maxBy(compare, otherwise) {
    return (0, import_common3.OptLazy)(otherwise);
  }
  intersperse() {
    return this;
  }
  join({ start = "", end = "", ifEmpty = void 0 } = {}) {
    if (void 0 !== ifEmpty)
      return ifEmpty;
    return start.concat(end);
  }
  mkGroup({
    start = emptyStream,
    end = emptyStream
  } = {}) {
    return fromStreamSource(start).concat(end);
  }
  splitOn() {
    return this;
  }
  splitWhere() {
    return this;
  }
  distinctPrevious() {
    return this;
  }
  window() {
    return this;
  }
  fold(init) {
    return (0, import_common3.OptLazy)(init);
  }
  foldStream() {
    return this;
  }
  reduce(reducer) {
    return reducer.stateToResult((0, import_common3.OptLazy)(reducer.init));
  }
  reduceStream() {
    return this;
  }
  reduceAll(...reducers) {
    return reducers.map((p) => p.stateToResult((0, import_common3.OptLazy)(p.init)));
  }
  reduceAllStream() {
    return this;
  }
  toArray() {
    return [];
  }
  toString() {
    return `Stream(<empty>)`;
  }
  toJSON() {
    return {
      dataType: "Stream",
      value: []
    };
  }
};
var ArrayStream = class _ArrayStream extends StreamBase {
  constructor(array, startIndex = 0, endIndex = array.length - 1, reversed = false) {
    super();
    this.array = array;
    this.startIndex = startIndex;
    this.endIndex = endIndex;
    this.reversed = reversed;
    this.length = endIndex - startIndex + 1;
  }
  [Symbol.iterator]() {
    if (!this.reversed) {
      return new ArrayIterator(this.array, this.startIndex, this.endIndex);
    }
    return new ArrayReverseIterator(this.array, this.startIndex, this.endIndex);
  }
  forEach(f, state = (0, import_common3.TraverseState)()) {
    const startIndex = this.startIndex;
    const endIndex = this.endIndex;
    const array = this.array;
    const { halt } = state;
    if (!this.reversed) {
      let i = this.startIndex - 1;
      while (!state.halted && ++i <= endIndex) {
        f(array[i], state.nextIndex(), halt);
      }
    } else {
      let i = endIndex + 1;
      while (!state.halted && --i >= startIndex) {
        f(array[i], state.nextIndex(), halt);
      }
    }
  }
  first(otherwise) {
    if (this.length <= 0)
      return (0, import_common3.OptLazy)(otherwise);
    if (!this.reversed)
      return this.array[this.startIndex];
    return this.array[this.endIndex];
  }
  last(otherwise) {
    if (this.length <= 0)
      return (0, import_common3.OptLazy)(otherwise);
    if (!this.reversed)
      return this.array[this.endIndex];
    return this.array[this.startIndex];
  }
  count() {
    return this.endIndex - this.startIndex + 1;
  }
  find(pred, occurrance = 1, otherwise) {
    const startIndex = this.startIndex;
    const endIndex = this.endIndex;
    const array = this.array;
    let remain = occurrance;
    let index = 0;
    if (!this.reversed) {
      let i = startIndex - 1;
      while (++i <= endIndex) {
        const value = array[i];
        if (pred(value, index++) && --remain <= 0)
          return value;
      }
    } else {
      let i = endIndex + 1;
      while (--i >= startIndex) {
        const value = array[i];
        if (pred(value, index++) && --remain <= 0)
          return value;
      }
    }
    return (0, import_common3.OptLazy)(otherwise);
  }
  elementAt(index, otherwise) {
    if (index < 0 || index >= this.length)
      return (0, import_common3.OptLazy)(otherwise);
    if (!this.reversed)
      return this.array[index + this.startIndex];
    return this.array[this.endIndex - index];
  }
  some(pred) {
    const startIndex = this.startIndex;
    const endIndex = this.endIndex;
    const array = this.array;
    let index = 0;
    if (!this.reversed) {
      let i = this.startIndex - 1;
      while (++i <= endIndex) {
        const value = array[i];
        if (pred(value, index++))
          return true;
      }
    } else {
      let i = this.endIndex + 1;
      while (--i >= startIndex) {
        const value = array[i];
        if (pred(value, index++))
          return true;
      }
    }
    return false;
  }
  every(pred) {
    const startIndex = this.startIndex;
    const endIndex = this.endIndex;
    const array = this.array;
    let index = 0;
    if (!this.reversed) {
      let i = startIndex - 1;
      while (++i <= endIndex) {
        const value = array[i];
        if (!pred(value, index++))
          return false;
      }
    } else {
      let i = endIndex + 1;
      while (--i >= startIndex) {
        const value = array[i];
        if (!pred(value, index++))
          return false;
      }
    }
    return true;
  }
  indexOf(searchValue, occurrance = 1, eq = Object.is) {
    if (occurrance <= 0)
      return void 0;
    let remain = occurrance;
    const startIndex = this.startIndex;
    const endIndex = this.endIndex;
    const array = this.array;
    if (!this.reversed) {
      let i = startIndex - 1;
      while (++i <= endIndex) {
        if (eq(array[i], searchValue) && --remain <= 0)
          return i - startIndex;
      }
    } else {
      let i = endIndex + 1;
      while (--i >= startIndex) {
        if (eq(array[i], searchValue) && --remain <= 0)
          return endIndex - i;
      }
    }
    return void 0;
  }
  contains(searchValue, amount = 1, eq = Object.is) {
    if (amount <= 0)
      return true;
    return void 0 !== this.indexOf(searchValue, amount, eq);
  }
  take(amount) {
    if (amount <= 0)
      return emptyStream;
    if (amount >= this.length)
      return this;
    if (!this.reversed) {
      return new _ArrayStream(
        this.array,
        this.startIndex,
        this.startIndex + amount - 1,
        this.reversed
      );
    }
    return new _ArrayStream(
      this.array,
      this.endIndex - (amount - 1),
      this.endIndex,
      this.reversed
    );
  }
  drop(amount) {
    if (amount <= 0)
      return this;
    if (amount >= this.length)
      return emptyStream;
    if (!this.reversed) {
      return new _ArrayStream(
        this.array,
        this.startIndex + amount,
        this.endIndex,
        this.reversed
      );
    }
    return new _ArrayStream(
      this.array,
      this.startIndex,
      this.endIndex - amount,
      this.reversed
    );
  }
  toArray() {
    const array = this.array;
    if (typeof array === "string") {
      return super.toArray();
    }
    if (this.reversed)
      return super.toArray();
    return array.slice(this.startIndex, this.endIndex + 1);
  }
};
var AlwaysStream = class extends StreamBase {
  constructor(value) {
    super();
    this.value = value;
  }
  [Symbol.iterator]() {
    return new AlwaysIterator(this.value);
  }
  first() {
    return this.value;
  }
  append() {
    return this;
  }
  forEach(f, state) {
    const s = state ?? (0, import_common3.TraverseState)();
    const value = this.value;
    while (!s.halted) {
      f(value, s.nextIndex(), s.halt);
    }
  }
  last() {
    return this.value;
  }
  elementAt() {
    return this.value;
  }
  repeat() {
    return this;
  }
  concat() {
    return this.assumeNonEmpty();
  }
  min() {
    return this.value;
  }
  minBy() {
    return this.value;
  }
  max() {
    return this.value;
  }
  maxBy() {
    return this.value;
  }
};
var MapApplyStream = class extends StreamBase {
  constructor(source, f, args) {
    super();
    this.source = source;
    this.f = f;
    this.args = args;
  }
  [Symbol.iterator]() {
    return new MapApplyIterator(
      this.source,
      this.f,
      this.args,
      streamSourceHelpers
    );
  }
};
var FilterApplyStream = class extends StreamBase {
  constructor(source, pred, args, invert = false) {
    super();
    this.source = source;
    this.pred = pred;
    this.args = args;
    this.invert = invert;
  }
  [Symbol.iterator]() {
    return new FilterApplyIterator(
      this.source,
      this.pred,
      this.args,
      this.invert,
      streamSourceHelpers
    );
  }
};
var RangeStream = class extends StreamBase {
  constructor(start, end, delta = 1) {
    super();
    this.start = start;
    this.end = end;
    this.delta = delta;
  }
  [Symbol.iterator]() {
    if (this.delta >= 0) {
      return new RangeUpIterator(this.start, this.end, this.delta);
    }
    return new RangeDownIterator(this.start, this.end, this.delta);
  }
};
var DistinctPreviousStream = class extends StreamBase {
  constructor(source, eq) {
    super();
    this.source = source;
    this.eq = eq;
  }
  [Symbol.iterator]() {
    return new DistinctPreviousIterator(
      this.source[Symbol.iterator](),
      this.eq
    );
  }
};
var WindowStream = class extends StreamBase {
  constructor(source, windowSize, skipAmount, collector) {
    super();
    this.source = source;
    this.windowSize = windowSize;
    this.skipAmount = skipAmount;
    this.collector = collector;
  }
  [Symbol.iterator]() {
    return new WindowIterator(
      this.source[Symbol.iterator](),
      this.windowSize,
      this.skipAmount,
      this.collector
    );
  }
};
var emptyStream = Object.freeze(new EmptyStream());
function isStream(obj) {
  return obj instanceof StreamBase;
}
var fromStreamSource = (source) => {
  if (void 0 === source || isEmptyStreamSourceInstance(source))
    return emptyStream;
  if (isStream(source))
    return source;
  if (typeof source === "object" && `stream` in source)
    return source.stream();
  if (Array.isArray(source)) {
    if (source.length <= 0)
      return emptyStream;
    return new ArrayStream(source);
  }
  return new FromIterable(source);
};
function isEmptyStreamSourceInstance(source) {
  if (source === "")
    return true;
  if (typeof source === "object") {
    if (source === emptyStream)
      return true;
    if (`length` in source && source.length === 0)
      return true;
    if (`size` in source && source.size === 0)
      return true;
    if (`isEmpty` in source && source.isEmpty === true)
      return true;
  }
  return false;
}
var streamSourceHelpers = {
  fromStreamSource,
  isEmptyStreamSourceInstance
};
var StreamConstructorsImpl = Object.freeze({
  empty() {
    return emptyStream;
  },
  of(...values) {
    return fromStreamSource(values);
  },
  from(...sources) {
    const [first, ...rest] = sources;
    if (rest.length <= 0) {
      return fromStreamSource(first);
    }
    const [rest1, ...restOther] = rest;
    return fromStreamSource(first).concat(rest1, ...restOther);
  },
  fromArray(array, range, reversed = false) {
    if (array.length === 0)
      return emptyStream;
    if (void 0 === range) {
      return new ArrayStream(array, void 0, void 0, reversed);
    }
    const result = import_common3.IndexRange.getIndicesFor(range, array.length);
    if (result === "empty") {
      return emptyStream;
    }
    if (result === "all") {
      return new ArrayStream(array, void 0, void 0, reversed);
    }
    return new ArrayStream(array, result[0], result[1], reversed);
  },
  fromObjectKeys(obj) {
    return StreamConstructorsImpl.from(yieldObjKeys(obj));
  },
  fromObjectValues(obj) {
    return StreamConstructorsImpl.from(yieldObjValues(obj));
  },
  fromObject(obj) {
    return StreamConstructorsImpl.from(yieldObjEntries(obj));
  },
  fromString(source, range, reversed = false) {
    return StreamConstructorsImpl.fromArray(
      source,
      range,
      reversed
    );
  },
  always(value) {
    return new AlwaysStream(value);
  },
  applyForEach(source, f, ...args) {
    const iter = StreamConstructorsImpl.from(source)[Symbol.iterator]();
    const done = Symbol();
    let values;
    while (done !== (values = iter.fastNext(done))) {
      f(...values, ...args);
    }
  },
  applyMap(source, mapFun, ...args) {
    return new MapApplyStream(source, mapFun, args);
  },
  applyFilter(source, pred, ...args) {
    return new FilterApplyStream(source, pred, args);
  },
  range(range, delta = 1) {
    if (void 0 !== range.amount) {
      if (range.amount <= 0)
        return emptyStream;
      let startIndex2 = 0;
      if (void 0 !== range.start) {
        if (Array.isArray(range.start)) {
          startIndex2 = range.start[0];
          if (!range.start[1])
            startIndex2++;
        } else
          startIndex2 = range.start;
      }
      const endIndex2 = startIndex2 + range.amount - 1;
      return new RangeStream(startIndex2, endIndex2, delta);
    }
    const { start, end } = import_common3.Range.getNormalizedRange(range);
    let startIndex = 0;
    let endIndex = void 0;
    if (void 0 !== start) {
      startIndex = start[0];
      if (!start[1])
        startIndex++;
    }
    if (void 0 !== end) {
      endIndex = end[0];
      if (!end[1])
        endIndex--;
    }
    if (void 0 !== endIndex) {
      if (delta > 0 && endIndex < startIndex)
        return emptyStream;
      else if (delta < 0 && startIndex <= endIndex)
        return emptyStream;
    }
    return new RangeStream(startIndex, endIndex, delta);
  },
  random() {
    return new FromStream(
      () => new RandomIterator()
    );
  },
  randomInt(min, max) {
    if (min >= max)
      import_common3.ErrBase.msg("min should be smaller than max");
    return new FromStream(
      () => new RandomIntIterator(min, max)
    );
  },
  unfold(init, next) {
    return new FromStream(
      () => new UnfoldIterator(init, next)
    );
  },
  zipWith(...sources) {
    return (zipFun) => {
      if (sources.some(isEmptyStreamSourceInstance)) {
        return emptyStream;
      }
      return new FromStream(
        () => new ZipWithIterator(sources, zipFun, streamSourceHelpers)
      );
    };
  },
  zip(...sources) {
    return StreamConstructorsImpl.zipWith(...sources)(Array);
  },
  zipAllWith(...sources) {
    return (fillValue, zipFun) => {
      if (sources.every(isEmptyStreamSourceInstance)) {
        return emptyStream;
      }
      return new FromStream(
        () => new ZipAllWithItererator(
          fillValue,
          sources,
          zipFun,
          streamSourceHelpers
        )
      );
    };
  },
  zipAll(fillValue, ...sources) {
    return StreamConstructorsImpl.zipAllWith(...sources)(
      fillValue,
      Array
    );
  },
  flatten(source) {
    return fromStreamSource(source).flatMap((s) => s);
  },
  unzip(source, length) {
    if (isEmptyStreamSourceInstance(source)) {
      return StreamConstructorsImpl.of(emptyStream).repeat(length).toArray();
    }
    const result = [];
    let i = -1;
    while (++i < length) {
      const index = i;
      result[i] = source.map((t) => t[index]);
    }
    return result;
  }
});

// src/main/interface.mts
var Stream = StreamConstructorsImpl;

// src/main/transformer.mts
var import_common4 = require("@rimbu/common");
var Transformer;
((Transformer2) => {
  Transformer2.window = (windowSize, skipAmount = windowSize, collector = import_common4.Reducer.toArray()) => {
    return import_common4.Reducer.create(
      () => /* @__PURE__ */ new Set(),
      (state, elem, index) => {
        for (const current of state) {
          if (current.size >= windowSize || current.halted) {
            state.delete(current);
          }
          current.result = collector.next(
            current.result,
            elem,
            current.size,
            current.halt
          );
          current.size++;
        }
        if (index % skipAmount === 0) {
          const newState = {
            result: (0, import_common4.OptLazy)(collector.init),
            size: 1,
            halted: false,
            halt() {
              this.halted = true;
            }
          };
          newState.result = collector.next(
            (0, import_common4.OptLazy)(collector.init),
            elem,
            0,
            newState.halt
          );
          state.add(newState);
        }
        return state;
      },
      (current) => {
        return Stream.from(current).collect(
          (v, _, skip) => v.size === windowSize ? Stream.of(collector.stateToResult(v.result)) : skip
        ).first(Stream.empty());
      }
    );
  };
  function distinctPrevious(eq = import_common4.Eq.objectIs) {
    return import_common4.Reducer.create(
      () => [],
      (current, elem) => {
        current.push(elem);
        if (current.length > 2) {
          current.shift();
        }
        return current;
      },
      (state) => {
        if (state.length > 0) {
          if (state.length === 1) {
            return Stream.of(state[0]);
          }
          if (!eq(state[0], state[1])) {
            return Stream.of(state[1]);
          }
        }
        return Stream.empty();
      }
    );
  }
  Transformer2.distinctPrevious = distinctPrevious;
})(Transformer || (Transformer = {}));

// src/async-custom/async-stream-custom.mts
var AsyncStreamBase = class {
  asyncStream() {
    return this;
  }
  async equals(other, eq = import_common5.Eq.objectIs) {
    const it1 = this[Symbol.asyncIterator]();
    const it2 = fromAsyncStreamSource(other)[Symbol.asyncIterator]();
    const done = Symbol("Done");
    while (true) {
      const [v1, v2] = await Promise.all([
        it1.fastNext(done),
        it2.fastNext(done)
      ]);
      if (done === v1) {
        if (done === v2)
          return true;
        await closeIters(it2);
        return false;
      }
      if (done === v2) {
        await closeIters(it1);
        return false;
      }
      if (!eq(v1, v2)) {
        await closeIters(it1, it2);
        return false;
      }
    }
  }
  assumeNonEmpty() {
    return this;
  }
  asNormal() {
    return this;
  }
  prepend(value) {
    return new AsyncPrependStream(this, value).assumeNonEmpty();
  }
  append(value) {
    return new AsyncAppendStream(this, value).assumeNonEmpty();
  }
  async forEach(f, state = (0, import_common5.TraverseState)()) {
    if (state.halted)
      return;
    const done = Symbol("Done");
    let value;
    const iterator = this[Symbol.asyncIterator]();
    const { halt } = state;
    try {
      while (!state.halted && done !== (value = await iterator.fastNext(done))) {
        await f(value, state.nextIndex(), halt);
      }
    } finally {
      if (done !== value)
        await closeIters(iterator);
    }
  }
  async forEachPure(f, ...args) {
    const done = Symbol("Done");
    let value;
    const iterator = this[Symbol.asyncIterator]();
    try {
      while (done !== (value = await iterator.fastNext(done))) {
        await f(value, ...args);
      }
    } catch (e) {
      await closeIters(iterator);
      throw e;
    }
  }
  indexed(startIndex = 0) {
    return new AsyncIndexedStream(this, startIndex);
  }
  map(mapFun) {
    return new AsyncMapStream(this, mapFun);
  }
  mapPure(mapFun, ...args) {
    return new AsyncMapPureStream(this, mapFun, args);
  }
  flatMap(flatMapFun) {
    return new AsyncFlatMapStream(this, flatMapFun);
  }
  flatZip(flatMapFun) {
    return this.flatMap(
      (value, index, halt) => fromAsyncStreamSource(flatMapFun(value, index, halt)).map((result) => [
        value,
        result
      ])
    );
  }
  transform(transformer) {
    return AsyncStreamConstructorsImpl.flatten(this.reduceStream(transformer));
  }
  filter(pred) {
    return new AsyncFilterStream(this, pred);
  }
  filterNot(pred) {
    return new AsyncFilterStream(this, pred, true);
  }
  filterPure(pred, ...args) {
    return new AsyncFilterPureStream(this, pred, args);
  }
  filterNotPure(pred, ...args) {
    return new AsyncFilterPureStream(this, pred, args, true);
  }
  collect(collectFun) {
    return new AsyncCollectStream(this, collectFun);
  }
  async first(otherwise) {
    const done = Symbol("done");
    const iter = this[Symbol.asyncIterator]();
    const value = await iter.fastNext(done);
    if (done === value) {
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    }
    await closeIters(iter);
    return value;
  }
  async last(otherwise) {
    const done = Symbol("Done");
    let value;
    let lastValue = done;
    const iterator = this[Symbol.asyncIterator]();
    while (done !== (value = await iterator.fastNext(done))) {
      lastValue = value;
    }
    if (done === lastValue)
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    return lastValue;
  }
  async single(otherwise) {
    const iterator = this[Symbol.asyncIterator]();
    const done = Symbol("Done");
    const value = await iterator.fastNext(done);
    if (done !== value) {
      if (done === await iterator.fastNext(done)) {
        return value;
      }
    }
    await closeIters(iterator);
    return import_common5.AsyncOptLazy.toPromise(otherwise);
  }
  async count() {
    let result = 0;
    const done = Symbol("Done");
    const iterator = this[Symbol.asyncIterator]();
    try {
      while (done !== await iterator.fastNext(done))
        result++;
      return result;
    } catch (e) {
      await closeIters(iterator);
      throw e;
    }
  }
  async countElement(value, eq = import_common5.Eq.objectIs) {
    let result = 0;
    const done = Symbol("Done");
    const iterator = this[Symbol.asyncIterator]();
    let current;
    try {
      while (done !== (current = await iterator.fastNext(done))) {
        if (eq(value, current))
          result++;
      }
      return result;
    } finally {
      if (done !== current)
        await closeIters(iterator);
    }
  }
  async countNotElement(value, eq = import_common5.Eq.objectIs) {
    let result = 0;
    const done = Symbol("Done");
    const iterator = this[Symbol.asyncIterator]();
    let current;
    try {
      while (done !== (current = await iterator.fastNext(done))) {
        if (!eq(value, current))
          result++;
      }
      return result;
    } finally {
      if (done !== current)
        await closeIters(iterator);
    }
  }
  async find(pred, occurrance = 1, otherwise) {
    if (occurrance <= 0)
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    const done = Symbol("Done");
    const iterator = this[Symbol.asyncIterator]();
    let value;
    let remain = occurrance;
    let index = 0;
    try {
      while (done !== (value = await iterator.fastNext(done))) {
        const cond = await pred(value, index++);
        if (cond && --remain <= 0) {
          return value;
        }
      }
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    } finally {
      if (done !== value)
        await closeIters(iterator);
    }
  }
  async elementAt(index, otherwise) {
    if (index < 0)
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    const done = Symbol("Done");
    const iterator = this[Symbol.asyncIterator]();
    let value;
    let i = 0;
    try {
      while (i <= index && done !== (value = await iterator.fastNext(done))) {
        if (i === index) {
          return value;
        }
        i++;
      }
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    } finally {
      if (done !== value)
        await closeIters(iterator);
    }
  }
  indicesWhere(pred) {
    return new AsyncIndicesWhereStream(this, pred);
  }
  indicesOf(searchValue, eq = import_common5.Eq.objectIs) {
    return new AsyncIndicesOfStream(this, searchValue, eq);
  }
  async indexWhere(pred, occurrance = 1) {
    if (occurrance <= 0)
      return void 0;
    const done = Symbol("Done");
    let value;
    const iterator = this[Symbol.asyncIterator]();
    let index = 0;
    let occ = 0;
    try {
      while (done !== (value = await iterator.fastNext(done))) {
        const i = index++;
        const cond = await pred(value, i);
        if (cond) {
          occ++;
          if (occ >= occurrance) {
            return i;
          }
        }
      }
      return void 0;
    } finally {
      if (done !== value)
        await closeIters(iterator);
    }
  }
  async indexOf(searchValue, occurrance = 1, eq = import_common5.Eq.objectIs) {
    if (occurrance <= 0)
      return void 0;
    const done = Symbol("Done");
    let value;
    const iterator = this[Symbol.asyncIterator]();
    let index = 0;
    let occ = 0;
    try {
      while (done !== (value = await iterator.fastNext(done))) {
        const i = index++;
        if (eq(value, searchValue)) {
          occ++;
          if (occ >= occurrance) {
            return i;
          }
        }
      }
      return void 0;
    } finally {
      if (done !== value)
        await closeIters(iterator);
    }
  }
  async some(pred) {
    return void 0 !== await this.indexWhere(pred);
  }
  async every(pred) {
    const iterator = this[Symbol.asyncIterator]();
    const done = Symbol("Done");
    let value;
    let index = 0;
    try {
      while (done !== (value = await iterator.fastNext(done))) {
        const cond = await pred(value, index++);
        if (!cond) {
          return false;
        }
      }
      return true;
    } finally {
      if (done !== value)
        await closeIters(iterator);
    }
  }
  async contains(searchValue, amount = 1, eq) {
    if (amount <= 0)
      return true;
    return void 0 !== await this.indexOf(searchValue, amount, eq);
  }
  async containsSlice(source, eq = import_common5.Eq.objectIs) {
    const iterator = this[Symbol.asyncIterator]();
    const sourceStream = fromAsyncStreamSource(source);
    let sourceIterator = sourceStream[Symbol.asyncIterator]();
    const done = Symbol("Done");
    while (true) {
      const sourceValue = await sourceIterator.fastNext(done);
      if (done === sourceValue) {
        await closeIters(iterator);
        return true;
      }
      const value = await iterator.fastNext(done);
      if (done === value) {
        return false;
      }
      if (!eq(sourceValue, value)) {
        sourceIterator = sourceStream[Symbol.asyncIterator]();
      }
    }
  }
  takeWhile(pred) {
    return new AsyncTakeWhileStream(this, pred);
  }
  dropWhile(pred) {
    return new AsyncDropWhileStream(this, pred);
  }
  take(amount) {
    if (amount <= 0)
      return emptyAsyncStream;
    return new AsyncTakeStream(this, amount);
  }
  drop(amount) {
    if (amount <= 0)
      return this;
    return new AsyncDropStream(this, amount);
  }
  repeat(amount) {
    if (void 0 !== amount && amount <= 1) {
      return this;
    }
    return new AsyncFromStream(
      () => new AsyncRepeatIterator(this, amount)
    );
  }
  concat(...others) {
    if (others.every(isEmptyAsyncStreamSourceInstance))
      return this;
    return new AsyncConcatStream(this, others);
  }
  min(otherwise) {
    return this.minBy(import_common5.Comp.defaultComp().compare, otherwise);
  }
  async minBy(compare, otherwise) {
    const done = Symbol("Done");
    const iterator = this[Symbol.asyncIterator]();
    let result;
    let value;
    try {
      result = await iterator.fastNext(done);
      if (done === result)
        return import_common5.AsyncOptLazy.toPromise(otherwise);
      while (done !== (value = await iterator.fastNext(done))) {
        if (compare(value, result) < 0)
          result = value;
      }
      return result;
    } finally {
      if (done !== result && done !== value)
        await closeIters(iterator);
    }
  }
  max(otherwise) {
    return this.maxBy(import_common5.Comp.defaultComp().compare, otherwise);
  }
  async maxBy(compare, otherwise) {
    const done = Symbol("Done");
    const iterator = this[Symbol.asyncIterator]();
    let result;
    let value;
    try {
      result = await iterator.fastNext(done);
      if (done === result)
        return import_common5.AsyncOptLazy.toPromise(otherwise);
      while (done !== (value = await iterator.fastNext(done))) {
        if (compare(value, result) > 0)
          result = value;
      }
      return result;
    } finally {
      if (done !== result && done !== value)
        await closeIters(iterator);
    }
  }
  intersperse(sep) {
    if (isEmptyAsyncStreamSourceInstance(sep))
      return this;
    const sepStream = fromAsyncStreamSource(sep);
    return new AsyncIntersperseStream(this, sepStream);
  }
  async join({
    sep = "",
    start = "",
    end = "",
    valueToString = String,
    ifEmpty = void 0
  } = {}) {
    const done = Symbol("Done");
    const iterator = this[Symbol.asyncIterator]();
    let value = await iterator.fastNext(done);
    try {
      if (done === value) {
        if (void 0 !== ifEmpty)
          return ifEmpty;
        return start.concat(end);
      }
      let result = start.concat(valueToString(value));
      while (done !== (value = await iterator.fastNext(done))) {
        result = result.concat(sep, valueToString(value));
      }
      return result.concat(end);
    } finally {
      if (done !== value)
        await closeIters(iterator);
    }
  }
  mkGroup({
    sep = emptyAsyncStream,
    start = emptyAsyncStream,
    end = emptyAsyncStream
  } = {}) {
    return fromAsyncStreamSource(start).concat(this.intersperse(sep), end);
  }
  splitWhere(pred) {
    return new AsyncSplitWhereStream(this, pred);
  }
  splitOn(sepElem, eq = import_common5.Eq.objectIs) {
    return new AsyncSplitOnStream(this, sepElem, eq);
  }
  distinctPrevious(eq = import_common5.Eq.objectIs) {
    return new AsyncDistinctPreviousStream(this, eq);
  }
  window(windowSize, skipAmount = windowSize, collector = import_common5.AsyncReducer.toArray()) {
    return new AsyncWindowStream(this, windowSize, skipAmount, collector);
  }
  async fold(init, next) {
    let current = await import_common5.AsyncOptLazy.toMaybePromise(init);
    const state = (0, import_common5.TraverseState)();
    const done = Symbol("done");
    const iterator = this[Symbol.asyncIterator]();
    let value;
    try {
      while (!state.halted && done !== (value = await iterator.fastNext(done))) {
        current = await next(current, value, state.nextIndex(), state.halt);
      }
      return current;
    } finally {
      if (done !== value)
        await closeIters(iterator);
    }
  }
  foldStream(init, next) {
    return new AsyncFromStream(
      () => new AsyncFoldIterator(this[Symbol.asyncIterator](), init, next)
    );
  }
  async reduce(reducer) {
    const traverseState = (0, import_common5.TraverseState)();
    const next = reducer.next;
    let state = await import_common5.AsyncOptLazy.toMaybePromise(reducer.init);
    const done = Symbol("Done");
    let value;
    const iter = this[Symbol.asyncIterator]();
    try {
      while (!traverseState.halted && done !== (value = await iter.fastNext(done))) {
        state = await next(
          state,
          value,
          traverseState.nextIndex(),
          traverseState.halt
        );
      }
    } catch (err) {
      await reducer.onClose?.(state, err);
      throw err;
    } finally {
      if (done !== value)
        await closeIters(iter);
    }
    await reducer.onClose?.(state);
    return reducer.stateToResult(state);
  }
  reduceStream(reducer) {
    return new AsyncReduceStream(this, reducer);
  }
  async reduceAll(...reducers) {
    let state = await Promise.all(
      reducers.map((d) => import_common5.AsyncOptLazy.toMaybePromise(d.init))
    );
    const reducersToClose = new Set(reducers);
    const iter = this[Symbol.asyncIterator]();
    const done = Symbol("Done");
    let value;
    let index = 0;
    let err;
    try {
      while (done !== (value = await iter.fastNext(done))) {
        const v = value;
        state = await Promise.all(
          reducers.map((red, i) => {
            const st = state[i];
            if (!reducersToClose.has(red))
              return st;
            return red.next(st, v, index, async () => {
              reducersToClose.delete(red);
              await red.onClose?.(st);
              return st;
            });
          })
        );
        if (reducersToClose.size === 0) {
          break;
        }
        index++;
      }
      return await Promise.all(
        state.map((s, i) => reducers[i].stateToResult(s))
      );
    } catch (e) {
      err = e;
    } finally {
      if (done !== value)
        await closeIters(iter);
      await Promise.all(
        [...reducersToClose].map((r, i) => r.onClose?.(state[i], err))
      );
    }
    if (err)
      throw err;
  }
  reduceAllStream(...reducers) {
    return new AsyncReduceAllStream(this, reducers);
  }
  async toArray() {
    const iterator = this[Symbol.asyncIterator]();
    const result = [];
    const done = Symbol("Done");
    let value;
    try {
      while (done !== (value = await iterator.fastNext(done))) {
        result.push(value);
      }
      return result;
    } finally {
      if (done !== value)
        await closeIters(iterator);
    }
  }
  toString() {
    return `AsyncStream(...<potentially empty>)`;
  }
  async toJSON() {
    return {
      dataType: "AsyncStream",
      value: await this.toArray()
    };
  }
};
var _a2;
var AsyncFromStream = class extends AsyncStreamBase {
  constructor(createIterator) {
    super();
    this[_a2] = void 0;
    this[Symbol.asyncIterator] = createIterator;
  }
};
_a2 = Symbol.asyncIterator;
var AsyncPrependStream = class extends AsyncStreamBase {
  constructor(source, item) {
    super();
    this.source = source;
    this.item = item;
  }
  [Symbol.asyncIterator]() {
    return new AsyncPrependIterator(
      this.source[Symbol.asyncIterator](),
      this.item
    );
  }
  async first() {
    return import_common5.AsyncOptLazy.toPromise(this.item);
  }
  async last() {
    return this.source.last(this.item);
  }
  async count() {
    return await this.source.count() + 1;
  }
};
var AsyncAppendStream = class extends AsyncStreamBase {
  constructor(source, item) {
    super();
    this.source = source;
    this.item = item;
  }
  [Symbol.asyncIterator]() {
    return new AsyncAppendIterator(
      this.source[Symbol.asyncIterator](),
      this.item
    );
  }
  first() {
    return this.source.first(this.item);
  }
  async last() {
    return import_common5.AsyncOptLazy.toPromise(this.item);
  }
  async count() {
    return await this.source.count() + 1;
  }
};
var AsyncIndexedStream = class extends AsyncStreamBase {
  constructor(source, startIndex) {
    super();
    this.source = source;
    this.startIndex = startIndex;
  }
  [Symbol.asyncIterator]() {
    return new AsyncIndexedIterator(
      this.source[Symbol.asyncIterator](),
      this.startIndex
    );
  }
  count() {
    return this.source.count();
  }
};
var AsyncMapStream = class _AsyncMapStream extends AsyncStreamBase {
  constructor(source, mapFun) {
    super();
    this.source = source;
    this.mapFun = mapFun;
  }
  [Symbol.asyncIterator]() {
    return new AsyncMapIterator(
      this.source[Symbol.asyncIterator](),
      this.mapFun
    );
  }
  async first(otherwise) {
    const done = Symbol("Done");
    const value = await this.source.first(done);
    if (done === value)
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    return this.mapFun(value, 0);
  }
  async last(otherwise) {
    const done = Symbol("Done");
    const value = await this.source.last(done);
    if (done === value)
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    return this.mapFun(value, 0);
  }
  async count() {
    return this.source.count();
  }
  async elementAt(index, otherwise) {
    const done = Symbol("Done");
    const value = await this.source.elementAt(index, done);
    if (done === value)
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    return this.mapFun(value, index);
  }
  map(mapFun) {
    return new _AsyncMapStream(
      this.source,
      async (value, index) => mapFun(await this.mapFun(value, index), index)
    );
  }
};
var AsyncMapPureStream = class extends AsyncStreamBase {
  constructor(source, mapFun, args) {
    super();
    this.source = source;
    this.mapFun = mapFun;
    this.args = args;
  }
  [Symbol.asyncIterator]() {
    return new AsyncMapPureIterator(
      this.source[Symbol.asyncIterator](),
      this.mapFun,
      this.args
    );
  }
  async first(otherwise) {
    const done = Symbol("Done");
    const value = await this.source.first(done);
    if (done === value)
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    return this.mapFun(value, ...this.args);
  }
  async last(otherwise) {
    const done = Symbol("Done");
    const value = await this.source.last(done);
    if (done === value)
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    return this.mapFun(value, ...this.args);
  }
  async count() {
    return this.source.count();
  }
  async elementAt(index, otherwise) {
    const done = Symbol("Done");
    const value = await this.source.elementAt(index, done);
    if (done === value)
      return import_common5.AsyncOptLazy.toPromise(otherwise);
    return this.mapFun(value, ...this.args);
  }
};
var AsyncFlatMapStream = class extends AsyncStreamBase {
  constructor(source, flatmapFun) {
    super();
    this.source = source;
    this.flatmapFun = flatmapFun;
  }
  [Symbol.asyncIterator]() {
    return new AsyncFlatMapIterator(
      this.source,
      this.flatmapFun,
      asyncStreamSourceHelpers
    );
  }
};
var AsyncConcatStream = class extends AsyncStreamBase {
  constructor(source, others) {
    super();
    this.source = source;
    this.others = others;
  }
  [Symbol.asyncIterator]() {
    return new AsyncConcatIterator(
      this.source,
      this.others,
      asyncStreamSourceHelpers
    );
  }
};
var AsyncIntersperseStream = class extends AsyncStreamBase {
  constructor(source, sepStream) {
    super();
    this.source = source;
    this.sepStream = sepStream;
  }
  [Symbol.asyncIterator]() {
    return new AsyncIntersperseIterator(
      this.source[Symbol.asyncIterator](),
      this.sepStream
    );
  }
};
var AsyncFilterStream = class _AsyncFilterStream extends AsyncStreamBase {
  constructor(source, pred, invert = false) {
    super();
    this.source = source;
    this.pred = pred;
    this.invert = invert;
  }
  [Symbol.asyncIterator]() {
    return new AsyncFilterIterator(
      this.source[Symbol.asyncIterator](),
      this.pred,
      this.invert
    );
  }
  filter(pred) {
    return new _AsyncFilterStream(
      this.source,
      async (v, i, halt) => await this.pred(v, i, halt) && await pred(v, i, halt)
    );
  }
};
var AsyncFilterPureStream = class extends AsyncStreamBase {
  constructor(source, pred, args, invert = false) {
    super();
    this.source = source;
    this.pred = pred;
    this.args = args;
    this.invert = invert;
  }
  [Symbol.asyncIterator]() {
    return new AsyncFilterPureIterator(
      this.source[Symbol.asyncIterator](),
      this.pred,
      this.args,
      this.invert
    );
  }
};
var AsyncCollectStream = class extends AsyncStreamBase {
  constructor(source, collectFun) {
    super();
    this.source = source;
    this.collectFun = collectFun;
  }
  [Symbol.asyncIterator]() {
    return new AsyncCollectIterator(
      this.source[Symbol.asyncIterator](),
      this.collectFun
    );
  }
};
var AsyncIndicesWhereStream = class extends AsyncStreamBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
  }
  [Symbol.asyncIterator]() {
    return new AsyncIndicesWhereIterator(
      this.source[Symbol.asyncIterator](),
      this.pred
    );
  }
};
var AsyncIndicesOfStream = class extends AsyncStreamBase {
  constructor(source, searchValue, eq) {
    super();
    this.source = source;
    this.searchValue = searchValue;
    this.eq = eq;
  }
  [Symbol.asyncIterator]() {
    return new AsyncIndicesOfIterator(
      this.source[Symbol.asyncIterator](),
      this.searchValue,
      this.eq
    );
  }
};
var AsyncTakeWhileStream = class extends AsyncStreamBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
  }
  [Symbol.asyncIterator]() {
    return new AsyncTakeWhileIterator(
      this.source[Symbol.asyncIterator](),
      this.pred
    );
  }
};
var AsyncDropWhileStream = class extends AsyncStreamBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
  }
  [Symbol.asyncIterator]() {
    return new AsyncDropWhileIterator(
      this.source[Symbol.asyncIterator](),
      this.pred
    );
  }
};
var AsyncTakeStream = class extends AsyncStreamBase {
  constructor(source, amount) {
    super();
    this.source = source;
    this.amount = amount;
  }
  [Symbol.asyncIterator]() {
    return new AsyncTakeIterator(
      this.source[Symbol.asyncIterator](),
      this.amount
    );
  }
  take(amount) {
    if (amount === this.amount)
      return this;
    return this.source.take(amount);
  }
};
var AsyncDropStream = class extends AsyncStreamBase {
  constructor(source, amount) {
    super();
    this.source = source;
    this.amount = amount;
  }
  [Symbol.asyncIterator]() {
    return new AsyncDropIterator(
      this.source[Symbol.asyncIterator](),
      this.amount
    );
  }
  drop(amount) {
    if (amount <= 0)
      return this;
    return this.source.drop(this.amount + amount);
  }
};
var AsyncSplitWhereStream = class extends AsyncStreamBase {
  constructor(source, pred) {
    super();
    this.source = source;
    this.pred = pred;
  }
  [Symbol.asyncIterator]() {
    return new AsyncSplitWhereIterator(
      this.source[Symbol.asyncIterator](),
      this.pred
    );
  }
};
var AsyncSplitOnStream = class extends AsyncStreamBase {
  constructor(source, sepElem, eq) {
    super();
    this.source = source;
    this.sepElem = sepElem;
    this.eq = eq;
  }
  [Symbol.asyncIterator]() {
    return new AsyncSplitOnIterator(
      this.source[Symbol.asyncIterator](),
      this.sepElem,
      this.eq
    );
  }
};
var AsyncDistinctPreviousStream = class extends AsyncStreamBase {
  constructor(source, eq) {
    super();
    this.source = source;
    this.eq = eq;
  }
  [Symbol.asyncIterator]() {
    return new AsyncDistinctPreviousIterator(
      this.source[Symbol.asyncIterator](),
      this.eq
    );
  }
};
var AsyncWindowStream = class extends AsyncStreamBase {
  constructor(source, windowSize, skipAmount, collector) {
    super();
    this.source = source;
    this.windowSize = windowSize;
    this.skipAmount = skipAmount;
    this.collector = collector;
  }
  [Symbol.asyncIterator]() {
    return new AsyncWindowIterator(
      this.source[Symbol.asyncIterator](),
      this.windowSize,
      this.skipAmount,
      this.collector
    );
  }
};
var AsyncReduceStream = class extends AsyncStreamBase {
  constructor(source, reducerDef) {
    super();
    this.source = source;
    this.reducerDef = reducerDef;
  }
  [Symbol.asyncIterator]() {
    return new AsyncReduceIterator(
      this.source[Symbol.asyncIterator](),
      this.reducerDef
    );
  }
};
var AsyncReduceAllStream = class extends AsyncStreamBase {
  constructor(source, reducers) {
    super();
    this.source = source;
    this.reducers = reducers;
  }
  [Symbol.asyncIterator]() {
    return new AsyncReduceAllIterator(
      this.source[Symbol.asyncIterator](),
      this.reducers
    );
  }
};
var AsyncOfStream = class extends AsyncStreamBase {
  constructor(values) {
    super();
    this.values = values;
  }
  [Symbol.asyncIterator]() {
    return new AsyncOfIterator(this.values);
  }
};
function isAsyncStream(obj) {
  return obj instanceof AsyncStreamBase;
}
var AsyncEmptyStream = class extends AsyncStreamBase {
  [Symbol.asyncIterator]() {
    return emptyAsyncFastIterator;
  }
  asyncStream() {
    return this;
  }
  async equals(other) {
    if (other === this)
      return true;
    const done = Symbol("done");
    return done === fromAsyncStreamSource(other)[Symbol.asyncIterator]().fastNext(done);
  }
  prepend(value) {
    return AsyncStreamConstructorsImpl.of(value);
  }
  append(value) {
    return AsyncStreamConstructorsImpl.of(value);
  }
  assumeNonEmpty() {
    import_base4.RimbuError.throwEmptyCollectionAssumedNonEmptyError();
  }
  async forEach() {
  }
  async forEachPure() {
  }
  indexed() {
    return this;
  }
  map() {
    return this;
  }
  mapPure() {
    return this;
  }
  flatMap() {
    return this;
  }
  flatZip() {
    return this;
  }
  transform(transformer) {
    return AsyncStreamConstructorsImpl.from(
      async () => await transformer.stateToResult(
        await import_common5.AsyncOptLazy.toMaybePromise(transformer.init)
      )
    );
  }
  filter() {
    return this;
  }
  filterNot() {
    return this;
  }
  filterPure() {
    return this;
  }
  filterNotPure() {
    return this;
  }
  collect() {
    return this;
  }
  first(otherwise) {
    return import_common5.AsyncOptLazy.toPromise(otherwise);
  }
  last(otherwise) {
    return import_common5.AsyncOptLazy.toPromise(otherwise);
  }
  single(otherwise) {
    return import_common5.AsyncOptLazy.toPromise(otherwise);
  }
  async count() {
    return 0;
  }
  async countElement() {
    return 0;
  }
  async countNotElement() {
    return 0;
  }
  find(pred, occurrance, otherwise) {
    return import_common5.AsyncOptLazy.toPromise(otherwise);
  }
  elementAt(index, otherwise) {
    return import_common5.AsyncOptLazy.toPromise(otherwise);
  }
  indicesWhere() {
    return this;
  }
  indicesOf() {
    return this;
  }
  async indexWhere() {
    return void 0;
  }
  async indexOf() {
    return void 0;
  }
  async some() {
    return false;
  }
  async every() {
    return true;
  }
  async contains() {
    return false;
  }
  async containsSlice() {
    return false;
  }
  takeWhile() {
    return this;
  }
  dropWhile() {
    return this;
  }
  take() {
    return this;
  }
  drop() {
    return this;
  }
  repeat() {
    return this;
  }
  concat(...others) {
    if (others.every(isEmptyAsyncStreamSourceInstance))
      return this;
    const [source1, source2, ...sources] = others;
    if (void 0 === source2)
      return source1;
    return fromAsyncStreamSource(source1).concat(source2, ...sources);
  }
  min(otherwise) {
    return import_common5.AsyncOptLazy.toPromise(otherwise);
  }
  minBy(compare, otherwise) {
    return import_common5.AsyncOptLazy.toPromise(otherwise);
  }
  max(otherwise) {
    return import_common5.AsyncOptLazy.toPromise(otherwise);
  }
  maxBy(compare, otherwise) {
    return import_common5.AsyncOptLazy.toPromise(otherwise);
  }
  intersperse() {
    return this;
  }
  async join({
    start = "",
    end = "",
    ifEmpty = void 0
  } = {}) {
    if (void 0 !== ifEmpty)
      return ifEmpty;
    return start.concat(end);
  }
  mkGroup({
    start = emptyAsyncStream,
    end = emptyAsyncStream
  } = {}) {
    return fromAsyncStreamSource(start).concat(end);
  }
  splitOn() {
    return this;
  }
  splitWhere() {
    return this;
  }
  distinctPrevious() {
    return this;
  }
  window() {
    return this;
  }
  fold(init) {
    return import_common5.AsyncOptLazy.toPromise(init);
  }
  foldStream() {
    return this;
  }
  async reduce(reducer) {
    return reducer.stateToResult(await import_common5.AsyncOptLazy.toPromise(reducer.init));
  }
  reduceStream() {
    return this;
  }
  reduceAll(...reducers) {
    return Promise.all(
      reducers.map(
        async (p) => p.stateToResult(await import_common5.AsyncOptLazy.toMaybePromise(p.init))
      )
    );
  }
  reduceAllStream() {
    return this;
  }
  async toArray() {
    return [];
  }
  toString() {
    return `AsyncStream(<empty>)`;
  }
  async toJSON() {
    return {
      dataType: "AsyncStream",
      value: []
    };
  }
};
var FromSource = class extends AsyncStreamBase {
  constructor(source, close) {
    super();
    this.source = source;
    this.close = close;
  }
  [Symbol.asyncIterator]() {
    return asyncStreamSourceToIterator(this.source, this.close);
  }
};
var FromResource = class extends AsyncStreamBase {
  constructor(open, createSource, close) {
    super();
    this.open = open;
    this.createSource = createSource;
    this.close = close;
  }
  [Symbol.asyncIterator]() {
    return new FromResourceIterator(
      this.open,
      this.createSource,
      this.close,
      asyncStreamSourceHelpers
    );
  }
};
var emptyAsyncStream = Object.freeze(
  new AsyncEmptyStream()
);
function isEmptyAsyncStreamSourceInstance(source) {
  return source === emptyAsyncStream || isEmptyStreamSourceInstance(source);
}
function asyncStreamSourceToIterator(source, close) {
  if (source instanceof Function) {
    return new FromPromise(source, asyncStreamSourceHelpers, close);
  }
  if (isEmptyAsyncStreamSourceInstance(source)) {
    return emptyAsyncFastIterator;
  }
  if (typeof source === "string") {
    return new FromIterator(source[Symbol.iterator](), close);
  }
  if (typeof source === "object") {
    if (Symbol.asyncIterator in source) {
      const iterator = source[Symbol.asyncIterator]();
      if (isAsyncFastIterator(iterator)) {
        if (void 0 === close) {
          return iterator;
        }
        if (void 0 === iterator.return) {
          iterator.return = close;
          return iterator;
        }
        const oldReturn = iterator.return;
        iterator.return = () => Promise.all([oldReturn, close]);
        return iterator;
      }
      return new FromAsyncIterator(iterator, close);
    }
    if (`asyncStream` in source) {
      return asyncStreamSourceToIterator(source.asyncStream(), close);
    }
    if (Symbol.iterator in source) {
      return new FromIterator(source[Symbol.iterator](), close);
    }
  }
  throw Error("unknown async stream source");
}
var fromAsyncStreamSource = (source) => {
  if (void 0 === source)
    return emptyAsyncStream;
  if (isAsyncStream(source))
    return source;
  if (isEmptyAsyncStreamSourceInstance(source))
    return emptyAsyncStream;
  return new FromSource(source);
};
var asyncStreamSourceHelpers = {
  fromAsyncStreamSource,
  isEmptyAsyncStreamSourceInstance
};
var AsyncStreamConstructorsImpl = Object.freeze({
  of(...values) {
    return new AsyncOfStream(values);
  },
  from(...sources) {
    const [first, ...rest] = sources;
    if (rest.length <= 0) {
      return fromAsyncStreamSource(first);
    }
    const [rest1, ...restOther] = rest;
    return fromAsyncStreamSource(first).concat(rest1, ...restOther);
  },
  fromResource(open, createSource, close) {
    return new FromResource(open, createSource, close);
  },
  live(maxSize = 100) {
    const listenerIterators = /* @__PURE__ */ new Set();
    let closed = false;
    function subscribe(iter) {
      if (closed) {
        iter.close();
        return;
      }
      listenerIterators.add(iter);
    }
    function submit(value) {
      if (closed) {
        return;
      }
      for (const listenerIterator of listenerIterators) {
        listenerIterator.submit(value);
      }
    }
    function close() {
      if (closed) {
        return;
      }
      closed = true;
      for (const listener of listenerIterators) {
        listener.close();
      }
      listenerIterators.clear();
    }
    const stream = new AsyncFromStream(() => {
      if (closed) {
        return emptyAsyncFastIterator;
      }
      const iter = new AsyncLiveIterator(maxSize);
      subscribe(iter);
      return iter;
    });
    return [{ submit, close }, stream];
  },
  zipWith(...sources) {
    return (zipFun) => {
      if (sources.some(isEmptyAsyncStreamSourceInstance)) {
        return emptyAsyncStream;
      }
      return new AsyncFromStream(
        () => new AsyncZipWithIterator(sources, zipFun, asyncStreamSourceHelpers)
      );
    };
  },
  zip(...sources) {
    return AsyncStreamConstructorsImpl.zipWith(...sources)(Array);
  },
  zipAllWith(...sources) {
    return (fillValue, zipFun) => {
      if (sources.every(isEmptyAsyncStreamSourceInstance)) {
        return emptyAsyncStream;
      }
      return new AsyncFromStream(
        () => new AsyncZipAllWithItererator(
          fillValue,
          sources,
          zipFun,
          asyncStreamSourceHelpers
        )
      );
    };
  },
  zipAll(fillValue, ...sources) {
    return AsyncStreamConstructorsImpl.zipAllWith(...sources)(
      fillValue,
      Array
    );
  },
  flatten(source) {
    return AsyncStreamConstructorsImpl.from(source).flatMap((s) => s);
  },
  unzip(source, length) {
    if (isEmptyAsyncStreamSourceInstance(source)) {
      return Stream.of(emptyAsyncStream).repeat(length).toArray();
    }
    const result = [];
    let i = -1;
    while (++i < length) {
      const index = i;
      result[i] = source.map((t) => t[index]);
    }
    return result;
  },
  empty() {
    return emptyAsyncStream;
  },
  always(value) {
    return AsyncStreamConstructorsImpl.of(value).repeat();
  },
  unfold(init, next) {
    return new AsyncFromStream(
      () => new AsyncUnfoldIterator(init, next)
    );
  }
});

// src/async/interface.mts
var AsyncStream = AsyncStreamConstructorsImpl;

// src/async/async-transformer.mts
var import_common6 = require("@rimbu/common");
var AsyncTransformer;
((AsyncTransformer2) => {
  AsyncTransformer2.window = (windowSize, skipAmount = windowSize, collector = import_common6.AsyncReducer.toArray()) => {
    return import_common6.AsyncReducer.create(
      () => /* @__PURE__ */ new Set(),
      async (state, elem, index) => {
        for (const current of state) {
          if (current.size >= windowSize || current.halted) {
            state.delete(current);
          }
          current.result = await collector.next(
            current.result,
            elem,
            current.size,
            current.halt
          );
          current.size++;
        }
        if (index % skipAmount === 0) {
          const newState = {
            result: await import_common6.AsyncOptLazy.toMaybePromise(collector.init),
            size: 1,
            halted: false,
            halt() {
              this.halted = true;
            }
          };
          newState.result = collector.next(
            await import_common6.AsyncOptLazy.toMaybePromise(collector.init),
            elem,
            0,
            newState.halt
          );
          state.add(newState);
        }
        return state;
      },
      (current) => {
        return AsyncStream.from(current).collect(
          (v, _, skip) => v.size === windowSize ? AsyncStream.of(collector.stateToResult(v.result)) : skip
        ).first(AsyncStream.empty());
      }
    );
  };
  function distinctPrevious(eq = import_common6.Eq.objectIs) {
    return import_common6.AsyncReducer.create(
      () => [],
      (current, elem) => {
        current.push(elem);
        if (current.length > 2) {
          current.shift();
        }
        return current;
      },
      (state) => {
        if (state.length > 0) {
          if (state.length === 1) {
            return AsyncStream.of(state[0]);
          }
          if (!eq(state[0], state[1])) {
            return AsyncStream.of(state[1]);
          }
        }
        return AsyncStream.empty();
      }
    );
  }
  AsyncTransformer2.distinctPrevious = distinctPrevious;
})(AsyncTransformer || (AsyncTransformer = {}));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AsyncStream,
  AsyncTransformer
});
