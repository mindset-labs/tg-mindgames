import { Token } from '@rimbu/base';
import { AsyncOptLazy, TraverseState, type ArrayNonEmpty, type AsyncCollectFun, type AsyncReducer, type Eq, type MaybePromise } from '@rimbu/common';
import type { AsyncFastIterator, AsyncStream, AsyncStreamSource } from '@rimbu/stream/async';
import { type AsyncStreamSourceHelpers } from '@rimbu/stream/async-custom';
export declare const fixedDoneAsyncIteratorResult: Readonly<Promise<IteratorResult<any, any>>>;
export declare function isAsyncFastIterator<T>(iterator: AsyncIterator<T>): iterator is AsyncFastIterator<T>;
export declare const emptyAsyncFastIterator: AsyncFastIterator<any>;
export declare abstract class AsyncFastIteratorBase<T> implements AsyncFastIterator<T> {
    abstract fastNext<O>(otherwise?: AsyncOptLazy<O>): MaybePromise<T | O>;
    return?: () => Promise<any>;
    next(): Promise<IteratorResult<T>>;
}
export declare class AsyncOfIterator<T> extends AsyncFastIteratorBase<T> {
    readonly values: ArrayNonEmpty<AsyncOptLazy<T>>;
    constructor(values: ArrayNonEmpty<AsyncOptLazy<T>>);
    index: number;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): MaybePromise<T | O>;
}
export declare class FromResourceIterator<T, R> extends AsyncFastIteratorBase<T> {
    readonly open: () => MaybePromise<R>;
    readonly createSource: (resource: R) => MaybePromise<AsyncStreamSource<T>>;
    readonly close: (resource: R) => MaybePromise<void>;
    readonly asyncStreamSourceHelpers: AsyncStreamSourceHelpers;
    constructor(open: () => MaybePromise<R>, createSource: (resource: R) => MaybePromise<AsyncStreamSource<T>>, close: (resource: R) => MaybePromise<void>, asyncStreamSourceHelpers: AsyncStreamSourceHelpers);
    resource?: R;
    iterator?: AsyncFastIterator<T>;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncUnfoldIterator<T> extends AsyncFastIteratorBase<T> {
    readonly getNext: (current: T, index: number, stop: Token) => MaybePromise<T | Token>;
    constructor(init: T, getNext: (current: T, index: number, stop: Token) => MaybePromise<T | Token>);
    current: T | Token;
    index: number;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncZipWithIterator<I extends readonly unknown[], R> extends AsyncFastIteratorBase<R> {
    readonly iterables: {
        [K in keyof I]: AsyncStreamSource<I[K]>;
    };
    readonly zipFun: (...values: I) => MaybePromise<R>;
    readonly asyncStreamSourceHelpers: AsyncStreamSourceHelpers;
    constructor(iterables: {
        [K in keyof I]: AsyncStreamSource<I[K]>;
    }, zipFun: (...values: I) => MaybePromise<R>, asyncStreamSourceHelpers: AsyncStreamSourceHelpers);
    readonly sources: AsyncFastIterator<any>[];
    readonly sourcesToClose: Set<AsyncFastIterator<any>>;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<R | O>;
}
export declare class AsyncZipAllWithItererator<I extends readonly unknown[], F, R> extends AsyncFastIteratorBase<R> {
    readonly fillValue: AsyncOptLazy<F>;
    readonly iters: {
        [K in keyof I]: AsyncStreamSource<I[K]>;
    };
    readonly zipFun: (...values: {
        [K in keyof I]: I[K] | F;
    }) => MaybePromise<R>;
    readonly asyncStreamSourceHelpers: AsyncStreamSourceHelpers;
    constructor(fillValue: AsyncOptLazy<F>, iters: {
        [K in keyof I]: AsyncStreamSource<I[K]>;
    }, zipFun: (...values: {
        [K in keyof I]: I[K] | F;
    }) => MaybePromise<R>, asyncStreamSourceHelpers: AsyncStreamSourceHelpers);
    readonly sources: AsyncFastIterator<any>[];
    readonly sourcesToClose: Set<AsyncFastIterator<any>>;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<R | O>;
}
export declare class FromAsyncIterator<T> implements AsyncFastIterator<T> {
    readonly source: AsyncIterator<T>;
    constructor(source: AsyncIterator<T>, close?: () => MaybePromise<void>);
    return?: () => MaybePromise<any>;
    next(): Promise<IteratorResult<T>>;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class FromIterator<T> extends AsyncFastIteratorBase<T> {
    readonly iterator: Iterator<T>;
    constructor(iterator: Iterator<T>, close?: () => MaybePromise<void>);
    return?: () => MaybePromise<any>;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class FromPromise<T> extends AsyncFastIteratorBase<T> {
    readonly promise: () => Promise<AsyncStreamSource<T>>;
    readonly asyncStreamSourceHelpers: AsyncStreamSourceHelpers;
    constructor(promise: () => Promise<AsyncStreamSource<T>>, asyncStreamSourceHelpers: AsyncStreamSourceHelpers, close?: () => MaybePromise<void>);
    iterator: AsyncFastIterator<T> | undefined;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncLiveIterator<T> extends AsyncFastIteratorBase<T> {
    readonly maxSize: number;
    constructor(maxSize: number);
    readonly queue: T[];
    waitPromise: Promise<void> | undefined;
    wakeUp: (() => void) | undefined;
    submit: (value: T) => void;
    halted: boolean;
    close: () => void;
    fastNext<O>(otherwise?: AsyncOptLazy<O> | undefined): Promise<T | O>;
}
export declare class AsyncPrependIterator<T> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncFastIterator<T>;
    readonly item: AsyncOptLazy<T>;
    constructor(source: AsyncFastIterator<T>, item: AsyncOptLazy<T>);
    prependDone: boolean;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): MaybePromise<T | O>;
}
export declare class AsyncAppendIterator<T> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncFastIterator<T>;
    readonly item: AsyncOptLazy<T>;
    constructor(source: AsyncFastIterator<T>, item: AsyncOptLazy<T>);
    appendDone: boolean;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncIndexedIterator<T> extends AsyncFastIteratorBase<[
    number,
    T
]> {
    readonly source: AsyncFastIterator<T>;
    readonly startIndex: number;
    index: number;
    constructor(source: AsyncFastIterator<T>, startIndex?: number);
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<[number, T] | O>;
}
export declare class AsyncMapIterator<T, T2> extends AsyncFastIteratorBase<T2> {
    readonly source: AsyncFastIterator<T>;
    readonly mapFun: (value: T, index: number) => MaybePromise<T2>;
    constructor(source: AsyncFastIterator<T>, mapFun: (value: T, index: number) => MaybePromise<T2>);
    readonly state: TraverseState;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T2 | O>;
}
export declare class AsyncMapPureIterator<T, A extends readonly unknown[], T2> extends AsyncFastIteratorBase<T2> {
    readonly source: AsyncFastIterator<T>;
    readonly mapFun: (value: T, ...args: A) => MaybePromise<T2>;
    readonly args: A;
    constructor(source: AsyncFastIterator<T>, mapFun: (value: T, ...args: A) => MaybePromise<T2>, args: A);
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T2 | O>;
}
export declare class AsyncFlatMapIterator<T, T2> extends AsyncFastIteratorBase<T2> {
    readonly source: AsyncStream<T>;
    readonly flatMapFun: (value: T, index: number, halt: () => void) => AsyncStreamSource<T2>;
    readonly asyncStreamSourceHelpers: AsyncStreamSourceHelpers;
    iterator: AsyncFastIterator<T>;
    constructor(source: AsyncStream<T>, flatMapFun: (value: T, index: number, halt: () => void) => AsyncStreamSource<T2>, asyncStreamSourceHelpers: AsyncStreamSourceHelpers);
    readonly state: TraverseState;
    done: boolean;
    currentIterator: null | AsyncFastIterator<T2>;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T2 | O>;
}
export declare class AsyncConcatIterator<T> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncStream<T>;
    readonly otherSources: AsyncStreamSource<T>[];
    readonly asyncStreamSourceHelpers: AsyncStreamSourceHelpers;
    iterator: AsyncFastIterator<T>;
    constructor(source: AsyncStream<T>, otherSources: AsyncStreamSource<T>[], asyncStreamSourceHelpers: AsyncStreamSourceHelpers);
    sourceIndex: number;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncIntersperseIterator<T, S> extends AsyncFastIteratorBase<T | S> {
    readonly source: AsyncFastIterator<T>;
    readonly sepStream: AsyncStream<S>;
    constructor(source: AsyncFastIterator<T>, sepStream: AsyncStream<S>);
    sepIterator: AsyncFastIterator<S> | undefined;
    nextValue: T;
    isInitialized: boolean;
    isDone: boolean;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | S | O>;
}
export declare class AsyncFilterIterator<T> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncFastIterator<T>;
    readonly pred: (value: T, index: number, halt: () => void) => MaybePromise<boolean>;
    readonly invert: boolean;
    constructor(source: AsyncFastIterator<T>, pred: (value: T, index: number, halt: () => void) => MaybePromise<boolean>, invert: boolean);
    readonly state: TraverseState;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncFilterPureIterator<T, A extends readonly unknown[]> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncFastIterator<T>;
    readonly pred: (value: T, ...args: A) => MaybePromise<boolean>;
    readonly args: A;
    readonly invert: boolean;
    constructor(source: AsyncFastIterator<T>, pred: (value: T, ...args: A) => MaybePromise<boolean>, args: A, invert: boolean);
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncCollectIterator<T, R> extends AsyncFastIteratorBase<R> {
    readonly source: AsyncFastIterator<T>;
    readonly collectFun: AsyncCollectFun<T, R>;
    constructor(source: AsyncFastIterator<T>, collectFun: AsyncCollectFun<T, R>);
    readonly state: TraverseState;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<R | O>;
}
export declare class AsyncIndicesWhereIterator<T> extends AsyncFastIteratorBase<number> {
    readonly source: AsyncFastIterator<T>;
    readonly pred: (value: T) => MaybePromise<boolean>;
    constructor(source: AsyncFastIterator<T>, pred: (value: T) => MaybePromise<boolean>);
    index: number;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<number | O>;
}
export declare class AsyncIndicesOfIterator<T> extends AsyncFastIteratorBase<number> {
    readonly source: AsyncFastIterator<T>;
    readonly searchValue: T;
    readonly eq: Eq<T>;
    constructor(source: AsyncFastIterator<T>, searchValue: T, eq: Eq<T>);
    index: number;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<number | O>;
}
export declare class AsyncTakeWhileIterator<T> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncFastIterator<T>;
    readonly pred: (value: T, index: number) => MaybePromise<boolean>;
    constructor(source: AsyncFastIterator<T>, pred: (value: T, index: number) => MaybePromise<boolean>);
    isDone: boolean;
    index: number;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncDropWhileIterator<T> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncFastIterator<T>;
    readonly pred: (value: T, index: number) => MaybePromise<boolean>;
    constructor(source: AsyncFastIterator<T>, pred: (value: T, index: number) => MaybePromise<boolean>);
    pass: boolean;
    index: number;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncTakeIterator<T> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncFastIterator<T>;
    readonly amount: number;
    constructor(source: AsyncFastIterator<T>, amount: number);
    i: number;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncDropIterator<T> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncFastIterator<T>;
    readonly amount: number;
    remain: number;
    constructor(source: AsyncFastIterator<T>, amount: number);
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncRepeatIterator<T> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncStream<T>;
    readonly amount?: number | undefined;
    iterator: AsyncFastIterator<T>;
    remain: number | undefined;
    constructor(source: AsyncStream<T>, amount?: number | undefined);
    isEmpty: boolean;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncSplitWhereIterator<T> extends AsyncFastIteratorBase<T[]> {
    readonly source: AsyncFastIterator<T>;
    readonly pred: (value: T, index: number) => MaybePromise<boolean>;
    constructor(source: AsyncFastIterator<T>, pred: (value: T, index: number) => MaybePromise<boolean>);
    index: number;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T[] | O>;
}
export declare class AsyncFoldIterator<I, R> extends AsyncFastIteratorBase<R> {
    readonly source: AsyncFastIterator<I>;
    readonly init: AsyncOptLazy<R>;
    readonly getNext: (current: R, value: I, index: number, halt: () => void) => MaybePromise<R>;
    constructor(source: AsyncFastIterator<I>, init: AsyncOptLazy<R>, getNext: (current: R, value: I, index: number, halt: () => void) => MaybePromise<R>);
    current?: R;
    isInitialized: boolean;
    state: TraverseState;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<R | O>;
}
export declare class AsyncSplitOnIterator<T> extends AsyncFastIteratorBase<T[]> {
    readonly source: AsyncFastIterator<T>;
    readonly sepElem: T;
    readonly eq: Eq<T>;
    constructor(source: AsyncFastIterator<T>, sepElem: T, eq: Eq<T>);
    isDone: boolean;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T[] | O>;
}
export declare class AsyncReduceIterator<I, R> extends AsyncFastIteratorBase<R> {
    readonly source: AsyncFastIterator<I>;
    readonly reducer: AsyncReducer<I, R>;
    state: unknown;
    constructor(source: AsyncFastIterator<I>, reducer: AsyncReducer<I, R>);
    readonly traverseState: TraverseState;
    isInitialized: boolean;
    isDone: boolean;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<R | O>;
}
export declare class AsyncReduceAllIterator<I, R> extends AsyncFastIteratorBase<R> {
    readonly source: AsyncFastIterator<I>;
    readonly reducers: AsyncReducer<I, any>[];
    state?: unknown[];
    readonly reducersToClose: Set<AsyncReducer<any>>;
    constructor(source: AsyncFastIterator<I>, reducers: AsyncReducer<I, any>[]);
    index: number;
    isDone: boolean;
    err: any;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<R | O>;
}
export declare class AsyncDistinctPreviousIterator<T> extends AsyncFastIteratorBase<T> {
    readonly source: AsyncFastIterator<T>;
    readonly eq: Eq<T>;
    constructor(source: AsyncFastIterator<T>, eq: Eq<T>);
    readonly previous: T[];
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
}
export declare class AsyncWindowIterator<T, R> extends AsyncFastIteratorBase<R> {
    readonly source: AsyncFastIterator<T>;
    readonly windowSize: number;
    readonly skipAmount: number;
    readonly collector: AsyncReducer<T, R>;
    constructor(source: AsyncFastIterator<T>, windowSize: number, skipAmount: number, collector: AsyncReducer<T, R>);
    state: Set<{
        result: unknown;
        size: number;
        halted: boolean;
        halt: () => void;
    }>;
    index: number;
    fastNext<O>(otherwise?: AsyncOptLazy<O>): Promise<R | O>;
}
