import { AsyncOptLazy, AsyncReducer, Eq, TraverseState, type ArrayNonEmpty, type AsyncCollectFun, type MaybePromise, type ToJSON } from '@rimbu/common';
import type { AsyncFastIterator, AsyncStream, AsyncStreamSource } from '@rimbu/stream/async';
import { type AsyncStreamConstructors } from '@rimbu/stream/async-custom';
export declare abstract class AsyncStreamBase<T> implements AsyncStream<T> {
    abstract [Symbol.asyncIterator](): AsyncFastIterator<T>;
    asyncStream(): this;
    equals(other: AsyncStreamSource<T>, eq?: Eq<T>): Promise<boolean>;
    assumeNonEmpty(): AsyncStream.NonEmpty<T>;
    asNormal(): AsyncStream<T>;
    prepend(value: AsyncOptLazy<T>): AsyncStream.NonEmpty<T>;
    append(value: AsyncOptLazy<T>): AsyncStream.NonEmpty<T>;
    forEach(f: (value: T, index: number, halt: () => void) => MaybePromise<void>, state?: TraverseState): Promise<void>;
    forEachPure<A extends readonly unknown[]>(f: (value: T, ...args: A) => MaybePromise<void>, ...args: A): Promise<void>;
    indexed(startIndex?: number): AsyncStream<[number, T]>;
    map<T2>(mapFun: (value: T, index: number) => MaybePromise<T2>): AsyncStream<T2>;
    mapPure<T2, A extends readonly unknown[]>(mapFun: (value: T, ...args: A) => MaybePromise<T2>, ...args: A): AsyncStream<T2>;
    flatMap<T2>(flatMapFun: (value: T, index: number, halt: () => void) => AsyncStreamSource<T2>): AsyncStream<T2>;
    flatZip<T2>(flatMapFun: (value: T, index: number, halt: () => void) => AsyncStreamSource<T2>): AsyncStream<[T, T2]>;
    transform<R>(transformer: AsyncReducer<T, AsyncStreamSource<R>>): AsyncStream<R>;
    filter(pred: (value: T, index: number, halt: () => void) => MaybePromise<boolean>): AsyncStream<T>;
    filterNot(pred: (value: T, index: number, halt: () => void) => MaybePromise<boolean>): AsyncStream<T>;
    filterPure<A extends readonly unknown[]>(pred: (value: T, ...args: A) => MaybePromise<boolean>, ...args: A): AsyncStream<T>;
    filterNotPure<A extends readonly unknown[]>(pred: (value: T, ...args: A) => MaybePromise<boolean>, ...args: A): AsyncStream<T>;
    collect<R>(collectFun: AsyncCollectFun<T, R>): AsyncStream<R>;
    first<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
    last<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
    single<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
    count(): Promise<number>;
    countElement(value: T, eq?: Eq<any>): Promise<number>;
    countNotElement(value: T, eq?: Eq<any>): Promise<number>;
    find<O>(pred: (value: T, index: number) => MaybePromise<boolean>, occurrance?: number, otherwise?: AsyncOptLazy<O>): Promise<T | O>;
    elementAt<O>(index: number, otherwise?: AsyncOptLazy<O>): Promise<T | O>;
    indicesWhere(pred: (value: T) => MaybePromise<boolean>): AsyncStream<number>;
    indicesOf(searchValue: T, eq?: Eq<T>): AsyncStream<number>;
    indexWhere(pred: (value: T, index: number) => MaybePromise<boolean>, occurrance?: number): Promise<number | undefined>;
    indexOf(searchValue: T, occurrance?: number, eq?: Eq<T>): Promise<number | undefined>;
    some(pred: (value: T, index: number) => MaybePromise<boolean>): Promise<boolean>;
    every(pred: (value: T, index: number) => MaybePromise<boolean>): Promise<boolean>;
    contains(searchValue: T, amount?: number, eq?: Eq<T>): Promise<boolean>;
    containsSlice(source: AsyncStreamSource.NonEmpty<T>, eq?: Eq<any>): Promise<boolean>;
    takeWhile(pred: (value: T, index: number) => MaybePromise<boolean>): AsyncStream<T>;
    dropWhile(pred: (value: T, index: number) => MaybePromise<boolean>): AsyncStream<T>;
    take(amount: number): AsyncStream<T>;
    drop(amount: number): AsyncStream<T>;
    repeat(amount?: number): AsyncStream<T>;
    concat(...others: ArrayNonEmpty<AsyncStreamSource<T>>): any;
    min<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
    minBy<O>(compare: (v1: T, v2: T) => number, otherwise?: AsyncOptLazy<O>): Promise<T | O>;
    max<O>(otherwise?: AsyncOptLazy<O>): Promise<T | O>;
    maxBy<O>(compare: (v1: T, v2: T) => number, otherwise?: AsyncOptLazy<O>): Promise<T | O>;
    intersperse(sep: AsyncStreamSource<T>): AsyncStream<T>;
    join({ sep, start, end, valueToString, ifEmpty, }?: {
        sep?: string | undefined;
        start?: string | undefined;
        end?: string | undefined;
        valueToString?: StringConstructor | undefined;
        ifEmpty?: undefined;
    }): Promise<string>;
    mkGroup({ sep, start, end, }?: {
        sep?: AsyncStreamSource<T>;
        start?: AsyncStreamSource<T>;
        end?: AsyncStreamSource<T>;
    }): any;
    splitWhere(pred: (value: T, index: number) => MaybePromise<boolean>): AsyncStream<T[]>;
    splitOn(sepElem: T, eq?: Eq<T>): AsyncStream<T[]>;
    distinctPrevious(eq?: Eq<T>): AsyncStream<T>;
    window<R>(windowSize: number, skipAmount?: number, collector?: AsyncReducer<T, R>): AsyncStream<R>;
    fold<R>(init: AsyncOptLazy<R>, next: (current: R, value: T, index: number, halt: () => void) => MaybePromise<R>): Promise<R>;
    foldStream<R>(init: AsyncOptLazy<R>, next: (current: R, value: T, index: number, halt: () => void) => MaybePromise<R>): AsyncStream<R>;
    reduce<R>(reducer: AsyncReducer<T, R>): Promise<R>;
    reduceStream<R>(reducer: AsyncReducer<T, R>): AsyncStream<R>;
    reduceAll<R extends [unknown, unknown, ...unknown[]]>(...reducers: {
        [K in keyof R]: AsyncReducer<T, R[K]>;
    }): Promise<any>;
    reduceAllStream<R extends [unknown, unknown, ...unknown[]]>(...reducers: {
        [K in keyof R]: AsyncReducer<T, R[K]>;
    }): any;
    toArray(): Promise<T[]>;
    toString(): string;
    toJSON(): Promise<ToJSON<T[], 'AsyncStream'>>;
}
export declare class AsyncFromStream<T> extends AsyncStreamBase<T> {
    [Symbol.asyncIterator]: () => AsyncFastIterator<T>;
    constructor(createIterator: () => AsyncFastIterator<T>);
}
export declare class AsyncOfStream<T> extends AsyncStreamBase<T> {
    readonly values: ArrayNonEmpty<AsyncOptLazy<T>>;
    constructor(values: ArrayNonEmpty<AsyncOptLazy<T>>);
    [Symbol.asyncIterator](): AsyncFastIterator<T>;
}
export declare function isAsyncStream(obj: any): obj is AsyncStream<any>;
export declare class FromSource<T> extends AsyncStreamBase<T> {
    readonly source: AsyncStreamSource<T>;
    readonly close?: (() => MaybePromise<void>) | undefined;
    constructor(source: AsyncStreamSource<T>, close?: (() => MaybePromise<void>) | undefined);
    [Symbol.asyncIterator](): AsyncFastIterator<T>;
}
export declare class FromResource<T, R> extends AsyncStreamBase<T> {
    readonly open: () => MaybePromise<R>;
    readonly createSource: (resource: R) => MaybePromise<AsyncStreamSource<T>>;
    readonly close: (resource: R) => MaybePromise<void>;
    constructor(open: () => MaybePromise<R>, createSource: (resource: R) => MaybePromise<AsyncStreamSource<T>>, close: (resource: R) => MaybePromise<void>);
    [Symbol.asyncIterator](): AsyncFastIterator<T>;
}
export declare const emptyAsyncStream: AsyncStream<any>;
export declare function isEmptyAsyncStreamSourceInstance(source: AsyncStreamSource<any>): boolean;
export declare function asyncStreamSourceToIterator<T>(source: AsyncStreamSource<T>, close?: () => MaybePromise<void>): AsyncFastIterator<T>;
export declare const fromAsyncStreamSource: {
    <T>(source: AsyncStreamSource.NonEmpty<T>): AsyncStream.NonEmpty<T>;
    <T>(source: AsyncStreamSource<T>): AsyncStream<T>;
};
declare const asyncStreamSourceHelpers: {
    fromAsyncStreamSource: {
        <T>(source: AsyncStreamSource.NonEmpty<T>): AsyncStream.NonEmpty<T>;
        <T_1>(source: AsyncStreamSource<T_1>): AsyncStream<T_1>;
    };
    isEmptyAsyncStreamSourceInstance: typeof isEmptyAsyncStreamSourceInstance;
};
export type AsyncStreamSourceHelpers = typeof asyncStreamSourceHelpers;
export declare const AsyncStreamConstructorsImpl: AsyncStreamConstructors;
export {};
