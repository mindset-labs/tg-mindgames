import { Eq, Reducer } from '@rimbu/common';
import { type StreamSource } from '@rimbu/stream';
/**
 * A Reducer that produces instances of `StreamSource`.
 * @typeparam T - the input element type
 * @typeparam R - the result stream element type
 */
export type Transformer<T, R = T> = Reducer<T, StreamSource<R>>;
export declare namespace Transformer {
    /**
     * A Reducer that produces instances of `StreamSource.NonEmpty`.
     * @typeparam T - the input element type
     * @typeparam R - the result stream element type
     */
    type NonEmpty<T, R = T> = Reducer<T, StreamSource.NonEmpty<R>>;
    /**
     * Returns a transformer that produces windows/collections of `windowSize` size, each
     * window starting `skipAmount` of elements after the previous, and optionally collected
     * by a custom reducer.
     * @typeparam T - the input element type
     * @typeparam R - the window type
     * @param windowSize - the amount of elements for each window
     * @param skipAmount - (default: `windowSize`) the amount of elements between the start of each window
     * @param collector - (default: Reducer.toArray()) the reducer to use to convert elements to windows
     * @example
     * ```ts
     * Stream.of(1, 2, 3, 4, 5, 6)
     *   .transform(Transformer.window(3))
     *   .toArray()
     * // => [[1, 2, 3], [4, 5, 6]]
     * ```
     */
    const window: {
        <T>(windowSize: number, skipAmount?: number): Transformer<T, T[]>;
        <T, R>(windowSize: number, skipAmount?: number, collector?: Reducer<T, R>): Transformer<T, R>;
    };
    /**
     * Returns a transformer that returns only those elements from the input that are different to previous element
     * according to the optionally given `eq` function.
     * @param eq - (default: `Eq.objectIs`) the equality testing function
     * @example
     * ```ts
     * Stream.of(1, 1, 2, 3, 2, 2)
     *   .transform(Transformer.distinctPrevious())
     *   .toArray()
     * // => [1, 2, 3, 2]
     * ```
     */
    function distinctPrevious<T>(eq?: Eq<T>): Transformer<T>;
}
