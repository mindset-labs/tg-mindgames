import { Eq, OptLazy, Reducer, TraverseState, type ArrayNonEmpty, type CollectFun, type ToJSON } from '@rimbu/common';
import type { StreamConstructors } from '@rimbu/stream/custom';
import type { FastIterator, Stream, StreamSource, Transformer } from '@rimbu/stream';
export declare abstract class StreamBase<T> implements Stream<T> {
    abstract [Symbol.iterator](): FastIterator<T>;
    stream(): this;
    equals(other: StreamSource<T>, eq?: Eq<T>): boolean;
    assumeNonEmpty(): Stream.NonEmpty<T>;
    asNormal(): Stream<T>;
    prepend(value: OptLazy<T>): Stream.NonEmpty<T>;
    append(value: OptLazy<T>): Stream.NonEmpty<T>;
    forEach(f: (value: T, index: number, halt: () => void) => void, state?: TraverseState): void;
    forEachPure<A extends readonly unknown[]>(f: (value: T, ...args: A) => void, ...args: A): void;
    indexed(startIndex?: number): Stream<[number, T]>;
    map<T2>(mapFun: (value: T, index: number) => T2): Stream<T2>;
    mapPure<T2, A extends readonly unknown[]>(mapFun: (value: T, ...args: A) => T2, ...args: A): Stream<T2>;
    flatMap<T2>(flatMapFun: (value: T, index: number, halt: () => void) => StreamSource<T2>): Stream<T2>;
    flatZip<T2>(flatMapFun: (value: T, index: number, halt: () => void) => StreamSource<T2>): Stream<[T, T2]>;
    transform<R>(transformer: Transformer<T, R>): Stream<R>;
    filter(pred: (value: T, index: number, halt: () => void) => boolean): Stream<T>;
    filterNot(pred: (value: T, index: number, halt: () => void) => boolean): Stream<T>;
    filterPure<A extends readonly unknown[]>(pred: (value: T, ...args: A) => boolean, ...args: A): Stream<T>;
    filterNotPure<A extends readonly unknown[]>(pred: (value: T, ...args: A) => boolean, ...args: A): Stream<T>;
    collect<R>(collectFun: CollectFun<T, R>): Stream<R>;
    first<O>(otherwise?: OptLazy<O>): T | O;
    last<O>(otherwise?: OptLazy<O>): T | O;
    single<O>(otherwise?: OptLazy<O>): T | O;
    count(): number;
    countElement(value: T, eq?: Eq<T>): number;
    countNotElement(value: T, eq?: Eq<T>): number;
    find<O>(pred: (value: T, index: number) => boolean, occurrance?: number, otherwise?: OptLazy<O>): T | O;
    elementAt<O>(index: number, otherwise?: OptLazy<O>): T | O;
    indicesWhere(pred: (value: T) => boolean): Stream<number>;
    indicesOf(searchValue: T, eq?: Eq<T>): Stream<number>;
    indexWhere(pred: (value: T, index: number) => boolean, occurrance?: number): number | undefined;
    indexOf(searchValue: T, occurrance?: number, eq?: Eq<T>): number | undefined;
    some(pred: (value: T, index: number) => boolean): boolean;
    every(pred: (value: T, index: number) => boolean): boolean;
    contains(searchValue: T, amount?: number, eq?: Eq<T>): boolean;
    containsSlice(source: StreamSource.NonEmpty<T>, eq?: Eq<any>): boolean;
    takeWhile(pred: (value: T, index: number) => boolean): Stream<T>;
    dropWhile(pred: (value: T, index: number) => boolean): Stream<T>;
    take(amount: number): Stream<T>;
    drop(amount: number): Stream<T>;
    repeat(amount?: number): Stream<T>;
    concat(...others: ArrayNonEmpty<StreamSource<T>>): Stream.NonEmpty<T>;
    min<O>(otherwise?: OptLazy<O>): T | O;
    minBy<O>(compare: (v1: T, v2: T) => number, otherwise?: OptLazy<O>): T | O;
    max<O>(otherwise?: OptLazy<O>): T | O;
    maxBy<O>(compare: (v1: T, v2: T) => number, otherwise?: OptLazy<O>): T | O;
    intersperse(sep: StreamSource<T>): Stream<T>;
    join({ sep, start, end, valueToString, ifEmpty, }?: {
        sep?: string | undefined;
        start?: string | undefined;
        end?: string | undefined;
        valueToString?: StringConstructor | undefined;
        ifEmpty?: undefined;
    }): string;
    mkGroup({ sep, start, end, }?: {
        sep?: StreamSource<T>;
        start?: StreamSource<T>;
        end?: StreamSource<T>;
    }): any;
    splitWhere(pred: (value: T, index: number) => boolean): Stream<T[]>;
    splitOn(sepElem: T, eq?: Eq<T>): Stream<T[]>;
    distinctPrevious(eq?: Eq<T>): Stream<T>;
    window<R>(windowSize: number, skipAmount?: number, collector?: Reducer<T, R>): Stream<R>;
    fold<R>(init: OptLazy<R>, next: (current: R, value: T, index: number, halt: () => void) => R): R;
    foldStream<R>(init: OptLazy<R>, next: (current: R, value: T, index: number, halt: () => void) => R): Stream<R>;
    reduce<O>(reducer: Reducer<T, O>): O;
    reduceStream<O>(reducer: Reducer<T, O>): Stream<O>;
    reduceAll(...reducers: any): any;
    reduceAllStream(...reducers: any): any;
    toArray(): T[];
    toString(): string;
    toJSON(): ToJSON<T[], 'Stream'>;
}
export declare class FromStream<T> extends StreamBase<T> {
    [Symbol.iterator]: () => FastIterator<T>;
    constructor(createIterator: () => FastIterator<T>);
}
export declare class FromIterable<T> extends StreamBase<T> {
    readonly iterable: Iterable<T>;
    constructor(iterable: Iterable<T>);
    [Symbol.iterator](): FastIterator<T>;
}
export declare class ArrayStream<T> extends StreamBase<T> {
    readonly array: readonly T[];
    readonly startIndex: number;
    readonly endIndex: number;
    readonly reversed: boolean;
    readonly length: number;
    constructor(array: readonly T[], startIndex?: number, endIndex?: number, reversed?: boolean);
    [Symbol.iterator](): FastIterator<T>;
    forEach(f: (value: T, index: number, halt: () => void) => void, state?: TraverseState): void;
    first<O>(otherwise?: OptLazy<O>): T | O;
    last<O>(otherwise?: OptLazy<O>): T | O;
    count(): number;
    find<O>(pred: (value: T, index: number) => boolean, occurrance?: number, otherwise?: OptLazy<O>): T | O;
    elementAt<O>(index: number, otherwise?: OptLazy<O>): T | O;
    some(pred: (value: T, index: number) => boolean): boolean;
    every(pred: (value: T, index: number) => boolean): boolean;
    indexOf(searchValue: T, occurrance?: number, eq?: Eq<T>): number | undefined;
    contains(searchValue: T, amount?: number, eq?: Eq<T>): boolean;
    take(amount: number): Stream<T>;
    drop(amount: number): Stream<T>;
    toArray(): T[];
}
export declare class AlwaysStream<T> extends StreamBase<T> {
    readonly value: T;
    constructor(value: T);
    [Symbol.iterator](): FastIterator<T>;
    first(): T;
    append(): Stream.NonEmpty<T>;
    forEach(f: (value: T, index: number, halt: () => void) => void, state?: TraverseState): void;
    last(): T;
    elementAt(): T;
    repeat(): Stream<T>;
    concat<T2>(): Stream.NonEmpty<T | T2>;
    min(): T;
    minBy(): T;
    max(): T;
    maxBy(): T;
}
export declare class MapApplyStream<T extends readonly unknown[], A extends readonly unknown[], R> extends StreamBase<R> {
    readonly source: StreamSource<T>;
    readonly f: (...args: [...T, ...A]) => R;
    readonly args: A;
    constructor(source: StreamSource<T>, f: (...args: [...T, ...A]) => R, args: A);
    [Symbol.iterator](): FastIterator<R>;
}
export declare class FilterApplyStream<T extends readonly unknown[], A extends readonly unknown[]> extends StreamBase<T> {
    readonly source: StreamSource<T>;
    readonly pred: (...args: [...T, ...A]) => boolean;
    readonly args: A;
    readonly invert: boolean;
    constructor(source: StreamSource<T>, pred: (...args: [...T, ...A]) => boolean, args: A, invert?: boolean);
    [Symbol.iterator](): FastIterator<T>;
}
export declare class RangeStream extends StreamBase<number> {
    readonly start: number;
    readonly end?: number | undefined;
    readonly delta: number;
    constructor(start: number, end?: number | undefined, delta?: number);
    [Symbol.iterator](): FastIterator<number>;
}
export declare class DistinctPreviousStream<T> extends StreamBase<T> {
    readonly source: Stream<T>;
    readonly eq: Eq<T>;
    constructor(source: Stream<T>, eq: Eq<T>);
    [Symbol.iterator](): FastIterator<T>;
}
export declare class WindowStream<T, R> extends StreamBase<R> {
    readonly source: Stream<T>;
    readonly windowSize: number;
    readonly skipAmount: number;
    readonly collector: Reducer<T, R>;
    constructor(source: Stream<T>, windowSize: number, skipAmount: number, collector: Reducer<T, R>);
    [Symbol.iterator](): FastIterator<R>;
}
export declare const emptyStream: Stream<any>;
export declare function isStream(obj: any): obj is Stream<any>;
export declare const fromStreamSource: {
    <T>(source: StreamSource.NonEmpty<T>): Stream.NonEmpty<T>;
    <T>(source: StreamSource<T>): Stream<T>;
};
/**
 * Returns true if the given `source` StreamSource is known to be empty.
 * @param source - a StreamSource
 * @note
 * If this function returns false, it does not guarantee that the Stream is not empty. It only
 * means that it is not known if it is empty.
 */
export declare function isEmptyStreamSourceInstance(source: StreamSource<unknown>): boolean;
declare const streamSourceHelpers: {
    fromStreamSource: {
        <T>(source: StreamSource.NonEmpty<T>): Stream.NonEmpty<T>;
        <T_1>(source: StreamSource<T_1>): Stream<T_1>;
    };
    isEmptyStreamSourceInstance: typeof isEmptyStreamSourceInstance;
};
export type StreamSourceHelpers = typeof streamSourceHelpers;
export declare const StreamConstructorsImpl: StreamConstructors;
export {};
