import { Token } from '@rimbu/base';
import { CollectFun, OptLazy, TraverseState, type Eq, type Reducer } from '@rimbu/common';
import type { StreamSourceHelpers } from '@rimbu/stream/custom';
import type { FastIterator, Stream, StreamSource } from '@rimbu/stream';
export declare const fixedDoneIteratorResult: IteratorResult<any>;
export declare const emptyFastIterator: FastIterator<any>;
export declare function isFastIterator<T>(iterator: Iterator<T>): iterator is FastIterator<T>;
/**
 * A base class for `FastIterator` instances, that takes implements the default `next`
 * function based on the abstract `fastNext` function.
 */
export declare abstract class FastIteratorBase<T> implements FastIterator<T> {
    abstract fastNext<O>(otherwise?: OptLazy<O>): T | O;
    next(): IteratorResult<T>;
}
export declare class FlatMapIterator<T, T2> extends FastIteratorBase<T2> {
    readonly source: Stream<T>;
    readonly flatMapFun: (value: T, index: number, halt: () => void) => StreamSource<T2>;
    readonly streamSourceHelpers: StreamSourceHelpers;
    iterator: FastIterator<T>;
    constructor(source: Stream<T>, flatMapFun: (value: T, index: number, halt: () => void) => StreamSource<T2>, streamSourceHelpers: StreamSourceHelpers);
    readonly state: TraverseState;
    done: boolean;
    currentIterator: null | FastIterator<T2>;
    fastNext<O>(otherwise?: OptLazy<O>): T2 | O;
}
export declare class ConcatIterator<T> extends FastIteratorBase<T> {
    readonly source: Stream<T>;
    readonly otherSources: StreamSource<T>[];
    readonly streamSourceHelpers: StreamSourceHelpers;
    iterator: FastIterator<T>;
    constructor(source: Stream<T>, otherSources: StreamSource<T>[], streamSourceHelpers: StreamSourceHelpers);
    sourceIndex: number;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class FilterIterator<T> extends FastIteratorBase<T> {
    readonly source: FastIterator<T>;
    readonly pred: (value: T, index: number, halt: () => void) => boolean;
    readonly invert: boolean;
    constructor(source: FastIterator<T>, pred: (value: T, index: number, halt: () => void) => boolean, invert: boolean);
    readonly state: TraverseState;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class FilterPureIterator<T, A extends readonly unknown[]> extends FastIteratorBase<T> {
    readonly source: FastIterator<T>;
    readonly pred: (value: T, ...args: A) => boolean;
    readonly args: A;
    readonly invert: boolean;
    constructor(source: FastIterator<T>, pred: (value: T, ...args: A) => boolean, args: A, invert: boolean);
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class CollectIterator<T, R> extends FastIteratorBase<R> {
    readonly source: FastIterator<T>;
    readonly collectFun: CollectFun<T, R>;
    constructor(source: FastIterator<T>, collectFun: CollectFun<T, R>);
    readonly state: TraverseState;
    fastNext<O>(otherwise?: OptLazy<O>): R | O;
}
export declare class IndicesWhereIterator<T> extends FastIteratorBase<number> {
    readonly source: FastIterator<T>;
    readonly pred: (value: T) => boolean;
    constructor(source: FastIterator<T>, pred: (value: T) => boolean);
    index: number;
    fastNext<O>(otherwise?: OptLazy<O>): number | O;
}
export declare class IndicesOfIterator<T> extends FastIteratorBase<number> {
    readonly source: FastIterator<T>;
    readonly searchValue: T;
    readonly eq: Eq<T>;
    constructor(source: FastIterator<T>, searchValue: T, eq: Eq<T>);
    index: number;
    fastNext<O>(otherwise?: OptLazy<O>): number | O;
}
export declare class TakeWhileIterator<T> extends FastIteratorBase<T> {
    readonly source: FastIterator<T>;
    readonly pred: (value: T, index: number) => boolean;
    constructor(source: FastIterator<T>, pred: (value: T, index: number) => boolean);
    isDone: boolean;
    index: number;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class DropWhileIterator<T> extends FastIteratorBase<T> {
    readonly source: FastIterator<T>;
    readonly pred: (value: T, index: number) => boolean;
    constructor(source: FastIterator<T>, pred: (value: T, index: number) => boolean);
    pass: boolean;
    index: number;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class TakeIterator<T> extends FastIteratorBase<T> {
    readonly source: FastIterator<T>;
    readonly amount: number;
    constructor(source: FastIterator<T>, amount: number);
    i: number;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class DropIterator<T> extends FastIteratorBase<T> {
    readonly source: FastIterator<T>;
    readonly amount: number;
    remain: number;
    constructor(source: FastIterator<T>, amount: number);
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class RepeatIterator<T> extends FastIteratorBase<T> {
    readonly source: Stream<T>;
    readonly amount?: number | undefined;
    iterator: FastIterator<T>;
    remain: number | undefined;
    constructor(source: Stream<T>, amount?: number | undefined);
    isEmpty: boolean;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class IntersperseIterator<T> extends FastIteratorBase<T> {
    readonly source: FastIterator<T>;
    readonly sepStream: Stream<T>;
    constructor(source: FastIterator<T>, sepStream: Stream<T>);
    sepIterator: FastIterator<T> | undefined;
    nextValue: T;
    isInitialized: boolean;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class SplitWhereIterator<T> extends FastIteratorBase<T[]> {
    readonly source: FastIterator<T>;
    readonly pred: (value: T, index: number) => boolean;
    constructor(source: FastIterator<T>, pred: (value: T, index: number) => boolean);
    index: number;
    fastNext<O>(otherwise?: OptLazy<O>): T[] | O;
}
export declare class SplitOnIterator<T> extends FastIteratorBase<T[]> {
    readonly source: FastIterator<T>;
    readonly sepElem: T;
    readonly eq: Eq<T>;
    constructor(source: FastIterator<T>, sepElem: T, eq: Eq<T>);
    fastNext<O>(otherwise?: OptLazy<O>): T[] | O;
}
export declare class ReduceIterator<I, R> extends FastIteratorBase<R> {
    readonly source: FastIterator<I>;
    readonly reducer: Reducer<I, R>;
    state: unknown;
    constructor(source: FastIterator<I>, reducer: Reducer<I, R>);
    halted: boolean;
    index: number;
    halt: () => void;
    fastNext<O>(otherwise?: OptLazy<O>): R | O;
}
export declare class ReduceAllIterator<I, R> extends FastIteratorBase<R> {
    readonly source: FastIterator<I>;
    readonly reducers: Reducer<I, any>[];
    readonly state: unknown[];
    readonly done: ((() => void) | null)[];
    constructor(source: FastIterator<I>, reducers: Reducer<I, any>[]);
    halted: boolean;
    index: number;
    isDone: boolean;
    fastNext<O>(otherwise?: OptLazy<O>): R | O;
}
export declare class ArrayIterator<T> extends FastIteratorBase<T> {
    readonly array: readonly T[];
    readonly startIndex: number;
    readonly endIndex: number;
    i: number;
    constructor(array: readonly T[], startIndex: number, endIndex: number);
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class ArrayReverseIterator<T> extends FastIteratorBase<T> {
    readonly array: readonly T[];
    readonly startIndex: number;
    i: number;
    constructor(array: readonly T[], startIndex: number, endIndex: number);
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class AlwaysIterator<T> extends FastIteratorBase<T> {
    readonly value: T;
    constructor(value: T);
    fastNext(): T;
}
export declare class MapApplyIterator<T extends readonly unknown[], A extends readonly unknown[], R> extends FastIteratorBase<R> {
    readonly f: (...args: [...T, ...A]) => R;
    readonly args: A;
    constructor(source: StreamSource<T>, f: (...args: [...T, ...A]) => R, args: A, streamSourceHelpers: StreamSourceHelpers);
    iter: FastIterator<T>;
    fastNext<O>(otherwise?: OptLazy<O>): R | O;
}
export declare class FilterApplyIterator<T extends readonly unknown[], A extends readonly unknown[]> extends FastIteratorBase<T> {
    readonly pred: (...args: [...T, ...A]) => boolean;
    readonly args: A;
    readonly invert: boolean;
    constructor(source: StreamSource<T>, pred: (...args: [...T, ...A]) => boolean, args: A, invert: boolean, streamSourceHelpers: StreamSourceHelpers);
    iter: FastIterator<T>;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class RangeUpIterator extends FastIteratorBase<number> {
    readonly start: number;
    readonly end: number | undefined;
    readonly delta: number;
    state: number;
    constructor(start: number, end: number | undefined, delta: number);
    fastNext<O>(otherwise?: OptLazy<O>): number | O;
}
export declare class RangeDownIterator extends FastIteratorBase<number> {
    readonly start: number;
    readonly end: number | undefined;
    readonly delta: number;
    state: number;
    constructor(start: number, end: number | undefined, delta: number);
    fastNext<O>(otherwise?: OptLazy<O>): number | O;
}
export declare class RandomIterator extends FastIteratorBase<number> {
    fastNext(): number;
}
export declare class RandomIntIterator extends FastIteratorBase<number> {
    readonly min: number;
    readonly max: number;
    readonly width: number;
    constructor(min: number, max: number);
    fastNext(): number;
}
export declare class UnfoldIterator<T> extends FastIteratorBase<T> {
    readonly getNext: (current: T, index: number, stop: Token) => T | Token;
    constructor(init: T, getNext: (current: T, index: number, stop: Token) => T | Token);
    current: T | Token;
    index: number;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class ZipWithIterator<I extends readonly unknown[], R> extends FastIteratorBase<R> {
    readonly iterables: {
        [K in keyof I]: StreamSource<I[K]>;
    };
    readonly zipFun: (...values: I) => R;
    constructor(iterables: {
        [K in keyof I]: StreamSource<I[K]>;
    }, zipFun: (...values: I) => R, streamSourceHelpers: StreamSourceHelpers);
    readonly sources: FastIterator<any>[];
    fastNext<O>(otherwise?: OptLazy<O>): R | O;
}
export declare class ZipAllWithItererator<I extends readonly unknown[], F, R> extends FastIteratorBase<R> {
    readonly fillValue: OptLazy<F>;
    readonly iters: {
        [K in keyof I]: StreamSource<I[K]>;
    };
    readonly zipFun: (...values: {
        [K in keyof I]: I[K] | F;
    }) => R;
    constructor(fillValue: OptLazy<F>, iters: {
        [K in keyof I]: StreamSource<I[K]>;
    }, zipFun: (...values: {
        [K in keyof I]: I[K] | F;
    }) => R, streamSourceHelpers: StreamSourceHelpers);
    readonly sources: FastIterator<any>[];
    allDone: boolean;
    fastNext<O>(otherwise?: OptLazy<O>): R | O;
}
export declare class PrependIterator<T> extends FastIteratorBase<T> {
    readonly source: FastIterator<T>;
    readonly item: OptLazy<T>;
    constructor(source: FastIterator<T>, item: OptLazy<T>);
    prependDone: boolean;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class AppendIterator<T> extends FastIteratorBase<T> {
    readonly source: FastIterator<T>;
    readonly item: OptLazy<T>;
    constructor(source: FastIterator<T>, item: OptLazy<T>);
    appendDone: boolean;
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class IndexedIterator<T> extends FastIteratorBase<[number, T]> {
    readonly source: FastIterator<T>;
    readonly startIndex: number;
    index: number;
    constructor(source: FastIterator<T>, startIndex?: number);
    fastNext<O>(otherwise?: OptLazy<O>): [number, T] | O;
}
export declare class MapIterator<T, T2> extends FastIteratorBase<T2> {
    readonly source: FastIterator<T>;
    readonly mapFun: (value: T, index: number) => T2;
    constructor(source: FastIterator<T>, mapFun: (value: T, index: number) => T2);
    readonly state: TraverseState;
    fastNext<O>(otherwise?: OptLazy<O>): T2 | O;
}
export declare class MapPureIterator<T, A extends readonly unknown[], T2> extends FastIteratorBase<T2> {
    readonly source: FastIterator<T>;
    readonly mapFun: (value: T, ...args: A) => T2;
    readonly args: A;
    constructor(source: FastIterator<T>, mapFun: (value: T, ...args: A) => T2, args: A);
    fastNext<O>(otherwise?: OptLazy<O>): T2 | O;
}
export declare class DistinctPreviousIterator<T> extends FastIteratorBase<T> {
    readonly source: FastIterator<T>;
    readonly eq: Eq<T>;
    constructor(source: FastIterator<T>, eq: Eq<T>);
    readonly previous: T[];
    fastNext<O>(otherwise?: OptLazy<O>): T | O;
}
export declare class WindowIterator<T, R> extends FastIteratorBase<R> {
    readonly source: FastIterator<T>;
    readonly windowSize: number;
    readonly skipAmount: number;
    readonly collector: Reducer<T, R>;
    constructor(source: FastIterator<T>, windowSize: number, skipAmount: number, collector: Reducer<T, R>);
    state: Set<{
        result: unknown;
        size: number;
        halted: boolean;
        halt: () => void;
    }>;
    index: number;
    fastNext<O>(otherwise?: OptLazy<O>): R | O;
}
