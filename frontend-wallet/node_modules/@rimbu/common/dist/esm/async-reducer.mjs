import { AsyncOptLazy, CollectFun, Reducer, Eq, } from './internal.mjs';
function identity(value) {
    return value;
}
export var AsyncReducer;
(function (AsyncReducer) {
    /**
     * A base class that can be used to easily create `AsyncReducer` instances.
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @typeparam S - the internal state type
     */
    class Base {
        constructor(init, next, stateToResult, onClose) {
            this.init = init;
            this.next = next;
            this.stateToResult = stateToResult;
            this.onClose = onClose;
        }
        filterInput(pred) {
            return create(async () => ({
                nextIndex: 0,
                state: await AsyncOptLazy.toMaybePromise(this.init),
            }), async (state, elem, index, halt) => {
                if (pred(elem, index, halt)) {
                    state.state = await this.next(state.state, elem, state.nextIndex++, halt);
                }
                return state;
            }, (state) => this.stateToResult(state.state), (state, error) => this.onClose?.(state.state, error));
        }
        mapInput(mapFun) {
            return create(this.init, async (state, elem, index, halt) => this.next(state, await mapFun(elem, index), index, halt), this.stateToResult, this.onClose);
        }
        collectInput(collectFun) {
            return create(async () => ({
                nextIndex: 0,
                state: await AsyncOptLazy.toMaybePromise(this.init),
            }), async (state, elem, index, halt) => {
                const nextElem = await collectFun(elem, index, CollectFun.Skip, halt);
                if (CollectFun.Skip !== nextElem) {
                    state.state = await this.next(state.state, nextElem, state.nextIndex++, halt);
                }
                return state;
            }, (state) => this.stateToResult(state.state), (state, error) => this.onClose?.(state.state, error));
        }
        mapOutput(mapFun) {
            return create(this.init, this.next, async (state) => mapFun(await this.stateToResult(state)), this.onClose);
        }
        takeInput(amount) {
            if (amount <= 0) {
                return create(this.init, identity, this.stateToResult);
            }
            return this.filterInput((_, i, halt) => {
                const more = i < amount;
                if (!more)
                    halt();
                return more;
            });
        }
        dropInput(amount) {
            if (amount <= 0) {
                return this;
            }
            return this.filterInput((_, i) => i >= amount);
        }
        sliceInput(from = 0, amount) {
            if (undefined === amount)
                return this.dropInput(from);
            if (amount <= 0)
                return create(this.init, identity, this.stateToResult);
            if (from <= 0)
                return this.takeInput(amount);
            return this.takeInput(amount).dropInput(from);
        }
    }
    AsyncReducer.Base = Base;
    /**
     * Returns an `AsyncReducer` with the given options:
     * @param init - the optionally lazy and/or promised initial state value
     * @param next - returns (potentially asynchronously) the next state value based on the given inputs:<br/>
     * - current: the current state<br/>
     * - next: the current input value<br/>
     * - index: the input index value<br/>
     * - halt: function that, when called, ensures no more elements are passed to the reducer
     * @param stateToResult - a potentially asynchronous function that converts the current state to an output value
     * @param onClose - (optional) a function that will be called when the reducer will no longer receive values
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @typeparam S - the internal state type
     */
    function create(init, next, stateToResult, onClose) {
        return new AsyncReducer.Base(init, next, stateToResult, onClose);
    }
    AsyncReducer.create = create;
    /**
     * Returns an `AsyncReducer` of which the input, state, and output types are the same.
     * @param init - the optionally lazy and/or promised initial state value
     * @param next - returns (potentially asynchronously) the next state value based on the given inputs:<br/>
     * - current: the current state<br/>
     * - next: the current input value<br/>
     * - index: the input index value<br/>
     * - halt: function that, when called, ensures no more elements are passed to the reducer
     * @param stateToResult - a potentially asynchronous function that converts the current state to an output value
     * @param onClose - (optional) a function that will be called when the reducer will no longer receive values
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @typeparam S - the internal state type
     */
    function createMono(init, next, stateToResult, onClose) {
        return create(init, next, stateToResult ?? identity, onClose);
    }
    AsyncReducer.createMono = createMono;
    /**
     * Returns an `AsyncReducer` of which the state and output types are the same.
     * @param init - the optionally lazy and/or promised initial state value
     * @param next - returns (potentially asynchronously) the next state value based on the given inputs:<br/>
     * - current: the current state<br/>
     * - next: the current input value<br/>
     * - index: the input index value<br/>
     * - halt: function that, when called, ensures no more elements are passed to the reducer
     * @param stateToResult - a potentially asynchronous function that converts the current state to an output value
     * @param onClose - (optional) a function that will be called when the reducer will no longer receive values
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @typeparam S - the internal state type
     */
    function createOutput(init, next, stateToResult, onClose) {
        return create(init, next, stateToResult ?? identity, onClose);
    }
    AsyncReducer.createOutput = createOutput;
    function from(reducer) {
        return AsyncReducer.create(reducer.init, reducer.next, reducer.stateToResult);
    }
    AsyncReducer.from = from;
    /**
     * A `Reducer` that sums all given numeric input values.
     * @example
     * ```ts
     * console.log(Stream.range({ amount: 5 }).reduce(Reducer.sum))
     * // => 10
     * ```
     */
    AsyncReducer.sum = createMono(0, (state, next) => state + next);
    /**
     * A `Reducer` that calculates the product of all given numeric input values.
     * @example
     * ```ts
     * console.log(Stream.range({ start: 1, amount: 5 }).reduce(product))
     * // => 120
     * ```
     */
    AsyncReducer.product = createMono(1, (state, next, _, halt) => {
        if (0 === next)
            halt();
        return state * next;
    });
    /**
     * A `Reducer` that calculates the average of all given numberic input values.
     * @example
     * ```ts
     * console.log(Stream.range({ amount: 5 }).reduce(Reducer.average));
     * // => 2
     * ```
     */
    AsyncReducer.average = createMono(0, (avg, value, index) => avg + (value - avg) / (index + 1));
    /**
     * Returns a `Reducer` that remembers the minimum value of the inputs using the given `compFun` to compare input values
     * @param compFun - a comparison function for two input values, returning 0 when equal, positive when greater, negetive when smaller
     * @param otherwise - (default: undefineds) a fallback value when there were no input values given
     * @example
     * ```ts
     * const stream = Stream.of('abc', 'a', 'abcde', 'ab')
     * console.log(stream.minBy((s1, s2) => s1.length - s2.length))
     * // 'a'
     * ```
     */
    AsyncReducer.minBy = (compFun, otherwise) => {
        const token = Symbol();
        return create(token, async (state, next) => {
            if (token === state)
                return next;
            return (await compFun(state, next)) < 0 ? state : next;
        }, (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state);
    };
    /**
     * Returns a `Reducer` that remembers the minimum value of the numberic inputs.
     * @param otherwise - (default: undefined) a fallback value when there were no input values given
     * @example
     * ```ts
     * console.log(Stream.of(5, 3, 7, 4).reduce(Reducer.min()))
     * // => 3
     * ```
     */
    // prettier-ignore
    AsyncReducer.min = (otherwise) => {
        return create(undefined, (state, next) => undefined !== state && state < next ? state : next, (state) => state ?? AsyncOptLazy.toMaybePromise(otherwise));
    };
    /**
     * Returns a `Reducer` that remembers the maximum value of the inputs using the given `compFun` to compare input values
     * @param compFun - a comparison function for two input values, returning 0 when equal, positive when greater, negetive when smaller
     * @param otherwise - (default: undefined) a fallback value when there were no input values given
     * @example
     * ```ts
     * const stream = Stream.of('abc', 'a', 'abcde', 'ab')
     * console.log(stream.maxBy((s1, s2) => s1.length - s2.length))
     * // 'abcde'
     * ```
     */
    AsyncReducer.maxBy = (compFun, otherwise) => {
        const token = Symbol();
        return create(token, async (state, next) => {
            if (token === state)
                return next;
            return (await compFun(state, next)) > 0 ? state : next;
        }, (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state);
    };
    /**
     * Returns a `Reducer` that remembers the maximum value of the numberic inputs.
     * @param otherwise - (default: undefined) a fallback value when there were no input values given
     * @example
     * ```ts
     * console.log(Stream.of(5, 3, 7, 4).reduce(Reducer.max()))
     * // => 7
     * ```
     */
    // prettier-ignore
    AsyncReducer.max = (otherwise) => {
        return create(undefined, (state, next) => undefined !== state && state > next ? state : next, (state) => state ?? AsyncOptLazy.toMaybePromise(otherwise));
    };
    /**
     * Returns a `Reducer` that joins the given input values into a string using the given options.
     * @param options - an object containing:<br/>
     * - sep: (optional) a seperator string value between values in the output<br/>
     * - start: (optional) a start string to prepend to the output<br/>
     * - end: (optional) an end string to append to the output<br/>
     * @example
     * ```ts
     * console.log(Stream.of(1, 2, 3).reduce(Reducer.join({ sep: '-' })))
     * // => '1-2-3'
     * ```
     */
    function join({ sep = '', start = '', end = '', valueToString = String, } = {}) {
        let curSep = '';
        let curStart = start;
        return create('', (state, next) => {
            const result = curStart.concat(state, curSep, valueToString(next));
            curSep = sep;
            curStart = '';
            return result;
        }, (state) => state.concat(end));
    }
    AsyncReducer.join = join;
    /**
     * Returns an `AsyncReducer` that remembers the amount of input items provided.
     * @param pred - (optional) a predicate that returns false if the item should not be counted given:<br/>
     * - value: the current input value<br/>
     * - index: the input value index
     * @example
     * ```ts
     * const stream = AsyncStream.from(Stream.range({ amount: 10 }))
     * console.log(await stream.reduce(AsyncReducer.count()))
     * // => 10
     * console.log(await stream.reduce(AsyncReducer.count(async v => v < 5)))
     * // => 5
     * ```
     */
    AsyncReducer.count = (pred) => {
        if (undefined === pred)
            return createOutput(0, (_, __, i) => i + 1);
        return createOutput(0, async (state, next, i) => {
            if (await pred?.(next, i))
                return state + 1;
            return state;
        });
    };
    /**
     * Returns an `AsyncReducer` that remembers the first input value for which the given `pred` function returns true.
     * @param pred - a function taking an input value and its index, and returning true if the value should be remembered
     * @param otherwise - (default: undefined) a fallback value to output if no input value yet has satisfied the given predicate
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range({ amount: 10 })).reduce(AsyncReducer.firstWhere(async v => v > 5)))
     * // => 6
     * ```
     */
    AsyncReducer.firstWhere = (pred, otherwise) => {
        const token = Symbol();
        return create(token, async (state, next, i, halt) => {
            if (token === state && (await pred(next, i))) {
                halt();
                return next;
            }
            return state;
        }, (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state);
    };
    /**
     * Returns an `AsyncReducer` that remembers the first input value.
     * @param otherwise - (default: undefined) a fallback value to output if no input value has been provided
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range{ amount: 10 })).reduce(AsyncReducer.first())
     * // => 0
     * ```
     */
    AsyncReducer.first = (otherwise) => {
        const token = Symbol();
        return create(token, (state, next, _, halt) => {
            halt();
            if (token === state)
                return next;
            return state;
        }, (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state);
    };
    /**
     * Returns an `AsyncReducer` that remembers the last input value for which the given `pred` function returns true.
     * @param pred - a function taking an input value and its index, and returning true if the value should be remembered
     * @param otherwise - (default: undefined) a fallback value to output if no input value yet has satisfied the given predicate
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range({ amount: 10 })).reduce(AsyncReducer.lastWhere(async v => v > 5)))
     * // => 9
     * ```
     */
    AsyncReducer.lastWhere = (pred, otherwise) => {
        const token = Symbol();
        return create(token, async (state, next, i) => {
            if (await pred(next, i))
                return next;
            return state;
        }, (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state);
    };
    /**
     * Returns an `AsyncReducer` that remembers the last input value.
     * @param otherwise - (default: undefined) a fallback value to output if no input value has been provided
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range{ amount: 10 })).reduce(AsyncReducer.last())
     * // => 9
     * ```
     */
    AsyncReducer.last = (otherwise) => {
        const token = Symbol();
        return create(() => token, (_, next) => next, (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state);
    };
    /**
     * Returns a `Reducer` that ouputs false as long as no input value satisfies given `pred`, true otherwise.
     * @typeparam T - the element type
     * @param pred - a function taking an input value and its index, and returning true if the value satisfies the predicate
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range{ amount: 10 })).reduce(AsyncReducer.some(async v => v > 5))
     * // => true
     * ```
     */
    function some(pred) {
        return createOutput(false, async (state, next, i, halt) => {
            if (state)
                return state;
            const satisfies = await pred(next, i);
            if (satisfies) {
                halt();
            }
            return satisfies;
        });
    }
    AsyncReducer.some = some;
    /**
     * Returns an `AsyncReducer` that ouputs true as long as all input values satisfy the given `pred`, false otherwise.
     * @typeparam T - the element type
     * @param pred - a function taking an input value and its index, and returning true if the value satisfies the predicate
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range{ amount: 10 })).reduce(AsyncReducer.every(async v => v < 5))
     * // => false
     * ```
     */
    function every(pred) {
        return createOutput(true, async (state, next, i, halt) => {
            if (!state)
                return state;
            const satisfies = await pred(next, i);
            if (!satisfies) {
                halt();
            }
            return satisfies;
        });
    }
    AsyncReducer.every = every;
    /**
     * Returns an `AsyncReducer` that outputs false as long as the given `elem` has not been encountered in the input values, true otherwise.
     * @typeparam T - the element type
     * @param elem - the element to search for
     * @param eq - (optional) a comparison function that returns true if te two given input values are considered equal
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range({ amount: 10 })).reduce(AsyncReducer.contains(5)))
     * // => true
     * ```
     */
    function contains(elem, eq = Object.is) {
        return createOutput(false, (state, next, _, halt) => {
            if (state)
                return state;
            const satisfies = eq(next, elem);
            if (satisfies) {
                halt();
            }
            return satisfies;
        });
    }
    AsyncReducer.contains = contains;
    /**
     * Returns an `AsyncReducer` that takes boolean values and outputs true if all input values are true, and false otherwise.
     * @example
     * ```ts
     * await AsyncStream.of(true, false, true)).reduce(AsyncReducer.and))
     * // => false
     * ```
     */
    AsyncReducer.and = createMono(true, (state, next, _, halt) => {
        if (!state)
            return state;
        if (!next)
            halt();
        return next;
    });
    /**
     * Returns an `AsyncReducer` that takes boolean values and outputs true if one or more input values are true, and false otherwise.
     * @example
     * ```ts
     * await AsyncStream.of(true, false, true)).reduce(AsyncReducer.or))
     * // => true
     * ```
     */
    AsyncReducer.or = createMono(false, (state, next, _, halt) => {
        if (state)
            return state;
        if (next)
            halt();
        return next;
    });
    /**
     * Returns an `AsyncReducer` that outputs true if no input values are received, false otherwise.
     * @example
     * ```ts
     * await AsyncStream.of(1, 2, 3).reduce(AsyncReducer.isEmpty))
     * // => false
     * ```
     */
    AsyncReducer.isEmpty = createOutput(true, (_, __, ___, halt) => {
        halt();
        return false;
    });
    /**
     * Returns an `AsyncReducer` that outputs true if one or more input values are received, false otherwise.
     * @example
     * ```ts
     * await AsyncStream.of(1, 2, 3).reduce(AsyncReducer.nonEmpty))
     * // => true
     * ```
     */
    AsyncReducer.nonEmpty = createOutput(false, (_, __, ___, halt) => {
        halt();
        return true;
    });
    /**
     * Returns an `AsyncReducer` that collects received input values in an array, and returns a copy of that array as an output value when requested.
     * @typeparam T - the element type
     * @example
     * ```ts
     * await AsyncStream.of(1, 2, 3).reduce(AsyncReducer.toArray()))
     * // => [1, 2, 3]
     * ```
     */
    function toArray() {
        return create(() => [], (state, next) => {
            state.push(next);
            return state;
        }, (state) => state.slice());
    }
    AsyncReducer.toArray = toArray;
    /**
     * Returns a `AsyncReducer` that collects received input tuples into a mutable JS Map, and returns
     * a copy of that map when output is requested.
     * @typeparam K - the map key type
     * @typeparam V - the map value type
     * @example
     * ```ts
     * await AsyncStream.of([1, 'a'], [2, 'b']).reduce(AsyncReducer.toJSMap()))
     * // Map { 1 => 'a', 2 => 'b' }
     * ```
     */
    function toJSMap() {
        return create(() => new Map(), (state, next) => {
            state.set(next[0], next[1]);
            return state;
        }, (s) => new Map(s));
    }
    AsyncReducer.toJSMap = toJSMap;
    /**
     * Returns an `AsyncReducer` that collects received input values into a mutable JS Set, and returns
     * a copy of that map when output is requested.
     * @typeparam T - the element type
     * @example
     * ```ts
     * await AsyncStream.of(1, 2, 3).reduce(AsyncReducer.toJSSet()))
     * // Set {1, 2, 3}
     * ```
     */
    function toJSSet() {
        return create(() => new Set(), (state, next) => {
            state.add(next);
            return state;
        }, (s) => new Set(s));
    }
    AsyncReducer.toJSSet = toJSSet;
    /**
     * Returns an `AsyncReducer` that collects 2-tuples containing keys and values into a plain JS object, and
     * returns a copy of that object when output is requested.
     * @typeparam K - the result object key type
     * @typeparam V - the result object value type
     * @example
     * ```ts
     * await AsyncStream.of(['a', 1], ['b', true]).reduce(AsyncReducer.toJSObject()))
     * // { a: 1, b: true }
     * ```
     */
    function toJSObject() {
        return create(() => ({}), (state, entry) => {
            state[entry[0]] = entry[1];
            return state;
        }, (s) => ({ ...s }));
    }
    AsyncReducer.toJSObject = toJSObject;
    /**
     * Returns an `AsyncReducer` that combines multiple input `reducers` by providing input values to all of them and collecting the outputs in an array.
     * @param reducers - 2 or more reducers to combine
     * @example
     * ```ts
     * const red = AsyncReducer.combineArr(AsyncReducer.sum, AsyncReducer.average)
     *
     * await AsyncStream.from(Stream.range({ amount: 9 }))
     *  .reduce(red)
     * // => [36, 4]
     * ```
     */
    function combineArr(...reducers) {
        const createState = () => {
            return Promise.all(reducers.map(async (reducer) => {
                const result = {
                    reducer,
                    halted: false,
                    halt() {
                        result.halted = true;
                    },
                    state: await AsyncOptLazy.toMaybePromise(reducer.init),
                };
                return result;
            }));
        };
        return create(createState, async (allState, next, index, halt) => {
            let anyNotHalted = false;
            await Promise.all(allState.map(async (red) => {
                if (red.halted)
                    return;
                red.state = await red.reducer.next(red.state, next, index, red.halt);
                if (!red.halted)
                    anyNotHalted = true;
            }));
            if (!anyNotHalted)
                halt();
            return allState;
        }, (allState) => Promise.all(allState.map((st) => st.reducer.stateToResult(st.state))));
    }
    AsyncReducer.combineArr = combineArr;
    /**
     * Returns an `AsyncReducer` that combines multiple input `reducers` by providing input values to all of them and collecting the outputs in the shape of the given object.
     * @typeparam T - the input type for all the reducers
     * @typeparam R - the result object shape
     * @param reducerObj - an object of keys, and reducers corresponding to those keys
     * @example
     * ```ts
     * const red = AsyncReducer.combineObj({
     *   theSum: Reducer.sum,
     *   theAverage: Reducer.average
     * });
     *
     * await AsyncStream.from(Stream.range({ amount: 9 }))
     *   .reduce(red));
     * // => { theSum: 36, theAverage: 4 }
     * ```
     */
    function combineObj(reducerObj) {
        const createState = async () => {
            const entries = await Promise.all(Object.entries(reducerObj).map(async ([key, reducer]) => {
                const result = {
                    reducer,
                    halted: false,
                    halt() {
                        result.halted = true;
                    },
                    state: await AsyncOptLazy.toMaybePromise(reducer.init),
                };
                return [key, result];
            }));
            return Object.fromEntries(entries);
        };
        return create(createState, async (allState, next, index, halt) => {
            let anyNotHalted = false;
            await Promise.all(Object.values(allState).map(async (red) => {
                if (red.halted) {
                    return;
                }
                red.state = await red.reducer.next(red.state, next, index, red.halt);
                if (!red.halted) {
                    anyNotHalted = true;
                }
            }));
            if (!anyNotHalted) {
                halt();
            }
            return allState;
        }, async (allState) => {
            const entries = await Promise.all(Object.entries(allState).map(async ([key, st]) => [key, await st.reducer.stateToResult(st.state)]));
            return Object.fromEntries(entries);
        });
    }
    AsyncReducer.combineObj = combineObj;
})(AsyncReducer || (AsyncReducer = {}));
//# sourceMappingURL=async-reducer.mjs.map