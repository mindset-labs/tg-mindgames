import { CollectFun, Eq, OptLazy } from './internal.mjs';
function identity(value) {
    return value;
}
export var Reducer;
(function (Reducer) {
    /**
     * A base class that can be used to easily create `Reducer` instances.
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @typeparam S - the internal state type
     */
    class Base {
        constructor(init, next, stateToResult) {
            this.init = init;
            this.next = next;
            this.stateToResult = stateToResult;
        }
        filterInput(pred) {
            return create(() => ({
                nextIndex: 0,
                state: OptLazy(this.init),
            }), (state, elem, index, halt) => {
                if (pred(elem, index, halt)) {
                    state.state = this.next(state.state, elem, state.nextIndex++, halt);
                }
                return state;
            }, (state) => this.stateToResult(state.state));
        }
        mapInput(mapFun) {
            return create(this.init, (state, elem, index, halt) => this.next(state, mapFun(elem, index), index, halt), this.stateToResult);
        }
        collectInput(collectFun) {
            return create(() => ({
                nextIndex: 0,
                state: OptLazy(this.init),
            }), (state, elem, index, halt) => {
                const nextElem = collectFun(elem, index, CollectFun.Skip, halt);
                if (CollectFun.Skip !== nextElem) {
                    state.state = this.next(state.state, nextElem, state.nextIndex++, halt);
                }
                return state;
            }, (state) => this.stateToResult(state.state));
        }
        mapOutput(mapFun) {
            return create(this.init, this.next, (state) => mapFun(this.stateToResult(state)));
        }
        takeInput(amount) {
            if (amount <= 0) {
                return create(this.init, identity, this.stateToResult);
            }
            return this.filterInput((_, i, halt) => {
                const more = i < amount;
                if (!more)
                    halt();
                return more;
            });
        }
        dropInput(amount) {
            if (amount <= 0)
                return this;
            return this.filterInput((_, i) => i >= amount);
        }
        sliceInput(from = 0, amount) {
            if (undefined === amount)
                return this.dropInput(from);
            if (amount <= 0)
                return create(this.init, identity, this.stateToResult);
            if (from <= 0)
                return this.takeInput(amount);
            return this.takeInput(amount).dropInput(from);
        }
    }
    Reducer.Base = Base;
    /**
     * Returns a `Reducer` with the given options:
     * @param init - the initial state value
     * @param next - returns the next state value based on the given inputs:<br/>
     * - current: the current state<br/>
     * - next: the current input value<br/>
     * - index: the input index value<br/>
     * - halt: function that, when called, ensures no more elements are passed to the reducer
     * @param stateToResult - a function that converts the current state to an output value
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @typeparam S - the internal state type
     * @example
     * ```ts
     * const evenNumberOfOnes = Reducer
     *   .create(
     *     true,
     *     (current, value: number) => value === 1 ? !current : current,
     *     state => state ? 'even' : 'not even')
     * const result = Stream.of(1, 2, 3, 2, 1)).reduce(evenNumberOfOnes)
     * console.log+(result)
     * // => 'even'
     * ```
     */
    function create(init, next, stateToResult) {
        return new Reducer.Base(init, next, stateToResult);
    }
    Reducer.create = create;
    /**
     * Returns a `Reducer` of which the input, state, and output types are the same.
     * @param init - the initial state value
     * @param next - returns the next state value based on the given inputs:<br/>
     * - current: the current state<br/>
     * - next: the current input value<br/>
     * - index: the input index value<br/>
     * - halt: function that, when called, ensures no more elements are passed to the reducer
     * @param stateToResult - (optional) a function that converts the current state to an output value
     * @typeparam T - the overall value type
     * @example
     * ```ts
     * const sum = Reducer
     *   .createMono(
     *     0,
     *     (current, value) => current + value
     *   )
     * const result = Stream.of(1, 2, 3, 2, 1)).reduce(sum)
     * console.log+(result)
     * // => 9
     * ```
     */
    function createMono(init, next, stateToResult) {
        return create(init, next, stateToResult ?? identity);
    }
    Reducer.createMono = createMono;
    /**
     * Returns a `Reducer` of which the state and output types are the same.
     * @param init - the initial state value
     * @param next - returns the next state value based on the given inputs:<br/>
     * - current: the current state<br/>
     * - next: the current input value<br/>
     * - index: the input index value<br/>
     * - halt: function that, when called, ensures no more elements are passed to the reducer
     * @param stateToResult - (optional) a function that converts the current state to an output value
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @example
     * ```ts
     * const boolToString = Reducer
     *   .createOutput(
     *     '',
     *     (current, value: boolean) => current + (value ? 'T' : 'F')
     *   )
     * const result = Stream.of(true, false, true)).reduce(boolToString)
     * console.log+(result)
     * // => 'TFT'
     * ```
     */
    function createOutput(init, next, stateToResult) {
        return create(init, next, stateToResult ?? identity);
    }
    Reducer.createOutput = createOutput;
    /**
     * A `Reducer` that sums all given numeric input values.
     * @example
     * ```ts
     * console.log(Stream.range({ amount: 5 }).reduce(Reducer.sum))
     * // => 10
     * ```
     */
    Reducer.sum = createMono(0, (state, next) => state + next);
    /**
     * A `Reducer` that calculates the product of all given numeric input values.
     * @example
     * ```ts
     * console.log(Stream.range({ start: 1, amount: 5 }).reduce(product))
     * // => 120
     * ```
     */
    Reducer.product = createMono(1, (state, next, _, halt) => {
        if (0 === next)
            halt();
        return state * next;
    });
    /**
     * A `Reducer` that calculates the average of all given numberic input values.
     * @example
     * ```ts
     * console.log(Stream.range({ amount: 5 }).reduce(Reducer.average));
     * // => 2
     * ```
     */
    Reducer.average = createMono(0, (avg, value, index) => avg + (value - avg) / (index + 1));
    /**
     * Returns a `Reducer` that remembers the minimum value of the inputs using the given `compFun` to compare input values
     * @param compFun - a comparison function for two input values, returning 0 when equal, positive when greater, negetive when smaller
     * @param otherwise - (default: undefineds) a fallback value when there were no input values given
     * @example
     * ```ts
     * const stream = Stream.of('abc', 'a', 'abcde', 'ab')
     * console.log(stream.minBy((s1, s2) => s1.length - s2.length))
     * // 'a'
     * ```
     */
    Reducer.minBy = (compFun, otherwise) => {
        const token = Symbol();
        return create(token, (state, next) => {
            if (token === state)
                return next;
            return compFun(state, next) < 0 ? state : next;
        }, (state) => (token === state ? OptLazy(otherwise) : state));
    };
    /**
     * Returns a `Reducer` that remembers the minimum value of the numberic inputs.
     * @param otherwise - (default: undefined) a fallback value when there were no input values given
     * @example
     * ```ts
     * console.log(Stream.of(5, 3, 7, 4).reduce(Reducer.min()))
     * // => 3
     * ```
     */
    // prettier-ignore
    Reducer.min = (otherwise) => {
        return create(undefined, (state, next) => undefined !== state && state < next ? state : next, (state) => state ?? OptLazy(otherwise));
    };
    /**
     * Returns a `Reducer` that remembers the maximum value of the inputs using the given `compFun` to compare input values
     * @param compFun - a comparison function for two input values, returning 0 when equal, positive when greater, negetive when smaller
     * @param otherwise - (default: undefined) a fallback value when there were no input values given
     * @example
     * ```ts
     * const stream = Stream.of('abc', 'a', 'abcde', 'ab')
     * console.log(stream.maxBy((s1, s2) => s1.length - s2.length))
     * // 'abcde'
     * ```
     */
    Reducer.maxBy = (compFun, otherwise) => {
        const token = Symbol();
        return create(token, (state, next) => {
            if (token === state)
                return next;
            return compFun(state, next) > 0 ? state : next;
        }, (state) => (token === state ? OptLazy(otherwise) : state));
    };
    /**
     * Returns a `Reducer` that remembers the maximum value of the numberic inputs.
     * @param otherwise - (default: undefined) a fallback value when there were no input values given
     * @example
     * ```ts
     * console.log(Stream.of(5, 3, 7, 4).reduce(Reducer.max()))
     * // => 7
     * ```
     */
    // prettier-ignore
    Reducer.max = (otherwise) => {
        return create(undefined, (state, next) => undefined !== state && state > next ? state : next, (state) => state ?? OptLazy(otherwise));
    };
    /**
     * Returns a `Reducer` that joins the given input values into a string using the given options.
     * @param options - an object containing:<br/>
     * - sep: (optional) a seperator string value between values in the output<br/>
     * - start: (optional) a start string to prepend to the output<br/>
     * - end: (optional) an end string to append to the output<br/>
     * @example
     * ```ts
     * console.log(Stream.of(1, 2, 3).reduce(Reducer.join({ sep: '-' })))
     * // => '1-2-3'
     * ```
     */
    function join({ sep = '', start = '', end = '', valueToString = String, } = {}) {
        let curSep = '';
        let curStart = start;
        return create('', (state, next) => {
            const result = curStart.concat(state, curSep, valueToString(next));
            curSep = sep;
            curStart = '';
            return result;
        }, (state) => state.concat(end));
    }
    Reducer.join = join;
    /**
     * Returns a `Reducer` that remembers the amount of input items provided.
     * @param pred - (optional) a predicate that returns false if the item should not be counted given:<br/>
     * - value: the current input value<br/>
     * - index: the input value index
     * @example
     * ```ts
     * const stream = Stream.range({ amount: 10 })
     * console.log(stream.reduce(Reducer.count()))
     * // => 10
     * console.log(stream.reduce(Reducer.count(v => v < 5)))
     * // => 5
     * ```
     */
    Reducer.count = (pred) => {
        if (undefined === pred)
            return createOutput(0, (_, __, i) => i + 1);
        return createOutput(0, (state, next, i) => {
            if (pred?.(next, i))
                return state + 1;
            return state;
        });
    };
    /**
     * Returns a `Reducer` that remembers the first input value for which the given `pred` function returns true.
     * @param pred - a function taking an input value and its index, and returning true if the value should be remembered
     * @param otherwise - (default: undefined) a fallback value to output if no input value yet has satisfied the given predicate
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * console.log(Stream.range({ amount: 10 }).reduce(Reducer.firstWhere(v => v > 5)))
     * // => 6
     * ```
     */
    Reducer.firstWhere = (pred, otherwise) => {
        const token = Symbol();
        return create(token, (state, next, i, halt) => {
            if (token === state && pred(next, i)) {
                halt();
                return next;
            }
            return state;
        }, (state) => (token === state ? OptLazy(otherwise) : state));
    };
    /**
     * Returns a `Reducer` that remembers the first input value.
     * @param otherwise - (default: undefined) a fallback value to output if no input value has been provided
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * console.log(Stream.range{ amount: 10 }).reduce(Reducer.first())
     * // => 0
     * ```
     */
    Reducer.first = (otherwise) => {
        const token = Symbol();
        return create(token, (state, next, _, halt) => {
            halt();
            if (token === state)
                return next;
            return state;
        }, (state) => (token === state ? OptLazy(otherwise) : state));
    };
    /**
     * Returns a `Reducer` that remembers the last input value for which the given `pred` function returns true.
     * @param pred - a function taking an input value and its index, and returning true if the value should be remembered
     * @param otherwise - (default: undefined) a fallback value to output if no input value yet has satisfied the given predicate
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * console.log(Stream.range({ amount: 10 }).reduce(Reducer.lastWhere(v => v > 5)))
     * // => 9
     * ```
     */
    Reducer.lastWhere = (pred, otherwise) => {
        const token = Symbol();
        return create(token, (state, next, i) => {
            if (pred(next, i))
                return next;
            return state;
        }, (state) => (token === state ? OptLazy(otherwise) : state));
    };
    /**
     * Returns a `Reducer` that remembers the last input value.
     * @param otherwise - (default: undefined) a fallback value to output if no input value has been provided
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * console.log(Stream.range{ amount: 10 }).reduce(Reducer.last())
     * // => 9
     * ```
     */
    Reducer.last = (otherwise) => {
        const token = Symbol();
        return create(() => token, (_, next) => next, (state) => (token === state ? OptLazy(otherwise) : state));
    };
    /**
     * Returns a `Reducer` that ouputs false as long as no input value satisfies given `pred`, true otherwise.
     * @typeparam T - the element type
     * @param pred - a function taking an input value and its index, and returning true if the value satisfies the predicate
     * @example
     * ```ts
     * console.log(Stream.range{ amount: 10 }).reduce(Reducer.some(v => v > 5))
     * // => true
     * ```
     */
    function some(pred) {
        return createOutput(false, (state, next, i, halt) => {
            if (state)
                return state;
            const satisfies = pred(next, i);
            if (satisfies) {
                halt();
            }
            return satisfies;
        });
    }
    Reducer.some = some;
    /**
     * Returns a `Reducer` that ouputs true as long as all input values satisfy the given `pred`, false otherwise.
     * @typeparam T - the element type
     * @param pred - a function taking an input value and its index, and returning true if the value satisfies the predicate
     * @example
     * ```ts
     * console.log(Stream.range{ amount: 10 }).reduce(Reducer.every(v => v < 5))
     * // => false
     * ```
     */
    function every(pred) {
        return createOutput(true, (state, next, i, halt) => {
            if (!state)
                return state;
            const satisfies = pred(next, i);
            if (!satisfies) {
                halt();
            }
            return satisfies;
        });
    }
    Reducer.every = every;
    /**
     * Returns a `Reducer` that outputs false as long as the given `elem` has not been encountered in the input values, true otherwise.
     * @typeparam T - the element type
     * @param elem - the element to search for
     * @param eq - (optional) a comparison function that returns true if te two given input values are considered equal
     * @example
     * ```ts
     * console.log(Stream.range({ amount: 10 }).reduce(Reducer.contains(5)))
     * // => true
     * ```
     */
    function contains(elem, eq = Object.is) {
        return createOutput(false, (state, next, _, halt) => {
            if (state)
                return state;
            const satisfies = eq(next, elem);
            if (satisfies) {
                halt();
            }
            return satisfies;
        });
    }
    Reducer.contains = contains;
    /**
     * Returns a `Reducer` that takes boolean values and outputs true if all input values are true, and false otherwise.
     * @example
     * ```ts
     * console.log(Stream.of(true, false, true)).reduce(Reducer.and))
     * // => false
     * ```
     */
    Reducer.and = createMono(true, (state, next, _, halt) => {
        if (!state)
            return state;
        if (!next)
            halt();
        return next;
    });
    /**
     * Returns a `Reducer` that takes boolean values and outputs true if one or more input values are true, and false otherwise.
     * @example
     * ```ts
     * console.log(Stream.of(true, false, true)).reduce(Reducer.or))
     * // => true
     * ```
     */
    Reducer.or = createMono(false, (state, next, _, halt) => {
        if (state)
            return state;
        if (next)
            halt();
        return next;
    });
    /**
     * Returns a `Reducer` that outputs true if no input values are received, false otherwise.
     * @example
     * ```ts
     * console.log(Stream.of(1, 2, 3).reduce(Reducer.isEmpty))
     * // => false
     * ```
     */
    Reducer.isEmpty = createOutput(true, (_, __, ___, halt) => {
        halt();
        return false;
    });
    /**
     * Returns a `Reducer` that outputs true if one or more input values are received, false otherwise.
     * @example
     * ```ts
     * console.log(Stream.of(1, 2, 3).reduce(Reducer.nonEmpty))
     * // => true
     * ```
     */
    Reducer.nonEmpty = createOutput(false, (_, __, ___, halt) => {
        halt();
        return true;
    });
    /**
     * Returns a `Reducer` that collects received input values in an array, and returns a copy of that array as an output value when requested.
     * @typeparam T - the element type
     * @example
     * ```ts
     * console.log(Stream.of(1, 2, 3).reduce(Reducer.toArray()))
     * // => [1, 2, 3]
     * ```
     */
    function toArray() {
        return create(() => [], (state, next) => {
            state.push(next);
            return state;
        }, (state) => state.slice());
    }
    Reducer.toArray = toArray;
    /**
     * Returns a `Reducer` that collects received input tuples into a mutable JS Map, and returns
     * a copy of that map when output is requested.
     * @typeparam K - the map key type
     * @typeparam V - the map value type
     * @example
     * ```ts
     * console.log(Stream.of([1, 'a'], [2, 'b']).reduce(Reducer.toJSMap()))
     * // Map { 1 => 'a', 2 => 'b' }
     * ```
     */
    function toJSMap() {
        return create(() => new Map(), (state, next) => {
            state.set(next[0], next[1]);
            return state;
        }, (s) => new Map(s));
    }
    Reducer.toJSMap = toJSMap;
    /**
     * Returns a `Reducer` that collects received input values into a mutable JS Set, and returns
     * a copy of that map when output is requested.
     * @typeparam T - the element type
     * @example
     * ```ts
     * console.log(Stream.of(1, 2, 3).reduce(Reducer.toJSSet()))
     * // Set {1, 2, 3}
     * ```
     */
    function toJSSet() {
        return create(() => new Set(), (state, next) => {
            state.add(next);
            return state;
        }, (s) => new Set(s));
    }
    Reducer.toJSSet = toJSSet;
    /**
     * Returns a `Reducer` that collects 2-tuples containing keys and values into a plain JS object, and
     * returns a copy of that object when output is requested.
     * @typeparam K - the result object key type
     * @typeparam V - the result object value type
     * @example
     * ```ts
     * console.log(Stream.of(['a', 1], ['b', true]).reduce(Reducer.toJSObject()))
     * // { a: 1, b: true }
     * ```
     */
    function toJSObject() {
        return create(() => ({}), (state, entry) => {
            state[entry[0]] = entry[1];
            return state;
        }, (s) => ({ ...s }));
    }
    Reducer.toJSObject = toJSObject;
    /**
     * Returns a `Reducer` that combines multiple input `reducers` by providing input values to all of them and collecting the outputs in an array.
     * @param reducers - 2 or more reducers to combine
     * @example
     * ```ts
     * const red = Reducer.combineArr(Reducer.sum, Reducer.average)
     * console.log(Stream.range({amount: 9 }).reduce(red))
     * // => [36, 4]
     * ```
     */
    function combineArr(...reducers) {
        const createState = () => {
            return reducers.map((reducer) => {
                const result = {
                    reducer,
                    halted: false,
                    halt() {
                        result.halted = true;
                    },
                    state: OptLazy(reducer.init),
                };
                return result;
            });
        };
        return create(createState, (allState, next, index, halt) => {
            let anyNotHalted = false;
            let i = -1;
            const len = allState.length;
            while (++i < len) {
                const red = allState[i];
                if (red.halted) {
                    continue;
                }
                red.state = red.reducer.next(red.state, next, index, red.halt);
                if (!red.halted) {
                    anyNotHalted = true;
                }
            }
            if (!anyNotHalted) {
                halt();
            }
            return allState;
        }, (allState) => allState.map((st) => st.reducer.stateToResult(st.state)));
    }
    Reducer.combineArr = combineArr;
    /**
     * Returns a `Reducer` that combines multiple input `reducers` by providing input values to all of them and collecting the outputs in the shape of the given object.
     * @typeparam T - the input type for all the reducers
     * @typeparam R - the result object shape
     * @param reducerObj - an object of keys, and reducers corresponding to those keys
     * @example
     * ```ts
     * const red = Reducer.combineObj({
     *   theSum: Reducer.sum,
     *   theAverage: Reducer.average
     * });
     *
     * Stream.range({ amount: 9 }).reduce(red);
     * // => { theSum: 36, theAverage: 4 }
     * ```
     */
    function combineObj(reducerObj) {
        const createState = () => {
            const allState = {};
            for (const key in reducerObj) {
                const reducer = reducerObj[key];
                const result = {
                    reducer,
                    halted: false,
                    halt() {
                        result.halted = true;
                    },
                    state: OptLazy(reducer.init),
                };
                allState[key] = result;
            }
            return allState;
        };
        return create(createState, (allState, next, index, halt) => {
            let anyNotHalted = false;
            for (const key in allState) {
                const red = allState[key];
                if (red.halted) {
                    continue;
                }
                red.state = red.reducer.next(red.state, next, index, red.halt);
                if (!red.halted) {
                    anyNotHalted = true;
                }
            }
            if (!anyNotHalted) {
                halt();
            }
            return allState;
        }, (allState) => {
            const result = {};
            for (const key in allState) {
                const st = allState[key];
                result[key] = st.reducer.stateToResult(st.state);
            }
            return result;
        });
    }
    Reducer.combineObj = combineObj;
})(Reducer || (Reducer = {}));
//# sourceMappingURL=reducer.mjs.map