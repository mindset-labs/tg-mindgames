import { type AsyncCollectFun, AsyncOptLazy, type MaybePromise, Reducer, Eq } from './internal.mjs';
/**
 * An `AsyncReducer` is a stand-alone asynchronous calculation that takes input values of type I,
 * and, when requested, produces an output value of type O.
 * @typeparam I - the input value type
 * @typeparam O - the output value type
 */
export type AsyncReducer<I, O = I> = AsyncReducer.Impl<I, O, unknown>;
export declare namespace AsyncReducer {
    interface Impl<I, O, S> {
        /**
         * The initial state value for the reducer algorithm.
         */
        readonly init: AsyncOptLazy<S>;
        /**
         * Returns the next state based on the given input values
         * @param state - the current state
         * @param elem - the current input value
         * @param index - the current input index
         * @param halt - a function that, when called, ensures no more values are passed to the reducer
         */
        next(state: S, elem: I, index: number, halt: () => void): MaybePromise<S>;
        /**
         * Returns the output value based on the given `state`
         * @param state - the current state
         */
        stateToResult(state: S): MaybePromise<O>;
        /**
         * An optional function that is called when the reducer will no longer receive values.
         * @param state - the final reducer state
         * @param error - (optional) if an error has occured, it ix passed here
         */
        onClose?: ((state: S, error?: unknown) => MaybePromise<void>) | undefined;
        /**
         * Returns an `AsyncReducer` instance that only passes values to the reducer that satisy the given `pred` predicate.
         * @param pred - a potaentially asynchronous function that returns true if the value should be passed to the reducer based on the following inputs:<br/>
         * - value: the current input value<br/>
         * - index: the current input index<br/>
         * - halt: function that, when called, ensures no more new values are passed to the reducer
         * @example
         * ```ts
         * AsyncReducer
         *   .createMono(0, async (c, v) => c + v)
         *   .filterInput(async v => v > 10)
         * // this reducer will only sum values larger than 10
         * ```
         */
        filterInput(pred: (value: I, index: number, halt: () => void) => MaybePromise<boolean>): AsyncReducer<I, O>;
        /**
         * Returns an `AsyncReducer` instance that converts its input values using given `mapFun` before passing them to the reducer.
         * @param mapFun - a potentially asynchronous function that returns a new value to pass to the reducer based on the following inputs:<br/>
         * - value: the current input value<br/>
         * - index: the current input index
         * @example
         * ```ts
         * AsyncReducer
         *   .createMono(0, async (c, v) => c + v)
         *   .mapInput(async v => v * 2)
         * // this reducer will double all input values before summing them
         * ```
         */
        mapInput<I2>(mapFun: (value: I2, index: number) => MaybePromise<I>): AsyncReducer<I2, O>;
        /**
         * Returns an `AsyncReducer` instance that converts or filters its input values using given `collectFun` before passing them to the reducer.
         * @param collectFun - a function receiving<br/>
         * - `value`: the next value<br/>
         * - `index`: the value index<br/>
         * - `skip`: a token that, when returned, will not add a value to the resulting collection<br/>
         * - `halt`: a function that, when called, ensures no next elements are passed
         * @example
         * ```ts
         * AsyncReducer
         *   .createMono(0, async (c, v) => c + v)
         *   .collectInput(async (v, _, skip) => v <= 10 ? skip : v * 2)
         * // this reducer will double all input values larger thant 10 before summing them,
         * // and will skip all values smaller than 10
         * ```
         */
        collectInput<I2>(collectFun: AsyncCollectFun<I2, I>): AsyncReducer<I2, O>;
        /**
         * Returns an `AsyncReducer` instance that converts its output values using given `mapFun`.
         * @param mapFun - a potentially asynchronous function that takes the current output value and converts it to a new output value
         * @example
         * ```ts
         * AsyncReducer
         *   .createMono(0, async (c, v) => c + v)
         *   .mapOutput(async v => String(v))
         * // this reducer will convert all its results to string before returning them
         * ```
         */
        mapOutput<O2>(mapFun: (value: O) => O2): AsyncReducer<I, O2>;
        mapOutput<O2>(mapFun: (value: O) => Promise<O2>): AsyncReducer<I, O2>;
        /**
         * Returns an `AsyncReducer` instance that takes at most the given `amount` of input elements, and will ignore subsequent elements.
         * @param amount - the amount of elements to accept
         * @example
         * ```ts
         * await AsyncStream
         *   .from(Stream.range({ end: 10 }))
         *   .reduce(
         *     AsyncReducer
         *       .createMono(0, async (c, v) => c + v)
         *       .takeInput(2)
         *   )
         * // => 1
         * ```
         */
        takeInput(amount: number): AsyncReducer<I, O>;
        /**
         * Returns a `Reducer` instance that skips the first given `amount` of input elements, and will process subsequent elements.
         * @param amount - the amount of elements to skip
         * @example
         * ```ts
         * await AsyncStream
         *   .from(Stream.range({ end: 10 }))
         *   .reduce(
         *     AsyncReducer
         *       .createMono(0, async (c, v) => c + v)
         *       .dropInput(9)
         *   )
         * // => 19
         * ```
         */
        dropInput(amount: number): AsyncReducer<I, O>;
        /**
         * Returns a `Reducer` instance that takes given `amount` of elements starting at given `from` index, and ignores other elements.
         * @param from - (default: 0) the index at which to start processing elements
         * @param amount - (optional) the amount of elements to process, if not given, processes all elements from the `from` index
         * @example
         * ```ts
         * await AsyncStream
         *   .from(Stream.range({ end: 10 }))
         *   .reduce(
         *     AsyncReducer
         *       .createMono(0, async (c, v) => c + v)
         *       .sliceInput(1, 2)
         *   )
         * // => 3
         * ```
         */
        sliceInput(from?: number, amount?: number): AsyncReducer<I, O>;
    }
    /**
     * A base class that can be used to easily create `AsyncReducer` instances.
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @typeparam S - the internal state type
     */
    class Base<I, O, S> implements AsyncReducer.Impl<I, O, S> {
        readonly init: AsyncOptLazy<S>;
        readonly next: (state: S, elem: I, index: number, halt: () => void) => MaybePromise<S>;
        readonly stateToResult: (state: S) => MaybePromise<O>;
        readonly onClose?: ((state: S, error?: unknown) => MaybePromise<void>) | undefined;
        constructor(init: AsyncOptLazy<S>, next: (state: S, elem: I, index: number, halt: () => void) => MaybePromise<S>, stateToResult: (state: S) => MaybePromise<O>, onClose?: ((state: S, error?: unknown) => MaybePromise<void>) | undefined);
        filterInput(pred: (value: I, index: number, halt: () => void) => MaybePromise<boolean>): AsyncReducer<I, O>;
        mapInput<I2>(mapFun: (value: I2, index: number) => MaybePromise<I>): AsyncReducer<I2, O>;
        collectInput<I2>(collectFun: AsyncCollectFun<I2, I>): AsyncReducer<I2, O>;
        mapOutput<O2>(mapFun: (value: O) => MaybePromise<O2>): AsyncReducer<I, O2>;
        takeInput(amount: number): AsyncReducer<I, O>;
        dropInput(amount: number): AsyncReducer<I, O>;
        sliceInput(from?: number, amount?: number): AsyncReducer<I, O>;
    }
    /**
     * Returns an `AsyncReducer` with the given options:
     * @param init - the optionally lazy and/or promised initial state value
     * @param next - returns (potentially asynchronously) the next state value based on the given inputs:<br/>
     * - current: the current state<br/>
     * - next: the current input value<br/>
     * - index: the input index value<br/>
     * - halt: function that, when called, ensures no more elements are passed to the reducer
     * @param stateToResult - a potentially asynchronous function that converts the current state to an output value
     * @param onClose - (optional) a function that will be called when the reducer will no longer receive values
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @typeparam S - the internal state type
     */
    function create<I, O = I, S = O>(init: AsyncOptLazy<S>, next: (current: S, next: I, index: number, halt: () => void) => MaybePromise<S>, stateToResult: (state: S) => MaybePromise<O>, onClose?: (state: S, error?: unknown) => MaybePromise<void>): AsyncReducer<I, O>;
    /**
     * Returns an `AsyncReducer` of which the input, state, and output types are the same.
     * @param init - the optionally lazy and/or promised initial state value
     * @param next - returns (potentially asynchronously) the next state value based on the given inputs:<br/>
     * - current: the current state<br/>
     * - next: the current input value<br/>
     * - index: the input index value<br/>
     * - halt: function that, when called, ensures no more elements are passed to the reducer
     * @param stateToResult - a potentially asynchronous function that converts the current state to an output value
     * @param onClose - (optional) a function that will be called when the reducer will no longer receive values
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @typeparam S - the internal state type
     */
    function createMono<T>(init: AsyncOptLazy<T>, next: (current: T, next: T, index: number, halt: () => void) => MaybePromise<T>, stateToResult?: (state: T) => MaybePromise<T>, onClose?: (state: T, error?: unknown) => MaybePromise<void>): AsyncReducer<T>;
    /**
     * Returns an `AsyncReducer` of which the state and output types are the same.
     * @param init - the optionally lazy and/or promised initial state value
     * @param next - returns (potentially asynchronously) the next state value based on the given inputs:<br/>
     * - current: the current state<br/>
     * - next: the current input value<br/>
     * - index: the input index value<br/>
     * - halt: function that, when called, ensures no more elements are passed to the reducer
     * @param stateToResult - a potentially asynchronous function that converts the current state to an output value
     * @param onClose - (optional) a function that will be called when the reducer will no longer receive values
     * @typeparam I - the input value type
     * @typeparam O - the output value type
     * @typeparam S - the internal state type
     */
    function createOutput<I, O = I>(init: AsyncOptLazy<O>, next: (current: O, next: I, index: number, halt: () => void) => MaybePromise<O>, stateToResult?: (state: O) => MaybePromise<O>, onClose?: (state: O, error?: unknown) => MaybePromise<void>): AsyncReducer<I, O>;
    function from<I, O>(reducer: Reducer<I, O>): AsyncReducer<I, O>;
    /**
     * A `Reducer` that sums all given numeric input values.
     * @example
     * ```ts
     * console.log(Stream.range({ amount: 5 }).reduce(Reducer.sum))
     * // => 10
     * ```
     */
    const sum: AsyncReducer<number, number>;
    /**
     * A `Reducer` that calculates the product of all given numeric input values.
     * @example
     * ```ts
     * console.log(Stream.range({ start: 1, amount: 5 }).reduce(product))
     * // => 120
     * ```
     */
    const product: AsyncReducer<number, number>;
    /**
     * A `Reducer` that calculates the average of all given numberic input values.
     * @example
     * ```ts
     * console.log(Stream.range({ amount: 5 }).reduce(Reducer.average));
     * // => 2
     * ```
     */
    const average: AsyncReducer<number, number>;
    /**
     * Returns a `Reducer` that remembers the minimum value of the inputs using the given `compFun` to compare input values
     * @param compFun - a comparison function for two input values, returning 0 when equal, positive when greater, negetive when smaller
     * @param otherwise - (default: undefineds) a fallback value when there were no input values given
     * @example
     * ```ts
     * const stream = Stream.of('abc', 'a', 'abcde', 'ab')
     * console.log(stream.minBy((s1, s2) => s1.length - s2.length))
     * // 'a'
     * ```
     */
    const minBy: {
        <T>(compFun: (v1: T, v2: T) => MaybePromise<number>): AsyncReducer<T, T | undefined>;
        <T, O>(compFun: (v1: T, v2: T) => MaybePromise<number>, otherwise: AsyncOptLazy<O>): AsyncReducer<T, T | O>;
    };
    /**
     * Returns a `Reducer` that remembers the minimum value of the numberic inputs.
     * @param otherwise - (default: undefined) a fallback value when there were no input values given
     * @example
     * ```ts
     * console.log(Stream.of(5, 3, 7, 4).reduce(Reducer.min()))
     * // => 3
     * ```
     */
    const min: {
        (): AsyncReducer<number, number | undefined>;
        <O>(otherwise: AsyncOptLazy<O>): AsyncReducer<number, number | O>;
    };
    /**
     * Returns a `Reducer` that remembers the maximum value of the inputs using the given `compFun` to compare input values
     * @param compFun - a comparison function for two input values, returning 0 when equal, positive when greater, negetive when smaller
     * @param otherwise - (default: undefined) a fallback value when there were no input values given
     * @example
     * ```ts
     * const stream = Stream.of('abc', 'a', 'abcde', 'ab')
     * console.log(stream.maxBy((s1, s2) => s1.length - s2.length))
     * // 'abcde'
     * ```
     */
    const maxBy: {
        <T>(compFun: (v1: T, v2: T) => MaybePromise<number>): AsyncReducer<T, T | undefined>;
        <T, O>(compFun: (v1: T, v2: T) => MaybePromise<number>, otherwise: AsyncOptLazy<O>): AsyncReducer<T, T | O>;
    };
    /**
     * Returns a `Reducer` that remembers the maximum value of the numberic inputs.
     * @param otherwise - (default: undefined) a fallback value when there were no input values given
     * @example
     * ```ts
     * console.log(Stream.of(5, 3, 7, 4).reduce(Reducer.max()))
     * // => 7
     * ```
     */
    const max: {
        (): AsyncReducer<number, number | undefined>;
        <O>(otherwise: AsyncOptLazy<O>): AsyncReducer<number, number | O>;
    };
    /**
     * Returns a `Reducer` that joins the given input values into a string using the given options.
     * @param options - an object containing:<br/>
     * - sep: (optional) a seperator string value between values in the output<br/>
     * - start: (optional) a start string to prepend to the output<br/>
     * - end: (optional) an end string to append to the output<br/>
     * @example
     * ```ts
     * console.log(Stream.of(1, 2, 3).reduce(Reducer.join({ sep: '-' })))
     * // => '1-2-3'
     * ```
     */
    function join<T>({ sep, start, end, valueToString, }?: {
        sep?: string | undefined;
        start?: string | undefined;
        end?: string | undefined;
        valueToString?: ((value: T) => string) | undefined;
    }): AsyncReducer<T, string>;
    /**
     * Returns an `AsyncReducer` that remembers the amount of input items provided.
     * @param pred - (optional) a predicate that returns false if the item should not be counted given:<br/>
     * - value: the current input value<br/>
     * - index: the input value index
     * @example
     * ```ts
     * const stream = AsyncStream.from(Stream.range({ amount: 10 }))
     * console.log(await stream.reduce(AsyncReducer.count()))
     * // => 10
     * console.log(await stream.reduce(AsyncReducer.count(async v => v < 5)))
     * // => 5
     * ```
     */
    const count: {
        (): AsyncReducer<never, number>;
        <T>(pred: (value: T, index: number) => MaybePromise<boolean>): AsyncReducer<T, number>;
    };
    /**
     * Returns an `AsyncReducer` that remembers the first input value for which the given `pred` function returns true.
     * @param pred - a function taking an input value and its index, and returning true if the value should be remembered
     * @param otherwise - (default: undefined) a fallback value to output if no input value yet has satisfied the given predicate
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range({ amount: 10 })).reduce(AsyncReducer.firstWhere(async v => v > 5)))
     * // => 6
     * ```
     */
    const firstWhere: {
        <T>(pred: (value: T, index: number) => MaybePromise<boolean>): AsyncReducer<T, T | undefined>;
        <T, O>(pred: (value: T, index: number) => MaybePromise<boolean>, otherwise: AsyncOptLazy<O>): AsyncReducer<T, T | O>;
    };
    /**
     * Returns an `AsyncReducer` that remembers the first input value.
     * @param otherwise - (default: undefined) a fallback value to output if no input value has been provided
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range{ amount: 10 })).reduce(AsyncReducer.first())
     * // => 0
     * ```
     */
    const first: {
        <T>(): AsyncReducer<T, T | undefined>;
        <T, O>(otherwise: AsyncOptLazy<O>): AsyncReducer<T, T | O>;
    };
    /**
     * Returns an `AsyncReducer` that remembers the last input value for which the given `pred` function returns true.
     * @param pred - a function taking an input value and its index, and returning true if the value should be remembered
     * @param otherwise - (default: undefined) a fallback value to output if no input value yet has satisfied the given predicate
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range({ amount: 10 })).reduce(AsyncReducer.lastWhere(async v => v > 5)))
     * // => 9
     * ```
     */
    const lastWhere: {
        <T>(pred: (value: T, index: number) => MaybePromise<boolean>): AsyncReducer<T, T | undefined>;
        <T, O>(pred: (value: T, index: number) => MaybePromise<boolean>, otherwise: AsyncOptLazy<O>): AsyncReducer<T, T | O>;
    };
    /**
     * Returns an `AsyncReducer` that remembers the last input value.
     * @param otherwise - (default: undefined) a fallback value to output if no input value has been provided
     * @typeparam T - the input value type
     * @typeparam O - the fallback value type
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range{ amount: 10 })).reduce(AsyncReducer.last())
     * // => 9
     * ```
     */
    const last: {
        <T>(): AsyncReducer<T, T | undefined>;
        <T, O>(otherwise: AsyncOptLazy<O>): AsyncReducer<T, T | O>;
    };
    /**
     * Returns a `Reducer` that ouputs false as long as no input value satisfies given `pred`, true otherwise.
     * @typeparam T - the element type
     * @param pred - a function taking an input value and its index, and returning true if the value satisfies the predicate
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range{ amount: 10 })).reduce(AsyncReducer.some(async v => v > 5))
     * // => true
     * ```
     */
    function some<T>(pred: (value: T, index: number) => MaybePromise<boolean>): AsyncReducer<T, boolean>;
    /**
     * Returns an `AsyncReducer` that ouputs true as long as all input values satisfy the given `pred`, false otherwise.
     * @typeparam T - the element type
     * @param pred - a function taking an input value and its index, and returning true if the value satisfies the predicate
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range{ amount: 10 })).reduce(AsyncReducer.every(async v => v < 5))
     * // => false
     * ```
     */
    function every<T>(pred: (value: T, index: number) => MaybePromise<boolean>): AsyncReducer<T, boolean>;
    /**
     * Returns an `AsyncReducer` that outputs false as long as the given `elem` has not been encountered in the input values, true otherwise.
     * @typeparam T - the element type
     * @param elem - the element to search for
     * @param eq - (optional) a comparison function that returns true if te two given input values are considered equal
     * @example
     * ```ts
     * await AsyncStream.from(Stream.range({ amount: 10 })).reduce(AsyncReducer.contains(5)))
     * // => true
     * ```
     */
    function contains<T>(elem: T, eq?: Eq<T>): AsyncReducer<T, boolean>;
    /**
     * Returns an `AsyncReducer` that takes boolean values and outputs true if all input values are true, and false otherwise.
     * @example
     * ```ts
     * await AsyncStream.of(true, false, true)).reduce(AsyncReducer.and))
     * // => false
     * ```
     */
    const and: AsyncReducer<boolean, boolean>;
    /**
     * Returns an `AsyncReducer` that takes boolean values and outputs true if one or more input values are true, and false otherwise.
     * @example
     * ```ts
     * await AsyncStream.of(true, false, true)).reduce(AsyncReducer.or))
     * // => true
     * ```
     */
    const or: AsyncReducer<boolean, boolean>;
    /**
     * Returns an `AsyncReducer` that outputs true if no input values are received, false otherwise.
     * @example
     * ```ts
     * await AsyncStream.of(1, 2, 3).reduce(AsyncReducer.isEmpty))
     * // => false
     * ```
     */
    const isEmpty: AsyncReducer<never, boolean>;
    /**
     * Returns an `AsyncReducer` that outputs true if one or more input values are received, false otherwise.
     * @example
     * ```ts
     * await AsyncStream.of(1, 2, 3).reduce(AsyncReducer.nonEmpty))
     * // => true
     * ```
     */
    const nonEmpty: AsyncReducer<never, boolean>;
    /**
     * Returns an `AsyncReducer` that collects received input values in an array, and returns a copy of that array as an output value when requested.
     * @typeparam T - the element type
     * @example
     * ```ts
     * await AsyncStream.of(1, 2, 3).reduce(AsyncReducer.toArray()))
     * // => [1, 2, 3]
     * ```
     */
    function toArray<T>(): AsyncReducer<T, T[]>;
    /**
     * Returns a `AsyncReducer` that collects received input tuples into a mutable JS Map, and returns
     * a copy of that map when output is requested.
     * @typeparam K - the map key type
     * @typeparam V - the map value type
     * @example
     * ```ts
     * await AsyncStream.of([1, 'a'], [2, 'b']).reduce(AsyncReducer.toJSMap()))
     * // Map { 1 => 'a', 2 => 'b' }
     * ```
     */
    function toJSMap<K, V>(): AsyncReducer<[K, V], Map<K, V>>;
    /**
     * Returns an `AsyncReducer` that collects received input values into a mutable JS Set, and returns
     * a copy of that map when output is requested.
     * @typeparam T - the element type
     * @example
     * ```ts
     * await AsyncStream.of(1, 2, 3).reduce(AsyncReducer.toJSSet()))
     * // Set {1, 2, 3}
     * ```
     */
    function toJSSet<T>(): AsyncReducer<T, Set<T>>;
    /**
     * Returns an `AsyncReducer` that collects 2-tuples containing keys and values into a plain JS object, and
     * returns a copy of that object when output is requested.
     * @typeparam K - the result object key type
     * @typeparam V - the result object value type
     * @example
     * ```ts
     * await AsyncStream.of(['a', 1], ['b', true]).reduce(AsyncReducer.toJSObject()))
     * // { a: 1, b: true }
     * ```
     */
    function toJSObject<K extends string | number | symbol, V>(): AsyncReducer<[K, V], Record<K, V>>;
    /**
     * Returns an `AsyncReducer` that combines multiple input `reducers` by providing input values to all of them and collecting the outputs in an array.
     * @param reducers - 2 or more reducers to combine
     * @example
     * ```ts
     * const red = AsyncReducer.combineArr(AsyncReducer.sum, AsyncReducer.average)
     *
     * await AsyncStream.from(Stream.range({ amount: 9 }))
     *  .reduce(red)
     * // => [36, 4]
     * ```
     */
    function combineArr<T, R extends readonly [unknown, unknown, ...unknown[]]>(...reducers: {
        [K in keyof R]: AsyncReducer<T, R[K]>;
    } & AsyncReducer<T, unknown>[]): AsyncReducer<T, R>;
    /**
     * Returns an `AsyncReducer` that combines multiple input `reducers` by providing input values to all of them and collecting the outputs in the shape of the given object.
     * @typeparam T - the input type for all the reducers
     * @typeparam R - the result object shape
     * @param reducerObj - an object of keys, and reducers corresponding to those keys
     * @example
     * ```ts
     * const red = AsyncReducer.combineObj({
     *   theSum: Reducer.sum,
     *   theAverage: Reducer.average
     * });
     *
     * await AsyncStream.from(Stream.range({ amount: 9 }))
     *   .reduce(red));
     * // => { theSum: 36, theAverage: 4 }
     * ```
     */
    function combineObj<T, R extends {
        readonly [key: string]: unknown;
    }>(reducerObj: {
        readonly [K in keyof R]: AsyncReducer<T, R[K]>;
    } & Record<string, AsyncReducer<T, unknown>>): AsyncReducer<T, R>;
}
