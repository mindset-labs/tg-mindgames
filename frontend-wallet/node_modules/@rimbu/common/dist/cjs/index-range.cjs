"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index-range.mts
var index_range_exports = {};
__export(index_range_exports, {
  IndexRange: () => IndexRange
});
module.exports = __toCommonJS(index_range_exports);
var IndexRange;
((IndexRange2) => {
  function getIndexRangeIndices(range) {
    if (void 0 !== range.amount) {
      if (void 0 === range.start)
        return [0, range.amount - 1];
      if (Array.isArray(range.start)) {
        const [start2, includeStart] = range.start;
        if (includeStart)
          return [start2, start2 + range.amount - 1];
        return [start2 + 1, start2 + 1 + range.amount - 1];
      }
      return [range.start, range.start + range.amount - 1];
    }
    let start = 0;
    let end = void 0;
    if (`start` in range) {
      if (Array.isArray(range.start)) {
        if (range.start[1])
          start = range.start[0];
        else
          start = range.start[0] + 1;
      } else
        start = range.start ?? 0;
    }
    if (`end` in range) {
      if (Array.isArray(range.end)) {
        if (range.end[1])
          end = range.end[0];
        else
          end = range.end[0] - 1;
      } else
        end = range.end;
    }
    return [start, end];
  }
  IndexRange2.getIndexRangeIndices = getIndexRangeIndices;
  function getIndicesFor(range, length) {
    if (length <= 0)
      return "empty";
    let start = 0;
    let end = length - 1;
    if (void 0 !== range.start) {
      if (Array.isArray(range.start)) {
        start = range.start[0];
        if (!range.start[1])
          start++;
      } else
        start = range.start;
      if (start >= length || -start > length)
        return "empty";
      if (start < 0)
        start = length + start;
    }
    if (void 0 !== range.amount) {
      if (range.amount <= 0)
        return "empty";
      if (void 0 === range.start) {
        if (range.amount >= length)
          return "all";
        return [0, Math.min(end, range.amount - 1)];
      }
      end = start + range.amount - 1;
    } else if (void 0 !== range.end) {
      if (Array.isArray(range.end)) {
        end = range.end[0];
        if (!range.end[1]) {
          if (end === 0)
            return "empty";
          end--;
        }
      } else
        end = range.end;
      if (end < 0)
        end = length + end;
    }
    if (end < start)
      return "empty";
    end = Math.min(length - 1, end);
    if (start === 0 && end === length - 1)
      return "all";
    return [start, end];
  }
  IndexRange2.getIndicesFor = getIndicesFor;
})(IndexRange || (IndexRange = {}));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  IndexRange
});
