"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/eq.mts
var eq_exports = {};
__export(eq_exports, {
  Eq: () => Eq
});
module.exports = __toCommonJS(eq_exports);
var Eq;
((Eq2) => {
  function convertAnyToString(value) {
    if (typeof value !== "object" || null === value || !("toString" in value) || typeof value.toString !== "function" || value.toString !== Object.prototype.toString) {
      return String(value);
    }
    return JSON.stringify(value);
  }
  Eq2.convertAnyToString = convertAnyToString;
  const _anyFlatEq = createAnyEq("FLAT");
  const _anyShallowEq = createAnyEq("SHALLOW");
  const _anyDeepEq = createAnyEq("DEEP");
  function defaultEq() {
    return _anyDeepEq;
  }
  Eq2.defaultEq = defaultEq;
  Eq2.objectIs = Object.is;
  const _valueOfEq = (v1, v2) => Object.is(v1.valueOf(), v2.valueOf());
  function valueOfEq() {
    return _valueOfEq;
  }
  Eq2.valueOfEq = valueOfEq;
  function dateEq() {
    return _valueOfEq;
  }
  Eq2.dateEq = dateEq;
  function createIterableEq(itemEq) {
    return (v1, v2) => {
      if (Object.is(v1, v2))
        return true;
      const iter1 = v1[Symbol.iterator]();
      const iter2 = v2[Symbol.iterator]();
      while (true) {
        const value1 = iter1.next();
        const value2 = iter2.next();
        if (value1.done || value2.done)
          return value1.done === value2.done;
        if (!itemEq(value1.value, value2.value))
          return false;
      }
    };
  }
  const _iterableAnyEq = createIterableEq(defaultEq());
  function iterableEq(itemEq) {
    if (void 0 === itemEq)
      return _iterableAnyEq;
    return createIterableEq(itemEq);
  }
  Eq2.iterableEq = iterableEq;
  function createObjectEq(valueEq) {
    return (v1, v2) => {
      if (Object.is(v1, v2))
        return true;
      if (v1.constructor !== v2.constructor)
        return false;
      for (const key in v1) {
        if (!(key in v2))
          return false;
      }
      for (const key in v2) {
        if (!(key in v1))
          return false;
      }
      for (const key in v1) {
        const value1 = v1[key];
        const value2 = v2[key];
        if (!valueEq(value1, value2))
          return false;
      }
      return true;
    };
  }
  const _objectEq = createObjectEq(defaultEq());
  function objectEq(valueEq) {
    if (void 0 === valueEq)
      return _objectEq;
    return createObjectEq(valueEq);
  }
  Eq2.objectEq = objectEq;
  function createAnyEq(mode) {
    const result = (v1, v2) => {
      if (Object.is(v1, v2))
        return true;
      const type1 = typeof v1;
      const type2 = typeof v2;
      if (type1 !== type2)
        return false;
      switch (type1) {
        case "undefined":
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "symbol":
        case "function":
          return Object.is(v1, v2);
        case "object": {
          if (v1 === null || v2 === null)
            return false;
          if (v1.constructor !== v2.constructor) {
            return false;
          }
          if (v1 instanceof Boolean || v1 instanceof Date || v1 instanceof Number || v1 instanceof String) {
            return _valueOfEq(v1, v2);
          }
          if (mode !== "FLAT") {
            if (Symbol.iterator in v1 && Symbol.iterator in v2) {
              if (mode === "SHALLOW") {
                return createIterableEq(_anyFlatEq)(v1, v2);
              }
              return createIterableEq(result)(v1, v2);
            }
            if (mode === "SHALLOW") {
              return createObjectEq(_anyFlatEq)(v1, v2);
            }
            return _objectEq(v1, v2);
          }
          return false;
        }
      }
    };
    return result;
  }
  function anyFlatEq() {
    return _anyFlatEq;
  }
  Eq2.anyFlatEq = anyFlatEq;
  function anyShallowEq() {
    return _anyShallowEq;
  }
  Eq2.anyShallowEq = anyShallowEq;
  function anyDeepEq() {
    return _anyDeepEq;
  }
  Eq2.anyDeepEq = anyDeepEq;
  const _defaultCollator = Intl.Collator("und");
  const _defaultStringCollatorEq = (v1, v2) => _defaultCollator.compare(v1, v2) === 0;
  function createStringCollatorEq(...args) {
    if (args.length === 0)
      return _defaultStringCollatorEq;
    const collator = Intl.Collator(...args);
    return (v1, v2) => collator.compare(v1, v2) === 0;
  }
  Eq2.createStringCollatorEq = createStringCollatorEq;
  const _stringCaseInsensitiveEq = createStringCollatorEq("und", {
    sensitivity: "accent"
  });
  function stringCaseInsentitiveEq() {
    return _stringCaseInsensitiveEq;
  }
  Eq2.stringCaseInsentitiveEq = stringCaseInsentitiveEq;
  const _stringCharCodeEq = (v1, v2) => {
    const len = v1.length;
    if (len !== v2.length)
      return false;
    let i = -1;
    while (++i < len) {
      if (v1.charCodeAt(i) !== v2.charCodeAt(i))
        return false;
    }
    return true;
  };
  function stringCharCodeEq() {
    return _stringCharCodeEq;
  }
  Eq2.stringCharCodeEq = stringCharCodeEq;
  const _anyToStringEq = (v1, v2) => convertAnyToString(v1) === convertAnyToString(v2);
  function anyToStringEq() {
    return _anyToStringEq;
  }
  Eq2.anyToStringEq = anyToStringEq;
  const _anyJsonEq = (v1, v2) => JSON.stringify(v1) === JSON.stringify(v2);
  function anyJsonEq() {
    return _anyJsonEq;
  }
  Eq2.anyJsonEq = anyJsonEq;
  function tupleSymmetric(eq = defaultEq()) {
    return (tup1, tup2) => eq(tup1[0], tup2[0]) && eq(tup1[1], tup2[1]) || eq(tup1[0], tup2[1]) && eq(tup1[1], tup2[0]);
  }
  Eq2.tupleSymmetric = tupleSymmetric;
})(Eq || (Eq = {}));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Eq
});
