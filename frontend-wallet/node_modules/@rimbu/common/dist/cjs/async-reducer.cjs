"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/async-reducer.mts
var async_reducer_exports = {};
__export(async_reducer_exports, {
  AsyncReducer: () => AsyncReducer
});
module.exports = __toCommonJS(async_reducer_exports);

// src/collect.mts
var CollectFun;
((CollectFun2) => {
  CollectFun2.Skip = Symbol("Skip");
})(CollectFun || (CollectFun = {}));

// src/comp.mts
var Comp;
((Comp2) => {
  const _anyFlatComp = createAnyComp("FLAT");
  const _anyShallowComp = createAnyComp("SHALLOW");
  const _anyDeepComp = createAnyComp("DEEP");
  function defaultComp() {
    return _anyDeepComp;
  }
  Comp2.defaultComp = defaultComp;
  const _numberComp = {
    isComparable(obj) {
      return typeof obj === "number";
    },
    compare(v1, v2) {
      if (Number.isFinite(v1) && Number.isFinite(v2)) {
        return v1 - v2;
      }
      if (Number.isNaN(v1)) {
        if (Number.isNaN(v2))
          return 0;
        if (v2 === Number.POSITIVE_INFINITY)
          return 1;
        if (v2 === Number.NEGATIVE_INFINITY)
          return -1;
        return -1;
      }
      if (v1 === Number.POSITIVE_INFINITY) {
        return v2 === Number.POSITIVE_INFINITY ? 0 : 1;
      }
      return v2 === Number.NEGATIVE_INFINITY ? 0 : -1;
    }
  };
  function numberComp() {
    return _numberComp;
  }
  Comp2.numberComp = numberComp;
  const _booleanComp = {
    isComparable(obj) {
      return typeof obj === "boolean";
    },
    compare(v1, v2) {
      return v1 === v2 ? 0 : v1 ? 1 : -1;
    }
  };
  function booleanComp() {
    return _booleanComp;
  }
  Comp2.booleanComp = booleanComp;
  const _bigIntComp = {
    isComparable(obj) {
      return typeof obj === "bigint";
    },
    compare(v1, v2) {
      const res = v1 - v2;
      if (res > 0)
        return 1;
      if (res < 0)
        return -1;
      return 0;
    }
  };
  function bigIntComp() {
    return _bigIntComp;
  }
  Comp2.bigIntComp = bigIntComp;
  const _defaultCollator = Intl.Collator("und");
  const _stringComp = {
    isComparable(obj) {
      return typeof obj === "string";
    },
    compare: _defaultCollator.compare
  };
  const _anyStringJSONComp = {
    isComparable(obj) {
      return true;
    },
    compare(v1, v2) {
      return _defaultCollator.compare(JSON.stringify(v1), JSON.stringify(v2));
    }
  };
  function anyStringJSONComp() {
    return _anyStringJSONComp;
  }
  Comp2.anyStringJSONComp = anyStringJSONComp;
  function stringComp(...args) {
    if (args.length === 0)
      return _stringComp;
    const collator = Intl.Collator(...args);
    return {
      isComparable(obj) {
        return typeof obj === "string";
      },
      compare: collator.compare
    };
  }
  Comp2.stringComp = stringComp;
  function stringCaseInsensitiveComp() {
    return stringComp("und", { sensitivity: "accent" });
  }
  Comp2.stringCaseInsensitiveComp = stringCaseInsensitiveComp;
  const _stringCharCodeComp = {
    isComparable(obj) {
      return typeof obj === "string";
    },
    compare(v1, v2) {
      const len = Math.min(v1.length, v2.length);
      let i = -1;
      while (++i < len) {
        const diff = v1.charCodeAt(i) - v2.charCodeAt(i);
        if (diff !== 0)
          return diff;
      }
      return v1.length - v2.length;
    }
  };
  function stringCharCodeComp() {
    return _stringCharCodeComp;
  }
  Comp2.stringCharCodeComp = stringCharCodeComp;
  const _anyToStringComp = {
    isComparable(obj) {
      return true;
    },
    compare(v1, v2) {
      return _defaultCollator.compare(
        Eq.convertAnyToString(v1),
        Eq.convertAnyToString(v2)
      );
    }
  };
  function anyToStringComp() {
    return _anyToStringComp;
  }
  Comp2.anyToStringComp = anyToStringComp;
  function createValueOfComp(cls, valueComp = anyShallowComp()) {
    return {
      isComparable(obj) {
        return obj instanceof cls;
      },
      compare(v1, v2) {
        return valueComp.compare(v1.valueOf(), v2.valueOf());
      }
    };
  }
  Comp2.createValueOfComp = createValueOfComp;
  const _DateComp = createValueOfComp(Date, _numberComp);
  function dateComp() {
    return _DateComp;
  }
  Comp2.dateComp = dateComp;
  function createIterableComp(itemComp) {
    return {
      isComparable(obj) {
        return typeof obj === "object" && obj !== null && Symbol.iterator in obj;
      },
      compare(v1, v2) {
        const iter1 = v1[Symbol.iterator]();
        const iter2 = v2[Symbol.iterator]();
        while (true) {
          const value1 = iter1.next();
          const value2 = iter2.next();
          if (value1.done)
            return value2.done ? 0 : -1;
          if (value2.done)
            return 1;
          const result = itemComp.compare(value1.value, value2.value);
          if (result !== 0)
            return result;
        }
      }
    };
  }
  const _iterableAnyComp = createIterableComp(
    Comp2.defaultComp()
  );
  function iterableComp(itemComp) {
    if (void 0 === itemComp)
      return _iterableAnyComp;
    return createIterableComp(itemComp);
  }
  Comp2.iterableComp = iterableComp;
  const _BooleanComp = createValueOfComp(Boolean, _booleanComp);
  const _NumberComp = createValueOfComp(Number, _numberComp);
  const _StringComp = createValueOfComp(String, _stringComp);
  const _wrappedComps = [
    _BooleanComp,
    _DateComp,
    _NumberComp,
    _StringComp
  ];
  function tryWrappedComp(v1, v2) {
    let i = -1;
    const len = _wrappedComps.length;
    while (++i < len) {
      const comp = _wrappedComps[i];
      if (comp.isComparable(v1) && comp.isComparable(v2)) {
        return comp.compare(v1, v2);
      }
    }
    return void 0;
  }
  function createObjectComp(keyComp = anyFlatComp(), valueComp = defaultComp()) {
    return {
      isComparable(obj) {
        return true;
      },
      compare(v1, v2) {
        const keys1 = Object.keys(v1);
        const keys2 = Object.keys(v2);
        if (keys1.length === 0) {
          return keys2.length === 0 ? 0 : -1;
        }
        if (keys2.length === 0) {
          return keys1.length === 0 ? 0 : 1;
        }
        keys1.sort(keyComp.compare);
        keys2.sort(keyComp.compare);
        const length = Math.min(keys1.length, keys2.length);
        for (let index = 0; index < length; index++) {
          const key1 = keys1[index];
          const key2 = keys2[index];
          const keyResult = keyComp.compare(key1, key2);
          if (keyResult !== 0)
            return keyResult;
          const value1 = v1[key1];
          const value2 = v2[key2];
          const valueResult = valueComp.compare(value1, value2);
          if (valueResult !== 0)
            return valueResult;
        }
        const keyDiff = keys1.length - keys2.length;
        return keyDiff;
      }
    };
  }
  const _objectAnyComp = createObjectComp();
  function objectComp(options) {
    if (void 0 === options)
      return _objectAnyComp;
    return createObjectComp(options.keyComp, options.valueComp);
  }
  Comp2.objectComp = objectComp;
  function createAnyComp(mode) {
    return {
      isComparable(obj) {
        return true;
      },
      compare(v1, v2) {
        if (Object.is(v1, v2))
          return 0;
        const type1 = typeof v1;
        const type2 = typeof v2;
        if (type1 !== type2) {
          return _anyToStringComp.compare(v1, v2);
        }
        switch (type1) {
          case "bigint":
            return _bigIntComp.compare(v1, v2);
          case "boolean":
            return _booleanComp.compare(v1, v2);
          case "number":
            return _numberComp.compare(v1, v2);
          case "string":
            return _stringComp.compare(v1, v2);
          case "object": {
            if (null === v1) {
              if (null === v2)
                return 0;
              return -1;
            }
            if (null === v2) {
              return 1;
            }
            const wrappedComp = tryWrappedComp(v1, v2);
            if (void 0 !== wrappedComp)
              return wrappedComp;
            if (mode !== "FLAT") {
              if (_iterableAnyComp.isComparable(v1) && _iterableAnyComp.isComparable(v2)) {
                if (mode === "SHALLOW") {
                  return iterableComp(_anyFlatComp).compare(v1, v2);
                }
                return iterableComp(this).compare(v1, v2);
              }
              if (mode === "SHALLOW") {
                return createObjectComp(_anyFlatComp, _anyFlatComp).compare(
                  v1,
                  v2
                );
              }
              return _objectAnyComp.compare(v1, v2);
            }
          }
        }
        return _anyToStringComp.compare(v1, v2);
      }
    };
  }
  function anyFlatComp() {
    return _anyFlatComp;
  }
  Comp2.anyFlatComp = anyFlatComp;
  function anyShallowComp() {
    return _anyShallowComp;
  }
  Comp2.anyShallowComp = anyShallowComp;
  function anyDeepComp() {
    return _anyDeepComp;
  }
  Comp2.anyDeepComp = anyDeepComp;
  function withUndefined(comp) {
    return {
      isComparable(obj) {
        return void 0 === obj || comp.isComparable(obj);
      },
      compare(v1, v2) {
        if (void 0 === v1) {
          if (void 0 === v2)
            return 0;
          return -1;
        }
        if (void 0 === v2)
          return 1;
        return comp.compare(v1, v2);
      }
    };
  }
  Comp2.withUndefined = withUndefined;
  function withNull(comp) {
    return {
      isComparable(obj) {
        return null === obj || comp.isComparable(obj);
      },
      compare(v1, v2) {
        if (null === v1) {
          if (null === v2)
            return 0;
          return -1;
        }
        if (null === v2)
          return 1;
        return comp.compare(v1, v2);
      }
    };
  }
  Comp2.withNull = withNull;
  function invert(comp) {
    return {
      compare(v1, v2) {
        return comp.compare(v2, v1);
      },
      isComparable: comp.isComparable
    };
  }
  Comp2.invert = invert;
  function toEq(comp) {
    return (v1, v2) => comp.compare(v1, v2) === 0;
  }
  Comp2.toEq = toEq;
})(Comp || (Comp = {}));

// src/eq.mts
var Eq;
((Eq4) => {
  function convertAnyToString(value) {
    if (typeof value !== "object" || null === value || !("toString" in value) || typeof value.toString !== "function" || value.toString !== Object.prototype.toString) {
      return String(value);
    }
    return JSON.stringify(value);
  }
  Eq4.convertAnyToString = convertAnyToString;
  const _anyFlatEq = createAnyEq("FLAT");
  const _anyShallowEq = createAnyEq("SHALLOW");
  const _anyDeepEq = createAnyEq("DEEP");
  function defaultEq() {
    return _anyDeepEq;
  }
  Eq4.defaultEq = defaultEq;
  Eq4.objectIs = Object.is;
  const _valueOfEq = (v1, v2) => Object.is(v1.valueOf(), v2.valueOf());
  function valueOfEq() {
    return _valueOfEq;
  }
  Eq4.valueOfEq = valueOfEq;
  function dateEq() {
    return _valueOfEq;
  }
  Eq4.dateEq = dateEq;
  function createIterableEq(itemEq) {
    return (v1, v2) => {
      if (Object.is(v1, v2))
        return true;
      const iter1 = v1[Symbol.iterator]();
      const iter2 = v2[Symbol.iterator]();
      while (true) {
        const value1 = iter1.next();
        const value2 = iter2.next();
        if (value1.done || value2.done)
          return value1.done === value2.done;
        if (!itemEq(value1.value, value2.value))
          return false;
      }
    };
  }
  const _iterableAnyEq = createIterableEq(defaultEq());
  function iterableEq(itemEq) {
    if (void 0 === itemEq)
      return _iterableAnyEq;
    return createIterableEq(itemEq);
  }
  Eq4.iterableEq = iterableEq;
  function createObjectEq(valueEq) {
    return (v1, v2) => {
      if (Object.is(v1, v2))
        return true;
      if (v1.constructor !== v2.constructor)
        return false;
      for (const key in v1) {
        if (!(key in v2))
          return false;
      }
      for (const key in v2) {
        if (!(key in v1))
          return false;
      }
      for (const key in v1) {
        const value1 = v1[key];
        const value2 = v2[key];
        if (!valueEq(value1, value2))
          return false;
      }
      return true;
    };
  }
  const _objectEq = createObjectEq(defaultEq());
  function objectEq(valueEq) {
    if (void 0 === valueEq)
      return _objectEq;
    return createObjectEq(valueEq);
  }
  Eq4.objectEq = objectEq;
  function createAnyEq(mode) {
    const result = (v1, v2) => {
      if (Object.is(v1, v2))
        return true;
      const type1 = typeof v1;
      const type2 = typeof v2;
      if (type1 !== type2)
        return false;
      switch (type1) {
        case "undefined":
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "symbol":
        case "function":
          return Object.is(v1, v2);
        case "object": {
          if (v1 === null || v2 === null)
            return false;
          if (v1.constructor !== v2.constructor) {
            return false;
          }
          if (v1 instanceof Boolean || v1 instanceof Date || v1 instanceof Number || v1 instanceof String) {
            return _valueOfEq(v1, v2);
          }
          if (mode !== "FLAT") {
            if (Symbol.iterator in v1 && Symbol.iterator in v2) {
              if (mode === "SHALLOW") {
                return createIterableEq(_anyFlatEq)(v1, v2);
              }
              return createIterableEq(result)(v1, v2);
            }
            if (mode === "SHALLOW") {
              return createObjectEq(_anyFlatEq)(v1, v2);
            }
            return _objectEq(v1, v2);
          }
          return false;
        }
      }
    };
    return result;
  }
  function anyFlatEq() {
    return _anyFlatEq;
  }
  Eq4.anyFlatEq = anyFlatEq;
  function anyShallowEq() {
    return _anyShallowEq;
  }
  Eq4.anyShallowEq = anyShallowEq;
  function anyDeepEq() {
    return _anyDeepEq;
  }
  Eq4.anyDeepEq = anyDeepEq;
  const _defaultCollator = Intl.Collator("und");
  const _defaultStringCollatorEq = (v1, v2) => _defaultCollator.compare(v1, v2) === 0;
  function createStringCollatorEq(...args) {
    if (args.length === 0)
      return _defaultStringCollatorEq;
    const collator = Intl.Collator(...args);
    return (v1, v2) => collator.compare(v1, v2) === 0;
  }
  Eq4.createStringCollatorEq = createStringCollatorEq;
  const _stringCaseInsensitiveEq = createStringCollatorEq("und", {
    sensitivity: "accent"
  });
  function stringCaseInsentitiveEq() {
    return _stringCaseInsensitiveEq;
  }
  Eq4.stringCaseInsentitiveEq = stringCaseInsentitiveEq;
  const _stringCharCodeEq = (v1, v2) => {
    const len = v1.length;
    if (len !== v2.length)
      return false;
    let i = -1;
    while (++i < len) {
      if (v1.charCodeAt(i) !== v2.charCodeAt(i))
        return false;
    }
    return true;
  };
  function stringCharCodeEq() {
    return _stringCharCodeEq;
  }
  Eq4.stringCharCodeEq = stringCharCodeEq;
  const _anyToStringEq = (v1, v2) => convertAnyToString(v1) === convertAnyToString(v2);
  function anyToStringEq() {
    return _anyToStringEq;
  }
  Eq4.anyToStringEq = anyToStringEq;
  const _anyJsonEq = (v1, v2) => JSON.stringify(v1) === JSON.stringify(v2);
  function anyJsonEq() {
    return _anyJsonEq;
  }
  Eq4.anyJsonEq = anyJsonEq;
  function tupleSymmetric(eq = defaultEq()) {
    return (tup1, tup2) => eq(tup1[0], tup2[0]) && eq(tup1[1], tup2[1]) || eq(tup1[0], tup2[1]) && eq(tup1[1], tup2[0]);
  }
  Eq4.tupleSymmetric = tupleSymmetric;
})(Eq || (Eq = {}));

// src/err.mts
var ErrBase;
((ErrBase2) => {
  class CustomError {
    constructor(message) {
      this.message = message;
    }
    get name() {
      return this.constructor.name;
    }
  }
  ErrBase2.CustomError = CustomError;
  class ForcedError extends CustomError {
  }
  ErrBase2.ForcedError = ForcedError;
  function msg(message) {
    return function() {
      throw new ErrBase2.ForcedError(message);
    };
  }
  ErrBase2.msg = msg;
})(ErrBase || (ErrBase = {}));

// src/index-range.mts
var IndexRange;
((IndexRange2) => {
  function getIndexRangeIndices(range) {
    if (void 0 !== range.amount) {
      if (void 0 === range.start)
        return [0, range.amount - 1];
      if (Array.isArray(range.start)) {
        const [start2, includeStart] = range.start;
        if (includeStart)
          return [start2, start2 + range.amount - 1];
        return [start2 + 1, start2 + 1 + range.amount - 1];
      }
      return [range.start, range.start + range.amount - 1];
    }
    let start = 0;
    let end = void 0;
    if (`start` in range) {
      if (Array.isArray(range.start)) {
        if (range.start[1])
          start = range.start[0];
        else
          start = range.start[0] + 1;
      } else
        start = range.start ?? 0;
    }
    if (`end` in range) {
      if (Array.isArray(range.end)) {
        if (range.end[1])
          end = range.end[0];
        else
          end = range.end[0] - 1;
      } else
        end = range.end;
    }
    return [start, end];
  }
  IndexRange2.getIndexRangeIndices = getIndexRangeIndices;
  function getIndicesFor(range, length) {
    if (length <= 0)
      return "empty";
    let start = 0;
    let end = length - 1;
    if (void 0 !== range.start) {
      if (Array.isArray(range.start)) {
        start = range.start[0];
        if (!range.start[1])
          start++;
      } else
        start = range.start;
      if (start >= length || -start > length)
        return "empty";
      if (start < 0)
        start = length + start;
    }
    if (void 0 !== range.amount) {
      if (range.amount <= 0)
        return "empty";
      if (void 0 === range.start) {
        if (range.amount >= length)
          return "all";
        return [0, Math.min(end, range.amount - 1)];
      }
      end = start + range.amount - 1;
    } else if (void 0 !== range.end) {
      if (Array.isArray(range.end)) {
        end = range.end[0];
        if (!range.end[1]) {
          if (end === 0)
            return "empty";
          end--;
        }
      } else
        end = range.end;
      if (end < 0)
        end = length + end;
    }
    if (end < start)
      return "empty";
    end = Math.min(length - 1, end);
    if (start === 0 && end === length - 1)
      return "all";
    return [start, end];
  }
  IndexRange2.getIndicesFor = getIndicesFor;
})(IndexRange || (IndexRange = {}));

// src/optlazy.mts
function OptLazy(optLazy) {
  if (optLazy instanceof Function)
    return optLazy();
  return optLazy;
}

// src/range.mts
var Range;
((Range2) => {
  function getNormalizedRange(range) {
    let start = void 0;
    let end = void 0;
    if (`start` in range && void 0 !== range.start) {
      if (Array.isArray(range.start) && range.start.length === 2 && typeof range.start[1] === "boolean") {
        start = range.start;
      } else {
        start = [range.start, true];
      }
    }
    if (`end` in range && void 0 !== range.end) {
      if (Array.isArray(range.end) && range.end.length === 2 && typeof range.end[1] === "boolean") {
        end = range.end;
      } else {
        end = [range.end, true];
      }
    }
    return { start, end };
  }
  Range2.getNormalizedRange = getNormalizedRange;
})(Range || (Range = {}));

// src/reducer.mts
function identity(value) {
  return value;
}
var Reducer;
((Reducer3) => {
  class Base {
    constructor(init, next, stateToResult) {
      this.init = init;
      this.next = next;
      this.stateToResult = stateToResult;
    }
    filterInput(pred) {
      return create(
        () => ({
          nextIndex: 0,
          state: OptLazy(this.init)
        }),
        (state, elem, index, halt) => {
          if (pred(elem, index, halt)) {
            state.state = this.next(state.state, elem, state.nextIndex++, halt);
          }
          return state;
        },
        (state) => this.stateToResult(state.state)
      );
    }
    mapInput(mapFun) {
      return create(
        this.init,
        (state, elem, index, halt) => this.next(state, mapFun(elem, index), index, halt),
        this.stateToResult
      );
    }
    collectInput(collectFun) {
      return create(
        () => ({
          nextIndex: 0,
          state: OptLazy(this.init)
        }),
        (state, elem, index, halt) => {
          const nextElem = collectFun(elem, index, CollectFun.Skip, halt);
          if (CollectFun.Skip !== nextElem) {
            state.state = this.next(
              state.state,
              nextElem,
              state.nextIndex++,
              halt
            );
          }
          return state;
        },
        (state) => this.stateToResult(state.state)
      );
    }
    mapOutput(mapFun) {
      return create(
        this.init,
        this.next,
        (state) => mapFun(this.stateToResult(state))
      );
    }
    takeInput(amount) {
      if (amount <= 0) {
        return create(this.init, identity, this.stateToResult);
      }
      return this.filterInput((_, i, halt) => {
        const more = i < amount;
        if (!more)
          halt();
        return more;
      });
    }
    dropInput(amount) {
      if (amount <= 0)
        return this;
      return this.filterInput((_, i) => i >= amount);
    }
    sliceInput(from = 0, amount) {
      if (void 0 === amount)
        return this.dropInput(from);
      if (amount <= 0)
        return create(this.init, identity, this.stateToResult);
      if (from <= 0)
        return this.takeInput(amount);
      return this.takeInput(amount).dropInput(from);
    }
  }
  Reducer3.Base = Base;
  function create(init, next, stateToResult) {
    return new Reducer3.Base(init, next, stateToResult);
  }
  Reducer3.create = create;
  function createMono(init, next, stateToResult) {
    return create(init, next, stateToResult ?? identity);
  }
  Reducer3.createMono = createMono;
  function createOutput(init, next, stateToResult) {
    return create(init, next, stateToResult ?? identity);
  }
  Reducer3.createOutput = createOutput;
  Reducer3.sum = createMono(0, (state, next) => state + next);
  Reducer3.product = createMono(1, (state, next, _, halt) => {
    if (0 === next)
      halt();
    return state * next;
  });
  Reducer3.average = createMono(
    0,
    (avg, value, index) => avg + (value - avg) / (index + 1)
  );
  Reducer3.minBy = (compFun, otherwise) => {
    const token = Symbol();
    return create(
      token,
      (state, next) => {
        if (token === state)
          return next;
        return compFun(state, next) < 0 ? state : next;
      },
      (state) => token === state ? OptLazy(otherwise) : state
    );
  };
  Reducer3.min = (otherwise) => {
    return create(
      void 0,
      (state, next) => void 0 !== state && state < next ? state : next,
      (state) => state ?? OptLazy(otherwise)
    );
  };
  Reducer3.maxBy = (compFun, otherwise) => {
    const token = Symbol();
    return create(
      token,
      (state, next) => {
        if (token === state)
          return next;
        return compFun(state, next) > 0 ? state : next;
      },
      (state) => token === state ? OptLazy(otherwise) : state
    );
  };
  Reducer3.max = (otherwise) => {
    return create(
      void 0,
      (state, next) => void 0 !== state && state > next ? state : next,
      (state) => state ?? OptLazy(otherwise)
    );
  };
  function join({
    sep = "",
    start = "",
    end = "",
    valueToString = String
  } = {}) {
    let curSep = "";
    let curStart = start;
    return create(
      "",
      (state, next) => {
        const result = curStart.concat(state, curSep, valueToString(next));
        curSep = sep;
        curStart = "";
        return result;
      },
      (state) => state.concat(end)
    );
  }
  Reducer3.join = join;
  Reducer3.count = (pred) => {
    if (void 0 === pred)
      return createOutput(0, (_, __, i) => i + 1);
    return createOutput(0, (state, next, i) => {
      if (pred?.(next, i))
        return state + 1;
      return state;
    });
  };
  Reducer3.firstWhere = (pred, otherwise) => {
    const token = Symbol();
    return create(
      token,
      (state, next, i, halt) => {
        if (token === state && pred(next, i)) {
          halt();
          return next;
        }
        return state;
      },
      (state) => token === state ? OptLazy(otherwise) : state
    );
  };
  Reducer3.first = (otherwise) => {
    const token = Symbol();
    return create(
      token,
      (state, next, _, halt) => {
        halt();
        if (token === state)
          return next;
        return state;
      },
      (state) => token === state ? OptLazy(otherwise) : state
    );
  };
  Reducer3.lastWhere = (pred, otherwise) => {
    const token = Symbol();
    return create(
      token,
      (state, next, i) => {
        if (pred(next, i))
          return next;
        return state;
      },
      (state) => token === state ? OptLazy(otherwise) : state
    );
  };
  Reducer3.last = (otherwise) => {
    const token = Symbol();
    return create(
      () => token,
      (_, next) => next,
      (state) => token === state ? OptLazy(otherwise) : state
    );
  };
  function some(pred) {
    return createOutput(false, (state, next, i, halt) => {
      if (state)
        return state;
      const satisfies = pred(next, i);
      if (satisfies) {
        halt();
      }
      return satisfies;
    });
  }
  Reducer3.some = some;
  function every(pred) {
    return createOutput(true, (state, next, i, halt) => {
      if (!state)
        return state;
      const satisfies = pred(next, i);
      if (!satisfies) {
        halt();
      }
      return satisfies;
    });
  }
  Reducer3.every = every;
  function contains(elem, eq = Object.is) {
    return createOutput(false, (state, next, _, halt) => {
      if (state)
        return state;
      const satisfies = eq(next, elem);
      if (satisfies) {
        halt();
      }
      return satisfies;
    });
  }
  Reducer3.contains = contains;
  Reducer3.and = createMono(true, (state, next, _, halt) => {
    if (!state)
      return state;
    if (!next)
      halt();
    return next;
  });
  Reducer3.or = createMono(false, (state, next, _, halt) => {
    if (state)
      return state;
    if (next)
      halt();
    return next;
  });
  Reducer3.isEmpty = createOutput(
    true,
    (_, __, ___, halt) => {
      halt();
      return false;
    }
  );
  Reducer3.nonEmpty = createOutput(
    false,
    (_, __, ___, halt) => {
      halt();
      return true;
    }
  );
  function toArray() {
    return create(
      () => [],
      (state, next) => {
        state.push(next);
        return state;
      },
      (state) => state.slice()
    );
  }
  Reducer3.toArray = toArray;
  function toJSMap() {
    return create(
      () => /* @__PURE__ */ new Map(),
      (state, next) => {
        state.set(next[0], next[1]);
        return state;
      },
      (s) => new Map(s)
    );
  }
  Reducer3.toJSMap = toJSMap;
  function toJSSet() {
    return create(
      () => /* @__PURE__ */ new Set(),
      (state, next) => {
        state.add(next);
        return state;
      },
      (s) => new Set(s)
    );
  }
  Reducer3.toJSSet = toJSSet;
  function toJSObject() {
    return create(
      () => ({}),
      (state, entry) => {
        state[entry[0]] = entry[1];
        return state;
      },
      (s) => ({ ...s })
    );
  }
  Reducer3.toJSObject = toJSObject;
  function combineArr(...reducers) {
    const createState = () => {
      return reducers.map((reducer) => {
        const result = {
          reducer,
          halted: false,
          halt() {
            result.halted = true;
          },
          state: OptLazy(reducer.init)
        };
        return result;
      });
    };
    return create(
      createState,
      (allState, next, index, halt) => {
        let anyNotHalted = false;
        let i = -1;
        const len = allState.length;
        while (++i < len) {
          const red = allState[i];
          if (red.halted) {
            continue;
          }
          red.state = red.reducer.next(red.state, next, index, red.halt);
          if (!red.halted) {
            anyNotHalted = true;
          }
        }
        if (!anyNotHalted) {
          halt();
        }
        return allState;
      },
      (allState) => allState.map((st) => st.reducer.stateToResult(st.state))
    );
  }
  Reducer3.combineArr = combineArr;
  function combineObj(reducerObj) {
    const createState = () => {
      const allState = {};
      for (const key in reducerObj) {
        const reducer = reducerObj[key];
        const result = {
          reducer,
          halted: false,
          halt() {
            result.halted = true;
          },
          state: OptLazy(reducer.init)
        };
        allState[key] = result;
      }
      return allState;
    };
    return create(
      createState,
      (allState, next, index, halt) => {
        let anyNotHalted = false;
        for (const key in allState) {
          const red = allState[key];
          if (red.halted) {
            continue;
          }
          red.state = red.reducer.next(red.state, next, index, red.halt);
          if (!red.halted) {
            anyNotHalted = true;
          }
        }
        if (!anyNotHalted) {
          halt();
        }
        return allState;
      },
      (allState) => {
        const result = {};
        for (const key in allState) {
          const st = allState[key];
          result[key] = st.reducer.stateToResult(st.state);
        }
        return result;
      }
    );
  }
  Reducer3.combineObj = combineObj;
})(Reducer || (Reducer = {}));

// src/async-optlazy.mts
var AsyncOptLazy;
((AsyncOptLazy2) => {
  function toMaybePromise(optLazy) {
    if (optLazy instanceof Function)
      return optLazy();
    return optLazy;
  }
  AsyncOptLazy2.toMaybePromise = toMaybePromise;
  async function toPromise(optLazy) {
    if (optLazy instanceof Function)
      return optLazy();
    return optLazy;
  }
  AsyncOptLazy2.toPromise = toPromise;
})(AsyncOptLazy || (AsyncOptLazy = {}));

// src/async-reducer.mts
function identity2(value) {
  return value;
}
var AsyncReducer;
((AsyncReducer2) => {
  class Base {
    constructor(init, next, stateToResult, onClose) {
      this.init = init;
      this.next = next;
      this.stateToResult = stateToResult;
      this.onClose = onClose;
    }
    filterInput(pred) {
      return create(
        async () => ({
          nextIndex: 0,
          state: await AsyncOptLazy.toMaybePromise(this.init)
        }),
        async (state, elem, index, halt) => {
          if (pred(elem, index, halt)) {
            state.state = await this.next(
              state.state,
              elem,
              state.nextIndex++,
              halt
            );
          }
          return state;
        },
        (state) => this.stateToResult(state.state),
        (state, error) => this.onClose?.(state.state, error)
      );
    }
    mapInput(mapFun) {
      return create(
        this.init,
        async (state, elem, index, halt) => this.next(state, await mapFun(elem, index), index, halt),
        this.stateToResult,
        this.onClose
      );
    }
    collectInput(collectFun) {
      return create(
        async () => ({
          nextIndex: 0,
          state: await AsyncOptLazy.toMaybePromise(this.init)
        }),
        async (state, elem, index, halt) => {
          const nextElem = await collectFun(elem, index, CollectFun.Skip, halt);
          if (CollectFun.Skip !== nextElem) {
            state.state = await this.next(
              state.state,
              nextElem,
              state.nextIndex++,
              halt
            );
          }
          return state;
        },
        (state) => this.stateToResult(state.state),
        (state, error) => this.onClose?.(state.state, error)
      );
    }
    mapOutput(mapFun) {
      return create(
        this.init,
        this.next,
        async (state) => mapFun(await this.stateToResult(state)),
        this.onClose
      );
    }
    takeInput(amount) {
      if (amount <= 0) {
        return create(this.init, identity2, this.stateToResult);
      }
      return this.filterInput((_, i, halt) => {
        const more = i < amount;
        if (!more)
          halt();
        return more;
      });
    }
    dropInput(amount) {
      if (amount <= 0) {
        return this;
      }
      return this.filterInput((_, i) => i >= amount);
    }
    sliceInput(from2 = 0, amount) {
      if (void 0 === amount)
        return this.dropInput(from2);
      if (amount <= 0)
        return create(this.init, identity2, this.stateToResult);
      if (from2 <= 0)
        return this.takeInput(amount);
      return this.takeInput(amount).dropInput(from2);
    }
  }
  AsyncReducer2.Base = Base;
  function create(init, next, stateToResult, onClose) {
    return new AsyncReducer2.Base(
      init,
      next,
      stateToResult,
      onClose
    );
  }
  AsyncReducer2.create = create;
  function createMono(init, next, stateToResult, onClose) {
    return create(init, next, stateToResult ?? identity2, onClose);
  }
  AsyncReducer2.createMono = createMono;
  function createOutput(init, next, stateToResult, onClose) {
    return create(init, next, stateToResult ?? identity2, onClose);
  }
  AsyncReducer2.createOutput = createOutput;
  function from(reducer) {
    return AsyncReducer2.create(
      reducer.init,
      reducer.next,
      reducer.stateToResult
    );
  }
  AsyncReducer2.from = from;
  AsyncReducer2.sum = createMono(0, (state, next) => state + next);
  AsyncReducer2.product = createMono(1, (state, next, _, halt) => {
    if (0 === next)
      halt();
    return state * next;
  });
  AsyncReducer2.average = createMono(
    0,
    (avg, value, index) => avg + (value - avg) / (index + 1)
  );
  AsyncReducer2.minBy = (compFun, otherwise) => {
    const token = Symbol();
    return create(
      token,
      async (state, next) => {
        if (token === state)
          return next;
        return await compFun(state, next) < 0 ? state : next;
      },
      (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state
    );
  };
  AsyncReducer2.min = (otherwise) => {
    return create(
      void 0,
      (state, next) => void 0 !== state && state < next ? state : next,
      (state) => state ?? AsyncOptLazy.toMaybePromise(otherwise)
    );
  };
  AsyncReducer2.maxBy = (compFun, otherwise) => {
    const token = Symbol();
    return create(
      token,
      async (state, next) => {
        if (token === state)
          return next;
        return await compFun(state, next) > 0 ? state : next;
      },
      (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state
    );
  };
  AsyncReducer2.max = (otherwise) => {
    return create(
      void 0,
      (state, next) => void 0 !== state && state > next ? state : next,
      (state) => state ?? AsyncOptLazy.toMaybePromise(otherwise)
    );
  };
  function join({
    sep = "",
    start = "",
    end = "",
    valueToString = String
  } = {}) {
    let curSep = "";
    let curStart = start;
    return create(
      "",
      (state, next) => {
        const result = curStart.concat(state, curSep, valueToString(next));
        curSep = sep;
        curStart = "";
        return result;
      },
      (state) => state.concat(end)
    );
  }
  AsyncReducer2.join = join;
  AsyncReducer2.count = (pred) => {
    if (void 0 === pred)
      return createOutput(0, (_, __, i) => i + 1);
    return createOutput(0, async (state, next, i) => {
      if (await pred?.(next, i))
        return state + 1;
      return state;
    });
  };
  AsyncReducer2.firstWhere = (pred, otherwise) => {
    const token = Symbol();
    return create(
      token,
      async (state, next, i, halt) => {
        if (token === state && await pred(next, i)) {
          halt();
          return next;
        }
        return state;
      },
      (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state
    );
  };
  AsyncReducer2.first = (otherwise) => {
    const token = Symbol();
    return create(
      token,
      (state, next, _, halt) => {
        halt();
        if (token === state)
          return next;
        return state;
      },
      (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state
    );
  };
  AsyncReducer2.lastWhere = (pred, otherwise) => {
    const token = Symbol();
    return create(
      token,
      async (state, next, i) => {
        if (await pred(next, i))
          return next;
        return state;
      },
      (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state
    );
  };
  AsyncReducer2.last = (otherwise) => {
    const token = Symbol();
    return create(
      () => token,
      (_, next) => next,
      (state) => token === state ? AsyncOptLazy.toMaybePromise(otherwise) : state
    );
  };
  function some(pred) {
    return createOutput(
      false,
      async (state, next, i, halt) => {
        if (state)
          return state;
        const satisfies = await pred(next, i);
        if (satisfies) {
          halt();
        }
        return satisfies;
      }
    );
  }
  AsyncReducer2.some = some;
  function every(pred) {
    return createOutput(
      true,
      async (state, next, i, halt) => {
        if (!state)
          return state;
        const satisfies = await pred(next, i);
        if (!satisfies) {
          halt();
        }
        return satisfies;
      }
    );
  }
  AsyncReducer2.every = every;
  function contains(elem, eq = Object.is) {
    return createOutput(false, (state, next, _, halt) => {
      if (state)
        return state;
      const satisfies = eq(next, elem);
      if (satisfies) {
        halt();
      }
      return satisfies;
    });
  }
  AsyncReducer2.contains = contains;
  AsyncReducer2.and = createMono(true, (state, next, _, halt) => {
    if (!state)
      return state;
    if (!next)
      halt();
    return next;
  });
  AsyncReducer2.or = createMono(false, (state, next, _, halt) => {
    if (state)
      return state;
    if (next)
      halt();
    return next;
  });
  AsyncReducer2.isEmpty = createOutput(
    true,
    (_, __, ___, halt) => {
      halt();
      return false;
    }
  );
  AsyncReducer2.nonEmpty = createOutput(
    false,
    (_, __, ___, halt) => {
      halt();
      return true;
    }
  );
  function toArray() {
    return create(
      () => [],
      (state, next) => {
        state.push(next);
        return state;
      },
      (state) => state.slice()
    );
  }
  AsyncReducer2.toArray = toArray;
  function toJSMap() {
    return create(
      () => /* @__PURE__ */ new Map(),
      (state, next) => {
        state.set(next[0], next[1]);
        return state;
      },
      (s) => new Map(s)
    );
  }
  AsyncReducer2.toJSMap = toJSMap;
  function toJSSet() {
    return create(
      () => /* @__PURE__ */ new Set(),
      (state, next) => {
        state.add(next);
        return state;
      },
      (s) => new Set(s)
    );
  }
  AsyncReducer2.toJSSet = toJSSet;
  function toJSObject() {
    return create(
      () => ({}),
      (state, entry) => {
        state[entry[0]] = entry[1];
        return state;
      },
      (s) => ({ ...s })
    );
  }
  AsyncReducer2.toJSObject = toJSObject;
  function combineArr(...reducers) {
    const createState = () => {
      return Promise.all(
        reducers.map(async (reducer) => {
          const result = {
            reducer,
            halted: false,
            halt() {
              result.halted = true;
            },
            state: await AsyncOptLazy.toMaybePromise(reducer.init)
          };
          return result;
        })
      );
    };
    return create(
      createState,
      async (allState, next, index, halt) => {
        let anyNotHalted = false;
        await Promise.all(
          allState.map(async (red) => {
            if (red.halted)
              return;
            red.state = await red.reducer.next(
              red.state,
              next,
              index,
              red.halt
            );
            if (!red.halted)
              anyNotHalted = true;
          })
        );
        if (!anyNotHalted)
          halt();
        return allState;
      },
      (allState) => Promise.all(
        allState.map((st) => st.reducer.stateToResult(st.state))
      )
    );
  }
  AsyncReducer2.combineArr = combineArr;
  function combineObj(reducerObj) {
    const createState = async () => {
      const entries = await Promise.all(
        Object.entries(reducerObj).map(async ([key, reducer]) => {
          const result = {
            reducer,
            halted: false,
            halt() {
              result.halted = true;
            },
            state: await AsyncOptLazy.toMaybePromise(reducer.init)
          };
          return [key, result];
        })
      );
      return Object.fromEntries(entries);
    };
    return create(
      createState,
      async (allState, next, index, halt) => {
        let anyNotHalted = false;
        await Promise.all(
          Object.values(allState).map(async (red) => {
            if (red.halted) {
              return;
            }
            red.state = await red.reducer.next(
              red.state,
              next,
              index,
              red.halt
            );
            if (!red.halted) {
              anyNotHalted = true;
            }
          })
        );
        if (!anyNotHalted) {
          halt();
        }
        return allState;
      },
      async (allState) => {
        const entries = await Promise.all(
          Object.entries(allState).map(
            async ([key, st]) => [key, await st.reducer.stateToResult(st.state)]
          )
        );
        return Object.fromEntries(entries);
      }
    );
  }
  AsyncReducer2.combineObj = combineObj;
})(AsyncReducer || (AsyncReducer = {}));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AsyncReducer
});
