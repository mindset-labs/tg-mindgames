import type { IndexRange, TraverseState, Update } from '@rimbu/common';
import type { Stream } from '@rimbu/stream';
import type { Block, BlockBuilder, ListContext, NonLeaf, NonLeafBlock, NonLeafBuilder, Tree } from '@rimbu/list/custom';
export declare class NonLeafTree<T, C extends Block<T, C>> implements Tree<T, NonLeafTree<T, C>, NonLeafBlock<T, C>, C>, NonLeaf<T> {
    readonly context: ListContext;
    readonly left: NonLeafBlock<T, C>;
    readonly right: NonLeafBlock<T, C>;
    readonly middle: NonLeaf<T, NonLeafBlock<T, C>> | null;
    readonly level: number;
    readonly length: number;
    constructor(context: ListContext, left: NonLeafBlock<T, C>, right: NonLeafBlock<T, C>, middle: NonLeaf<T, NonLeafBlock<T, C>> | null, level: number, length?: number);
    getChildLength(child: C): number;
    copy(left?: NonLeafBlock<T, C>, right?: NonLeafBlock<T, C>, middle?: NonLeaf<T, NonLeafBlock<T, C>> | null): NonLeafTree<T, C>;
    copy2<T2, C2 extends Block<T2, C2>>(left: NonLeafBlock<T2, C2>, right: NonLeafBlock<T2, C2>, middle: NonLeaf<T2, NonLeafBlock<T2, C2>> | null): NonLeafTree<T2, C2>;
    stream(reversed?: boolean): Stream.NonEmpty<T>;
    streamRange(range: IndexRange, reversed?: boolean): Stream<T>;
    get(index: number): T;
    prepend(child: C): NonLeafTree<T, C>;
    append(child: C): NonLeafTree<T, C>;
    prependMiddle(child: NonLeafBlock<T, C>): NonLeaf<T, NonLeafBlock<T, C>>;
    appendMiddle(child: NonLeafBlock<T, C>): NonLeaf<T, NonLeafBlock<T, C>>;
    dropFirst(): [NonLeaf<T, C> | null, C];
    dropLast(): [NonLeaf<T, C> | null, C];
    takeInternal(amount: number): [NonLeaf<T, C> | null, C, number];
    dropInternal(amount: number): [NonLeaf<T, C> | null, C, number];
    concat<T2>(other: NonLeaf<T2, C>): NonLeaf<T | T2, C>;
    concatBlock(other: NonLeafBlock<T, C>): NonLeaf<T, C>;
    concatTree(other: NonLeafTree<T, C>): NonLeaf<T, C>;
    updateAt(index: number, update: Update<T>): NonLeafTree<T, C>;
    forEach(f: (value: T, index: number, halt: () => void) => void, state: TraverseState): void;
    mapPure<T2>(mapFun: (value: T) => T2, reversed?: boolean, cacheMap?: import("@rimbu/list/custom").CacheMap): NonLeafTree<T2, any>;
    map<T2>(mapFun: (value: T, index: number) => T2, reversed?: boolean, indexOffset?: number): NonLeafTree<T2, any>;
    reversed(cacheMap?: import("@rimbu/list/custom").CacheMap): NonLeafTree<T, C>;
    _normalize(): NonLeaf<T, C>;
    toArray(range?: IndexRange, reversed?: boolean): T[] | any;
    structure(): string;
    createNonLeafBuilder(): NonLeafBuilder<T, BlockBuilder<T, unknown>>;
}
