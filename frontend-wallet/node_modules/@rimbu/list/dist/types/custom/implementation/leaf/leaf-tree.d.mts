import { OptLazy, TraverseState, type ArrayNonEmpty, type IndexRange, type Update } from '@rimbu/common';
import type { Stream, StreamSource } from '@rimbu/stream';
import type { LeafBlock, ListContext, NonLeaf, Tree } from '@rimbu/list/custom';
import type { List } from '@rimbu/list';
import { ListNonEmptyBase } from './non-empty.mjs';
export declare class LeafTree<T> extends ListNonEmptyBase<T> implements Tree<T, LeafTree<T>, LeafBlock<T>, T> {
    readonly context: ListContext;
    readonly left: LeafBlock<T>;
    readonly right: LeafBlock<T>;
    readonly middle: NonLeaf<T, LeafBlock<T>> | null;
    readonly length: number;
    constructor(context: ListContext, left: LeafBlock<T>, right: LeafBlock<T>, middle: NonLeaf<T, LeafBlock<T>> | null, length?: number);
    getChildLength(): 1;
    copy(left?: LeafBlock<T>, right?: LeafBlock<T>, middle?: NonLeaf<T, LeafBlock<T>> | null): LeafTree<T>;
    copy2<T2>(left: LeafBlock<T2>, right: LeafBlock<T2>, middle: NonLeaf<T2, LeafBlock<T2>> | null): LeafTree<T2>;
    stream(reversed?: boolean): Stream.NonEmpty<T>;
    streamRange(range: IndexRange, reversed?: boolean): Stream<T>;
    get<O>(index: number, otherwise?: OptLazy<O>): T | O;
    prepend(value: T): LeafTree<T>;
    append(value: T): LeafTree<T>;
    prependMiddle(child: LeafBlock<T>): NonLeaf<T, LeafBlock<T>>;
    appendMiddle(child: LeafBlock<T>): NonLeaf<T, LeafBlock<T>>;
    take(amountInput: number): List<T> | any;
    drop(amount: number): List<T>;
    concat<T2>(...sources: ArrayNonEmpty<StreamSource<T2>>): List.NonEmpty<T | T2>;
    concatBlock(other: LeafBlock<T>): List.NonEmpty<T>;
    concatTree(other: LeafTree<T>): LeafTree<T>;
    updateAt(index: number, update: Update<T>): LeafTree<T>;
    forEach(f: (value: T, index: number, halt: () => void) => void, state?: TraverseState): void;
    mapPure<T2>(mapFun: (value: T) => T2, reversed?: boolean, cacheMap?: import("@rimbu/list/custom").CacheMap): LeafTree<T2>;
    map<T2>(mapFun: (value: T, index: number) => T2, reversed?: boolean, indexOffset?: number): LeafTree<T2>;
    reversed(cacheMap?: import("@rimbu/list/custom").CacheMap): LeafTree<T>;
    toArray(range?: IndexRange, reversed?: boolean): T[] | any;
    _normalize(): List.NonEmpty<T>;
    structure(): string;
}
