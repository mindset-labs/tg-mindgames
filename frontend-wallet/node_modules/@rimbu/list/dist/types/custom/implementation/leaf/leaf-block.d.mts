import { type ArrayNonEmpty, IndexRange, OptLazy, TraverseState, Update } from '@rimbu/common';
import { Stream, type StreamSource } from '@rimbu/stream';
import type { List } from '@rimbu/list';
import type { Block, BlockBuilder, LeafTree, ListContext } from '@rimbu/list/custom';
import { ListNonEmptyBase } from './non-empty.mjs';
export declare class LeafBlock<T> extends ListNonEmptyBase<T> implements Block<T, LeafBlock<T>, T> {
    readonly context: ListContext;
    readonly children: readonly T[];
    constructor(context: ListContext, children: readonly T[]);
    get length(): number;
    get level(): 0;
    copy(children: readonly T[]): LeafBlock<T>;
    copy2<T2>(children: readonly T2[]): LeafBlock<T2>;
    get mutateChildren(): T[];
    get childrenInMax(): boolean;
    get childrenInMin(): boolean;
    get canAddChild(): boolean;
    stream(reversed?: boolean): Stream.NonEmpty<T>;
    streamRange(range: IndexRange, reversed?: boolean): Stream<T>;
    get<O>(index: number, otherwise?: OptLazy<O>): T | O;
    prepend(value: T): List.NonEmpty<T>;
    append(value: T): List.NonEmpty<T>;
    prependInternal(value: T): LeafBlock<T>;
    appendInternal(value: T): LeafBlock<T>;
    take(amount: number): List<T> | any;
    drop(amount: number): List<T>;
    takeChildren(childAmount: number): LeafBlock<T>;
    dropChildren(childAmount: number): LeafBlock<T>;
    concatChildren(other: LeafBlock<T>): LeafBlock<T>;
    concat<T2>(...sources: ArrayNonEmpty<StreamSource<T2>>): List.NonEmpty<T | T2>;
    concatBlock(other: LeafBlock<T>): List.NonEmpty<T>;
    concatTree(other: LeafTree<T>): LeafTree<T>;
    updateAt(index: number, update: Update<T>): LeafBlock<T>;
    forEach(f: (value: T, index: number, halt: () => void) => void, state?: TraverseState): void;
    mapPure<T2>(mapFun: (value: T) => T2, reversed?: boolean, cacheMap?: import("@rimbu/list/custom").CacheMap): LeafBlock<T2>;
    map<T2>(mapFun: (value: T, index: number) => T2, reversed?: boolean, indexOffset?: number): LeafBlock<T2>;
    reversed(cacheMap?: import("@rimbu/list/custom").CacheMap): LeafBlock<T>;
    _mutateNormalize(): List.NonEmpty<T>;
    _mutateSplitRight(childIndex?: number): LeafBlock<T>;
    toArray(range?: IndexRange, reversed?: boolean): T[] | any;
    structure(): string;
    createBlockBuilder(): BlockBuilder<T, any>;
}
export declare class ReversedLeafBlock<T> extends LeafBlock<T> {
    copy(children: readonly T[]): LeafBlock<T>;
    copy2<T2>(children: readonly T2[]): LeafBlock<T2>;
    stream(reversed?: boolean): Stream.NonEmpty<T>;
    streamRange(range: IndexRange, reversed?: boolean): Stream<T>;
    get<O>(index: number, otherwise?: OptLazy<O>): T | O;
    prependInternal(value: T): LeafBlock<T>;
    appendInternal(value: T): LeafBlock<T>;
    takeChildren(childAmount: number): LeafBlock<T>;
    dropChildren(childAmount: number): LeafBlock<T>;
    concatChildren(other: LeafBlock<T>): LeafBlock<T>;
    updateAt(index: number, update: Update<T>): LeafBlock<T>;
    map<T2>(mapFun: (value: T, index: number) => T2, reversed?: boolean, indexOffset?: number): LeafBlock<T2>;
    reversed(cacheMap?: import("@rimbu/list/custom").CacheMap): LeafBlock<T>;
    toArray(range?: IndexRange, reversed?: boolean): T[] | any;
    _mutateSplitRight(childIndex?: number): LeafBlock<T>;
    structure(): string;
}
