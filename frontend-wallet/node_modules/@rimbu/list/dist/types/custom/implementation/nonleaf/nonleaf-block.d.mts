import { IndexRange, type TraverseState, type Update } from '@rimbu/common';
import { Stream } from '@rimbu/stream';
import type { Block, BlockBuilder, ListContext, NonLeaf, NonLeafBuilder, NonLeafTree } from '@rimbu/list/custom';
export declare class NonLeafBlock<T, C extends Block<T, C>> implements Block<T, NonLeafBlock<T, C>, C>, NonLeaf<T, Block<T>> {
    readonly context: ListContext;
    _length: number;
    readonly children: readonly C[];
    readonly level: number;
    constructor(context: ListContext, _length: number, children: readonly C[], level: number);
    get length(): number;
    set length(value: number);
    get nrChildren(): number;
    get mutateChildren(): C[];
    get childrenInMax(): boolean;
    get childrenInMin(): boolean;
    get canAddChild(): boolean;
    copy(children: readonly C[], length?: number): NonLeafBlock<T, C>;
    copy2<T2, C2 extends Block<T2, C2>>(children: readonly C2[], length?: number): NonLeafBlock<T2, C2>;
    stream(reversed?: boolean): Stream.NonEmpty<T>;
    streamRange(range: IndexRange, reversed?: boolean): Stream<T>;
    get(index: number): T;
    prepend(child: C): NonLeaf<T, C>;
    append(child: C): NonLeaf<T, C>;
    dropFirst(): [NonLeafBlock<T, C> | null, C];
    dropLast(): [NonLeafBlock<T, C> | null, C];
    concat<T2>(other: NonLeaf<T2, C>): NonLeaf<T | T2, C>;
    concatBlock(other: NonLeafBlock<T, C>): NonLeaf<T, C>;
    concatTree(other: NonLeafTree<T, C>): NonLeaf<T, C>;
    prependInternal(child: C): NonLeafBlock<T, C>;
    appendInternal(child: C): NonLeafBlock<T, C>;
    takeChildren(childAmount: number): NonLeafBlock<T, C> | null;
    dropChildren(childAmount: number): NonLeafBlock<T, C> | null;
    concatChildren(other: NonLeafBlock<T, C>): NonLeafBlock<T, C>;
    takeInternal(amount: number): [NonLeafBlock<T, C> | null, C, number];
    dropInternal(amount: number): [NonLeafBlock<T, C> | null, C, number];
    getChild(childIndex: number): C;
    updateAt(index: number, update: Update<T>): NonLeafBlock<T, C>;
    forEach(f: (value: T, index: number, halt: () => void) => void, state: TraverseState): void;
    mapPure<T2>(mapFun: (value: T) => T2, reversed?: boolean, cacheMap?: import("@rimbu/list/custom").CacheMap): NonLeafBlock<T2, Block<T2>>;
    map<T2>(mapFun: (value: T, index: number) => T2, reversed?: boolean, indexOffset?: number): NonLeafBlock<T2, Block<T2>>;
    reversed(cacheMap?: import("@rimbu/list/custom").CacheMap): NonLeafBlock<T, C>;
    toArray(range?: IndexRange, reversed?: boolean): T[] | any;
    getCoordinates(index: number, forTake: boolean, noEmptyLast: boolean): [number, number];
    _mutateRebalance(): NonLeafBlock<T, C>;
    _mutateNormalize(): NonLeaf<T>;
    _mutateSplitRight(childIndex?: number): NonLeafBlock<T, C>;
    structure(): string;
    createBlockBuilder(): BlockBuilder<T, any>;
    createNonLeafBuilder(): NonLeafBuilder<T, BlockBuilder<T, unknown>>;
}
