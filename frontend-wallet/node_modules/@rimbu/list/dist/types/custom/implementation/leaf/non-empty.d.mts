import { NonEmptyBase } from '@rimbu/collection-types/set-custom';
import { IndexRange, type ArrayNonEmpty, type CollectFun, type Comp, type OptLazy, type ToJSON, type TraverseState, type Update } from '@rimbu/common';
import type { FastIterator, Stream, StreamSource } from '@rimbu/stream';
import type { CacheMap, ListContext } from '@rimbu/list/custom';
import type { List } from '@rimbu/list';
export declare abstract class ListNonEmptyBase<T> extends NonEmptyBase<T> implements List.NonEmpty<T> {
    abstract get context(): ListContext;
    abstract get length(): number;
    abstract stream(reversed?: boolean): Stream.NonEmpty<T>;
    abstract streamRange(range: IndexRange, reversed?: boolean): Stream<T>;
    abstract forEach(f: (value: T, index: number, halt: () => void) => void, traverseState?: TraverseState): void;
    abstract get<O>(index: number, otherwise?: OptLazy<O>): T | O;
    abstract prepend(value: T): List.NonEmpty<T>;
    abstract append(value: T): List.NonEmpty<T>;
    abstract take(amount: number): List<T> | any;
    abstract drop(amount: number): List<T>;
    abstract concat<T2 = T>(...sources: ArrayNonEmpty<StreamSource<T2>>): List.NonEmpty<T | T2>;
    abstract updateAt(index: number, update: Update<T>): List.NonEmpty<T>;
    abstract mapPure<T2>(mapFun: (value: T) => T2, reversed?: boolean, cacheMap?: CacheMap): List.NonEmpty<T2>;
    abstract map<T2>(mapFun: (value: T, index: number) => T2, reversed?: boolean): List.NonEmpty<T2>;
    abstract reversed(cache?: CacheMap): List.NonEmpty<T>;
    abstract toArray(range?: IndexRange, reversed?: boolean): T[] | any;
    abstract structure(): string;
    [Symbol.iterator](): FastIterator<T>;
    get isEmpty(): false;
    nonEmpty(): true;
    assumeNonEmpty(): this;
    asNormal(): this;
    first(): T;
    last(): T;
    slice(range: IndexRange, reversed: boolean): List<T>;
    sort(comp?: Comp<T>): List.NonEmpty<T>;
    splice({ index, remove, insert, }?: {
        index?: number;
        remove?: number;
        insert?: StreamSource<T>;
    }): List<T> | any;
    insert(index: number, values: StreamSource<T>): List<T> | any;
    remove(index: number, amount?: number): List<T>;
    repeat(amount: number): List.NonEmpty<T>;
    rotate(shiftRightAmount: number): List.NonEmpty<T>;
    padTo(length: number, fill: T, positionPercentage?: number): List.NonEmpty<T>;
    filter(pred: (value: T, index: number, halt: () => void) => boolean, range?: IndexRange, reversed?: boolean): List<T>;
    collect<T2>(collectFun: CollectFun<T, T2>, range?: IndexRange, reversed?: boolean): List<T2>;
    flatMap<T2>(flatMapFun: (value: T, index: number) => StreamSource<T2>, range?: IndexRange, reversed?: boolean): List<T2> | any;
    toBuilder(): List.Builder<T>;
    toString(): string;
    toJSON(): ToJSON<T[], this['context']['typeTag']>;
}
