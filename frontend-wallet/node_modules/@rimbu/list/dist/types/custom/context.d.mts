import { Reducer } from '@rimbu/common';
import { type StreamSource } from '@rimbu/stream';
import type { List } from '@rimbu/list';
import type { Block, BlockBuilder, LeafBuilder, NonLeaf, NonLeafBuilder } from '@rimbu/list/custom';
import { CacheMap, LeafBlock, ReversedLeafBlock, LeafTree, NonLeafBlock, NonLeafTree, GenBuilder, LeafBlockBuilder, NonLeafBlockBuilder, LeafTreeBuilder, NonLeafTreeBuilder } from '@rimbu/list/custom';
export declare class ListContext implements List.Context {
    readonly blockSizeBits: number;
    readonly maxBlockSize: number;
    readonly minBlockSize: number;
    constructor(blockSizeBits: number);
    get typeTag(): 'List';
    get _types(): List.Types;
    readonly builder: <T>() => GenBuilder<T>;
    createBuilder<T>(source?: List<T>): GenBuilder<T>;
    readonly _empty: List<any>;
    readonly empty: <T>() => List<T>;
    readonly of: <T>(values_0: T, ...values_1: T[]) => List.NonEmpty<T>;
    readonly from: <T>(sources_0: StreamSource<T>, ...sources_1: StreamSource<T>[]) => any;
    readonly fromString: (sources_0: string, ...sources_1: string[]) => any;
    readonly reducer: <T>(source?: StreamSource<T>) => Reducer<T, List<T>>;
    readonly flatten: (source: any) => any;
    readonly unzip: (source: any, length: number) => any;
    leafBlock<T>(children: readonly T[]): LeafBlock<T>;
    reversedLeaf<T>(children: readonly T[]): ReversedLeafBlock<T>;
    leafTree<T>(left: LeafBlock<T>, right: LeafBlock<T>, middle: NonLeaf<T, LeafBlock<T>> | null): LeafTree<T>;
    nonLeafBlock<T, C extends Block<T, C>>(length: number, children: readonly C[], level: number): NonLeafBlock<T, C>;
    nonLeafTree<T, C extends Block<T, C>>(left: NonLeafBlock<T, C>, right: NonLeafBlock<T, C>, middle: NonLeaf<T, NonLeafBlock<T, C>> | null, level: number): NonLeafTree<T, C>;
    leafBlockBuilderSource<T>(source: LeafBlock<T>): LeafBlockBuilder<T>;
    leafBlockBuilder<T>(children: T[]): LeafBlockBuilder<T>;
    leafTreeBuilderSource<T>(source: LeafTree<T>): LeafTreeBuilder<T>;
    leafTreeBuilder<T>(left: LeafBlockBuilder<T>, right: LeafBlockBuilder<T>, middle?: NonLeafBuilder<T, LeafBlockBuilder<T>>, length?: number): LeafTreeBuilder<T>;
    nonLeafBlockBuilderSource<T, C extends BlockBuilder<T>>(source: NonLeafBlock<T, any>): NonLeafBlockBuilder<T, C>;
    nonLeafBlockBuilder<T, C extends BlockBuilder<T>>(level: number, children: C[], length: number): NonLeafBlockBuilder<T, C>;
    nonLeafTreeBuilderSource<T, C extends BlockBuilder<T>>(source: NonLeafTree<T, any>): NonLeafTreeBuilder<T, C>;
    nonLeafTreeBuilder<T, C extends BlockBuilder<T>>(level: number, left: NonLeafBlockBuilder<T, C>, right: NonLeafBlockBuilder<T, C>, middle?: NonLeafBuilder<T, NonLeafBlockBuilder<T, C>>, length?: number): NonLeafTreeBuilder<T, C>;
    isLeafBlock<T>(obj: List<T> | Block<T>): obj is LeafBlock<T>;
    isReversedLeafBlock<T>(obj: List<T> | Block<T>): obj is ReversedLeafBlock<T>;
    isNonLeafBlock<T>(obj: List<T> | Block<T> | NonLeaf<T>): obj is NonLeafBlock<T, any>;
    isLeafTree<T>(obj: List<T>): obj is LeafTree<T>;
    isNonLeafTree<T>(obj: NonLeaf<T>): obj is NonLeafTree<T, any>;
    isLeafBlockBuilder<T>(obj: LeafBuilder<T>): obj is LeafBlockBuilder<T>;
    isLeafTreeBuilder<T>(obj: LeafBuilder<T>): obj is LeafTreeBuilder<T>;
    isNonLeafBlockBuilder<T>(obj: NonLeafBuilder<T, any>): obj is NonLeafBlockBuilder<T, any>;
    createCacheMap(): CacheMap;
}
export declare function createListContext(options?: {
    blockSizeBits?: number;
}): List.Context;
