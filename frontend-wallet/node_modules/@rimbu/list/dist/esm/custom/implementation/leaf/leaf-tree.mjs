import { RimbuError } from '@rimbu/base';
import { OptLazy, TraverseState, } from '@rimbu/common';
import { treeAppend, treeForEach, treeGet, treePrepend, treeStream, treeToArray, treeUpdate, } from '../tree/operations.mjs';
import { ListNonEmptyBase } from './non-empty.mjs';
export class LeafTree extends ListNonEmptyBase {
    constructor(context, left, right, middle, length = left.length +
        right.length +
        (null === middle ? 0 : middle.length)) {
        super();
        this.context = context;
        this.left = left;
        this.right = right;
        this.middle = middle;
        this.length = length;
    }
    getChildLength() {
        return 1;
    }
    copy(left = this.left, right = this.right, middle = this.middle) {
        if (left === this.left && right === this.right && middle === this.middle) {
            return this;
        }
        return this.context.leafTree(left, right, middle);
    }
    copy2(left, right, middle) {
        return this.context.leafTree(left, right, middle);
    }
    stream(reversed = false) {
        return treeStream(this, undefined, reversed);
    }
    streamRange(range, reversed = false) {
        return treeStream(this, range, reversed);
    }
    get(index, otherwise) {
        if (index >= this.length || -index > this.length) {
            return OptLazy(otherwise);
        }
        if (index < 0) {
            return this.get(this.length + index, otherwise);
        }
        return treeGet(this, index);
    }
    prepend(value) {
        return treePrepend(this, value);
    }
    append(value) {
        return treeAppend(this, value);
    }
    prependMiddle(child) {
        return (this.middle?.prepend(child) ??
            this.context.nonLeafBlock(child.length, [child], 1));
    }
    appendMiddle(child) {
        return (this.middle?.append(child) ??
            this.context.nonLeafBlock(child.length, [child], 1));
    }
    take(amountInput) {
        const amount = Math.floor(amountInput);
        if (amount === 0)
            return this.context.empty();
        if (amount >= this.length || -amount > this.length)
            return this;
        if (amount < 0)
            return this.drop(this.length + amount);
        const middleAmount = amount - this.left.length;
        if (middleAmount <= 0)
            return this.left.take(amount);
        if (null === this.middle) {
            return this.copy(undefined, this.right.takeChildren(middleAmount))._normalize();
        }
        const rightAmount = middleAmount - this.middle.length;
        if (rightAmount > 0) {
            const newRight = this.right.takeChildren(rightAmount);
            return this.copy(undefined, newRight)._normalize();
        }
        const [newMiddle, upRight, inUpRight] = this.middle.takeInternal(middleAmount);
        const newRight = upRight.takeChildren(inUpRight);
        return this.copy(undefined, newRight, newMiddle)._normalize();
    }
    drop(amount) {
        if (amount === 0)
            return this;
        if (amount >= this.length || -amount > this.length)
            return this.context.empty();
        if (amount < 0)
            return this.take(this.length + amount);
        const middleAmount = amount - this.left.length;
        if (middleAmount < 0) {
            const newLeft = this.left.dropChildren(amount);
            return this.copy(newLeft)._normalize();
        }
        if (null === this.middle) {
            return this.right.drop(middleAmount);
        }
        const rightAmount = middleAmount - this.middle.length;
        if (rightAmount >= 0) {
            return this.right.drop(rightAmount);
        }
        const [newMiddle, upLeft, inUpLeft] = this.middle.dropInternal(middleAmount);
        const newLeft = upLeft.dropChildren(inUpLeft);
        return this.copy(newLeft, undefined, newMiddle)._normalize();
    }
    concat(...sources) {
        const asList = this.context.from(...sources);
        if (asList.nonEmpty()) {
            if (this.context.isLeafBlock(asList)) {
                return this.concatBlock(asList);
            }
            else if (this.context.isLeafTree(asList)) {
                return this.concatTree(asList);
            }
            else {
                RimbuError.throwInvalidStateError();
            }
        }
        return this;
    }
    concatBlock(other) {
        if (this.right.length + other.length <= this.context.maxBlockSize) {
            const newRight = this.right.concatChildren(other);
            return this.copy(undefined, newRight);
        }
        if (this.right.childrenInMin) {
            const newMiddle = this.appendMiddle(this.right);
            return this.copy(undefined, other, newMiddle);
        }
        const newRight = this.right.concatChildren(other);
        const newLast = newRight._mutateSplitRight(this.context.maxBlockSize);
        const newMiddle = this.appendMiddle(newRight);
        return this.copy(undefined, newLast, newMiddle);
    }
    concatTree(other) {
        const jointLength = this.right.length + other.left.length;
        if (jointLength < this.context.minBlockSize) {
            if (null === this.middle) {
                // left + right > maxBlockSize
                const joint = this.left
                    .concatChildren(this.right)
                    .concatChildren(other.left);
                const toMiddle = joint._mutateSplitRight(joint.children.length - this.context.maxBlockSize);
                const newMiddle = other.prependMiddle(toMiddle);
                return other.copy(joint, undefined, newMiddle);
            }
            const [newMiddle, toJoint] = this.middle.dropLast();
            const joint = toJoint
                .concatChildren(this.right)
                .concatChildren(other.left);
            if (joint.childrenInMax) {
                const m = null === newMiddle
                    ? other.prependMiddle(joint)
                    : newMiddle.concat(other.prependMiddle(joint));
                return this.copy(undefined, other.right, m);
            }
            const newOtherLeft = joint._mutateSplitRight();
            const newMiddle2 = null === newMiddle
                ? other.prependMiddle(newOtherLeft).prepend(joint)
                : null === other.middle
                    ? newMiddle.append(joint).append(newOtherLeft)
                    : newMiddle.append(joint).append(newOtherLeft).concat(other.middle);
            return this.copy(undefined, other.right, newMiddle2);
        }
        if (jointLength <= this.context.maxBlockSize) {
            const joint = this.right.concatChildren(other.left);
            const newThisMiddle = this.appendMiddle(joint);
            const newMiddle = null === other.middle
                ? newThisMiddle
                : newThisMiddle.concat(other.middle);
            return this.copy(undefined, other.right, newMiddle);
        }
        if (this.right.childrenInMin && other.left.childrenInMin) {
            const newThisMiddle = this.appendMiddle(this.right).append(other.left);
            const newMiddle = null === other.middle
                ? newThisMiddle
                : newThisMiddle.concat(other.middle);
            return this.copy(undefined, other.right, newMiddle);
        }
        const joint = this.right.concatChildren(other.left);
        const jointRight = joint._mutateSplitRight();
        const newThisMiddle = this.appendMiddle(joint).append(jointRight);
        const newMiddle = null === other.middle
            ? newThisMiddle
            : newThisMiddle.concat(other.middle);
        return this.copy(undefined, other.right, newMiddle);
    }
    updateAt(index, update) {
        if (index >= this.length || -index > this.length)
            return this;
        if (index < 0)
            return this.updateAt(this.length + index, update);
        return treeUpdate(this, index, update);
    }
    forEach(f, state = TraverseState()) {
        if (state.halted)
            return;
        treeForEach(this, f, state);
    }
    mapPure(mapFun, reversed = false, cacheMap = this.context.createCacheMap()) {
        const currentValue = cacheMap.get(this);
        if (currentValue)
            return currentValue;
        const mappedLeft = this.left.mapPure(mapFun, reversed, cacheMap);
        const mappedMiddle = null === this.middle
            ? null
            : this.middle.mapPure(mapFun, reversed, cacheMap);
        const mappedRight = this.right.mapPure(mapFun, reversed, cacheMap);
        const result = reversed
            ? this.copy2(mappedRight, mappedLeft, mappedMiddle)
            : this.copy2(mappedLeft, mappedRight, mappedMiddle);
        return cacheMap.setAndReturn(this, result);
    }
    map(mapFun, reversed = false, indexOffset = 0) {
        let offset = indexOffset;
        if (reversed) {
            const newLeft = this.right.map(mapFun, true, offset);
            offset += this.right.length;
            const newMiddle = null === this.middle ? null : this.middle.map(mapFun, true, offset);
            if (null !== this.middle)
                offset += this.middle.length;
            const newRight = this.left.map(mapFun, true, offset);
            return this.copy2(newLeft, newRight, newMiddle);
        }
        const newLeft = this.left.map(mapFun, false, offset);
        offset += this.left.length;
        const newMiddle = null === this.middle ? null : this.middle.map(mapFun, false, offset);
        if (null !== this.middle)
            offset += this.middle.length;
        const newRight = this.right.map(mapFun, false, offset);
        return this.copy2(newLeft, newRight, newMiddle);
    }
    reversed(cacheMap = this.context.createCacheMap()) {
        const cachedThis = cacheMap.get(this);
        if (cachedThis !== undefined)
            return cachedThis;
        const newMid = this.middle?.reversed(cacheMap) ?? null;
        const newLeft = this.right.reversed(cacheMap);
        const newRight = this.left === this.right ? newLeft : this.left.reversed(cacheMap);
        const reversedThis = this.copy(newLeft, newRight, newMid);
        return cacheMap.setAndReturn(this, reversedThis);
    }
    toArray(range, reversed = false) {
        return treeToArray(this, range, reversed);
    }
    _normalize() {
        if (null === this.middle) {
            if (this.length <= this.context.maxBlockSize) {
                // can merge left and right
                return this.left.concatChildren(this.right);
            }
        }
        else if (this.context.isNonLeafBlock(this.middle)) {
            if (this.length <= this.context.maxBlockSize) {
                // left, middle, and right can be merged into one block
                return this.left
                    .concatChildren(this.middle.getChild(0))
                    .concatChildren(this.right);
            }
            const firstChild = this.middle.getChild(0);
            if (this.left.length + firstChild.length <= this.context.maxBlockSize) {
                // first middle child can be merged with left
                const result = this.middle.dropFirst();
                const newMiddle = result[0];
                const block = result[1];
                return this.copy(this.left.concatChildren(block), undefined, newMiddle);
            }
            const lastChild = this.middle.getChild(this.middle.nrChildren - 1);
            if (this.right.length + lastChild.length <= this.context.maxBlockSize) {
                // last middle child can be merged with right
                const result = this.middle.dropLast();
                const newMiddle = result[0];
                const block = result[1];
                return this.copy(undefined, block.concatChildren(this.right), newMiddle);
            }
        }
        return this;
    }
    structure() {
        return `<LeafTree len:${this.length}\n l:${this.left.structure()}\n m: ${this.middle && this.middle.structure()}\n r:${this.right.structure()}\n>`;
    }
}
//# sourceMappingURL=leaf-tree.mjs.map