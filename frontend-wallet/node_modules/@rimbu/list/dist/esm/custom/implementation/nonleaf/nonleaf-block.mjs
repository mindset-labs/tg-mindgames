import { Arr, RimbuError } from '@rimbu/base';
import { IndexRange } from '@rimbu/common';
import { Stream } from '@rimbu/stream';
export class NonLeafBlock {
    constructor(context, _length, children, level) {
        this.context = context;
        this._length = _length;
        this.children = children;
        this.level = level;
    }
    get length() {
        return this._length;
    }
    set length(value) {
        this._length = value;
    }
    get nrChildren() {
        return this.children.length;
    }
    get mutateChildren() {
        return this.children;
    }
    get childrenInMax() {
        return this.children.length <= this.context.maxBlockSize;
    }
    get childrenInMin() {
        return this.children.length >= this.context.minBlockSize;
    }
    get canAddChild() {
        return this.children.length < this.context.maxBlockSize;
    }
    copy(children, length = this.length) {
        if (children === this.children && length === this.length)
            return this;
        return this.context.nonLeafBlock(length, children, this.level);
    }
    copy2(children, length = this.length) {
        return this.context.nonLeafBlock(length, children, this.level);
    }
    stream(reversed = false) {
        return Stream.fromArray(this.children, undefined, reversed).flatMap((child) => child.stream(reversed));
    }
    streamRange(range, reversed = false) {
        const indexRange = IndexRange.getIndicesFor(range, this.length);
        if (indexRange === 'all') {
            return Stream.fromArray(this.children, undefined, reversed).flatMap((child) => child.stream(reversed));
        }
        if (indexRange === 'empty')
            return Stream.empty();
        const [start, end] = indexRange;
        const [startChildIndex, inStartChildIndex] = this.getCoordinates(start, false, true);
        const [endChildIndex, inEndChildIndex] = this.getCoordinates(end, false, true);
        if (startChildIndex === endChildIndex) {
            const child = this.children[startChildIndex];
            return child.streamRange({
                start: inStartChildIndex,
                end: inEndChildIndex,
            }, reversed);
        }
        const startChild = this.children[startChildIndex];
        const endChild = this.children[endChildIndex];
        const childStream = Stream.fromArray(this.children, { start: startChildIndex, end: endChildIndex }, reversed);
        return childStream.flatMap((child) => {
            if (child === startChild)
                return child.streamRange({ start: inStartChildIndex }, reversed);
            if (child === endChild)
                return child.streamRange({ end: inEndChildIndex }, reversed);
            return child.stream(reversed);
        });
    }
    get(index) {
        const [childIndex, inChildIndex] = this.getCoordinates(index, false, false);
        return this.getChild(childIndex).get(inChildIndex, RimbuError.throwInvalidStateError);
    }
    prepend(child) {
        if (this.canAddChild)
            return this.prependInternal(child);
        return this.context.nonLeafTree(this.copy([child], child.length), this, null, this.level);
    }
    append(child) {
        if (this.canAddChild)
            return this.appendInternal(child);
        return this.context.nonLeafTree(this, this.copy([child], child.length), null, this.level);
    }
    dropFirst() {
        const firstChild = this.children[0];
        if (this.nrChildren === 1)
            return [null, firstChild];
        const newChildren = Arr.tail(this.children);
        const newLength = this.length - firstChild.length;
        const newSelf = this.copy(newChildren, newLength);
        return [newSelf, firstChild];
    }
    dropLast() {
        const lastChild = Arr.last(this.children);
        if (this.nrChildren === 1)
            return [null, lastChild];
        const newChildren = Arr.init(this.children);
        const newLength = this.length - lastChild.length;
        const newSelf = this.copy(newChildren, newLength);
        return [newSelf, lastChild];
    }
    concat(other) {
        if (other.context.isNonLeafBlock(other)) {
            if (other === this && this.children.length > this.context.minBlockSize) {
                return this.context.nonLeafTree(this, this, null, this.level);
            }
            return this.concatBlock(other);
        }
        if (this.context.isNonLeafTree(other)) {
            return this.concatTree(other);
        }
        RimbuError.throwInvalidStateError();
    }
    concatBlock(other) {
        return this.concatChildren(other)._mutateNormalize();
    }
    concatTree(other) {
        if (this.nrChildren + other.left.nrChildren <= this.context.maxBlockSize) {
            const newLeft = this.concatChildren(other.left)._mutateRebalance();
            return other.copy(newLeft);
        }
        if (other.left.childrenInMin) {
            const newMiddle = other.prependMiddle(other.left);
            return other.copy(this, undefined, newMiddle);
        }
        const newLeft = this.concatChildren(other.left)._mutateRebalance();
        if (newLeft.childrenInMax)
            return other.copy(newLeft);
        const newSecond = newLeft._mutateSplitRight(newLeft.nrChildren - this.context.maxBlockSize);
        const newMiddle = other.prependMiddle(newSecond);
        return other.copy(newLeft, undefined, newMiddle);
    }
    prependInternal(child) {
        const newChildren = Arr.prepend(this.children, child);
        return this.copy(newChildren, this.length + child.length);
    }
    appendInternal(child) {
        const newChildren = Arr.append(this.children, child);
        return this.copy(newChildren, this.length + child.length);
    }
    takeChildren(childAmount) {
        if (childAmount <= 0)
            return null;
        if (childAmount >= this.nrChildren)
            return this;
        const newChildren = Arr.splice(this.children, childAmount, this.context.maxBlockSize);
        const length = newChildren.reduce((l, c) => l + c.length, 0);
        return this.copy(newChildren, length);
    }
    dropChildren(childAmount) {
        if (childAmount <= 0) {
            return this;
        }
        if (childAmount >= this.nrChildren) {
            return null;
        }
        const newChildren = Arr.splice(this.children, 0, childAmount);
        const length = newChildren.reduce((l, c) => l + c.length, 0);
        return this.copy(newChildren, length);
    }
    concatChildren(other) {
        const newChildren = Arr.concat(this.children, other.children);
        return this.copy(newChildren, this.length + other.length); //._mutateRebalance();
    }
    takeInternal(amount) {
        const [childIndex, inChildIndex] = this.getCoordinates(amount, true, false);
        if (childIndex >= this.nrChildren) {
            RimbuError.throwInvalidStateError();
        }
        const lastChild = this.getChild(childIndex);
        const newSelf = this.takeChildren(childIndex);
        return [newSelf, lastChild, inChildIndex];
    }
    // return remainer, first new child, and index in new child
    dropInternal(amount) {
        const [childIndex, inChildIndex] = this.getCoordinates(amount, false, false);
        if (childIndex >= this.nrChildren) {
            RimbuError.throwInvalidStateError();
        }
        const firstChild = this.getChild(childIndex);
        const newSelf = this.dropChildren(childIndex + 1);
        return [newSelf, firstChild, inChildIndex];
    }
    getChild(childIndex) {
        return this.children[childIndex];
    }
    updateAt(index, update) {
        const [childIndex, inChildIndex] = this.getCoordinates(index, false, false);
        const newChildren = Arr.update(this.children, childIndex, (child) => child.updateAt(inChildIndex, update));
        return this.copy(newChildren);
    }
    forEach(f, state) {
        if (state.halted)
            return;
        const length = this.children.length;
        let i = -1;
        const children = this.children;
        while (!state.halted && ++i < length) {
            children[i].forEach(f, state);
        }
    }
    mapPure(mapFun, reversed = false, cacheMap = this.context.createCacheMap()) {
        const cachedThis = cacheMap.get(this);
        if (cachedThis)
            return cachedThis;
        const fn = reversed ? Arr.reverseMap : Arr.map;
        const newChildren = fn(this.children, (c) => c.mapPure(mapFun, reversed, cacheMap));
        return cacheMap.setAndReturn(this, this.copy2(newChildren));
    }
    map(mapFun, reversed = false, indexOffset = 0) {
        let offset = indexOffset;
        const children = this.children;
        if (reversed) {
            const newChildren = [];
            let i = children.length;
            while (--i >= 0) {
                const child = children[i];
                newChildren.push(child.map(mapFun, true, offset));
                offset += child.length;
            }
            return this.copy2(newChildren);
        }
        else {
            const newChildren = [];
            let i = -1;
            const length = children.length;
            while (++i < length) {
                const child = children[i];
                newChildren.push(child.map(mapFun, false, offset));
                offset += child.length;
            }
            return this.copy2(newChildren);
        }
    }
    reversed(cacheMap = this.context.createCacheMap()) {
        const cachedThis = cacheMap.get(this);
        if (cachedThis !== undefined)
            return cachedThis;
        const newChildren = Arr.reverseMap(this.children, (child) => child.reversed(cacheMap));
        const reversedThis = this.copy(newChildren, this.length);
        return cacheMap.setAndReturn(this, reversedThis);
    }
    toArray(range, reversed = false) {
        let start = 0;
        let end = this.length - 1;
        if (undefined !== range) {
            const indexRange = IndexRange.getIndicesFor(range, this.length);
            if (indexRange === 'empty')
                return [];
            if (indexRange !== 'all') {
                start = indexRange[0];
                end = indexRange[1];
            }
        }
        const [startChildIndex, inStartChildIndex] = this.getCoordinates(start, false, true);
        const [endChildIndex, inEndChildIndex] = this.getCoordinates(end, false, true);
        const children = this.children;
        if (startChildIndex === endChildIndex) {
            const child = children[startChildIndex];
            return child.toArray({
                start: inStartChildIndex,
                end: inEndChildIndex,
            }, reversed);
        }
        const firstArray = children[startChildIndex].toArray({
            start: inStartChildIndex,
        }, reversed);
        const lastArray = children[endChildIndex].toArray({ end: inEndChildIndex }, reversed);
        if (reversed) {
            let result = lastArray;
            for (let childIndex = endChildIndex - 1; childIndex > startChildIndex; childIndex--) {
                result = Arr.concat(result, children[childIndex].toArray(undefined, true));
            }
            return Arr.concat(result, firstArray);
        }
        let result = firstArray;
        for (let childIndex = startChildIndex + 1; childIndex < endChildIndex; childIndex++) {
            result = Arr.concat(result, children[childIndex].toArray());
        }
        return Arr.concat(result, lastArray);
    }
    getCoordinates(index, forTake, noEmptyLast) {
        const offSet = forTake ? 1 : 0;
        let indexWithOffset = index - offSet;
        const nrChildren = this.nrChildren;
        const length = this.length;
        const children = this.children;
        if (indexWithOffset >= length) {
            // return the end
            if (noEmptyLast) {
                return [nrChildren - 1, Arr.last(children).length - 1];
            }
            return [nrChildren, 0];
        }
        const levelBits = this.context.blockSizeBits << (this.level - 1);
        const blockSize = 1 << levelBits;
        const regularSize = nrChildren * blockSize;
        if (length === regularSize) {
            // regular blocks, calculate coordinates
            const childIndex = indexWithOffset >>> levelBits;
            const mask = blockSize - 1;
            const inChildIndex = indexWithOffset & mask;
            return [childIndex, inChildIndex + offSet];
        }
        // not regular, need to search per child
        if (indexWithOffset <= length >>> 1) {
            // search from left to right
            for (let childIndex = 0; childIndex < nrChildren; childIndex++) {
                const childLength = children[childIndex].length;
                if (indexWithOffset < childLength) {
                    return [childIndex, indexWithOffset + offSet];
                }
                indexWithOffset -= childLength;
            }
        }
        else {
            // search right to left
            let i = length - indexWithOffset;
            for (let childIndex = nrChildren - 1; childIndex >= 0; childIndex--) {
                const childLength = children[childIndex].length;
                if (i <= childLength) {
                    return [childIndex, childLength - i + offSet];
                }
                i -= childLength;
            }
        }
        RimbuError.throwInvalidStateError();
    }
    _mutateRebalance() {
        let i = 0;
        const children = this.children;
        while (i < children.length - 1) {
            const child = children[i];
            const rightChild = children[i + 1];
            if (child.children.length + rightChild.children.length <=
                this.context.maxBlockSize) {
                const newChild = child.concatChildren(rightChild);
                this.mutateChildren.splice(i, 2, newChild);
            }
            else
                i++;
        }
        return this;
    }
    _mutateNormalize() {
        if (this.childrenInMax) {
            return this;
        }
        const newRight = this._mutateSplitRight();
        return this.context.nonLeafTree(this, newRight, null, this.level);
    }
    _mutateSplitRight(childIndex = this.children.length >>> 1) {
        const rightChildren = this.mutateChildren.splice(childIndex);
        let rightLength = 0;
        for (let i = 0; i < rightChildren.length; i++) {
            rightLength += rightChildren[i].length;
        }
        this.length -= rightLength;
        return this.copy(rightChildren, rightLength);
    }
    structure() {
        const space = ' '.padEnd(this.level * 2);
        return `\n${space}<NLBlock(${this.level}) len:${this.length} c:${this.nrChildren} ${this.children.map((c) => c.structure()).join(' ')}>`;
    }
    createBlockBuilder() {
        return this.context.nonLeafBlockBuilderSource(this);
    }
    createNonLeafBuilder() {
        return this.context.nonLeafBlockBuilderSource(this);
    }
}
//# sourceMappingURL=nonleaf-block.mjs.map