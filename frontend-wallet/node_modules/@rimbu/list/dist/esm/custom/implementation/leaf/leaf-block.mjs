import { Arr, RimbuError } from '@rimbu/base';
import { IndexRange, OptLazy, TraverseState, Update, } from '@rimbu/common';
import { Stream } from '@rimbu/stream';
import { ListNonEmptyBase } from './non-empty.mjs';
export class LeafBlock extends ListNonEmptyBase {
    constructor(context, children) {
        super();
        this.context = context;
        this.children = children;
    }
    get length() {
        return this.children.length;
    }
    get level() {
        return 0;
    }
    copy(children) {
        if (children === this.children)
            return this;
        return this.context.leafBlock(children);
    }
    copy2(children) {
        return this.context.leafBlock(children);
    }
    get mutateChildren() {
        return this.children;
    }
    get childrenInMax() {
        return this.children.length <= this.context.maxBlockSize;
    }
    get childrenInMin() {
        return this.children.length >= this.context.minBlockSize;
    }
    get canAddChild() {
        return this.children.length < this.context.maxBlockSize;
    }
    stream(reversed = false) {
        return Stream.fromArray(this.children, undefined, reversed);
    }
    streamRange(range, reversed = false) {
        return Stream.fromArray(this.children, range, reversed);
    }
    get(index, otherwise) {
        if (index >= this.length || -index > this.length) {
            return OptLazy(otherwise);
        }
        if (index < 0) {
            return this.get(this.length + index, otherwise);
        }
        return this.children[index];
    }
    prepend(value) {
        if (this.length === 1 && !this.context.isReversedLeafBlock(this)) {
            return this.context.reversedLeaf([this.children[0], value]);
        }
        if (this.canAddChild) {
            return this.prependInternal(value);
        }
        return this.context.leafTree(this.copy([value]), this, null);
    }
    append(value) {
        if (this.canAddChild)
            return this.appendInternal(value);
        return this.context.leafTree(this, this.copy([value]), null);
    }
    prependInternal(value) {
        const newChildren = Arr.prepend(this.children, value);
        return this.copy(newChildren);
    }
    appendInternal(value) {
        const newChildren = Arr.append(this.children, value);
        return this.copy(newChildren);
    }
    take(amount) {
        if (amount === 0)
            return this.context.empty();
        if (amount >= this.length || -amount > this.length)
            return this;
        if (amount < 0)
            return this.drop(this.length + amount);
        return this.takeChildren(amount);
    }
    drop(amount) {
        if (amount === 0)
            return this;
        if (amount >= this.length || -amount > this.length)
            return this.context.empty();
        if (amount < 0)
            return this.take(this.length + amount);
        return this.dropChildren(amount);
    }
    takeChildren(childAmount) {
        if (childAmount >= this.length)
            return this;
        const newChildren = Arr.splice(this.children, childAmount, this.context.maxBlockSize);
        return this.copy(newChildren);
    }
    dropChildren(childAmount) {
        if (childAmount <= 0)
            return this;
        const newChildren = Arr.splice(this.children, 0, childAmount);
        return this.copy(newChildren);
    }
    concatChildren(other) {
        const addChildren = this.context.isReversedLeafBlock(other)
            ? Arr.reverse(other.children)
            : other.children;
        const newChildren = this.children.concat(addChildren);
        return this.copy(newChildren);
    }
    concat(...sources) {
        const asList = this.context.from(...sources);
        if (asList.nonEmpty()) {
            if (this.context.isLeafBlock(asList)) {
                if (asList === this &&
                    this.children.length > this.context.minBlockSize) {
                    return this.context.leafTree(this, this, null);
                }
                return this.concatBlock(asList);
            }
            if (this.context.isLeafTree(asList)) {
                return this.concatTree(asList);
            }
            RimbuError.throwInvalidStateError();
        }
        return this;
    }
    concatBlock(other) {
        return this.concatChildren(other)._mutateNormalize();
    }
    concatTree(other) {
        if (this.length + other.left.length <= this.context.maxBlockSize) {
            const newLeft = this.concatChildren(other.left);
            return other.copy(newLeft);
        }
        if (other.left.childrenInMin) {
            const newMiddle = other.prependMiddle(other.left);
            return other.copy(this, undefined, newMiddle);
        }
        const newLeft = this.concatChildren(other.left);
        const newSecond = newLeft._mutateSplitRight(newLeft.length - this.context.maxBlockSize);
        const newMiddle = other.prependMiddle(newSecond);
        return other.copy(newLeft, undefined, newMiddle);
    }
    updateAt(index, update) {
        if (index >= this.length || -index > this.length)
            return this;
        if (index < 0)
            return this.updateAt(this.length + index, update);
        const newChildren = Arr.update(this.children, index, (c) => Update(c, update));
        return this.copy(newChildren);
    }
    forEach(f, state = TraverseState()) {
        if (state.halted)
            return;
        Arr.forEach(this.children, f, state, this.context.isReversedLeafBlock(this));
    }
    mapPure(mapFun, reversed = false, cacheMap = this.context.createCacheMap()) {
        const currentValue = cacheMap.get(this);
        if (currentValue)
            return currentValue;
        const fn = reversed ? Arr.reverseMap : Arr.map;
        const newChildren = fn(this.children, mapFun);
        return cacheMap.setAndReturn(this, this.copy2(newChildren));
    }
    map(mapFun, reversed = false, indexOffset = 0) {
        if (reversed) {
            const newChildren = Arr.reverseMap(this.children, mapFun, indexOffset);
            return this.copy2(newChildren);
        }
        const newChildren = Arr.map(this.children, mapFun, indexOffset);
        return this.copy2(newChildren);
    }
    reversed(cacheMap = this.context.createCacheMap()) {
        if (this.length === 1)
            return this;
        const cachedThis = cacheMap.get(this);
        if (cachedThis !== undefined)
            return cachedThis;
        const reversedThis = this.context.reversedLeaf(this.children);
        return cacheMap.setAndReturn(this, reversedThis);
    }
    _mutateNormalize() {
        if (this.childrenInMax)
            return this;
        const newRight = this._mutateSplitRight();
        return this.context.leafTree(this, newRight, null);
    }
    _mutateSplitRight(childIndex = this.children.length >>> 1) {
        const rightChildren = this.mutateChildren.splice(childIndex);
        return this.copy(rightChildren);
    }
    toArray(range, reversed = false) {
        let result;
        if (undefined === range)
            result = this.children;
        else {
            const indexRange = IndexRange.getIndicesFor(range, this.length);
            if (indexRange === 'all')
                result = this.children;
            else if (indexRange === 'empty')
                result = [];
            else {
                const [start, end] = indexRange;
                if (!reversed)
                    return this.children.slice(start, end + 1);
                return Arr.reverse(this.children, start, end);
            }
        }
        if (reversed)
            return Arr.reverse(result);
        return result.slice();
    }
    structure() {
        return `<Leaf ${this.length}>`;
    }
    createBlockBuilder() {
        return this.context.leafBlockBuilderSource(this);
    }
}
export class ReversedLeafBlock extends LeafBlock {
    copy(children) {
        if (children === this.children)
            return this;
        return this.context.reversedLeaf(children);
    }
    copy2(children) {
        return this.context.reversedLeaf(children);
    }
    stream(reversed = false) {
        return Stream.fromArray(this.children, undefined, !reversed);
    }
    streamRange(range, reversed = false) {
        const indices = IndexRange.getIndicesFor(range, this.length);
        if (indices === 'empty')
            return Stream.empty();
        if (indices === 'all')
            return this.stream(reversed);
        const start = this.length - 1 - indices[1];
        const end = this.length - 1 - indices[0];
        return Stream.fromArray(this.children, { start, end }, !reversed);
    }
    get(index, otherwise) {
        if (index >= this.length || -index > this.length) {
            return OptLazy(otherwise);
        }
        if (index < 0) {
            return this.get(this.length + index, otherwise);
        }
        return this.children[this.length - 1 - index];
    }
    prependInternal(value) {
        return super.appendInternal(value);
    }
    appendInternal(value) {
        return super.prependInternal(value);
    }
    takeChildren(childAmount) {
        return super.dropChildren(this.length - childAmount);
    }
    dropChildren(childAmount) {
        return super.takeChildren(this.length - childAmount);
    }
    concatChildren(other) {
        if (other.context.isReversedLeafBlock(other)) {
            return this.copy(other.children.concat(this.children));
        }
        return other.copy(Arr.reverse(this.children).concat(other.children));
    }
    updateAt(index, update) {
        if (index >= this.length || -index > this.length)
            return this;
        if (index < 0)
            return this.updateAt(this.length + index, update);
        return super.updateAt(this.length - 1 - index, update);
    }
    map(mapFun, reversed = false, indexOffset = 0) {
        if (!reversed) {
            const newChildren = Arr.reverseMap(this.children, mapFun, indexOffset);
            return super.copy2(newChildren);
        }
        const newChildren = Arr.map(this.children, mapFun, indexOffset);
        return super.copy2(newChildren);
    }
    reversed(cacheMap = this.context.createCacheMap()) {
        if (this.length === 1)
            return this;
        const cachedThis = cacheMap.get(this);
        if (cachedThis !== undefined)
            return cachedThis;
        const reversedThis = this.context.leafBlock(this.children);
        return cacheMap.setAndReturn(this, reversedThis);
    }
    toArray(range, reversed = false) {
        let result;
        if (undefined === range)
            result = this.children;
        else {
            const indexRange = IndexRange.getIndicesFor(range, this.length);
            if (indexRange === 'empty')
                return [];
            else if (indexRange === 'all')
                result = this.children;
            else {
                const [indexStart, indexEnd] = indexRange;
                const start = this.length - 1 - indexEnd;
                const end = this.length - 1 - indexStart;
                if (!reversed)
                    return Arr.reverse(this.children, start, end);
                return this.children.slice(start, end + 1);
            }
        }
        if (!reversed)
            return Arr.reverse(result);
        return result.slice();
    }
    _mutateSplitRight(childIndex = this.children.length >>> 1) {
        const rightChildren = this.mutateChildren.splice(0, this.children.length - childIndex);
        return this.copy(rightChildren);
    }
    structure() {
        return `<RLeaf ${this.length}>`;
    }
}
//# sourceMappingURL=leaf-block.mjs.map