import { RimbuError } from '@rimbu/base';
import { NonEmptyBase } from '@rimbu/collection-types/set-custom';
import { IndexRange, } from '@rimbu/common';
import { isEmptyStreamSourceInstance } from '@rimbu/stream/custom';
export class ListNonEmptyBase extends NonEmptyBase {
    [Symbol.iterator]() {
        return this.stream()[Symbol.iterator]();
    }
    get isEmpty() {
        return false;
    }
    nonEmpty() {
        return true;
    }
    assumeNonEmpty() {
        return this;
    }
    asNormal() {
        return this;
    }
    first() {
        return this.get(0, RimbuError.throwInvalidStateError);
    }
    last() {
        return this.get(this.length - 1, RimbuError.throwInvalidStateError);
    }
    slice(range, reversed) {
        const result = IndexRange.getIndicesFor(range, this.length);
        if (result === 'all') {
            if (reversed)
                return this.reversed();
            return this;
        }
        if (result === 'empty')
            return this.context.empty();
        const [start, end] = result;
        const values = this.drop(start).take(end - start + 1);
        if (!reversed)
            return values;
        return values.reversed();
    }
    sort(comp) {
        const sortedArray = this.toArray().sort(comp?.compare);
        return this.context.from(sortedArray);
    }
    splice({ index = 0, remove = 0, insert, } = {}) {
        if (index < 0) {
            return this.splice({ index: this.length + index, remove, insert });
        }
        if (undefined === insert) {
            if (remove <= 0)
                return this;
            return this.take(index).concat(this.drop(index + remove));
        }
        if (remove <= 0 && isEmptyStreamSourceInstance(insert))
            return this;
        return this.take(index).concat(insert, this.drop(index + remove));
    }
    insert(index, values) {
        return this.splice({ index, insert: values });
    }
    remove(index, amount = 1) {
        return this.splice({ index, remove: amount });
    }
    repeat(amount) {
        if (amount <= -1)
            return this.reversed().repeat(-amount);
        if (amount <= 1)
            return this;
        const doubleTimes = amount >>> 1;
        const doubleResult = this.concat(this).repeat(doubleTimes);
        const remainTimes = amount % 2;
        if (remainTimes === 0)
            return doubleResult;
        return doubleResult.concat(this);
    }
    rotate(shiftRightAmount) {
        let normalizedAmount = shiftRightAmount % this.length;
        if (normalizedAmount === 0)
            return this;
        if (normalizedAmount < 0)
            normalizedAmount += this.length;
        return this.take(-normalizedAmount)
            .concat(this.drop(-normalizedAmount))
            .assumeNonEmpty();
    }
    padTo(length, fill, positionPercentage = 0) {
        if (this.length >= length)
            return this;
        const diff = length - this.length;
        const frac = Math.max(0, Math.min(100, positionPercentage)) / 100;
        const frontSize = Math.round(diff * frac);
        const pad = this.context.leafBlock([fill]).repeat(diff);
        return pad.splice({ index: frontSize, insert: this }).assumeNonEmpty();
    }
    filter(pred, range, reversed = false) {
        const stream = undefined === range
            ? this.stream(reversed)
            : this.streamRange(range, reversed);
        const result = this.context.from(stream.filter(pred));
        if (result.length !== this.length)
            return result;
        if (!reversed)
            return this;
        return this.reversed();
    }
    collect(collectFun, range, reversed = false) {
        const stream = undefined === range
            ? this.stream(reversed)
            : this.streamRange(range, reversed);
        return this.context.from(stream.collect(collectFun));
    }
    flatMap(flatMapFun, range, reversed = false) {
        let result = this.context.empty();
        const stream = undefined === range
            ? this.stream(reversed)
            : this.streamRange(range, reversed);
        const iterator = stream[Symbol.iterator]();
        let index = 0;
        const done = Symbol('Done');
        let value;
        while (done !== (value = iterator.fastNext(done))) {
            result = result.concat(flatMapFun(value, index++));
        }
        return result;
    }
    toBuilder() {
        return this.context.createBuilder(this);
    }
    toString() {
        return this.stream().join({ start: 'List(', sep: ', ', end: ')' });
    }
    toJSON() {
        return {
            dataType: this.context.typeTag,
            value: this.toArray(),
        };
    }
}
//# sourceMappingURL=non-empty.mjs.map