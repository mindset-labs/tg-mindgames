import { RimbuError } from '@rimbu/base';
import { OptLazy, TraverseState } from '@rimbu/common';
import { Stream } from '@rimbu/stream';
export class GenBuilder {
    constructor(context, builder) {
        this.context = context;
        this.builder = builder;
        this._lock = 0;
        // prettier-ignore
        this.get = (index, otherwise) => {
            if (undefined === this.builder ||
                index >= this.length ||
                -index > this.length) {
                return OptLazy(otherwise);
            }
            if (index < 0) {
                return this.get(this.length + index, otherwise);
            }
            return this.builder.get(index, otherwise);
        };
        // prettier-ignore
        this.updateAt = (index, update, otherwise) => {
            this.checkLock();
            if (undefined === this.builder ||
                index >= this.length ||
                -index > this.length) {
                return OptLazy(otherwise);
            }
            if (index < 0) {
                return this.updateAt(this.length + index, update);
            }
            return this.builder.updateAt(index, update);
        };
        // prettier-ignore
        this.set = (index, value, otherwise) => {
            return this.updateAt(index, value, otherwise);
        };
        this.prepend = (value) => {
            this.checkLock();
            if (undefined === this.builder) {
                this.builder = this.context.leafBlockBuilder([value]);
                return;
            }
            this.builder.prepend(value);
            this.builder = this.builder.normalized();
        };
        this.append = (value) => {
            this.checkLock();
            if (undefined === this.builder) {
                this.builder = this.context.leafBlockBuilder([value]);
                return;
            }
            this.builder.append(value);
            this.builder = this.builder.normalized();
        };
        this.appendAll = (values) => {
            this.checkLock();
            if (Array.isArray(values)) {
                this.appendArray(values);
                return;
            }
            Stream.from(values).forEachPure(this.append);
        };
        this.insert = (index, value) => {
            this.checkLock();
            if (undefined === this.builder) {
                this.builder = this.context.leafBlockBuilder([value]);
            }
            else {
                if (index === 0) {
                    return this.prepend(value);
                }
                if (index > this.length || -index > this.length + 1) {
                    return this.append(value);
                }
                if (index < 0) {
                    return this.insert(this.length + index, value);
                }
                this.builder.insert(index, value);
                this.builder = this.builder.normalized();
            }
        };
        // prettier-ignore
        this.remove = (index, otherwise) => {
            this.checkLock();
            if (undefined === this.builder ||
                index >= this.length ||
                -index > this.length) {
                return OptLazy(otherwise);
            }
            if (index < 0) {
                return this.remove(this.length + index);
            }
            const result = this.builder.remove(index);
            this.builder = this.builder.normalized();
            return result;
        };
        this.forEach = (f, state = TraverseState()) => {
            if (undefined !== this.builder) {
                if (state.halted)
                    return;
                this._lock++;
                try {
                    this.builder.forEach(f, state);
                }
                finally {
                    this._lock--;
                }
            }
        };
        this.build = () => {
            if (undefined === this.builder) {
                return this.context.empty();
            }
            const result = this.builder.build();
            return result;
        };
        // prettier-ignore
        this.buildMap = (f) => {
            if (undefined === this.builder) {
                return this.context.empty();
            }
            return this.builder.buildMap(f);
        };
    }
    checkLock() {
        if (this._lock) {
            RimbuError.throwModifiedBuilderWhileLoopingOverItError();
        }
    }
    get length() {
        return this.builder?.length ?? 0;
    }
    get isEmpty() {
        return this.length === 0;
    }
    appendFullOrLastWindow(window) {
        const leafBlockBuilder = this.context.leafBlockBuilder(window);
        if (undefined === this.builder) {
            this.builder = leafBlockBuilder;
            return;
        }
        if (this.context.isLeafBlockBuilder(this.builder)) {
            this.builder = this.context.leafTreeBuilder(this.builder, leafBlockBuilder, undefined, this.builder.length + leafBlockBuilder.length);
            return;
        }
        if (this.context.isLeafTreeBuilder(this.builder)) {
            this.builder.appendMiddle(this.builder.right);
            this.builder.right = leafBlockBuilder;
            this.builder.length += leafBlockBuilder.length;
            return;
        }
        RimbuError.throwInvalidStateError();
    }
    appendArray(array) {
        let index = 0;
        const blockSize = this.context.maxBlockSize;
        // fill last child
        if (undefined !== this.builder) {
            if (this.context.isLeafBlockBuilder(this.builder)) {
                index = blockSize - this.builder.length;
                if (index > 0) {
                    const slice = array.slice(0, index);
                    this.builder.children = this.builder.children.concat(slice);
                }
            }
            else if (this.context.isLeafTreeBuilder(this.builder)) {
                const left = this.builder.left;
                index = blockSize - left.length;
                if (index > 0) {
                    const slice = array.slice(0, index);
                    left.children = left.children.concat(slice);
                }
            }
        }
        // append blocks
        while (index < array.length) {
            const end = index + blockSize;
            const window = array.slice(index, end);
            this.appendFullOrLastWindow(window);
            index = end;
        }
    }
}
//# sourceMappingURL=gen-builder.mjs.map