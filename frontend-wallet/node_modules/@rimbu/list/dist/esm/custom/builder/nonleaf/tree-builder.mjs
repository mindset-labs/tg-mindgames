import { TreeBuilderBase } from '../tree/tree-builder.mjs';
export class NonLeafTreeBuilder extends TreeBuilderBase {
    constructor(context, level, source, _left, _right, _middle, length = source?.length ?? 0) {
        super();
        this.context = context;
        this.level = level;
        this.source = source;
        this._left = _left;
        this._right = _right;
        this._middle = _middle;
        this.length = length;
    }
    prepareMutate() {
        if (undefined !== this.source) {
            this._left = this.source.left.createBlockBuilder();
            this._right = this.source.right.createBlockBuilder();
            this._middle =
                null === this.source.middle
                    ? undefined
                    : this.source.middle.createNonLeafBuilder();
            this.source = undefined;
        }
    }
    get left() {
        this.prepareMutate();
        return this._left;
    }
    set left(value) {
        this.prepareMutate();
        this._left = value;
    }
    get right() {
        this.prepareMutate();
        return this._right;
    }
    set right(value) {
        this.prepareMutate();
        this._right = value;
    }
    get middle() {
        this.prepareMutate();
        return this._middle;
    }
    set middle(value) {
        this.prepareMutate();
        this._middle = value;
    }
    getChildLength(child) {
        return child.length;
    }
    modifyFirstChild(f) {
        const delta = this.left.modifyFirstChild(f);
        if (undefined !== delta) {
            this.length += delta;
        }
        return delta;
    }
    modifyLastChild(f) {
        const delta = this.right.modifyLastChild(f);
        if (undefined !== delta) {
            this.length += delta;
        }
        return delta;
    }
    normalized() {
        if (undefined !== this.middle) {
            // middle, nothing to normalize
            return this;
        }
        // no middle
        if (this.left.nrChildren + this.right.nrChildren <=
            this.context.maxBlockSize) {
            // combine left and right
            this.left.concat(this.right);
            return this.left;
        }
        return this;
    }
    first() {
        return this.left.first();
    }
    last() {
        return this.right.last();
    }
    get(index, otherwise) {
        if (undefined !== this.source) {
            return this.source.get(index);
        }
        return super.get(index, otherwise);
    }
    build() {
        if (undefined !== this.source) {
            return this.source;
        }
        return this.context.nonLeafTree(this.left.build(), this.right.build(), this.middle?.build?.() ?? null, this.level);
    }
    buildMap(f) {
        if (undefined !== this.source) {
            return this.source.map(f);
        }
        return this.context.nonLeafTree(this.left.buildMap(f), this.right.buildMap(f), this.middle?.buildMap?.(f) ?? null, this.level);
    }
}
//# sourceMappingURL=tree-builder.mjs.map