import { TreeBuilderBase } from '../tree/tree-builder.mjs';
export class LeafTreeBuilder extends TreeBuilderBase {
    constructor(context, source, _left, _right, _middle, length = source?.length ?? 0) {
        super();
        this.context = context;
        this.source = source;
        this._left = _left;
        this._right = _right;
        this._middle = _middle;
        this.length = length;
    }
    prepareMutate() {
        if (undefined !== this.source) {
            this._left = this.context.leafBlockBuilderSource(this.source.left);
            this._right = this.context.leafBlockBuilderSource(this.source.right);
            this._middle =
                this.source.middle?.createNonLeafBuilder?.() ?? undefined;
            this.source = undefined;
        }
    }
    get level() {
        return 0;
    }
    get left() {
        this.prepareMutate();
        return this._left;
    }
    set left(value) {
        this.prepareMutate();
        this._left = value;
    }
    get right() {
        this.prepareMutate();
        return this._right;
    }
    set right(value) {
        this.prepareMutate();
        this._right = value;
    }
    get middle() {
        this.prepareMutate();
        return this._middle;
    }
    set middle(value) {
        this.prepareMutate();
        this._middle = value;
    }
    getChildLength() {
        return 1;
    }
    appendChildren(children, from) {
        if (children.length === 0 || from >= children.length)
            return;
        if (this.right.nrChildren < this.context.maxBlockSize) {
            // fill right, and append rest
            const items = children.slice(from, from + this.context.maxBlockSize - this.right.nrChildren);
            this.right.children = this.right.children.concat(items);
            this.length += items.length;
            this.appendChildren(children, from + items.length);
            return;
        }
        // add current right to middle and split new
        const block = children.slice(from, from + this.context.maxBlockSize);
        this.appendMiddle(this.right);
        this.right = this.context.leafBlockBuilder(block);
        this.length += block.length;
        this.appendChildren(children, from + block.length);
    }
    normalized() {
        if (this.length <= this.context.maxBlockSize) {
            // can collapse into block
            this.left.concat(this.right);
            return this.left;
        }
        if (undefined !== this.middle) {
            if (this.middle.length + this.left.length <= this.context.maxBlockSize) {
                // can merge middle with left
                this.left.concat(this.middle.first());
                this.middle = undefined;
            }
            else if (this.middle.length + this.right.length <=
                this.context.maxBlockSize) {
                // can merge middle with right
                const newRight = this.middle.last();
                newRight.concat(this.right);
                this.right = newRight;
                this.middle = undefined;
            }
        }
        return this;
    }
    get(index, otherwise) {
        if (undefined !== this.source) {
            return this.source.get(index, otherwise);
        }
        return super.get(index, otherwise);
    }
    build() {
        if (undefined !== this.source) {
            return this.source;
        }
        return this.context.leafTree(this.left.build(), this.right.build(), this.middle?.build?.() ?? null);
    }
    buildMap(f) {
        if (undefined !== this.source) {
            return this.source.map(f);
        }
        return this.context.leafTree(this.left.buildMap(f), this.right.buildMap(f), this.middle?.buildMap?.(f) ?? null);
    }
}
//# sourceMappingURL=tree-builder.mjs.map