import { Arr, RimbuError } from '@rimbu/base';
import { TraverseState } from '@rimbu/common';
export class NonLeafBlockBuilder {
    constructor(context, level, source, _children, length = source?.length ?? 0) {
        this.context = context;
        this.level = level;
        this.source = source;
        this._children = _children;
        this.length = length;
    }
    get children() {
        if (undefined !== this.source) {
            this._children = this.source.children.map((c) => c.createBlockBuilder());
            this.source = undefined;
        }
        return this._children;
    }
    set children(value) {
        if (undefined !== this.source) {
            this._children = this.source.children.map((c) => c.createBlockBuilder());
            this.source = undefined;
        }
        this._children = value;
    }
    get nrChildren() {
        return this.source?.nrChildren ?? this.children.length;
    }
    copy(children, length) {
        return this.context.nonLeafBlockBuilder(this.level, children, length);
    }
    getCoordinates(index) {
        const nrChildren = this.nrChildren;
        const length = this.length;
        if (index >= length) {
            // always return end of last child
            const lastChild = Arr.last(this.children);
            return [nrChildren - 1, lastChild.length];
        }
        const levelBits = this.context.blockSizeBits << (this.level - 1);
        const blockSize = 1 << levelBits;
        const regularSize = nrChildren * blockSize;
        if (length === regularSize) {
            // regular blocks, calculate coordinates
            const childIndex = index >>> levelBits;
            const mask = blockSize - 1;
            const inChildIndex = index & mask;
            return [childIndex, inChildIndex];
        }
        // not regular, need to search per child
        const children = this.children;
        if (index <= length >>> 1) {
            // search left to right
            let i = index;
            for (let childIndex = 0; childIndex < nrChildren; childIndex++) {
                const childLength = children[childIndex].length;
                if (i < childLength) {
                    return [childIndex, i];
                }
                i -= childLength;
            }
        }
        else {
            // search right to left
            let i = length - index;
            for (let childIndex = nrChildren - 1; childIndex >= 0; childIndex--) {
                const childLength = children[childIndex].length;
                if (i <= childLength) {
                    return [childIndex, childLength - i];
                }
                i -= childLength;
            }
        }
        RimbuError.throwInvalidStateError();
    }
    normalized() {
        if (this.nrChildren === 0) {
            // empty
            return undefined;
        }
        const context = this.context;
        const maxBlockSize = context.maxBlockSize;
        if (this.nrChildren > maxBlockSize) {
            // too many children, needs to split
            const middleLength = this.length;
            const result = context.nonLeafTreeBuilder(this.level, this, this.splitRight(), undefined, middleLength);
            return result;
        }
        // already normalized
        return this;
    }
    get(index) {
        if (undefined !== this.source) {
            return this.source.get(index);
        }
        const [childIndex, inChildIndex] = this.getCoordinates(index);
        return this.children[childIndex].get(inChildIndex, RimbuError.throwInvalidStateError);
    }
    updateAt(index, update, otherwise) {
        const [childIndex, inChildIndex] = this.getCoordinates(index);
        return this.children[childIndex].updateAt(inChildIndex, update, otherwise);
    }
    prepend(child) {
        this.length += child.length;
        this.children.unshift(child);
    }
    append(child) {
        this.length += child.length;
        this.children.push(child);
    }
    insert(index, value) {
        const [childIndex, inChildIndex] = this.getCoordinates(index);
        this.length++;
        // insert into child
        const child = this.children[childIndex];
        child.insert(inChildIndex, value);
        if (child.nrChildren <= this.context.maxBlockSize) {
            // no need to normalize
            return;
        }
        // child is too large
        const leftChild = this.children[childIndex - 1];
        if (undefined !== leftChild &&
            leftChild.nrChildren < this.context.maxBlockSize) {
            // shift to leftChild
            const shiftChild = child.dropFirst();
            leftChild.append(shiftChild);
            return;
        }
        const rightChild = this.children[childIndex + 1];
        if (undefined !== rightChild &&
            rightChild.nrChildren < this.context.maxBlockSize) {
            // shift to rightChild
            const shiftChild = child.dropLast();
            rightChild.prepend(shiftChild);
            return;
        }
        // cannot shift, split child
        const newRightChild = child.splitRight();
        this.children.splice(childIndex + 1, 0, newRightChild);
    }
    remove(index) {
        const [childIndex, inChildIndex] = this.getCoordinates(index);
        this.length--;
        // remove from child
        const child = this.children[childIndex];
        const oldValue = child.remove(inChildIndex);
        if (child.nrChildren >= this.context.minBlockSize || this.nrChildren <= 1) {
            // no need to normalize
            return oldValue;
        }
        const leftChild = this.children[childIndex - 1];
        if (undefined !== leftChild &&
            leftChild.nrChildren > this.context.minBlockSize) {
            // can shift from left
            const shiftChild = leftChild.dropLast();
            child.prepend(shiftChild);
            return oldValue;
        }
        const rightChild = this.children[childIndex + 1];
        if (undefined !== rightChild &&
            rightChild.nrChildren > this.context.minBlockSize) {
            // can shift from right
            const shiftChild = rightChild.dropFirst();
            child.append(shiftChild);
            return oldValue;
        }
        if (undefined !== leftChild) {
            // merge with left
            leftChild.concat(child);
            this.children.splice(childIndex, 1);
            return oldValue;
        }
        // merge with right
        child.concat(rightChild);
        this.children.splice(childIndex + 1, 1);
        return oldValue;
    }
    dropFirst() {
        const first = this.children.shift();
        this.length -= first.length;
        return first;
    }
    dropLast() {
        const last = this.children.pop();
        this.length -= last.length;
        return last;
    }
    modifyFirstChild(f) {
        const delta = f(this.first());
        if (undefined !== delta) {
            this.length += delta;
        }
        return delta;
    }
    modifyLastChild(f) {
        const delta = f(this.last());
        if (undefined !== delta) {
            this.length += delta;
        }
        return delta;
    }
    first() {
        return this.children[0];
    }
    last() {
        return Arr.last(this.children);
    }
    splitRight(index = this.nrChildren >>> 1) {
        const rightChildren = this.children.splice(index);
        const oldLength = this.length;
        this.length = 0;
        for (let i = 0; i < this.nrChildren; i++) {
            this.length += this.children[i].length;
        }
        const rightLength = oldLength - this.length;
        return this.copy(rightChildren, rightLength);
    }
    concat(other, prependOther = false) {
        this.children = prependOther
            ? other.children.concat(this.children)
            : this.children.concat(other.children);
        this.length += other.length;
    }
    forEach(f, state = TraverseState()) {
        if (state.halted)
            return;
        let i = -1;
        const length = this.children.length;
        while (!state.halted && ++i < length) {
            this.children[i].forEach(f, state);
        }
    }
    build() {
        if (undefined !== this.source) {
            return this.source;
        }
        return this.context.nonLeafBlock(this.length, this.children.map((c) => c.build()), this.level);
    }
    buildMap(f) {
        if (undefined !== this.source) {
            return this.source.map(f);
        }
        return this.context.nonLeafBlock(this.length, this.children.map((c) => c.buildMap(f)), this.level);
    }
}
//# sourceMappingURL=block-builder.mjs.map