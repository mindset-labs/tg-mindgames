import { RimbuError } from '@rimbu/base';
import { Reducer } from '@rimbu/common';
import { Stream } from '@rimbu/stream';
import { isEmptyStreamSourceInstance } from '@rimbu/stream/custom';
import { CacheMap, createEmptyList, LeafBlock, ReversedLeafBlock, LeafTree, NonLeafBlock, NonLeafTree, GenBuilder, LeafBlockBuilder, NonLeafBlockBuilder, LeafTreeBuilder, NonLeafTreeBuilder, } from '@rimbu/list/custom';
export class ListContext {
    constructor(blockSizeBits) {
        this.blockSizeBits = blockSizeBits;
        // prettier-ignore
        this.builder = () => {
            return new GenBuilder(this);
        };
        this._empty = createEmptyList(this);
        // prettier-ignore
        this.empty = () => {
            return this._empty;
        };
        // prettier-ignore
        this.of = (...values) => {
            if (values.length <= this.maxBlockSize) {
                return this.leafBlock(values);
            }
            return this.from(values);
        };
        // prettier-ignore
        this.from = (...sources) => {
            if (sources.length === 1) {
                const source = sources[0];
                if (source.context === this)
                    return source;
            }
            let result = null;
            let i = -1;
            const length = sources.length;
            while (++i < length) {
                const source = sources[i];
                if (!isEmptyStreamSourceInstance(source)) {
                    if (source.context === this) {
                        if (null === result)
                            result = source;
                        else
                            result = result.concat(source);
                    }
                    else {
                        const builder = this.builder();
                        if (Array.isArray(source))
                            builder.appendArray(source);
                        else
                            builder.appendAll(source);
                        if (!builder.isEmpty) {
                            const build = builder.build();
                            if (null === result)
                                result = build;
                            else
                                result = result.concat(build);
                        }
                    }
                }
            }
            if (null === result)
                return this.empty();
            return result;
        };
        this.fromString = (...sources) => {
            return this.from(...sources);
        };
        // prettier-ignore
        this.reducer = (source) => {
            return Reducer.create(() => undefined === source
                ? this.builder()
                : this.from(source).toBuilder(), (builder, value) => {
                builder.append(value);
                return builder;
            }, (builder) => builder.build());
        };
        this.flatten = (source) => this.from(source).flatMap((s) => s);
        this.unzip = (source, length) => {
            const streams = Stream.unzip(source, length);
            return Stream.from(streams).mapPure(this.from);
        };
        if (blockSizeBits < 2) {
            RimbuError.throwInvalidUsageError('List: blockSizeBits should be at least 2');
        }
        this.maxBlockSize = 1 << blockSizeBits;
        this.minBlockSize = this.maxBlockSize >>> 1;
    }
    get typeTag() {
        return 'List';
    }
    get _types() {
        return undefined;
    }
    createBuilder(source) {
        if (undefined === source || source.isEmpty)
            return new GenBuilder(this);
        const context = source.context;
        if (context.isLeafBlock(source)) {
            const builder = this.leafBlockBuilderSource(source);
            return new GenBuilder(this, builder);
        }
        if (context.isLeafTree(source)) {
            const builder = this.leafTreeBuilderSource(source);
            return new GenBuilder(this, builder);
        }
        RimbuError.throwInvalidStateError();
    }
    leafBlock(children) {
        return new LeafBlock(this, children);
    }
    reversedLeaf(children) {
        return new ReversedLeafBlock(this, children);
    }
    leafTree(left, right, middle) {
        return new LeafTree(this, left, right, middle);
    }
    nonLeafBlock(length, children, level) {
        return new NonLeafBlock(this, length, children, level);
    }
    nonLeafTree(left, right, middle, level) {
        return new NonLeafTree(this, left, right, middle, level);
    }
    leafBlockBuilderSource(source) {
        return new LeafBlockBuilder(this, source);
    }
    leafBlockBuilder(children) {
        return new LeafBlockBuilder(this, undefined, children);
    }
    leafTreeBuilderSource(source) {
        return new LeafTreeBuilder(this, source);
    }
    leafTreeBuilder(left, right, middle, length) {
        return new LeafTreeBuilder(this, undefined, left, right, middle, length);
    }
    nonLeafBlockBuilderSource(source) {
        return new NonLeafBlockBuilder(this, source.level, source);
    }
    nonLeafBlockBuilder(level, children, length) {
        return new NonLeafBlockBuilder(this, level, undefined, children, length);
    }
    nonLeafTreeBuilderSource(source) {
        return new NonLeafTreeBuilder(this, source.level, source);
    }
    nonLeafTreeBuilder(level, left, right, middle, length) {
        return new NonLeafTreeBuilder(this, level, undefined, left, right, middle, length);
    }
    isLeafBlock(obj) {
        return obj instanceof LeafBlock;
    }
    isReversedLeafBlock(obj) {
        return obj instanceof ReversedLeafBlock;
    }
    isNonLeafBlock(obj) {
        return obj instanceof NonLeafBlock;
    }
    isLeafTree(obj) {
        return obj instanceof LeafTree;
    }
    isNonLeafTree(obj) {
        return obj instanceof NonLeafTree;
    }
    isLeafBlockBuilder(obj) {
        return obj instanceof LeafBlockBuilder;
    }
    isLeafTreeBuilder(obj) {
        return obj instanceof LeafTreeBuilder;
    }
    isNonLeafBlockBuilder(obj) {
        return obj instanceof NonLeafBlockBuilder;
    }
    createCacheMap() {
        return new CacheMap();
    }
}
export function createListContext(options) {
    return Object.freeze(new ListContext(options?.blockSizeBits ?? 5));
}
//# sourceMappingURL=context.mjs.map