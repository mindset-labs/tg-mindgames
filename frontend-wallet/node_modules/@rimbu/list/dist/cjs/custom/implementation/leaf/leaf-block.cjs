"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/implementation/leaf/leaf-block.mts
var leaf_block_exports = {};
__export(leaf_block_exports, {
  LeafBlock: () => LeafBlock,
  ReversedLeafBlock: () => ReversedLeafBlock
});
module.exports = __toCommonJS(leaf_block_exports);
var import_base2 = require("@rimbu/base");
var import_common2 = require("@rimbu/common");
var import_stream = require("@rimbu/stream");

// src/custom/implementation/leaf/non-empty.mts
var import_base = require("@rimbu/base");
var import_set_custom = require("@rimbu/collection-types/set-custom");
var import_common = require("@rimbu/common");
var import_custom = require("@rimbu/stream/custom");
var ListNonEmptyBase = class extends import_set_custom.NonEmptyBase {
  [Symbol.iterator]() {
    return this.stream()[Symbol.iterator]();
  }
  get isEmpty() {
    return false;
  }
  nonEmpty() {
    return true;
  }
  assumeNonEmpty() {
    return this;
  }
  asNormal() {
    return this;
  }
  first() {
    return this.get(0, import_base.RimbuError.throwInvalidStateError);
  }
  last() {
    return this.get(this.length - 1, import_base.RimbuError.throwInvalidStateError);
  }
  slice(range, reversed) {
    const result = import_common.IndexRange.getIndicesFor(range, this.length);
    if (result === "all") {
      if (reversed)
        return this.reversed();
      return this;
    }
    if (result === "empty")
      return this.context.empty();
    const [start, end] = result;
    const values = this.drop(start).take(end - start + 1);
    if (!reversed)
      return values;
    return values.reversed();
  }
  sort(comp) {
    const sortedArray = this.toArray().sort(comp?.compare);
    return this.context.from(sortedArray);
  }
  splice({
    index = 0,
    remove = 0,
    insert
  } = {}) {
    if (index < 0) {
      return this.splice({ index: this.length + index, remove, insert });
    }
    if (void 0 === insert) {
      if (remove <= 0)
        return this;
      return this.take(index).concat(this.drop(index + remove));
    }
    if (remove <= 0 && (0, import_custom.isEmptyStreamSourceInstance)(insert))
      return this;
    return this.take(index).concat(insert, this.drop(index + remove));
  }
  insert(index, values) {
    return this.splice({ index, insert: values });
  }
  remove(index, amount = 1) {
    return this.splice({ index, remove: amount });
  }
  repeat(amount) {
    if (amount <= -1)
      return this.reversed().repeat(-amount);
    if (amount <= 1)
      return this;
    const doubleTimes = amount >>> 1;
    const doubleResult = this.concat(this).repeat(doubleTimes);
    const remainTimes = amount % 2;
    if (remainTimes === 0)
      return doubleResult;
    return doubleResult.concat(this);
  }
  rotate(shiftRightAmount) {
    let normalizedAmount = shiftRightAmount % this.length;
    if (normalizedAmount === 0)
      return this;
    if (normalizedAmount < 0)
      normalizedAmount += this.length;
    return this.take(-normalizedAmount).concat(this.drop(-normalizedAmount)).assumeNonEmpty();
  }
  padTo(length, fill, positionPercentage = 0) {
    if (this.length >= length)
      return this;
    const diff = length - this.length;
    const frac = Math.max(0, Math.min(100, positionPercentage)) / 100;
    const frontSize = Math.round(diff * frac);
    const pad = this.context.leafBlock([fill]).repeat(diff);
    return pad.splice({ index: frontSize, insert: this }).assumeNonEmpty();
  }
  filter(pred, range, reversed = false) {
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    const result = this.context.from(stream.filter(pred));
    if (result.length !== this.length)
      return result;
    if (!reversed)
      return this;
    return this.reversed();
  }
  collect(collectFun, range, reversed = false) {
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    return this.context.from(stream.collect(collectFun));
  }
  flatMap(flatMapFun, range, reversed = false) {
    let result = this.context.empty();
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    const iterator = stream[Symbol.iterator]();
    let index = 0;
    const done = Symbol("Done");
    let value;
    while (done !== (value = iterator.fastNext(done))) {
      result = result.concat(flatMapFun(value, index++));
    }
    return result;
  }
  toBuilder() {
    return this.context.createBuilder(this);
  }
  toString() {
    return this.stream().join({ start: "List(", sep: ", ", end: ")" });
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: this.toArray()
    };
  }
};

// src/custom/implementation/leaf/leaf-block.mts
var LeafBlock = class extends ListNonEmptyBase {
  constructor(context, children) {
    super();
    this.context = context;
    this.children = children;
  }
  get length() {
    return this.children.length;
  }
  get level() {
    return 0;
  }
  copy(children) {
    if (children === this.children)
      return this;
    return this.context.leafBlock(children);
  }
  copy2(children) {
    return this.context.leafBlock(children);
  }
  get mutateChildren() {
    return this.children;
  }
  get childrenInMax() {
    return this.children.length <= this.context.maxBlockSize;
  }
  get childrenInMin() {
    return this.children.length >= this.context.minBlockSize;
  }
  get canAddChild() {
    return this.children.length < this.context.maxBlockSize;
  }
  stream(reversed = false) {
    return import_stream.Stream.fromArray(
      this.children,
      void 0,
      reversed
    );
  }
  streamRange(range, reversed = false) {
    return import_stream.Stream.fromArray(
      this.children,
      range,
      reversed
    );
  }
  get(index, otherwise) {
    if (index >= this.length || -index > this.length) {
      return (0, import_common2.OptLazy)(otherwise);
    }
    if (index < 0) {
      return this.get(this.length + index, otherwise);
    }
    return this.children[index];
  }
  prepend(value) {
    if (this.length === 1 && !this.context.isReversedLeafBlock(this)) {
      return this.context.reversedLeaf([this.children[0], value]);
    }
    if (this.canAddChild) {
      return this.prependInternal(value);
    }
    return this.context.leafTree(this.copy([value]), this, null);
  }
  append(value) {
    if (this.canAddChild)
      return this.appendInternal(value);
    return this.context.leafTree(this, this.copy([value]), null);
  }
  prependInternal(value) {
    const newChildren = import_base2.Arr.prepend(this.children, value);
    return this.copy(newChildren);
  }
  appendInternal(value) {
    const newChildren = import_base2.Arr.append(this.children, value);
    return this.copy(newChildren);
  }
  take(amount) {
    if (amount === 0)
      return this.context.empty();
    if (amount >= this.length || -amount > this.length)
      return this;
    if (amount < 0)
      return this.drop(this.length + amount);
    return this.takeChildren(amount);
  }
  drop(amount) {
    if (amount === 0)
      return this;
    if (amount >= this.length || -amount > this.length)
      return this.context.empty();
    if (amount < 0)
      return this.take(this.length + amount);
    return this.dropChildren(amount);
  }
  takeChildren(childAmount) {
    if (childAmount >= this.length)
      return this;
    const newChildren = import_base2.Arr.splice(
      this.children,
      childAmount,
      this.context.maxBlockSize
    );
    return this.copy(newChildren);
  }
  dropChildren(childAmount) {
    if (childAmount <= 0)
      return this;
    const newChildren = import_base2.Arr.splice(this.children, 0, childAmount);
    return this.copy(newChildren);
  }
  concatChildren(other) {
    const addChildren = this.context.isReversedLeafBlock(other) ? import_base2.Arr.reverse(other.children) : other.children;
    const newChildren = this.children.concat(addChildren);
    return this.copy(newChildren);
  }
  concat(...sources) {
    const asList = this.context.from(...sources);
    if (asList.nonEmpty()) {
      if (this.context.isLeafBlock(asList)) {
        if (asList === this && this.children.length > this.context.minBlockSize) {
          return this.context.leafTree(this, this, null);
        }
        return this.concatBlock(asList);
      }
      if (this.context.isLeafTree(asList)) {
        return this.concatTree(asList);
      }
      import_base2.RimbuError.throwInvalidStateError();
    }
    return this;
  }
  concatBlock(other) {
    return this.concatChildren(other)._mutateNormalize();
  }
  concatTree(other) {
    if (this.length + other.left.length <= this.context.maxBlockSize) {
      const newLeft2 = this.concatChildren(other.left);
      return other.copy(newLeft2);
    }
    if (other.left.childrenInMin) {
      const newMiddle2 = other.prependMiddle(other.left);
      return other.copy(this, void 0, newMiddle2);
    }
    const newLeft = this.concatChildren(other.left);
    const newSecond = newLeft._mutateSplitRight(
      newLeft.length - this.context.maxBlockSize
    );
    const newMiddle = other.prependMiddle(newSecond);
    return other.copy(newLeft, void 0, newMiddle);
  }
  updateAt(index, update) {
    if (index >= this.length || -index > this.length)
      return this;
    if (index < 0)
      return this.updateAt(this.length + index, update);
    const newChildren = import_base2.Arr.update(
      this.children,
      index,
      (c) => (0, import_common2.Update)(c, update)
    );
    return this.copy(newChildren);
  }
  forEach(f, state = (0, import_common2.TraverseState)()) {
    if (state.halted)
      return;
    import_base2.Arr.forEach(
      this.children,
      f,
      state,
      this.context.isReversedLeafBlock(this)
    );
  }
  mapPure(mapFun, reversed = false, cacheMap = this.context.createCacheMap()) {
    const currentValue = cacheMap.get(this);
    if (currentValue)
      return currentValue;
    const fn = reversed ? import_base2.Arr.reverseMap : import_base2.Arr.map;
    const newChildren = fn(this.children, mapFun);
    return cacheMap.setAndReturn(this, this.copy2(newChildren));
  }
  map(mapFun, reversed = false, indexOffset = 0) {
    if (reversed) {
      const newChildren2 = import_base2.Arr.reverseMap(this.children, mapFun, indexOffset);
      return this.copy2(newChildren2);
    }
    const newChildren = import_base2.Arr.map(this.children, mapFun, indexOffset);
    return this.copy2(newChildren);
  }
  reversed(cacheMap = this.context.createCacheMap()) {
    if (this.length === 1)
      return this;
    const cachedThis = cacheMap.get(this);
    if (cachedThis !== void 0)
      return cachedThis;
    const reversedThis = this.context.reversedLeaf(this.children);
    return cacheMap.setAndReturn(this, reversedThis);
  }
  _mutateNormalize() {
    if (this.childrenInMax)
      return this;
    const newRight = this._mutateSplitRight();
    return this.context.leafTree(this, newRight, null);
  }
  _mutateSplitRight(childIndex = this.children.length >>> 1) {
    const rightChildren = this.mutateChildren.splice(childIndex);
    return this.copy(rightChildren);
  }
  toArray(range, reversed = false) {
    let result;
    if (void 0 === range)
      result = this.children;
    else {
      const indexRange = import_common2.IndexRange.getIndicesFor(range, this.length);
      if (indexRange === "all")
        result = this.children;
      else if (indexRange === "empty")
        result = [];
      else {
        const [start, end] = indexRange;
        if (!reversed)
          return this.children.slice(start, end + 1);
        return import_base2.Arr.reverse(this.children, start, end);
      }
    }
    if (reversed)
      return import_base2.Arr.reverse(result);
    return result.slice();
  }
  structure() {
    return `<Leaf ${this.length}>`;
  }
  createBlockBuilder() {
    return this.context.leafBlockBuilderSource(this);
  }
};
var ReversedLeafBlock = class extends LeafBlock {
  copy(children) {
    if (children === this.children)
      return this;
    return this.context.reversedLeaf(children);
  }
  copy2(children) {
    return this.context.reversedLeaf(children);
  }
  stream(reversed = false) {
    return import_stream.Stream.fromArray(
      this.children,
      void 0,
      !reversed
    );
  }
  streamRange(range, reversed = false) {
    const indices = import_common2.IndexRange.getIndicesFor(range, this.length);
    if (indices === "empty")
      return import_stream.Stream.empty();
    if (indices === "all")
      return this.stream(reversed);
    const start = this.length - 1 - indices[1];
    const end = this.length - 1 - indices[0];
    return import_stream.Stream.fromArray(this.children, { start, end }, !reversed);
  }
  get(index, otherwise) {
    if (index >= this.length || -index > this.length) {
      return (0, import_common2.OptLazy)(otherwise);
    }
    if (index < 0) {
      return this.get(this.length + index, otherwise);
    }
    return this.children[this.length - 1 - index];
  }
  prependInternal(value) {
    return super.appendInternal(value);
  }
  appendInternal(value) {
    return super.prependInternal(value);
  }
  takeChildren(childAmount) {
    return super.dropChildren(this.length - childAmount);
  }
  dropChildren(childAmount) {
    return super.takeChildren(this.length - childAmount);
  }
  concatChildren(other) {
    if (other.context.isReversedLeafBlock(other)) {
      return this.copy(other.children.concat(this.children));
    }
    return other.copy(import_base2.Arr.reverse(this.children).concat(other.children));
  }
  updateAt(index, update) {
    if (index >= this.length || -index > this.length)
      return this;
    if (index < 0)
      return this.updateAt(this.length + index, update);
    return super.updateAt(this.length - 1 - index, update);
  }
  map(mapFun, reversed = false, indexOffset = 0) {
    if (!reversed) {
      const newChildren2 = import_base2.Arr.reverseMap(this.children, mapFun, indexOffset);
      return super.copy2(newChildren2);
    }
    const newChildren = import_base2.Arr.map(this.children, mapFun, indexOffset);
    return super.copy2(newChildren);
  }
  reversed(cacheMap = this.context.createCacheMap()) {
    if (this.length === 1)
      return this;
    const cachedThis = cacheMap.get(this);
    if (cachedThis !== void 0)
      return cachedThis;
    const reversedThis = this.context.leafBlock(this.children);
    return cacheMap.setAndReturn(this, reversedThis);
  }
  toArray(range, reversed = false) {
    let result;
    if (void 0 === range)
      result = this.children;
    else {
      const indexRange = import_common2.IndexRange.getIndicesFor(range, this.length);
      if (indexRange === "empty")
        return [];
      else if (indexRange === "all")
        result = this.children;
      else {
        const [indexStart, indexEnd] = indexRange;
        const start = this.length - 1 - indexEnd;
        const end = this.length - 1 - indexStart;
        if (!reversed)
          return import_base2.Arr.reverse(this.children, start, end);
        return this.children.slice(start, end + 1);
      }
    }
    if (!reversed)
      return import_base2.Arr.reverse(result);
    return result.slice();
  }
  _mutateSplitRight(childIndex = this.children.length >>> 1) {
    const rightChildren = this.mutateChildren.splice(
      0,
      this.children.length - childIndex
    );
    return this.copy(rightChildren);
  }
  structure() {
    return `<RLeaf ${this.length}>`;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LeafBlock,
  ReversedLeafBlock
});
