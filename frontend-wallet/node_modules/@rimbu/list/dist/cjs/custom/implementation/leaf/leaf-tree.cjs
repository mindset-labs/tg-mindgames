"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/implementation/leaf/leaf-tree.mts
var leaf_tree_exports = {};
__export(leaf_tree_exports, {
  LeafTree: () => LeafTree
});
module.exports = __toCommonJS(leaf_tree_exports);
var import_base3 = require("@rimbu/base");
var import_common3 = require("@rimbu/common");

// src/custom/implementation/tree/operations.mts
var import_base = require("@rimbu/base");
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
function treeStream(tree, range, reversed = false) {
  const indexRange = import_common.IndexRange.getIndicesFor(
    range ?? { start: 0 },
    tree.length
  );
  if (indexRange === "empty")
    return import_stream.Stream.empty();
  if (indexRange === "all") {
    const rightStream2 = tree.right.stream(reversed);
    const leftStream2 = tree.left.stream(reversed);
    if (null === tree.middle) {
      if (reversed)
        return rightStream2.concat(leftStream2);
      return leftStream2.concat(rightStream2);
    }
    const middleStream2 = tree.middle.stream(reversed);
    if (reversed)
      return rightStream2.concat(middleStream2, leftStream2);
    return leftStream2.concat(middleStream2, rightStream2);
  }
  const [start, end] = indexRange;
  const leftStream = tree.left.streamRange({ start, end }, reversed);
  if (null === tree.middle) {
    const rightStart2 = Math.max(0, start - tree.left.length);
    const rightEnd2 = end - tree.left.length;
    if (rightEnd2 < 0)
      return leftStream;
    const rightStream2 = tree.right.streamRange(
      { start: rightStart2, end: rightEnd2 },
      reversed
    );
    if (reversed)
      return rightStream2.concat(leftStream);
    return leftStream.concat(rightStream2);
  }
  const middleStart = Math.max(0, start - tree.left.length);
  const middleEnd = end - tree.left.length;
  if (middleEnd < 0)
    return leftStream;
  const middleStream = tree.middle.streamRange(
    { start: middleStart, end: middleEnd },
    reversed
  );
  const rightStart = Math.max(0, middleStart - tree.middle.length);
  const rightEnd = middleEnd - tree.middle.length;
  if (rightEnd < 0) {
    if (reversed)
      return middleStream.concat(leftStream);
    return leftStream.concat(middleStream);
  }
  const rightStream = tree.right.streamRange(
    { start: rightStart, end: rightEnd },
    reversed
  );
  if (reversed)
    return rightStream.concat(middleStream, leftStream);
  return leftStream.concat(middleStream, rightStream);
}
function treeGet(tree, index) {
  const middleIndex = index - tree.left.length;
  if (middleIndex < 0) {
    return tree.left.get(index, import_base.RimbuError.throwInvalidStateError);
  }
  if (null === tree.middle) {
    return tree.right.get(middleIndex, import_base.RimbuError.throwInvalidStateError);
  }
  const rightIndex = middleIndex - tree.middle.length;
  if (rightIndex < 0)
    return tree.middle.get(middleIndex);
  return tree.right.get(rightIndex, import_base.RimbuError.throwInvalidStateError);
}
function treePrepend(tree, child) {
  if (tree.left.canAddChild) {
    const newLeft2 = tree.left.prependInternal(child);
    return tree.copy(newLeft2);
  }
  if (null === tree.middle && tree.right.canAddChild) {
    if (tree.context.isReversedLeafBlock(tree.left)) {
      const newLeftChildren2 = import_base.Arr.splice(tree.left.children, 0, 1);
      newLeftChildren2.push(child);
      const moveRightChild2 = tree.left.children[0];
      const newLeftLength2 = tree.left.length - tree.getChildLength(moveRightChild2) + tree.getChildLength(child);
      const newLeft3 = tree.left.copy(newLeftChildren2, newLeftLength2);
      const newRight2 = tree.right.prependInternal(moveRightChild2);
      return tree.copy(newLeft3, newRight2);
    }
    const newLeftChildren = import_base.Arr.splice(
      tree.left.children,
      tree.context.maxBlockSize - 1,
      1
    );
    newLeftChildren.unshift(child);
    const moveRightChild = import_base.Arr.last(tree.left.children);
    const newLeftLength = tree.left.length - tree.getChildLength(moveRightChild) + tree.getChildLength(child);
    const newLeft2 = tree.left.copy(newLeftChildren, newLeftLength);
    const newRight = tree.right.prependInternal(moveRightChild);
    return tree.copy(newLeft2, newRight);
  }
  const newMiddle = tree.prependMiddle(tree.left);
  const newLeft = tree.left.copy([child], tree.getChildLength(child));
  return tree.copy(newLeft, void 0, newMiddle);
}
function treeAppend(tree, child) {
  if (tree.right.canAddChild) {
    const newRight2 = tree.right.appendInternal(child);
    return tree.copy(void 0, newRight2);
  }
  if (null === tree.middle && tree.left.canAddChild) {
    if (tree.context.isReversedLeafBlock(tree.right)) {
      const newRightChildren2 = import_base.Arr.splice(
        tree.right.children,
        tree.right.children.length - 1,
        1
      );
      newRightChildren2.unshift(child);
      const moveLeftChild2 = import_base.Arr.last(tree.right.children);
      const newRightLength2 = tree.right.length - tree.getChildLength(moveLeftChild2) + tree.getChildLength(child);
      const newRight3 = tree.right.copy(newRightChildren2, newRightLength2);
      const newLeft2 = tree.left.appendInternal(moveLeftChild2);
      return tree.copy(newLeft2, newRight3);
    }
    const newRightChildren = import_base.Arr.splice(tree.right.children, 0, 1);
    newRightChildren.push(child);
    const moveLeftChild = tree.right.children[0];
    const newRightLength = tree.right.length - tree.getChildLength(moveLeftChild) + tree.getChildLength(child);
    const newRight2 = tree.right.copy(newRightChildren, newRightLength);
    const newLeft = tree.left.appendInternal(moveLeftChild);
    return tree.copy(newLeft, newRight2);
  }
  const newMiddle = tree.appendMiddle(tree.right);
  const newRight = tree.right.copy([child], tree.getChildLength(child));
  return tree.copy(void 0, newRight, newMiddle);
}
function treeUpdate(tree, index, update) {
  const middleIndex = index - tree.left.length;
  if (middleIndex < 0) {
    const newLeft = tree.left.updateAt(index, update);
    return tree.copy(newLeft);
  }
  if (null === tree.middle) {
    const newRight = tree.right.updateAt(middleIndex, update);
    return tree.copy(void 0, newRight);
  }
  const rightIndex = middleIndex - tree.middle.length;
  if (rightIndex >= 0) {
    const newRight = tree.right.updateAt(rightIndex, update);
    return tree.copy(void 0, newRight);
  }
  const newMiddle = tree.middle.updateAt(middleIndex, update);
  return tree.copy(void 0, void 0, newMiddle);
}
function treeToArray(tree, range, reversed = false) {
  const indexRange = import_common.IndexRange.getIndicesFor(
    range ?? { start: 0 },
    tree.length
  );
  if (indexRange === "empty")
    return [];
  if (indexRange === "all") {
    const leftArray2 = tree.left.toArray(void 0, reversed);
    const rightArray2 = tree.right.toArray(void 0, reversed);
    if (null === tree.middle) {
      if (reversed)
        return rightArray2.concat(leftArray2);
      return leftArray2.concat(rightArray2);
    }
    const middleArray2 = tree.middle.toArray(void 0, reversed);
    if (reversed)
      return rightArray2.concat(middleArray2, leftArray2);
    return leftArray2.concat(middleArray2, rightArray2);
  }
  const [start, end] = indexRange;
  const leftArray = tree.left.toArray({ start, end }, reversed);
  if (null === tree.middle) {
    const rightStart2 = Math.max(0, start - tree.left.length);
    const rightEnd2 = end - tree.left.length;
    if (rightEnd2 < 0)
      return leftArray;
    const rightArray2 = tree.right.toArray(
      { start: rightStart2, end: rightEnd2 },
      reversed
    );
    if (reversed)
      return rightArray2.concat(leftArray);
    return leftArray.concat(rightArray2);
  }
  const middleStart = Math.max(0, start - tree.left.length);
  const middleEnd = end - tree.left.length;
  if (middleEnd < 0)
    return leftArray;
  const middleArray = tree.middle.toArray(
    { start: middleStart, end: middleEnd },
    reversed
  );
  const rightStart = Math.max(0, middleStart - tree.middle.length);
  const rightEnd = middleEnd - tree.middle.length;
  if (rightEnd < 0) {
    if (reversed)
      return middleArray.concat(leftArray);
    return leftArray.concat(middleArray);
  }
  const rightArray = tree.right.toArray(
    { start: rightStart, end: rightEnd },
    reversed
  );
  if (reversed)
    return rightArray.concat(middleArray, leftArray);
  return leftArray.concat(middleArray, rightArray);
}
function treeForEach(tree, f, state) {
  if (state.halted)
    return;
  tree.left.forEach(f, state);
  if (state.halted)
    return;
  if (null !== tree.middle) {
    tree.middle.forEach(f, state);
  }
  if (state.halted)
    return;
  tree.right.forEach(f, state);
}

// src/custom/implementation/leaf/non-empty.mts
var import_base2 = require("@rimbu/base");
var import_set_custom = require("@rimbu/collection-types/set-custom");
var import_common2 = require("@rimbu/common");
var import_custom = require("@rimbu/stream/custom");
var ListNonEmptyBase = class extends import_set_custom.NonEmptyBase {
  [Symbol.iterator]() {
    return this.stream()[Symbol.iterator]();
  }
  get isEmpty() {
    return false;
  }
  nonEmpty() {
    return true;
  }
  assumeNonEmpty() {
    return this;
  }
  asNormal() {
    return this;
  }
  first() {
    return this.get(0, import_base2.RimbuError.throwInvalidStateError);
  }
  last() {
    return this.get(this.length - 1, import_base2.RimbuError.throwInvalidStateError);
  }
  slice(range, reversed) {
    const result = import_common2.IndexRange.getIndicesFor(range, this.length);
    if (result === "all") {
      if (reversed)
        return this.reversed();
      return this;
    }
    if (result === "empty")
      return this.context.empty();
    const [start, end] = result;
    const values = this.drop(start).take(end - start + 1);
    if (!reversed)
      return values;
    return values.reversed();
  }
  sort(comp) {
    const sortedArray = this.toArray().sort(comp?.compare);
    return this.context.from(sortedArray);
  }
  splice({
    index = 0,
    remove = 0,
    insert
  } = {}) {
    if (index < 0) {
      return this.splice({ index: this.length + index, remove, insert });
    }
    if (void 0 === insert) {
      if (remove <= 0)
        return this;
      return this.take(index).concat(this.drop(index + remove));
    }
    if (remove <= 0 && (0, import_custom.isEmptyStreamSourceInstance)(insert))
      return this;
    return this.take(index).concat(insert, this.drop(index + remove));
  }
  insert(index, values) {
    return this.splice({ index, insert: values });
  }
  remove(index, amount = 1) {
    return this.splice({ index, remove: amount });
  }
  repeat(amount) {
    if (amount <= -1)
      return this.reversed().repeat(-amount);
    if (amount <= 1)
      return this;
    const doubleTimes = amount >>> 1;
    const doubleResult = this.concat(this).repeat(doubleTimes);
    const remainTimes = amount % 2;
    if (remainTimes === 0)
      return doubleResult;
    return doubleResult.concat(this);
  }
  rotate(shiftRightAmount) {
    let normalizedAmount = shiftRightAmount % this.length;
    if (normalizedAmount === 0)
      return this;
    if (normalizedAmount < 0)
      normalizedAmount += this.length;
    return this.take(-normalizedAmount).concat(this.drop(-normalizedAmount)).assumeNonEmpty();
  }
  padTo(length, fill, positionPercentage = 0) {
    if (this.length >= length)
      return this;
    const diff = length - this.length;
    const frac = Math.max(0, Math.min(100, positionPercentage)) / 100;
    const frontSize = Math.round(diff * frac);
    const pad = this.context.leafBlock([fill]).repeat(diff);
    return pad.splice({ index: frontSize, insert: this }).assumeNonEmpty();
  }
  filter(pred, range, reversed = false) {
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    const result = this.context.from(stream.filter(pred));
    if (result.length !== this.length)
      return result;
    if (!reversed)
      return this;
    return this.reversed();
  }
  collect(collectFun, range, reversed = false) {
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    return this.context.from(stream.collect(collectFun));
  }
  flatMap(flatMapFun, range, reversed = false) {
    let result = this.context.empty();
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    const iterator = stream[Symbol.iterator]();
    let index = 0;
    const done = Symbol("Done");
    let value;
    while (done !== (value = iterator.fastNext(done))) {
      result = result.concat(flatMapFun(value, index++));
    }
    return result;
  }
  toBuilder() {
    return this.context.createBuilder(this);
  }
  toString() {
    return this.stream().join({ start: "List(", sep: ", ", end: ")" });
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: this.toArray()
    };
  }
};

// src/custom/implementation/leaf/leaf-tree.mts
var LeafTree = class extends ListNonEmptyBase {
  constructor(context, left, right, middle, length = left.length + right.length + (null === middle ? 0 : middle.length)) {
    super();
    this.context = context;
    this.left = left;
    this.right = right;
    this.middle = middle;
    this.length = length;
  }
  getChildLength() {
    return 1;
  }
  copy(left = this.left, right = this.right, middle = this.middle) {
    if (left === this.left && right === this.right && middle === this.middle) {
      return this;
    }
    return this.context.leafTree(left, right, middle);
  }
  copy2(left, right, middle) {
    return this.context.leafTree(left, right, middle);
  }
  stream(reversed = false) {
    return treeStream(
      this,
      void 0,
      reversed
    );
  }
  streamRange(range, reversed = false) {
    return treeStream(this, range, reversed);
  }
  get(index, otherwise) {
    if (index >= this.length || -index > this.length) {
      return (0, import_common3.OptLazy)(otherwise);
    }
    if (index < 0) {
      return this.get(this.length + index, otherwise);
    }
    return treeGet(this, index);
  }
  prepend(value) {
    return treePrepend(this, value);
  }
  append(value) {
    return treeAppend(this, value);
  }
  prependMiddle(child) {
    return this.middle?.prepend(child) ?? this.context.nonLeafBlock(child.length, [child], 1);
  }
  appendMiddle(child) {
    return this.middle?.append(child) ?? this.context.nonLeafBlock(child.length, [child], 1);
  }
  take(amountInput) {
    const amount = Math.floor(amountInput);
    if (amount === 0)
      return this.context.empty();
    if (amount >= this.length || -amount > this.length)
      return this;
    if (amount < 0)
      return this.drop(this.length + amount);
    const middleAmount = amount - this.left.length;
    if (middleAmount <= 0)
      return this.left.take(amount);
    if (null === this.middle) {
      return this.copy(
        void 0,
        this.right.takeChildren(middleAmount)
      )._normalize();
    }
    const rightAmount = middleAmount - this.middle.length;
    if (rightAmount > 0) {
      const newRight2 = this.right.takeChildren(rightAmount);
      return this.copy(void 0, newRight2)._normalize();
    }
    const [newMiddle, upRight, inUpRight] = this.middle.takeInternal(middleAmount);
    const newRight = upRight.takeChildren(inUpRight);
    return this.copy(void 0, newRight, newMiddle)._normalize();
  }
  drop(amount) {
    if (amount === 0)
      return this;
    if (amount >= this.length || -amount > this.length)
      return this.context.empty();
    if (amount < 0)
      return this.take(this.length + amount);
    const middleAmount = amount - this.left.length;
    if (middleAmount < 0) {
      const newLeft2 = this.left.dropChildren(amount);
      return this.copy(newLeft2)._normalize();
    }
    if (null === this.middle) {
      return this.right.drop(middleAmount);
    }
    const rightAmount = middleAmount - this.middle.length;
    if (rightAmount >= 0) {
      return this.right.drop(rightAmount);
    }
    const [newMiddle, upLeft, inUpLeft] = this.middle.dropInternal(middleAmount);
    const newLeft = upLeft.dropChildren(inUpLeft);
    return this.copy(newLeft, void 0, newMiddle)._normalize();
  }
  concat(...sources) {
    const asList = this.context.from(...sources);
    if (asList.nonEmpty()) {
      if (this.context.isLeafBlock(asList)) {
        return this.concatBlock(asList);
      } else if (this.context.isLeafTree(asList)) {
        return this.concatTree(asList);
      } else {
        import_base3.RimbuError.throwInvalidStateError();
      }
    }
    return this;
  }
  concatBlock(other) {
    if (this.right.length + other.length <= this.context.maxBlockSize) {
      const newRight2 = this.right.concatChildren(other);
      return this.copy(void 0, newRight2);
    }
    if (this.right.childrenInMin) {
      const newMiddle2 = this.appendMiddle(this.right);
      return this.copy(void 0, other, newMiddle2);
    }
    const newRight = this.right.concatChildren(other);
    const newLast = newRight._mutateSplitRight(this.context.maxBlockSize);
    const newMiddle = this.appendMiddle(newRight);
    return this.copy(void 0, newLast, newMiddle);
  }
  concatTree(other) {
    const jointLength = this.right.length + other.left.length;
    if (jointLength < this.context.minBlockSize) {
      if (null === this.middle) {
        const joint3 = this.left.concatChildren(this.right).concatChildren(other.left);
        const toMiddle = joint3._mutateSplitRight(
          joint3.children.length - this.context.maxBlockSize
        );
        const newMiddle3 = other.prependMiddle(toMiddle);
        return other.copy(joint3, void 0, newMiddle3);
      }
      const [newMiddle2, toJoint] = this.middle.dropLast();
      const joint2 = toJoint.concatChildren(this.right).concatChildren(other.left);
      if (joint2.childrenInMax) {
        const m = null === newMiddle2 ? other.prependMiddle(joint2) : newMiddle2.concat(other.prependMiddle(joint2));
        return this.copy(void 0, other.right, m);
      }
      const newOtherLeft = joint2._mutateSplitRight();
      const newMiddle22 = null === newMiddle2 ? other.prependMiddle(newOtherLeft).prepend(joint2) : null === other.middle ? newMiddle2.append(joint2).append(newOtherLeft) : newMiddle2.append(joint2).append(newOtherLeft).concat(other.middle);
      return this.copy(void 0, other.right, newMiddle22);
    }
    if (jointLength <= this.context.maxBlockSize) {
      const joint2 = this.right.concatChildren(other.left);
      const newThisMiddle2 = this.appendMiddle(joint2);
      const newMiddle2 = null === other.middle ? newThisMiddle2 : newThisMiddle2.concat(other.middle);
      return this.copy(void 0, other.right, newMiddle2);
    }
    if (this.right.childrenInMin && other.left.childrenInMin) {
      const newThisMiddle2 = this.appendMiddle(this.right).append(other.left);
      const newMiddle2 = null === other.middle ? newThisMiddle2 : newThisMiddle2.concat(other.middle);
      return this.copy(void 0, other.right, newMiddle2);
    }
    const joint = this.right.concatChildren(other.left);
    const jointRight = joint._mutateSplitRight();
    const newThisMiddle = this.appendMiddle(joint).append(jointRight);
    const newMiddle = null === other.middle ? newThisMiddle : newThisMiddle.concat(other.middle);
    return this.copy(void 0, other.right, newMiddle);
  }
  updateAt(index, update) {
    if (index >= this.length || -index > this.length)
      return this;
    if (index < 0)
      return this.updateAt(this.length + index, update);
    return treeUpdate(this, index, update);
  }
  forEach(f, state = (0, import_common3.TraverseState)()) {
    if (state.halted)
      return;
    treeForEach(this, f, state);
  }
  mapPure(mapFun, reversed = false, cacheMap = this.context.createCacheMap()) {
    const currentValue = cacheMap.get(this);
    if (currentValue)
      return currentValue;
    const mappedLeft = this.left.mapPure(mapFun, reversed, cacheMap);
    const mappedMiddle = null === this.middle ? null : this.middle.mapPure(mapFun, reversed, cacheMap);
    const mappedRight = this.right.mapPure(mapFun, reversed, cacheMap);
    const result = reversed ? this.copy2(mappedRight, mappedLeft, mappedMiddle) : this.copy2(mappedLeft, mappedRight, mappedMiddle);
    return cacheMap.setAndReturn(this, result);
  }
  map(mapFun, reversed = false, indexOffset = 0) {
    let offset = indexOffset;
    if (reversed) {
      const newLeft2 = this.right.map(mapFun, true, offset);
      offset += this.right.length;
      const newMiddle2 = null === this.middle ? null : this.middle.map(mapFun, true, offset);
      if (null !== this.middle)
        offset += this.middle.length;
      const newRight2 = this.left.map(mapFun, true, offset);
      return this.copy2(newLeft2, newRight2, newMiddle2);
    }
    const newLeft = this.left.map(mapFun, false, offset);
    offset += this.left.length;
    const newMiddle = null === this.middle ? null : this.middle.map(mapFun, false, offset);
    if (null !== this.middle)
      offset += this.middle.length;
    const newRight = this.right.map(mapFun, false, offset);
    return this.copy2(newLeft, newRight, newMiddle);
  }
  reversed(cacheMap = this.context.createCacheMap()) {
    const cachedThis = cacheMap.get(this);
    if (cachedThis !== void 0)
      return cachedThis;
    const newMid = this.middle?.reversed(cacheMap) ?? null;
    const newLeft = this.right.reversed(cacheMap);
    const newRight = this.left === this.right ? newLeft : this.left.reversed(cacheMap);
    const reversedThis = this.copy(newLeft, newRight, newMid);
    return cacheMap.setAndReturn(this, reversedThis);
  }
  toArray(range, reversed = false) {
    return treeToArray(this, range, reversed);
  }
  _normalize() {
    if (null === this.middle) {
      if (this.length <= this.context.maxBlockSize) {
        return this.left.concatChildren(this.right);
      }
    } else if (this.context.isNonLeafBlock(this.middle)) {
      if (this.length <= this.context.maxBlockSize) {
        return this.left.concatChildren(this.middle.getChild(0)).concatChildren(this.right);
      }
      const firstChild = this.middle.getChild(0);
      if (this.left.length + firstChild.length <= this.context.maxBlockSize) {
        const result = this.middle.dropFirst();
        const newMiddle = result[0];
        const block = result[1];
        return this.copy(this.left.concatChildren(block), void 0, newMiddle);
      }
      const lastChild = this.middle.getChild(this.middle.nrChildren - 1);
      if (this.right.length + lastChild.length <= this.context.maxBlockSize) {
        const result = this.middle.dropLast();
        const newMiddle = result[0];
        const block = result[1];
        return this.copy(
          void 0,
          block.concatChildren(this.right),
          newMiddle
        );
      }
    }
    return this;
  }
  structure() {
    return `<LeafTree len:${this.length}
 l:${this.left.structure()}
 m: ${this.middle && this.middle.structure()}
 r:${this.right.structure()}
>`;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LeafTree
});
