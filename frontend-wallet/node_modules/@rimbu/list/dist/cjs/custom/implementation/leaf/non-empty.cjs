"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/implementation/leaf/non-empty.mts
var non_empty_exports = {};
__export(non_empty_exports, {
  ListNonEmptyBase: () => ListNonEmptyBase
});
module.exports = __toCommonJS(non_empty_exports);
var import_base = require("@rimbu/base");
var import_set_custom = require("@rimbu/collection-types/set-custom");
var import_common = require("@rimbu/common");
var import_custom = require("@rimbu/stream/custom");
var ListNonEmptyBase = class extends import_set_custom.NonEmptyBase {
  [Symbol.iterator]() {
    return this.stream()[Symbol.iterator]();
  }
  get isEmpty() {
    return false;
  }
  nonEmpty() {
    return true;
  }
  assumeNonEmpty() {
    return this;
  }
  asNormal() {
    return this;
  }
  first() {
    return this.get(0, import_base.RimbuError.throwInvalidStateError);
  }
  last() {
    return this.get(this.length - 1, import_base.RimbuError.throwInvalidStateError);
  }
  slice(range, reversed) {
    const result = import_common.IndexRange.getIndicesFor(range, this.length);
    if (result === "all") {
      if (reversed)
        return this.reversed();
      return this;
    }
    if (result === "empty")
      return this.context.empty();
    const [start, end] = result;
    const values = this.drop(start).take(end - start + 1);
    if (!reversed)
      return values;
    return values.reversed();
  }
  sort(comp) {
    const sortedArray = this.toArray().sort(comp?.compare);
    return this.context.from(sortedArray);
  }
  splice({
    index = 0,
    remove = 0,
    insert
  } = {}) {
    if (index < 0) {
      return this.splice({ index: this.length + index, remove, insert });
    }
    if (void 0 === insert) {
      if (remove <= 0)
        return this;
      return this.take(index).concat(this.drop(index + remove));
    }
    if (remove <= 0 && (0, import_custom.isEmptyStreamSourceInstance)(insert))
      return this;
    return this.take(index).concat(insert, this.drop(index + remove));
  }
  insert(index, values) {
    return this.splice({ index, insert: values });
  }
  remove(index, amount = 1) {
    return this.splice({ index, remove: amount });
  }
  repeat(amount) {
    if (amount <= -1)
      return this.reversed().repeat(-amount);
    if (amount <= 1)
      return this;
    const doubleTimes = amount >>> 1;
    const doubleResult = this.concat(this).repeat(doubleTimes);
    const remainTimes = amount % 2;
    if (remainTimes === 0)
      return doubleResult;
    return doubleResult.concat(this);
  }
  rotate(shiftRightAmount) {
    let normalizedAmount = shiftRightAmount % this.length;
    if (normalizedAmount === 0)
      return this;
    if (normalizedAmount < 0)
      normalizedAmount += this.length;
    return this.take(-normalizedAmount).concat(this.drop(-normalizedAmount)).assumeNonEmpty();
  }
  padTo(length, fill, positionPercentage = 0) {
    if (this.length >= length)
      return this;
    const diff = length - this.length;
    const frac = Math.max(0, Math.min(100, positionPercentage)) / 100;
    const frontSize = Math.round(diff * frac);
    const pad = this.context.leafBlock([fill]).repeat(diff);
    return pad.splice({ index: frontSize, insert: this }).assumeNonEmpty();
  }
  filter(pred, range, reversed = false) {
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    const result = this.context.from(stream.filter(pred));
    if (result.length !== this.length)
      return result;
    if (!reversed)
      return this;
    return this.reversed();
  }
  collect(collectFun, range, reversed = false) {
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    return this.context.from(stream.collect(collectFun));
  }
  flatMap(flatMapFun, range, reversed = false) {
    let result = this.context.empty();
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    const iterator = stream[Symbol.iterator]();
    let index = 0;
    const done = Symbol("Done");
    let value;
    while (done !== (value = iterator.fastNext(done))) {
      result = result.concat(flatMapFun(value, index++));
    }
    return result;
  }
  toBuilder() {
    return this.context.createBuilder(this);
  }
  toString() {
    return this.stream().join({ start: "List(", sep: ", ", end: ")" });
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: this.toArray()
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ListNonEmptyBase
});
