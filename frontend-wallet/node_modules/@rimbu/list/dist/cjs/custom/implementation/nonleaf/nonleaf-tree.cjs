"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/implementation/nonleaf/nonleaf-tree.mts
var nonleaf_tree_exports = {};
__export(nonleaf_tree_exports, {
  NonLeafTree: () => NonLeafTree
});
module.exports = __toCommonJS(nonleaf_tree_exports);
var import_base2 = require("@rimbu/base");

// src/custom/implementation/tree/operations.mts
var import_base = require("@rimbu/base");
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
function treeStream(tree, range, reversed = false) {
  const indexRange = import_common.IndexRange.getIndicesFor(
    range ?? { start: 0 },
    tree.length
  );
  if (indexRange === "empty")
    return import_stream.Stream.empty();
  if (indexRange === "all") {
    const rightStream2 = tree.right.stream(reversed);
    const leftStream2 = tree.left.stream(reversed);
    if (null === tree.middle) {
      if (reversed)
        return rightStream2.concat(leftStream2);
      return leftStream2.concat(rightStream2);
    }
    const middleStream2 = tree.middle.stream(reversed);
    if (reversed)
      return rightStream2.concat(middleStream2, leftStream2);
    return leftStream2.concat(middleStream2, rightStream2);
  }
  const [start, end] = indexRange;
  const leftStream = tree.left.streamRange({ start, end }, reversed);
  if (null === tree.middle) {
    const rightStart2 = Math.max(0, start - tree.left.length);
    const rightEnd2 = end - tree.left.length;
    if (rightEnd2 < 0)
      return leftStream;
    const rightStream2 = tree.right.streamRange(
      { start: rightStart2, end: rightEnd2 },
      reversed
    );
    if (reversed)
      return rightStream2.concat(leftStream);
    return leftStream.concat(rightStream2);
  }
  const middleStart = Math.max(0, start - tree.left.length);
  const middleEnd = end - tree.left.length;
  if (middleEnd < 0)
    return leftStream;
  const middleStream = tree.middle.streamRange(
    { start: middleStart, end: middleEnd },
    reversed
  );
  const rightStart = Math.max(0, middleStart - tree.middle.length);
  const rightEnd = middleEnd - tree.middle.length;
  if (rightEnd < 0) {
    if (reversed)
      return middleStream.concat(leftStream);
    return leftStream.concat(middleStream);
  }
  const rightStream = tree.right.streamRange(
    { start: rightStart, end: rightEnd },
    reversed
  );
  if (reversed)
    return rightStream.concat(middleStream, leftStream);
  return leftStream.concat(middleStream, rightStream);
}
function treeGet(tree, index) {
  const middleIndex = index - tree.left.length;
  if (middleIndex < 0) {
    return tree.left.get(index, import_base.RimbuError.throwInvalidStateError);
  }
  if (null === tree.middle) {
    return tree.right.get(middleIndex, import_base.RimbuError.throwInvalidStateError);
  }
  const rightIndex = middleIndex - tree.middle.length;
  if (rightIndex < 0)
    return tree.middle.get(middleIndex);
  return tree.right.get(rightIndex, import_base.RimbuError.throwInvalidStateError);
}
function treePrepend(tree, child) {
  if (tree.left.canAddChild) {
    const newLeft2 = tree.left.prependInternal(child);
    return tree.copy(newLeft2);
  }
  if (null === tree.middle && tree.right.canAddChild) {
    if (tree.context.isReversedLeafBlock(tree.left)) {
      const newLeftChildren2 = import_base.Arr.splice(tree.left.children, 0, 1);
      newLeftChildren2.push(child);
      const moveRightChild2 = tree.left.children[0];
      const newLeftLength2 = tree.left.length - tree.getChildLength(moveRightChild2) + tree.getChildLength(child);
      const newLeft3 = tree.left.copy(newLeftChildren2, newLeftLength2);
      const newRight2 = tree.right.prependInternal(moveRightChild2);
      return tree.copy(newLeft3, newRight2);
    }
    const newLeftChildren = import_base.Arr.splice(
      tree.left.children,
      tree.context.maxBlockSize - 1,
      1
    );
    newLeftChildren.unshift(child);
    const moveRightChild = import_base.Arr.last(tree.left.children);
    const newLeftLength = tree.left.length - tree.getChildLength(moveRightChild) + tree.getChildLength(child);
    const newLeft2 = tree.left.copy(newLeftChildren, newLeftLength);
    const newRight = tree.right.prependInternal(moveRightChild);
    return tree.copy(newLeft2, newRight);
  }
  const newMiddle = tree.prependMiddle(tree.left);
  const newLeft = tree.left.copy([child], tree.getChildLength(child));
  return tree.copy(newLeft, void 0, newMiddle);
}
function treeAppend(tree, child) {
  if (tree.right.canAddChild) {
    const newRight2 = tree.right.appendInternal(child);
    return tree.copy(void 0, newRight2);
  }
  if (null === tree.middle && tree.left.canAddChild) {
    if (tree.context.isReversedLeafBlock(tree.right)) {
      const newRightChildren2 = import_base.Arr.splice(
        tree.right.children,
        tree.right.children.length - 1,
        1
      );
      newRightChildren2.unshift(child);
      const moveLeftChild2 = import_base.Arr.last(tree.right.children);
      const newRightLength2 = tree.right.length - tree.getChildLength(moveLeftChild2) + tree.getChildLength(child);
      const newRight3 = tree.right.copy(newRightChildren2, newRightLength2);
      const newLeft2 = tree.left.appendInternal(moveLeftChild2);
      return tree.copy(newLeft2, newRight3);
    }
    const newRightChildren = import_base.Arr.splice(tree.right.children, 0, 1);
    newRightChildren.push(child);
    const moveLeftChild = tree.right.children[0];
    const newRightLength = tree.right.length - tree.getChildLength(moveLeftChild) + tree.getChildLength(child);
    const newRight2 = tree.right.copy(newRightChildren, newRightLength);
    const newLeft = tree.left.appendInternal(moveLeftChild);
    return tree.copy(newLeft, newRight2);
  }
  const newMiddle = tree.appendMiddle(tree.right);
  const newRight = tree.right.copy([child], tree.getChildLength(child));
  return tree.copy(void 0, newRight, newMiddle);
}
function treeUpdate(tree, index, update) {
  const middleIndex = index - tree.left.length;
  if (middleIndex < 0) {
    const newLeft = tree.left.updateAt(index, update);
    return tree.copy(newLeft);
  }
  if (null === tree.middle) {
    const newRight = tree.right.updateAt(middleIndex, update);
    return tree.copy(void 0, newRight);
  }
  const rightIndex = middleIndex - tree.middle.length;
  if (rightIndex >= 0) {
    const newRight = tree.right.updateAt(rightIndex, update);
    return tree.copy(void 0, newRight);
  }
  const newMiddle = tree.middle.updateAt(middleIndex, update);
  return tree.copy(void 0, void 0, newMiddle);
}
function treeToArray(tree, range, reversed = false) {
  const indexRange = import_common.IndexRange.getIndicesFor(
    range ?? { start: 0 },
    tree.length
  );
  if (indexRange === "empty")
    return [];
  if (indexRange === "all") {
    const leftArray2 = tree.left.toArray(void 0, reversed);
    const rightArray2 = tree.right.toArray(void 0, reversed);
    if (null === tree.middle) {
      if (reversed)
        return rightArray2.concat(leftArray2);
      return leftArray2.concat(rightArray2);
    }
    const middleArray2 = tree.middle.toArray(void 0, reversed);
    if (reversed)
      return rightArray2.concat(middleArray2, leftArray2);
    return leftArray2.concat(middleArray2, rightArray2);
  }
  const [start, end] = indexRange;
  const leftArray = tree.left.toArray({ start, end }, reversed);
  if (null === tree.middle) {
    const rightStart2 = Math.max(0, start - tree.left.length);
    const rightEnd2 = end - tree.left.length;
    if (rightEnd2 < 0)
      return leftArray;
    const rightArray2 = tree.right.toArray(
      { start: rightStart2, end: rightEnd2 },
      reversed
    );
    if (reversed)
      return rightArray2.concat(leftArray);
    return leftArray.concat(rightArray2);
  }
  const middleStart = Math.max(0, start - tree.left.length);
  const middleEnd = end - tree.left.length;
  if (middleEnd < 0)
    return leftArray;
  const middleArray = tree.middle.toArray(
    { start: middleStart, end: middleEnd },
    reversed
  );
  const rightStart = Math.max(0, middleStart - tree.middle.length);
  const rightEnd = middleEnd - tree.middle.length;
  if (rightEnd < 0) {
    if (reversed)
      return middleArray.concat(leftArray);
    return leftArray.concat(middleArray);
  }
  const rightArray = tree.right.toArray(
    { start: rightStart, end: rightEnd },
    reversed
  );
  if (reversed)
    return rightArray.concat(middleArray, leftArray);
  return leftArray.concat(middleArray, rightArray);
}
function treeForEach(tree, f, state) {
  if (state.halted)
    return;
  tree.left.forEach(f, state);
  if (state.halted)
    return;
  if (null !== tree.middle) {
    tree.middle.forEach(f, state);
  }
  if (state.halted)
    return;
  tree.right.forEach(f, state);
}

// src/custom/implementation/nonleaf/nonleaf-tree.mts
var NonLeafTree = class {
  constructor(context, left, right, middle, level, length = left.length + right.length + (middle?.length ?? 0)) {
    this.context = context;
    this.left = left;
    this.right = right;
    this.middle = middle;
    this.level = level;
    this.length = length;
  }
  getChildLength(child) {
    return child.length;
  }
  copy(left = this.left, right = this.right, middle = this.middle) {
    if (left === this.left && right === this.right && middle === this.middle) {
      return this;
    }
    return this.context.nonLeafTree(left, right, middle, this.level);
  }
  copy2(left, right, middle) {
    return this.context.nonLeafTree(left, right, middle, this.level);
  }
  stream(reversed = false) {
    return treeStream(this, void 0, reversed);
  }
  streamRange(range, reversed = false) {
    return treeStream(this, range, reversed);
  }
  get(index) {
    return treeGet(this, index);
  }
  prepend(child) {
    return treePrepend(this, child);
  }
  append(child) {
    return treeAppend(this, child);
  }
  prependMiddle(child) {
    if (child.level !== this.level) {
      import_base2.RimbuError.throwInvalidStateError();
    }
    return this.middle?.prepend(child) ?? this.context.nonLeafBlock(
      child.length,
      [child],
      this.level + 1
    );
  }
  appendMiddle(child) {
    if (child.level !== this.level) {
      import_base2.RimbuError.throwInvalidStateError();
    }
    return this.middle?.append(child) ?? this.context.nonLeafBlock(
      child.length,
      [child],
      this.level + 1
    );
  }
  dropFirst() {
    const [newLeft, firstChild] = this.left.dropFirst();
    if (null === newLeft) {
      if (null === this.middle) {
        return [this.right, firstChild];
      }
      const [newMiddle, toLeft] = this.middle.dropFirst();
      const newSelf2 = this.copy(toLeft, void 0, newMiddle)._normalize();
      return [newSelf2, firstChild];
    }
    const newSelf = this.copy(newLeft)._normalize();
    return [newSelf, firstChild];
  }
  dropLast() {
    const [newRight, lastChild] = this.right.dropLast();
    if (null === newRight) {
      if (null === this.middle) {
        return [this.left, lastChild];
      }
      const [newMiddle, toRight] = this.middle.dropLast();
      const newSelf2 = this.copy(void 0, toRight, newMiddle)._normalize();
      return [newSelf2, lastChild];
    }
    const newSelf = this.copy(void 0, newRight)._normalize();
    return [newSelf, lastChild];
  }
  takeInternal(amount) {
    const middleAmount = amount - this.left.length;
    if (middleAmount <= 0) {
      return this.left.takeInternal(amount);
    }
    if (null === this.middle) {
      const [newRight, up, upAmount] = this.right.takeInternal(middleAmount);
      if (null === newRight) {
        return [this.left, up, upAmount];
      }
      return [this.left.concat(newRight), up, upAmount];
    }
    const rightAmount = middleAmount - this.middle.length;
    if (rightAmount > 0) {
      const [newRight, up, upAmount] = this.right.takeInternal(rightAmount);
      if (null === newRight) {
        const [newMiddle2, toRight] = this.middle.dropLast();
        const newSelf3 = this.copy(void 0, toRight, newMiddle2)._normalize();
        return [newSelf3, up, upAmount];
      }
      const newSelf2 = this.copy(void 0, newRight)._normalize();
      return [newSelf2, up, upAmount];
    }
    const [newMiddle, upRight] = this.middle.takeInternal(middleAmount);
    const newSelf = this.copy(void 0, upRight, newMiddle)._normalize();
    return newSelf.takeInternal(amount);
  }
  dropInternal(amount) {
    const middleAmount = amount - this.left.length;
    if (null === this.middle) {
      if (middleAmount < 0) {
        const [newLeft, upLeft2, upLeftAmount] = this.left.dropInternal(amount);
        const newSelf2 = null === newLeft ? this.right : newLeft.concat(this.right);
        return [newSelf2, upLeft2, upLeftAmount];
      } else {
        return this.right.dropInternal(middleAmount);
      }
    }
    if (middleAmount < 0) {
      const [newLeft, upLeft2, upLeftAmount] = this.left.dropInternal(amount);
      if (null === newLeft) {
        const [newMiddle2, toLeft] = this.middle.dropFirst();
        const newSelf3 = this.copy(toLeft, void 0, newMiddle2)._normalize();
        return [newSelf3, upLeft2, upLeftAmount];
      }
      const newSelf2 = this.copy(newLeft);
      return [newSelf2, upLeft2, upLeftAmount];
    }
    const rightAmount = middleAmount - this.middle.length;
    if (rightAmount >= 0) {
      return this.right.dropInternal(rightAmount);
    }
    const [newMiddle, upLeft, inUpLeft] = this.middle.dropInternal(middleAmount);
    const newSelf = this.copy(upLeft, void 0, newMiddle)._normalize();
    return newSelf.dropInternal(inUpLeft);
  }
  concat(other) {
    if (this.context.isNonLeafBlock(other)) {
      return this.concatBlock(other);
    }
    if (this.context.isNonLeafTree(other)) {
      return this.concatTree(other);
    }
    import_base2.RimbuError.throwInvalidStateError();
  }
  concatBlock(other) {
    if (other.level !== this.level) {
      import_base2.RimbuError.throwInvalidStateError();
    }
    if (this.right.nrChildren + other.nrChildren <= this.context.maxBlockSize) {
      const newRight2 = this.right.concatChildren(other);
      return this.copy(void 0, newRight2);
    }
    if (this.right.childrenInMin) {
      const newMiddle2 = this.appendMiddle(this.right);
      return this.copy(void 0, other, newMiddle2)._normalize();
    }
    const newRight = this.right.concatChildren(other);
    const newLast = newRight._mutateSplitRight(this.context.maxBlockSize);
    const newMiddle = this.appendMiddle(newRight);
    return this.copy(void 0, newLast, newMiddle)._normalize();
  }
  concatTree(other) {
    if (this.right.nrChildren + other.left.nrChildren <= this.context.maxBlockSize) {
      const joint2 = this.right.concatChildren(other.left);
      const newThisMiddle2 = this.appendMiddle(joint2);
      const newMiddle2 = null === other.middle ? newThisMiddle2 : newThisMiddle2.concat(other.middle);
      return this.copy(void 0, other.right, newMiddle2)._normalize();
    }
    if (this.right.childrenInMin && other.left.childrenInMin) {
      const newThisMiddle2 = this.appendMiddle(this.right).append(other.left);
      const newMiddle2 = null === other.middle ? newThisMiddle2 : newThisMiddle2.concat(other.middle);
      return this.copy(void 0, other.right, newMiddle2)._normalize();
    }
    const joint = this.right.concatChildren(other.left);
    const jointRight = joint._mutateSplitRight();
    const newThisMiddle = this.appendMiddle(joint).append(jointRight);
    const newMiddle = null === other.middle ? newThisMiddle : newThisMiddle.concat(other.middle);
    return this.copy(void 0, other.right, newMiddle)._normalize();
  }
  updateAt(index, update) {
    return treeUpdate(
      this,
      index,
      update
    );
  }
  forEach(f, state) {
    if (state.halted)
      return;
    treeForEach(this, f, state);
  }
  mapPure(mapFun, reversed = false, cacheMap = this.context.createCacheMap()) {
    const cachedThis = cacheMap.get(this);
    if (cachedThis)
      return cachedThis;
    const mappedLeft = this.left.mapPure(mapFun, reversed, cacheMap);
    const mappedMiddle = null === this.middle ? null : this.middle.mapPure(mapFun, reversed, cacheMap);
    const mappedRight = this.right.mapPure(mapFun, reversed, cacheMap);
    const result = reversed ? this.copy2(mappedRight, mappedLeft, mappedMiddle) : this.copy2(mappedLeft, mappedRight, mappedMiddle);
    return cacheMap.setAndReturn(this, result);
  }
  map(mapFun, reversed = false, indexOffset = 0) {
    let offset = indexOffset;
    const left = this.left;
    const middle = this.middle;
    const right = this.right;
    if (reversed) {
      const newLeft2 = right.map(mapFun, true, offset);
      offset += right.length;
      const newMiddle2 = null === middle ? null : middle.map(mapFun, true, offset);
      if (null !== middle)
        offset += middle.length;
      const newRight2 = left.map(mapFun, true, offset);
      return this.copy2(newLeft2, newRight2, newMiddle2);
    }
    const newLeft = left.map(mapFun, false, offset);
    offset += left.length;
    const newMiddle = null === middle ? null : middle.map(mapFun, false, offset);
    if (null !== middle)
      offset += middle.length;
    const newRight = right.map(mapFun, false, offset);
    return this.copy2(newLeft, newRight, newMiddle);
  }
  reversed(cacheMap = this.context.createCacheMap()) {
    const cachedThis = cacheMap.get(this);
    if (cachedThis !== void 0)
      return cachedThis;
    const newMid = this.middle?.reversed(cacheMap) ?? null;
    const newLeft = this.right.reversed(cacheMap);
    const newRight = this.left === this.right ? newLeft : this.left.reversed(cacheMap);
    const reversedThis = this.copy(newLeft, newRight, newMid);
    return cacheMap.setAndReturn(this, reversedThis);
  }
  _normalize() {
    if (null === this.middle) {
      if (this.left.nrChildren + this.right.nrChildren <= this.context.maxBlockSize) {
        return this.left.concatChildren(this.right);
      }
    } else if (this.context.isNonLeafBlock(this.middle)) {
      const firstChild = this.middle.getChild(0);
      if (this.left.nrChildren + firstChild.nrChildren <= this.context.maxBlockSize) {
        const result = this.middle.dropFirst();
        const newMiddle = result[0];
        const block = result[1];
        return this.copy(this.left.concatChildren(block), void 0, newMiddle);
      }
      const lastChild = this.middle.getChild(this.middle.nrChildren - 1);
      if (this.right.nrChildren + lastChild.nrChildren <= this.context.maxBlockSize) {
        const result = this.middle.dropLast();
        const newMiddle = result[0];
        const block = result[1];
        return this.copy(
          void 0,
          block.concatChildren(this.right),
          newMiddle
        );
      }
    }
    return this;
  }
  toArray(range, reversed = false) {
    return treeToArray(this, range, reversed);
  }
  structure() {
    const space = " ".padEnd(this.level * 2);
    return `
${space}<NLTree(${this.level}) len:${this.length}
  l:${this.left.structure()}
  m:${this.middle && this.middle.structure()}
  r:${this.right.structure()}
>`;
  }
  createNonLeafBuilder() {
    return this.context.nonLeafTreeBuilderSource(this);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  NonLeafTree
});
