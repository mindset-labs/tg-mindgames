"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/implementation/tree/operations.mts
var operations_exports = {};
__export(operations_exports, {
  treeAppend: () => treeAppend,
  treeForEach: () => treeForEach,
  treeGet: () => treeGet,
  treePrepend: () => treePrepend,
  treeStream: () => treeStream,
  treeToArray: () => treeToArray,
  treeUpdate: () => treeUpdate
});
module.exports = __toCommonJS(operations_exports);
var import_base = require("@rimbu/base");
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
function treeStream(tree, range, reversed = false) {
  const indexRange = import_common.IndexRange.getIndicesFor(
    range ?? { start: 0 },
    tree.length
  );
  if (indexRange === "empty")
    return import_stream.Stream.empty();
  if (indexRange === "all") {
    const rightStream2 = tree.right.stream(reversed);
    const leftStream2 = tree.left.stream(reversed);
    if (null === tree.middle) {
      if (reversed)
        return rightStream2.concat(leftStream2);
      return leftStream2.concat(rightStream2);
    }
    const middleStream2 = tree.middle.stream(reversed);
    if (reversed)
      return rightStream2.concat(middleStream2, leftStream2);
    return leftStream2.concat(middleStream2, rightStream2);
  }
  const [start, end] = indexRange;
  const leftStream = tree.left.streamRange({ start, end }, reversed);
  if (null === tree.middle) {
    const rightStart2 = Math.max(0, start - tree.left.length);
    const rightEnd2 = end - tree.left.length;
    if (rightEnd2 < 0)
      return leftStream;
    const rightStream2 = tree.right.streamRange(
      { start: rightStart2, end: rightEnd2 },
      reversed
    );
    if (reversed)
      return rightStream2.concat(leftStream);
    return leftStream.concat(rightStream2);
  }
  const middleStart = Math.max(0, start - tree.left.length);
  const middleEnd = end - tree.left.length;
  if (middleEnd < 0)
    return leftStream;
  const middleStream = tree.middle.streamRange(
    { start: middleStart, end: middleEnd },
    reversed
  );
  const rightStart = Math.max(0, middleStart - tree.middle.length);
  const rightEnd = middleEnd - tree.middle.length;
  if (rightEnd < 0) {
    if (reversed)
      return middleStream.concat(leftStream);
    return leftStream.concat(middleStream);
  }
  const rightStream = tree.right.streamRange(
    { start: rightStart, end: rightEnd },
    reversed
  );
  if (reversed)
    return rightStream.concat(middleStream, leftStream);
  return leftStream.concat(middleStream, rightStream);
}
function treeGet(tree, index) {
  const middleIndex = index - tree.left.length;
  if (middleIndex < 0) {
    return tree.left.get(index, import_base.RimbuError.throwInvalidStateError);
  }
  if (null === tree.middle) {
    return tree.right.get(middleIndex, import_base.RimbuError.throwInvalidStateError);
  }
  const rightIndex = middleIndex - tree.middle.length;
  if (rightIndex < 0)
    return tree.middle.get(middleIndex);
  return tree.right.get(rightIndex, import_base.RimbuError.throwInvalidStateError);
}
function treePrepend(tree, child) {
  if (tree.left.canAddChild) {
    const newLeft2 = tree.left.prependInternal(child);
    return tree.copy(newLeft2);
  }
  if (null === tree.middle && tree.right.canAddChild) {
    if (tree.context.isReversedLeafBlock(tree.left)) {
      const newLeftChildren2 = import_base.Arr.splice(tree.left.children, 0, 1);
      newLeftChildren2.push(child);
      const moveRightChild2 = tree.left.children[0];
      const newLeftLength2 = tree.left.length - tree.getChildLength(moveRightChild2) + tree.getChildLength(child);
      const newLeft3 = tree.left.copy(newLeftChildren2, newLeftLength2);
      const newRight2 = tree.right.prependInternal(moveRightChild2);
      return tree.copy(newLeft3, newRight2);
    }
    const newLeftChildren = import_base.Arr.splice(
      tree.left.children,
      tree.context.maxBlockSize - 1,
      1
    );
    newLeftChildren.unshift(child);
    const moveRightChild = import_base.Arr.last(tree.left.children);
    const newLeftLength = tree.left.length - tree.getChildLength(moveRightChild) + tree.getChildLength(child);
    const newLeft2 = tree.left.copy(newLeftChildren, newLeftLength);
    const newRight = tree.right.prependInternal(moveRightChild);
    return tree.copy(newLeft2, newRight);
  }
  const newMiddle = tree.prependMiddle(tree.left);
  const newLeft = tree.left.copy([child], tree.getChildLength(child));
  return tree.copy(newLeft, void 0, newMiddle);
}
function treeAppend(tree, child) {
  if (tree.right.canAddChild) {
    const newRight2 = tree.right.appendInternal(child);
    return tree.copy(void 0, newRight2);
  }
  if (null === tree.middle && tree.left.canAddChild) {
    if (tree.context.isReversedLeafBlock(tree.right)) {
      const newRightChildren2 = import_base.Arr.splice(
        tree.right.children,
        tree.right.children.length - 1,
        1
      );
      newRightChildren2.unshift(child);
      const moveLeftChild2 = import_base.Arr.last(tree.right.children);
      const newRightLength2 = tree.right.length - tree.getChildLength(moveLeftChild2) + tree.getChildLength(child);
      const newRight3 = tree.right.copy(newRightChildren2, newRightLength2);
      const newLeft2 = tree.left.appendInternal(moveLeftChild2);
      return tree.copy(newLeft2, newRight3);
    }
    const newRightChildren = import_base.Arr.splice(tree.right.children, 0, 1);
    newRightChildren.push(child);
    const moveLeftChild = tree.right.children[0];
    const newRightLength = tree.right.length - tree.getChildLength(moveLeftChild) + tree.getChildLength(child);
    const newRight2 = tree.right.copy(newRightChildren, newRightLength);
    const newLeft = tree.left.appendInternal(moveLeftChild);
    return tree.copy(newLeft, newRight2);
  }
  const newMiddle = tree.appendMiddle(tree.right);
  const newRight = tree.right.copy([child], tree.getChildLength(child));
  return tree.copy(void 0, newRight, newMiddle);
}
function treeUpdate(tree, index, update) {
  const middleIndex = index - tree.left.length;
  if (middleIndex < 0) {
    const newLeft = tree.left.updateAt(index, update);
    return tree.copy(newLeft);
  }
  if (null === tree.middle) {
    const newRight = tree.right.updateAt(middleIndex, update);
    return tree.copy(void 0, newRight);
  }
  const rightIndex = middleIndex - tree.middle.length;
  if (rightIndex >= 0) {
    const newRight = tree.right.updateAt(rightIndex, update);
    return tree.copy(void 0, newRight);
  }
  const newMiddle = tree.middle.updateAt(middleIndex, update);
  return tree.copy(void 0, void 0, newMiddle);
}
function treeToArray(tree, range, reversed = false) {
  const indexRange = import_common.IndexRange.getIndicesFor(
    range ?? { start: 0 },
    tree.length
  );
  if (indexRange === "empty")
    return [];
  if (indexRange === "all") {
    const leftArray2 = tree.left.toArray(void 0, reversed);
    const rightArray2 = tree.right.toArray(void 0, reversed);
    if (null === tree.middle) {
      if (reversed)
        return rightArray2.concat(leftArray2);
      return leftArray2.concat(rightArray2);
    }
    const middleArray2 = tree.middle.toArray(void 0, reversed);
    if (reversed)
      return rightArray2.concat(middleArray2, leftArray2);
    return leftArray2.concat(middleArray2, rightArray2);
  }
  const [start, end] = indexRange;
  const leftArray = tree.left.toArray({ start, end }, reversed);
  if (null === tree.middle) {
    const rightStart2 = Math.max(0, start - tree.left.length);
    const rightEnd2 = end - tree.left.length;
    if (rightEnd2 < 0)
      return leftArray;
    const rightArray2 = tree.right.toArray(
      { start: rightStart2, end: rightEnd2 },
      reversed
    );
    if (reversed)
      return rightArray2.concat(leftArray);
    return leftArray.concat(rightArray2);
  }
  const middleStart = Math.max(0, start - tree.left.length);
  const middleEnd = end - tree.left.length;
  if (middleEnd < 0)
    return leftArray;
  const middleArray = tree.middle.toArray(
    { start: middleStart, end: middleEnd },
    reversed
  );
  const rightStart = Math.max(0, middleStart - tree.middle.length);
  const rightEnd = middleEnd - tree.middle.length;
  if (rightEnd < 0) {
    if (reversed)
      return middleArray.concat(leftArray);
    return leftArray.concat(middleArray);
  }
  const rightArray = tree.right.toArray(
    { start: rightStart, end: rightEnd },
    reversed
  );
  if (reversed)
    return rightArray.concat(middleArray, leftArray);
  return leftArray.concat(middleArray, rightArray);
}
function treeForEach(tree, f, state) {
  if (state.halted)
    return;
  tree.left.forEach(f, state);
  if (state.halted)
    return;
  if (null !== tree.middle) {
    tree.middle.forEach(f, state);
  }
  if (state.halted)
    return;
  tree.right.forEach(f, state);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  treeAppend,
  treeForEach,
  treeGet,
  treePrepend,
  treeStream,
  treeToArray,
  treeUpdate
});
