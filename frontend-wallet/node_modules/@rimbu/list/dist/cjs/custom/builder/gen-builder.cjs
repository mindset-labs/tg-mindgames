"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/builder/gen-builder.mts
var gen_builder_exports = {};
__export(gen_builder_exports, {
  GenBuilder: () => GenBuilder
});
module.exports = __toCommonJS(gen_builder_exports);
var import_base = require("@rimbu/base");
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var GenBuilder = class {
  constructor(context, builder) {
    this.context = context;
    this.builder = builder;
    this._lock = 0;
    // prettier-ignore
    this.get = (index, otherwise) => {
      if (void 0 === this.builder || index >= this.length || -index > this.length) {
        return (0, import_common.OptLazy)(otherwise);
      }
      if (index < 0) {
        return this.get(this.length + index, otherwise);
      }
      return this.builder.get(index, otherwise);
    };
    // prettier-ignore
    this.updateAt = (index, update, otherwise) => {
      this.checkLock();
      if (void 0 === this.builder || index >= this.length || -index > this.length) {
        return (0, import_common.OptLazy)(otherwise);
      }
      if (index < 0) {
        return this.updateAt(this.length + index, update);
      }
      return this.builder.updateAt(index, update);
    };
    // prettier-ignore
    this.set = (index, value, otherwise) => {
      return this.updateAt(index, value, otherwise);
    };
    this.prepend = (value) => {
      this.checkLock();
      if (void 0 === this.builder) {
        this.builder = this.context.leafBlockBuilder([value]);
        return;
      }
      this.builder.prepend(value);
      this.builder = this.builder.normalized();
    };
    this.append = (value) => {
      this.checkLock();
      if (void 0 === this.builder) {
        this.builder = this.context.leafBlockBuilder([value]);
        return;
      }
      this.builder.append(value);
      this.builder = this.builder.normalized();
    };
    this.appendAll = (values) => {
      this.checkLock();
      if (Array.isArray(values)) {
        this.appendArray(values);
        return;
      }
      import_stream.Stream.from(values).forEachPure(this.append);
    };
    this.insert = (index, value) => {
      this.checkLock();
      if (void 0 === this.builder) {
        this.builder = this.context.leafBlockBuilder([value]);
      } else {
        if (index === 0) {
          return this.prepend(value);
        }
        if (index > this.length || -index > this.length + 1) {
          return this.append(value);
        }
        if (index < 0) {
          return this.insert(this.length + index, value);
        }
        this.builder.insert(index, value);
        this.builder = this.builder.normalized();
      }
    };
    // prettier-ignore
    this.remove = (index, otherwise) => {
      this.checkLock();
      if (void 0 === this.builder || index >= this.length || -index > this.length) {
        return (0, import_common.OptLazy)(otherwise);
      }
      if (index < 0) {
        return this.remove(this.length + index);
      }
      const result = this.builder.remove(index);
      this.builder = this.builder.normalized();
      return result;
    };
    this.forEach = (f, state = (0, import_common.TraverseState)()) => {
      if (void 0 !== this.builder) {
        if (state.halted)
          return;
        this._lock++;
        try {
          this.builder.forEach(f, state);
        } finally {
          this._lock--;
        }
      }
    };
    this.build = () => {
      if (void 0 === this.builder) {
        return this.context.empty();
      }
      const result = this.builder.build();
      return result;
    };
    // prettier-ignore
    this.buildMap = (f) => {
      if (void 0 === this.builder) {
        return this.context.empty();
      }
      return this.builder.buildMap(f);
    };
  }
  checkLock() {
    if (this._lock) {
      import_base.RimbuError.throwModifiedBuilderWhileLoopingOverItError();
    }
  }
  get length() {
    return this.builder?.length ?? 0;
  }
  get isEmpty() {
    return this.length === 0;
  }
  appendFullOrLastWindow(window) {
    const leafBlockBuilder = this.context.leafBlockBuilder(window);
    if (void 0 === this.builder) {
      this.builder = leafBlockBuilder;
      return;
    }
    if (this.context.isLeafBlockBuilder(this.builder)) {
      this.builder = this.context.leafTreeBuilder(
        this.builder,
        leafBlockBuilder,
        void 0,
        this.builder.length + leafBlockBuilder.length
      );
      return;
    }
    if (this.context.isLeafTreeBuilder(this.builder)) {
      this.builder.appendMiddle(this.builder.right);
      this.builder.right = leafBlockBuilder;
      this.builder.length += leafBlockBuilder.length;
      return;
    }
    import_base.RimbuError.throwInvalidStateError();
  }
  appendArray(array) {
    let index = 0;
    const blockSize = this.context.maxBlockSize;
    if (void 0 !== this.builder) {
      if (this.context.isLeafBlockBuilder(this.builder)) {
        index = blockSize - this.builder.length;
        if (index > 0) {
          const slice = array.slice(0, index);
          this.builder.children = this.builder.children.concat(slice);
        }
      } else if (this.context.isLeafTreeBuilder(this.builder)) {
        const left = this.builder.left;
        index = blockSize - left.length;
        if (index > 0) {
          const slice = array.slice(0, index);
          left.children = left.children.concat(slice);
        }
      }
    }
    while (index < array.length) {
      const end = index + blockSize;
      const window = array.slice(index, end);
      this.appendFullOrLastWindow(window);
      index = end;
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GenBuilder
});
