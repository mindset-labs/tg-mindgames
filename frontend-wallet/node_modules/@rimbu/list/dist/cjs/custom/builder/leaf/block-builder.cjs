"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/builder/leaf/block-builder.mts
var block_builder_exports = {};
__export(block_builder_exports, {
  LeafBlockBuilder: () => LeafBlockBuilder
});
module.exports = __toCommonJS(block_builder_exports);
var import_base = require("@rimbu/base");
var import_common = require("@rimbu/common");
var LeafBlockBuilder = class {
  constructor(context, source, _children) {
    this.context = context;
    this.source = source;
    this._children = _children;
  }
  get level() {
    return 0;
  }
  get children() {
    if (void 0 === this._children) {
      if (void 0 !== this.source) {
        if (this.context.isReversedLeafBlock(this.source)) {
          this._children = import_base.Arr.reverse(this.source.children);
        } else {
          this._children = this.source.children.slice();
        }
      }
    }
    return this._children;
  }
  set children(value) {
    this.source = void 0;
    this._children = value;
  }
  get length() {
    return this.source?.length ?? this.children.length;
  }
  get nrChildren() {
    return this.length;
  }
  copy(children) {
    return this.context.leafBlockBuilder(children);
  }
  normalized() {
    if (this.nrChildren <= 0) {
      return void 0;
    }
    if (this.nrChildren <= this.context.maxBlockSize) {
      return this;
    }
    const newLength = this.length;
    const newRight = this.splitRight();
    return this.context.leafTreeBuilder(this, newRight, void 0, newLength);
  }
  get(index, otherwise) {
    if (void 0 !== this.source) {
      return this.source.get(index, otherwise);
    }
    return this.children[index];
  }
  updateAt(index, update) {
    const oldValue = this.children[index];
    const newValue = (0, import_common.Update)(oldValue, update);
    if (!Object.is(oldValue, newValue)) {
      this.children[index] = newValue;
      this.source = void 0;
    }
    return oldValue;
  }
  prepend(value) {
    this.children.unshift(value);
    this.source = void 0;
  }
  append(value) {
    this.children.push(value);
    this.source = void 0;
  }
  insert(index, value) {
    this.children.splice(index, 0, value);
    this.source = void 0;
  }
  remove(index) {
    const [removed] = this.children.splice(index, 1);
    this.source = void 0;
    return removed;
  }
  dropFirst() {
    const value = this.children.shift();
    this.source = void 0;
    return value;
  }
  dropLast() {
    const value = this.children.pop();
    this.source = void 0;
    return value;
  }
  build() {
    return this.source ?? this.context.leafBlock(this.children.slice());
  }
  buildMap(f) {
    return this.source?.map(f) ?? this.context.leafBlock(this.children.map(f));
  }
  splitRight(index = this.nrChildren >>> 1) {
    const rightChildren = this.children.splice(index);
    this.source = void 0;
    return this.copy(rightChildren);
  }
  concat(other, prependOther = false) {
    this.children = prependOther ? other.children.concat(this.children) : this.children.concat(other.children);
  }
  forEach(f, state = (0, import_common.TraverseState)()) {
    import_base.Arr.forEach(this.children, f, state);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LeafBlockBuilder
});
