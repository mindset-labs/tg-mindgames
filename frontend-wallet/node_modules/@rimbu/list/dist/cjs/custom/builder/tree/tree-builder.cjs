"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/builder/tree/tree-builder.mts
var tree_builder_exports = {};
__export(tree_builder_exports, {
  TreeBuilderBase: () => TreeBuilderBase
});
module.exports = __toCommonJS(tree_builder_exports);
var import_base = require("@rimbu/base");
var import_common = require("@rimbu/common");
var TreeBuilderBase = class {
  get(index, otherwise) {
    const middleIndex = index - this.left.length;
    if (middleIndex < 0) {
      return this.left.get(index, otherwise);
    }
    const rightIndex = middleIndex - (this.middle?.length ?? 0);
    if (rightIndex >= 0) {
      return this.right.get(rightIndex, otherwise);
    }
    if (void 0 === this.middle) {
      import_base.RimbuError.throwInvalidStateError();
    }
    return this.middle.get(middleIndex, otherwise);
  }
  updateAt(index, update, otherwise) {
    const middleIndex = index - this.left.length;
    if (middleIndex < 0) {
      return this.left.updateAt(index, update, otherwise);
    }
    const rightIndex = middleIndex - (this.middle?.length ?? 0);
    if (rightIndex >= 0) {
      return this.right.updateAt(rightIndex, update, otherwise);
    }
    if (void 0 === this.middle) {
      import_base.RimbuError.throwInvalidStateError();
    }
    return this.middle.updateAt(middleIndex, update, otherwise);
  }
  prepend(child) {
    this.length += this.getChildLength(child);
    if (this.left.nrChildren < this.context.maxBlockSize) {
      this.left.prepend(child);
      return;
    }
    if (void 0 !== this.middle) {
      const delta = this.middle.modifyFirstChild(
        (firstChild) => {
          if (firstChild.nrChildren < this.context.maxBlockSize) {
            const shiftChild = this.left.dropLast();
            this.left.prepend(child);
            firstChild.prepend(shiftChild);
            return this.getChildLength(shiftChild);
          }
          return;
        }
      );
      if (void 0 !== delta) {
        return;
      }
    } else if (this.right.nrChildren < this.context.maxBlockSize) {
      const shiftChild = this.left.dropLast();
      this.left.prepend(child);
      this.right.prepend(shiftChild);
      return;
    }
    this.left.prepend(child);
    const toMiddle = this.left.splitRight(1);
    this.prependMiddle(toMiddle);
  }
  append(child) {
    this.length += this.getChildLength(child);
    if (this.right.nrChildren < this.context.maxBlockSize) {
      this.right.append(child);
      return;
    }
    if (void 0 !== this.middle) {
      const delta = this.middle.modifyLastChild(
        (lastChild) => {
          if (lastChild.nrChildren < this.context.maxBlockSize) {
            const shiftChild = this.right.dropFirst();
            this.right.append(child);
            lastChild.append(shiftChild);
            return this.getChildLength(shiftChild);
          }
          return;
        }
      );
      if (void 0 !== delta) {
        return;
      }
    } else if (this.left.nrChildren < this.context.maxBlockSize) {
      const shiftChild = this.right.dropFirst();
      this.right.append(child);
      this.left.append(shiftChild);
      return;
    }
    this.right.append(child);
    const newRight = this.right.splitRight(this.context.maxBlockSize);
    this.appendMiddle(this.right);
    this.right = newRight;
  }
  remove(index) {
    this.length--;
    const middleIndex = index - this.left.length;
    if (middleIndex < 0) {
      const oldValue2 = this.left.remove(index);
      if (this.left.nrChildren >= this.context.minBlockSize) {
        return oldValue2;
      }
      if (void 0 !== this.middle) {
        const delta = this.middle.modifyFirstChild(
          (firstChild) => {
            if (firstChild.nrChildren > this.context.minBlockSize) {
              const shiftChild = firstChild.dropFirst();
              this.left.append(shiftChild);
              return -this.getChildLength(shiftChild);
            }
            return;
          }
        );
        if (void 0 !== delta) {
          return oldValue2;
        }
        const middleFirst = this.middle.dropFirst();
        this.middle = this.middle.normalized();
        this.left.concat(middleFirst);
        return oldValue2;
      } else if (this.right.nrChildren > this.context.minBlockSize) {
        const shiftChild = this.right.dropFirst();
        this.left.append(shiftChild);
        return oldValue2;
      }
      import_base.RimbuError.throwInvalidStateError();
    }
    const rightIndex = middleIndex - (this.middle?.length ?? 0);
    if (rightIndex >= 0) {
      const oldValue2 = this.right.remove(rightIndex);
      if (this.right.nrChildren >= this.context.minBlockSize) {
        return oldValue2;
      }
      if (void 0 !== this.middle) {
        const delta = this.middle.modifyLastChild(
          (lastChild) => {
            if (lastChild.nrChildren > this.context.minBlockSize) {
              const shiftChild = lastChild.dropLast();
              this.right.prepend(shiftChild);
              return -this.getChildLength(shiftChild);
            }
            return;
          }
        );
        if (void 0 !== delta) {
          return oldValue2;
        }
        const middleLast = this.middle.dropLast();
        this.middle = this.middle.normalized();
        middleLast.concat(this.right);
        this.right = middleLast;
        return oldValue2;
      } else if (this.left.nrChildren > this.context.minBlockSize) {
        const shiftChild = this.left.dropLast();
        this.right.prepend(shiftChild);
        return oldValue2;
      }
      import_base.RimbuError.throwInvalidStateError();
    }
    if (void 0 === this.middle) {
      import_base.RimbuError.throwInvalidStateError();
    }
    const oldValue = this.middle.remove(middleIndex);
    this.middle = this.middle.normalized();
    return oldValue;
  }
  insert(index, value) {
    this.length++;
    const middleIndex = index - this.left.length;
    if (middleIndex <= 0) {
      this.left.insert(index, value);
      if (this.left.nrChildren <= this.context.maxBlockSize) {
        return;
      }
      if (void 0 !== this.middle) {
        const delta = this.middle.modifyFirstChild(
          (firstChild) => {
            if (firstChild.nrChildren < this.context.maxBlockSize) {
              const shiftChild = this.left.dropLast();
              firstChild.prepend(shiftChild);
              return this.getChildLength(shiftChild);
            }
            return;
          }
        );
        if (void 0 !== delta) {
          return;
        }
      } else if (this.right.nrChildren < this.context.maxBlockSize) {
        const shiftChild = this.left.dropLast();
        this.right.prepend(shiftChild);
        return;
      }
      const toMiddle = this.left.splitRight();
      this.prependMiddle(toMiddle);
      return;
    }
    const rightIndex = middleIndex - (this.middle?.length ?? 0);
    if (void 0 === this.middle || rightIndex >= 0) {
      this.right.insert(rightIndex, value);
      if (this.right.nrChildren <= this.context.maxBlockSize) {
        return;
      }
      if (void 0 !== this.middle) {
        const delta = this.middle.modifyLastChild(
          (lastChild) => {
            if (lastChild.nrChildren < this.context.maxBlockSize) {
              const shiftChild = this.right.dropFirst();
              lastChild.append(shiftChild);
              return this.getChildLength(shiftChild);
            }
            return;
          }
        );
        if (void 0 !== delta) {
          return;
        }
      } else if (this.left.nrChildren < this.context.maxBlockSize) {
        const shiftChild = this.right.dropFirst();
        this.left.append(shiftChild);
        return;
      }
      const newRight = this.right.splitRight();
      this.appendMiddle(this.right);
      this.right = newRight;
      return;
    }
    this.middle.insert(middleIndex, value);
    this.middle = this.middle.normalized();
  }
  prependMiddle(child) {
    if (void 0 === this.middle) {
      this.middle = this.context.nonLeafBlockBuilder(
        this.level + 1,
        [child],
        child.length
      );
      return;
    }
    if (child.nrChildren >= this.context.minBlockSize) {
      this.middle.prepend(child);
      this.middle = this.middle.normalized();
      return;
    }
    const delta = this.middle.modifyFirstChild((firstMiddleChild2) => {
      if (child.nrChildren + firstMiddleChild2.nrChildren <= this.context.maxBlockSize) {
        firstMiddleChild2.concat(child, true);
        return child.length;
      }
      return;
    });
    if (void 0 !== delta) {
      return;
    }
    const firstMiddleChild = this.middle.dropFirst();
    child.concat(firstMiddleChild);
    const newSecondChild = child.splitRight();
    this.middle.prepend(newSecondChild);
    this.middle.prepend(child);
    this.middle = this.middle.normalized();
  }
  appendMiddle(child) {
    if (void 0 === this.middle) {
      this.middle = this.context.nonLeafBlockBuilder(
        this.level + 1,
        [child],
        child.length
      );
      return;
    }
    if (child.nrChildren >= this.context.minBlockSize) {
      this.middle.append(child);
      this.middle = this.middle.normalized();
      return;
    }
    const delta = this.middle.modifyLastChild((lastMiddleChild2) => {
      if (child.nrChildren + lastMiddleChild2.nrChildren <= this.context.maxBlockSize) {
        lastMiddleChild2.concat(child);
        return child.length;
      }
      return;
    });
    if (void 0 !== delta) {
      return;
    }
    const lastMiddleChild = this.middle.last();
    lastMiddleChild.concat(child);
    const newLast = lastMiddleChild.splitRight();
    this.middle.append(newLast);
    this.middle = this.middle.normalized();
  }
  dropFirst() {
    const first = this.left.dropFirst();
    this.length -= this.getChildLength(first);
    if (this.left.nrChildren >= this.context.minBlockSize) {
      return first;
    }
    if (void 0 !== this.middle) {
      const firstMiddle = this.middle.first();
      if (this.left.nrChildren + firstMiddle.nrChildren <= this.context.maxBlockSize) {
        this.middle.dropFirst();
        this.middle = this.middle.normalized();
        this.left.concat(firstMiddle);
      }
      return first;
    }
    if (this.left.nrChildren + this.right.nrChildren > this.context.maxBlockSize) {
      const shiftChild = this.right.dropFirst();
      this.left.append(shiftChild);
    }
    return first;
  }
  dropLast() {
    const last = this.right.dropLast();
    this.length -= this.getChildLength(last);
    if (this.right.nrChildren >= this.context.minBlockSize) {
      return last;
    }
    if (void 0 !== this.middle) {
      const lastMiddle = this.middle.last();
      if (lastMiddle.nrChildren + this.right.nrChildren <= this.context.maxBlockSize) {
        this.middle.dropLast();
        this.middle = this.middle.normalized();
        this.right.concat(lastMiddle, true);
      }
      return last;
    }
    if (this.left.nrChildren + this.right.nrChildren > this.context.maxBlockSize) {
      const shiftChild = this.left.dropLast();
      this.right.prepend(shiftChild);
    }
    return last;
  }
  forEach(f, state = (0, import_common.TraverseState)()) {
    if (state.halted)
      return;
    this.left.forEach(f, state);
    if (state.halted)
      return;
    if (void 0 !== this.middle) {
      this.middle.forEach(f, state);
      if (state.halted)
        return;
    }
    this.right.forEach(f, state);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TreeBuilderBase
});
