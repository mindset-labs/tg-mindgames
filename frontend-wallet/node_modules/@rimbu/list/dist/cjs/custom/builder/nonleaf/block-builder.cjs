"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/custom/builder/nonleaf/block-builder.mts
var block_builder_exports = {};
__export(block_builder_exports, {
  NonLeafBlockBuilder: () => NonLeafBlockBuilder
});
module.exports = __toCommonJS(block_builder_exports);
var import_base = require("@rimbu/base");
var import_common = require("@rimbu/common");
var NonLeafBlockBuilder = class {
  constructor(context, level, source, _children, length = source?.length ?? 0) {
    this.context = context;
    this.level = level;
    this.source = source;
    this._children = _children;
    this.length = length;
  }
  get children() {
    if (void 0 !== this.source) {
      this._children = this.source.children.map(
        (c) => c.createBlockBuilder()
      );
      this.source = void 0;
    }
    return this._children;
  }
  set children(value) {
    if (void 0 !== this.source) {
      this._children = this.source.children.map(
        (c) => c.createBlockBuilder()
      );
      this.source = void 0;
    }
    this._children = value;
  }
  get nrChildren() {
    return this.source?.nrChildren ?? this.children.length;
  }
  copy(children, length) {
    return this.context.nonLeafBlockBuilder(this.level, children, length);
  }
  getCoordinates(index) {
    const nrChildren = this.nrChildren;
    const length = this.length;
    if (index >= length) {
      const lastChild = import_base.Arr.last(this.children);
      return [nrChildren - 1, lastChild.length];
    }
    const levelBits = this.context.blockSizeBits << this.level - 1;
    const blockSize = 1 << levelBits;
    const regularSize = nrChildren * blockSize;
    if (length === regularSize) {
      const childIndex = index >>> levelBits;
      const mask = blockSize - 1;
      const inChildIndex = index & mask;
      return [childIndex, inChildIndex];
    }
    const children = this.children;
    if (index <= length >>> 1) {
      let i = index;
      for (let childIndex = 0; childIndex < nrChildren; childIndex++) {
        const childLength = children[childIndex].length;
        if (i < childLength) {
          return [childIndex, i];
        }
        i -= childLength;
      }
    } else {
      let i = length - index;
      for (let childIndex = nrChildren - 1; childIndex >= 0; childIndex--) {
        const childLength = children[childIndex].length;
        if (i <= childLength) {
          return [childIndex, childLength - i];
        }
        i -= childLength;
      }
    }
    import_base.RimbuError.throwInvalidStateError();
  }
  normalized() {
    if (this.nrChildren === 0) {
      return void 0;
    }
    const context = this.context;
    const maxBlockSize = context.maxBlockSize;
    if (this.nrChildren > maxBlockSize) {
      const middleLength = this.length;
      const result = context.nonLeafTreeBuilder(
        this.level,
        this,
        this.splitRight(),
        void 0,
        middleLength
      );
      return result;
    }
    return this;
  }
  get(index) {
    if (void 0 !== this.source) {
      return this.source.get(index);
    }
    const [childIndex, inChildIndex] = this.getCoordinates(index);
    return this.children[childIndex].get(
      inChildIndex,
      import_base.RimbuError.throwInvalidStateError
    );
  }
  updateAt(index, update, otherwise) {
    const [childIndex, inChildIndex] = this.getCoordinates(index);
    return this.children[childIndex].updateAt(inChildIndex, update, otherwise);
  }
  prepend(child) {
    this.length += child.length;
    this.children.unshift(child);
  }
  append(child) {
    this.length += child.length;
    this.children.push(child);
  }
  insert(index, value) {
    const [childIndex, inChildIndex] = this.getCoordinates(index);
    this.length++;
    const child = this.children[childIndex];
    child.insert(inChildIndex, value);
    if (child.nrChildren <= this.context.maxBlockSize) {
      return;
    }
    const leftChild = this.children[childIndex - 1];
    if (void 0 !== leftChild && leftChild.nrChildren < this.context.maxBlockSize) {
      const shiftChild = child.dropFirst();
      leftChild.append(shiftChild);
      return;
    }
    const rightChild = this.children[childIndex + 1];
    if (void 0 !== rightChild && rightChild.nrChildren < this.context.maxBlockSize) {
      const shiftChild = child.dropLast();
      rightChild.prepend(shiftChild);
      return;
    }
    const newRightChild = child.splitRight();
    this.children.splice(childIndex + 1, 0, newRightChild);
  }
  remove(index) {
    const [childIndex, inChildIndex] = this.getCoordinates(index);
    this.length--;
    const child = this.children[childIndex];
    const oldValue = child.remove(inChildIndex);
    if (child.nrChildren >= this.context.minBlockSize || this.nrChildren <= 1) {
      return oldValue;
    }
    const leftChild = this.children[childIndex - 1];
    if (void 0 !== leftChild && leftChild.nrChildren > this.context.minBlockSize) {
      const shiftChild = leftChild.dropLast();
      child.prepend(shiftChild);
      return oldValue;
    }
    const rightChild = this.children[childIndex + 1];
    if (void 0 !== rightChild && rightChild.nrChildren > this.context.minBlockSize) {
      const shiftChild = rightChild.dropFirst();
      child.append(shiftChild);
      return oldValue;
    }
    if (void 0 !== leftChild) {
      leftChild.concat(child);
      this.children.splice(childIndex, 1);
      return oldValue;
    }
    child.concat(rightChild);
    this.children.splice(childIndex + 1, 1);
    return oldValue;
  }
  dropFirst() {
    const first = this.children.shift();
    this.length -= first.length;
    return first;
  }
  dropLast() {
    const last = this.children.pop();
    this.length -= last.length;
    return last;
  }
  modifyFirstChild(f) {
    const delta = f(this.first());
    if (void 0 !== delta) {
      this.length += delta;
    }
    return delta;
  }
  modifyLastChild(f) {
    const delta = f(this.last());
    if (void 0 !== delta) {
      this.length += delta;
    }
    return delta;
  }
  first() {
    return this.children[0];
  }
  last() {
    return import_base.Arr.last(this.children);
  }
  splitRight(index = this.nrChildren >>> 1) {
    const rightChildren = this.children.splice(index);
    const oldLength = this.length;
    this.length = 0;
    for (let i = 0; i < this.nrChildren; i++) {
      this.length += this.children[i].length;
    }
    const rightLength = oldLength - this.length;
    return this.copy(rightChildren, rightLength);
  }
  concat(other, prependOther = false) {
    this.children = prependOther ? other.children.concat(this.children) : this.children.concat(other.children);
    this.length += other.length;
  }
  forEach(f, state = (0, import_common.TraverseState)()) {
    if (state.halted)
      return;
    let i = -1;
    const length = this.children.length;
    while (!state.halted && ++i < length) {
      this.children[i].forEach(f, state);
    }
  }
  build() {
    if (void 0 !== this.source) {
      return this.source;
    }
    return this.context.nonLeafBlock(
      this.length,
      this.children.map((c) => c.build()),
      this.level
    );
  }
  buildMap(f) {
    if (void 0 !== this.source) {
      return this.source.map(f);
    }
    return this.context.nonLeafBlock(
      this.length,
      this.children.map((c) => c.buildMap(f)),
      this.level
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  NonLeafBlockBuilder
});
