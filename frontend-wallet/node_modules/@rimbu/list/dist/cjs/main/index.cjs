"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main/index.mts
var main_exports = {};
__export(main_exports, {
  List: () => List
});
module.exports = __toCommonJS(main_exports);

// src/custom/implementation/cache-map.mts
var CacheMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    return this.map.get(key);
  }
  setAndReturn(key, value) {
    this.map.set(key, value);
    return value;
  }
};

// src/custom/implementation/empty.mts
var import_set_custom = require("@rimbu/collection-types/set-custom");
var import_common = require("@rimbu/common");
var import_stream = require("@rimbu/stream");
var Empty = class extends import_set_custom.EmptyBase {
  constructor(context) {
    super();
    this.context = context;
  }
  streamRange() {
    return import_stream.Stream.empty();
  }
  first(otherwise) {
    return (0, import_common.OptLazy)(otherwise);
  }
  last(otherwise) {
    return (0, import_common.OptLazy)(otherwise);
  }
  get(index, otherwise) {
    return (0, import_common.OptLazy)(otherwise);
  }
  prepend(value) {
    return this.context.leafBlock([value]);
  }
  append(value) {
    return this.context.leafBlock([value]);
  }
  take() {
    return this;
  }
  drop() {
    return this;
  }
  slice() {
    return this;
  }
  sort() {
    return this;
  }
  splice(options) {
    if (void 0 === options.insert)
      return this;
    return this.context.from(options.insert);
  }
  insert(index, values) {
    return this.splice({ insert: values });
  }
  remove() {
    return this;
  }
  concat(...sources) {
    return this.context.from(...sources);
  }
  repeat() {
    return this;
  }
  rotate() {
    return this;
  }
  padTo(length, fill) {
    if (length <= 0)
      return this;
    return this.append(fill).repeat(length);
  }
  updateAt() {
    return this;
  }
  filter() {
    return this;
  }
  collect() {
    return this;
  }
  map() {
    return this;
  }
  mapPure() {
    return this;
  }
  flatMap() {
    return this;
  }
  reversed() {
    return this;
  }
  toArray() {
    return [];
  }
  toBuilder() {
    return this.context.builder();
  }
  structure() {
    return "<empty>";
  }
  toString() {
    return `List()`;
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: []
    };
  }
};
function createEmptyList(context) {
  return Object.freeze(new Empty(context));
}

// src/custom/implementation/nonleaf/nonleaf-block.mts
var import_base = require("@rimbu/base");
var import_common2 = require("@rimbu/common");
var import_stream2 = require("@rimbu/stream");
var NonLeafBlock = class {
  constructor(context, _length, children, level) {
    this.context = context;
    this._length = _length;
    this.children = children;
    this.level = level;
  }
  get length() {
    return this._length;
  }
  set length(value) {
    this._length = value;
  }
  get nrChildren() {
    return this.children.length;
  }
  get mutateChildren() {
    return this.children;
  }
  get childrenInMax() {
    return this.children.length <= this.context.maxBlockSize;
  }
  get childrenInMin() {
    return this.children.length >= this.context.minBlockSize;
  }
  get canAddChild() {
    return this.children.length < this.context.maxBlockSize;
  }
  copy(children, length = this.length) {
    if (children === this.children && length === this.length)
      return this;
    return this.context.nonLeafBlock(length, children, this.level);
  }
  copy2(children, length = this.length) {
    return this.context.nonLeafBlock(length, children, this.level);
  }
  stream(reversed = false) {
    return import_stream2.Stream.fromArray(this.children, void 0, reversed).flatMap(
      (child) => child.stream(reversed)
    );
  }
  streamRange(range, reversed = false) {
    const indexRange = import_common2.IndexRange.getIndicesFor(range, this.length);
    if (indexRange === "all") {
      return import_stream2.Stream.fromArray(this.children, void 0, reversed).flatMap(
        (child) => child.stream(reversed)
      );
    }
    if (indexRange === "empty")
      return import_stream2.Stream.empty();
    const [start, end] = indexRange;
    const [startChildIndex, inStartChildIndex] = this.getCoordinates(
      start,
      false,
      true
    );
    const [endChildIndex, inEndChildIndex] = this.getCoordinates(
      end,
      false,
      true
    );
    if (startChildIndex === endChildIndex) {
      const child = this.children[startChildIndex];
      return child.streamRange(
        {
          start: inStartChildIndex,
          end: inEndChildIndex
        },
        reversed
      );
    }
    const startChild = this.children[startChildIndex];
    const endChild = this.children[endChildIndex];
    const childStream = import_stream2.Stream.fromArray(
      this.children,
      { start: startChildIndex, end: endChildIndex },
      reversed
    );
    return childStream.flatMap((child) => {
      if (child === startChild)
        return child.streamRange({ start: inStartChildIndex }, reversed);
      if (child === endChild)
        return child.streamRange({ end: inEndChildIndex }, reversed);
      return child.stream(reversed);
    });
  }
  get(index) {
    const [childIndex, inChildIndex] = this.getCoordinates(index, false, false);
    return this.getChild(childIndex).get(
      inChildIndex,
      import_base.RimbuError.throwInvalidStateError
    );
  }
  prepend(child) {
    if (this.canAddChild)
      return this.prependInternal(child);
    return this.context.nonLeafTree(
      this.copy([child], child.length),
      this,
      null,
      this.level
    );
  }
  append(child) {
    if (this.canAddChild)
      return this.appendInternal(child);
    return this.context.nonLeafTree(
      this,
      this.copy([child], child.length),
      null,
      this.level
    );
  }
  dropFirst() {
    const firstChild = this.children[0];
    if (this.nrChildren === 1)
      return [null, firstChild];
    const newChildren = import_base.Arr.tail(this.children);
    const newLength = this.length - firstChild.length;
    const newSelf = this.copy(newChildren, newLength);
    return [newSelf, firstChild];
  }
  dropLast() {
    const lastChild = import_base.Arr.last(this.children);
    if (this.nrChildren === 1)
      return [null, lastChild];
    const newChildren = import_base.Arr.init(this.children);
    const newLength = this.length - lastChild.length;
    const newSelf = this.copy(newChildren, newLength);
    return [newSelf, lastChild];
  }
  concat(other) {
    if (other.context.isNonLeafBlock(other)) {
      if (other === this && this.children.length > this.context.minBlockSize) {
        return this.context.nonLeafTree(
          this,
          this,
          null,
          this.level
        );
      }
      return this.concatBlock(other);
    }
    if (this.context.isNonLeafTree(other)) {
      return this.concatTree(other);
    }
    import_base.RimbuError.throwInvalidStateError();
  }
  concatBlock(other) {
    return this.concatChildren(other)._mutateNormalize();
  }
  concatTree(other) {
    if (this.nrChildren + other.left.nrChildren <= this.context.maxBlockSize) {
      const newLeft2 = this.concatChildren(other.left)._mutateRebalance();
      return other.copy(newLeft2);
    }
    if (other.left.childrenInMin) {
      const newMiddle2 = other.prependMiddle(other.left);
      return other.copy(this, void 0, newMiddle2);
    }
    const newLeft = this.concatChildren(other.left)._mutateRebalance();
    if (newLeft.childrenInMax)
      return other.copy(newLeft);
    const newSecond = newLeft._mutateSplitRight(
      newLeft.nrChildren - this.context.maxBlockSize
    );
    const newMiddle = other.prependMiddle(newSecond);
    return other.copy(newLeft, void 0, newMiddle);
  }
  prependInternal(child) {
    const newChildren = import_base.Arr.prepend(this.children, child);
    return this.copy(newChildren, this.length + child.length);
  }
  appendInternal(child) {
    const newChildren = import_base.Arr.append(this.children, child);
    return this.copy(newChildren, this.length + child.length);
  }
  takeChildren(childAmount) {
    if (childAmount <= 0)
      return null;
    if (childAmount >= this.nrChildren)
      return this;
    const newChildren = import_base.Arr.splice(
      this.children,
      childAmount,
      this.context.maxBlockSize
    );
    const length = newChildren.reduce((l, c) => l + c.length, 0);
    return this.copy(newChildren, length);
  }
  dropChildren(childAmount) {
    if (childAmount <= 0) {
      return this;
    }
    if (childAmount >= this.nrChildren) {
      return null;
    }
    const newChildren = import_base.Arr.splice(this.children, 0, childAmount);
    const length = newChildren.reduce((l, c) => l + c.length, 0);
    return this.copy(newChildren, length);
  }
  concatChildren(other) {
    const newChildren = import_base.Arr.concat(this.children, other.children);
    return this.copy(newChildren, this.length + other.length);
  }
  takeInternal(amount) {
    const [childIndex, inChildIndex] = this.getCoordinates(amount, true, false);
    if (childIndex >= this.nrChildren) {
      import_base.RimbuError.throwInvalidStateError();
    }
    const lastChild = this.getChild(childIndex);
    const newSelf = this.takeChildren(childIndex);
    return [newSelf, lastChild, inChildIndex];
  }
  // return remainer, first new child, and index in new child
  dropInternal(amount) {
    const [childIndex, inChildIndex] = this.getCoordinates(
      amount,
      false,
      false
    );
    if (childIndex >= this.nrChildren) {
      import_base.RimbuError.throwInvalidStateError();
    }
    const firstChild = this.getChild(childIndex);
    const newSelf = this.dropChildren(childIndex + 1);
    return [newSelf, firstChild, inChildIndex];
  }
  getChild(childIndex) {
    return this.children[childIndex];
  }
  updateAt(index, update) {
    const [childIndex, inChildIndex] = this.getCoordinates(index, false, false);
    const newChildren = import_base.Arr.update(
      this.children,
      childIndex,
      (child) => child.updateAt(inChildIndex, update)
    );
    return this.copy(newChildren);
  }
  forEach(f, state) {
    if (state.halted)
      return;
    const length = this.children.length;
    let i = -1;
    const children = this.children;
    while (!state.halted && ++i < length) {
      children[i].forEach(f, state);
    }
  }
  mapPure(mapFun, reversed = false, cacheMap = this.context.createCacheMap()) {
    const cachedThis = cacheMap.get(this);
    if (cachedThis)
      return cachedThis;
    const fn = reversed ? import_base.Arr.reverseMap : import_base.Arr.map;
    const newChildren = fn(
      this.children,
      (c) => c.mapPure(mapFun, reversed, cacheMap)
    );
    return cacheMap.setAndReturn(this, this.copy2(newChildren));
  }
  map(mapFun, reversed = false, indexOffset = 0) {
    let offset = indexOffset;
    const children = this.children;
    if (reversed) {
      const newChildren = [];
      let i = children.length;
      while (--i >= 0) {
        const child = children[i];
        newChildren.push(child.map(mapFun, true, offset));
        offset += child.length;
      }
      return this.copy2(newChildren);
    } else {
      const newChildren = [];
      let i = -1;
      const length = children.length;
      while (++i < length) {
        const child = children[i];
        newChildren.push(child.map(mapFun, false, offset));
        offset += child.length;
      }
      return this.copy2(newChildren);
    }
  }
  reversed(cacheMap = this.context.createCacheMap()) {
    const cachedThis = cacheMap.get(this);
    if (cachedThis !== void 0)
      return cachedThis;
    const newChildren = import_base.Arr.reverseMap(
      this.children,
      (child) => child.reversed(cacheMap)
    );
    const reversedThis = this.copy(newChildren, this.length);
    return cacheMap.setAndReturn(this, reversedThis);
  }
  toArray(range, reversed = false) {
    let start = 0;
    let end = this.length - 1;
    if (void 0 !== range) {
      const indexRange = import_common2.IndexRange.getIndicesFor(range, this.length);
      if (indexRange === "empty")
        return [];
      if (indexRange !== "all") {
        start = indexRange[0];
        end = indexRange[1];
      }
    }
    const [startChildIndex, inStartChildIndex] = this.getCoordinates(
      start,
      false,
      true
    );
    const [endChildIndex, inEndChildIndex] = this.getCoordinates(
      end,
      false,
      true
    );
    const children = this.children;
    if (startChildIndex === endChildIndex) {
      const child = children[startChildIndex];
      return child.toArray(
        {
          start: inStartChildIndex,
          end: inEndChildIndex
        },
        reversed
      );
    }
    const firstArray = children[startChildIndex].toArray(
      {
        start: inStartChildIndex
      },
      reversed
    );
    const lastArray = children[endChildIndex].toArray(
      { end: inEndChildIndex },
      reversed
    );
    if (reversed) {
      let result2 = lastArray;
      for (let childIndex = endChildIndex - 1; childIndex > startChildIndex; childIndex--) {
        result2 = import_base.Arr.concat(
          result2,
          children[childIndex].toArray(void 0, true)
        );
      }
      return import_base.Arr.concat(result2, firstArray);
    }
    let result = firstArray;
    for (let childIndex = startChildIndex + 1; childIndex < endChildIndex; childIndex++) {
      result = import_base.Arr.concat(result, children[childIndex].toArray());
    }
    return import_base.Arr.concat(result, lastArray);
  }
  getCoordinates(index, forTake, noEmptyLast) {
    const offSet = forTake ? 1 : 0;
    let indexWithOffset = index - offSet;
    const nrChildren = this.nrChildren;
    const length = this.length;
    const children = this.children;
    if (indexWithOffset >= length) {
      if (noEmptyLast) {
        return [nrChildren - 1, import_base.Arr.last(children).length - 1];
      }
      return [nrChildren, 0];
    }
    const levelBits = this.context.blockSizeBits << this.level - 1;
    const blockSize = 1 << levelBits;
    const regularSize = nrChildren * blockSize;
    if (length === regularSize) {
      const childIndex = indexWithOffset >>> levelBits;
      const mask = blockSize - 1;
      const inChildIndex = indexWithOffset & mask;
      return [childIndex, inChildIndex + offSet];
    }
    if (indexWithOffset <= length >>> 1) {
      for (let childIndex = 0; childIndex < nrChildren; childIndex++) {
        const childLength = children[childIndex].length;
        if (indexWithOffset < childLength) {
          return [childIndex, indexWithOffset + offSet];
        }
        indexWithOffset -= childLength;
      }
    } else {
      let i = length - indexWithOffset;
      for (let childIndex = nrChildren - 1; childIndex >= 0; childIndex--) {
        const childLength = children[childIndex].length;
        if (i <= childLength) {
          return [childIndex, childLength - i + offSet];
        }
        i -= childLength;
      }
    }
    import_base.RimbuError.throwInvalidStateError();
  }
  _mutateRebalance() {
    let i = 0;
    const children = this.children;
    while (i < children.length - 1) {
      const child = children[i];
      const rightChild = children[i + 1];
      if (child.children.length + rightChild.children.length <= this.context.maxBlockSize) {
        const newChild = child.concatChildren(rightChild);
        this.mutateChildren.splice(i, 2, newChild);
      } else
        i++;
    }
    return this;
  }
  _mutateNormalize() {
    if (this.childrenInMax) {
      return this;
    }
    const newRight = this._mutateSplitRight();
    return this.context.nonLeafTree(this, newRight, null, this.level);
  }
  _mutateSplitRight(childIndex = this.children.length >>> 1) {
    const rightChildren = this.mutateChildren.splice(childIndex);
    let rightLength = 0;
    for (let i = 0; i < rightChildren.length; i++) {
      rightLength += rightChildren[i].length;
    }
    this.length -= rightLength;
    return this.copy(rightChildren, rightLength);
  }
  structure() {
    const space = " ".padEnd(this.level * 2);
    return `
${space}<NLBlock(${this.level}) len:${this.length} c:${this.nrChildren} ${this.children.map((c) => c.structure()).join(" ")}>`;
  }
  createBlockBuilder() {
    return this.context.nonLeafBlockBuilderSource(this);
  }
  createNonLeafBuilder() {
    return this.context.nonLeafBlockBuilderSource(this);
  }
};

// src/custom/builder/gen-builder.mts
var import_base2 = require("@rimbu/base");
var import_common3 = require("@rimbu/common");
var import_stream3 = require("@rimbu/stream");
var GenBuilder = class {
  constructor(context, builder) {
    this.context = context;
    this.builder = builder;
    this._lock = 0;
    // prettier-ignore
    this.get = (index, otherwise) => {
      if (void 0 === this.builder || index >= this.length || -index > this.length) {
        return (0, import_common3.OptLazy)(otherwise);
      }
      if (index < 0) {
        return this.get(this.length + index, otherwise);
      }
      return this.builder.get(index, otherwise);
    };
    // prettier-ignore
    this.updateAt = (index, update, otherwise) => {
      this.checkLock();
      if (void 0 === this.builder || index >= this.length || -index > this.length) {
        return (0, import_common3.OptLazy)(otherwise);
      }
      if (index < 0) {
        return this.updateAt(this.length + index, update);
      }
      return this.builder.updateAt(index, update);
    };
    // prettier-ignore
    this.set = (index, value, otherwise) => {
      return this.updateAt(index, value, otherwise);
    };
    this.prepend = (value) => {
      this.checkLock();
      if (void 0 === this.builder) {
        this.builder = this.context.leafBlockBuilder([value]);
        return;
      }
      this.builder.prepend(value);
      this.builder = this.builder.normalized();
    };
    this.append = (value) => {
      this.checkLock();
      if (void 0 === this.builder) {
        this.builder = this.context.leafBlockBuilder([value]);
        return;
      }
      this.builder.append(value);
      this.builder = this.builder.normalized();
    };
    this.appendAll = (values) => {
      this.checkLock();
      if (Array.isArray(values)) {
        this.appendArray(values);
        return;
      }
      import_stream3.Stream.from(values).forEachPure(this.append);
    };
    this.insert = (index, value) => {
      this.checkLock();
      if (void 0 === this.builder) {
        this.builder = this.context.leafBlockBuilder([value]);
      } else {
        if (index === 0) {
          return this.prepend(value);
        }
        if (index > this.length || -index > this.length + 1) {
          return this.append(value);
        }
        if (index < 0) {
          return this.insert(this.length + index, value);
        }
        this.builder.insert(index, value);
        this.builder = this.builder.normalized();
      }
    };
    // prettier-ignore
    this.remove = (index, otherwise) => {
      this.checkLock();
      if (void 0 === this.builder || index >= this.length || -index > this.length) {
        return (0, import_common3.OptLazy)(otherwise);
      }
      if (index < 0) {
        return this.remove(this.length + index);
      }
      const result = this.builder.remove(index);
      this.builder = this.builder.normalized();
      return result;
    };
    this.forEach = (f, state = (0, import_common3.TraverseState)()) => {
      if (void 0 !== this.builder) {
        if (state.halted)
          return;
        this._lock++;
        try {
          this.builder.forEach(f, state);
        } finally {
          this._lock--;
        }
      }
    };
    this.build = () => {
      if (void 0 === this.builder) {
        return this.context.empty();
      }
      const result = this.builder.build();
      return result;
    };
    // prettier-ignore
    this.buildMap = (f) => {
      if (void 0 === this.builder) {
        return this.context.empty();
      }
      return this.builder.buildMap(f);
    };
  }
  checkLock() {
    if (this._lock) {
      import_base2.RimbuError.throwModifiedBuilderWhileLoopingOverItError();
    }
  }
  get length() {
    return this.builder?.length ?? 0;
  }
  get isEmpty() {
    return this.length === 0;
  }
  appendFullOrLastWindow(window) {
    const leafBlockBuilder = this.context.leafBlockBuilder(window);
    if (void 0 === this.builder) {
      this.builder = leafBlockBuilder;
      return;
    }
    if (this.context.isLeafBlockBuilder(this.builder)) {
      this.builder = this.context.leafTreeBuilder(
        this.builder,
        leafBlockBuilder,
        void 0,
        this.builder.length + leafBlockBuilder.length
      );
      return;
    }
    if (this.context.isLeafTreeBuilder(this.builder)) {
      this.builder.appendMiddle(this.builder.right);
      this.builder.right = leafBlockBuilder;
      this.builder.length += leafBlockBuilder.length;
      return;
    }
    import_base2.RimbuError.throwInvalidStateError();
  }
  appendArray(array) {
    let index = 0;
    const blockSize = this.context.maxBlockSize;
    if (void 0 !== this.builder) {
      if (this.context.isLeafBlockBuilder(this.builder)) {
        index = blockSize - this.builder.length;
        if (index > 0) {
          const slice = array.slice(0, index);
          this.builder.children = this.builder.children.concat(slice);
        }
      } else if (this.context.isLeafTreeBuilder(this.builder)) {
        const left = this.builder.left;
        index = blockSize - left.length;
        if (index > 0) {
          const slice = array.slice(0, index);
          left.children = left.children.concat(slice);
        }
      }
    }
    while (index < array.length) {
      const end = index + blockSize;
      const window = array.slice(index, end);
      this.appendFullOrLastWindow(window);
      index = end;
    }
  }
};

// src/custom/builder/leaf/block-builder.mts
var import_base3 = require("@rimbu/base");
var import_common4 = require("@rimbu/common");
var LeafBlockBuilder = class {
  constructor(context, source, _children) {
    this.context = context;
    this.source = source;
    this._children = _children;
  }
  get level() {
    return 0;
  }
  get children() {
    if (void 0 === this._children) {
      if (void 0 !== this.source) {
        if (this.context.isReversedLeafBlock(this.source)) {
          this._children = import_base3.Arr.reverse(this.source.children);
        } else {
          this._children = this.source.children.slice();
        }
      }
    }
    return this._children;
  }
  set children(value) {
    this.source = void 0;
    this._children = value;
  }
  get length() {
    return this.source?.length ?? this.children.length;
  }
  get nrChildren() {
    return this.length;
  }
  copy(children) {
    return this.context.leafBlockBuilder(children);
  }
  normalized() {
    if (this.nrChildren <= 0) {
      return void 0;
    }
    if (this.nrChildren <= this.context.maxBlockSize) {
      return this;
    }
    const newLength = this.length;
    const newRight = this.splitRight();
    return this.context.leafTreeBuilder(this, newRight, void 0, newLength);
  }
  get(index, otherwise) {
    if (void 0 !== this.source) {
      return this.source.get(index, otherwise);
    }
    return this.children[index];
  }
  updateAt(index, update) {
    const oldValue = this.children[index];
    const newValue = (0, import_common4.Update)(oldValue, update);
    if (!Object.is(oldValue, newValue)) {
      this.children[index] = newValue;
      this.source = void 0;
    }
    return oldValue;
  }
  prepend(value) {
    this.children.unshift(value);
    this.source = void 0;
  }
  append(value) {
    this.children.push(value);
    this.source = void 0;
  }
  insert(index, value) {
    this.children.splice(index, 0, value);
    this.source = void 0;
  }
  remove(index) {
    const [removed] = this.children.splice(index, 1);
    this.source = void 0;
    return removed;
  }
  dropFirst() {
    const value = this.children.shift();
    this.source = void 0;
    return value;
  }
  dropLast() {
    const value = this.children.pop();
    this.source = void 0;
    return value;
  }
  build() {
    return this.source ?? this.context.leafBlock(this.children.slice());
  }
  buildMap(f) {
    return this.source?.map(f) ?? this.context.leafBlock(this.children.map(f));
  }
  splitRight(index = this.nrChildren >>> 1) {
    const rightChildren = this.children.splice(index);
    this.source = void 0;
    return this.copy(rightChildren);
  }
  concat(other, prependOther = false) {
    this.children = prependOther ? other.children.concat(this.children) : this.children.concat(other.children);
  }
  forEach(f, state = (0, import_common4.TraverseState)()) {
    import_base3.Arr.forEach(this.children, f, state);
  }
};

// src/custom/builder/nonleaf/block-builder.mts
var import_base4 = require("@rimbu/base");
var import_common5 = require("@rimbu/common");
var NonLeafBlockBuilder = class {
  constructor(context, level, source, _children, length = source?.length ?? 0) {
    this.context = context;
    this.level = level;
    this.source = source;
    this._children = _children;
    this.length = length;
  }
  get children() {
    if (void 0 !== this.source) {
      this._children = this.source.children.map(
        (c) => c.createBlockBuilder()
      );
      this.source = void 0;
    }
    return this._children;
  }
  set children(value) {
    if (void 0 !== this.source) {
      this._children = this.source.children.map(
        (c) => c.createBlockBuilder()
      );
      this.source = void 0;
    }
    this._children = value;
  }
  get nrChildren() {
    return this.source?.nrChildren ?? this.children.length;
  }
  copy(children, length) {
    return this.context.nonLeafBlockBuilder(this.level, children, length);
  }
  getCoordinates(index) {
    const nrChildren = this.nrChildren;
    const length = this.length;
    if (index >= length) {
      const lastChild = import_base4.Arr.last(this.children);
      return [nrChildren - 1, lastChild.length];
    }
    const levelBits = this.context.blockSizeBits << this.level - 1;
    const blockSize = 1 << levelBits;
    const regularSize = nrChildren * blockSize;
    if (length === regularSize) {
      const childIndex = index >>> levelBits;
      const mask = blockSize - 1;
      const inChildIndex = index & mask;
      return [childIndex, inChildIndex];
    }
    const children = this.children;
    if (index <= length >>> 1) {
      let i = index;
      for (let childIndex = 0; childIndex < nrChildren; childIndex++) {
        const childLength = children[childIndex].length;
        if (i < childLength) {
          return [childIndex, i];
        }
        i -= childLength;
      }
    } else {
      let i = length - index;
      for (let childIndex = nrChildren - 1; childIndex >= 0; childIndex--) {
        const childLength = children[childIndex].length;
        if (i <= childLength) {
          return [childIndex, childLength - i];
        }
        i -= childLength;
      }
    }
    import_base4.RimbuError.throwInvalidStateError();
  }
  normalized() {
    if (this.nrChildren === 0) {
      return void 0;
    }
    const context = this.context;
    const maxBlockSize = context.maxBlockSize;
    if (this.nrChildren > maxBlockSize) {
      const middleLength = this.length;
      const result = context.nonLeafTreeBuilder(
        this.level,
        this,
        this.splitRight(),
        void 0,
        middleLength
      );
      return result;
    }
    return this;
  }
  get(index) {
    if (void 0 !== this.source) {
      return this.source.get(index);
    }
    const [childIndex, inChildIndex] = this.getCoordinates(index);
    return this.children[childIndex].get(
      inChildIndex,
      import_base4.RimbuError.throwInvalidStateError
    );
  }
  updateAt(index, update, otherwise) {
    const [childIndex, inChildIndex] = this.getCoordinates(index);
    return this.children[childIndex].updateAt(inChildIndex, update, otherwise);
  }
  prepend(child) {
    this.length += child.length;
    this.children.unshift(child);
  }
  append(child) {
    this.length += child.length;
    this.children.push(child);
  }
  insert(index, value) {
    const [childIndex, inChildIndex] = this.getCoordinates(index);
    this.length++;
    const child = this.children[childIndex];
    child.insert(inChildIndex, value);
    if (child.nrChildren <= this.context.maxBlockSize) {
      return;
    }
    const leftChild = this.children[childIndex - 1];
    if (void 0 !== leftChild && leftChild.nrChildren < this.context.maxBlockSize) {
      const shiftChild = child.dropFirst();
      leftChild.append(shiftChild);
      return;
    }
    const rightChild = this.children[childIndex + 1];
    if (void 0 !== rightChild && rightChild.nrChildren < this.context.maxBlockSize) {
      const shiftChild = child.dropLast();
      rightChild.prepend(shiftChild);
      return;
    }
    const newRightChild = child.splitRight();
    this.children.splice(childIndex + 1, 0, newRightChild);
  }
  remove(index) {
    const [childIndex, inChildIndex] = this.getCoordinates(index);
    this.length--;
    const child = this.children[childIndex];
    const oldValue = child.remove(inChildIndex);
    if (child.nrChildren >= this.context.minBlockSize || this.nrChildren <= 1) {
      return oldValue;
    }
    const leftChild = this.children[childIndex - 1];
    if (void 0 !== leftChild && leftChild.nrChildren > this.context.minBlockSize) {
      const shiftChild = leftChild.dropLast();
      child.prepend(shiftChild);
      return oldValue;
    }
    const rightChild = this.children[childIndex + 1];
    if (void 0 !== rightChild && rightChild.nrChildren > this.context.minBlockSize) {
      const shiftChild = rightChild.dropFirst();
      child.append(shiftChild);
      return oldValue;
    }
    if (void 0 !== leftChild) {
      leftChild.concat(child);
      this.children.splice(childIndex, 1);
      return oldValue;
    }
    child.concat(rightChild);
    this.children.splice(childIndex + 1, 1);
    return oldValue;
  }
  dropFirst() {
    const first = this.children.shift();
    this.length -= first.length;
    return first;
  }
  dropLast() {
    const last = this.children.pop();
    this.length -= last.length;
    return last;
  }
  modifyFirstChild(f) {
    const delta = f(this.first());
    if (void 0 !== delta) {
      this.length += delta;
    }
    return delta;
  }
  modifyLastChild(f) {
    const delta = f(this.last());
    if (void 0 !== delta) {
      this.length += delta;
    }
    return delta;
  }
  first() {
    return this.children[0];
  }
  last() {
    return import_base4.Arr.last(this.children);
  }
  splitRight(index = this.nrChildren >>> 1) {
    const rightChildren = this.children.splice(index);
    const oldLength = this.length;
    this.length = 0;
    for (let i = 0; i < this.nrChildren; i++) {
      this.length += this.children[i].length;
    }
    const rightLength = oldLength - this.length;
    return this.copy(rightChildren, rightLength);
  }
  concat(other, prependOther = false) {
    this.children = prependOther ? other.children.concat(this.children) : this.children.concat(other.children);
    this.length += other.length;
  }
  forEach(f, state = (0, import_common5.TraverseState)()) {
    if (state.halted)
      return;
    let i = -1;
    const length = this.children.length;
    while (!state.halted && ++i < length) {
      this.children[i].forEach(f, state);
    }
  }
  build() {
    if (void 0 !== this.source) {
      return this.source;
    }
    return this.context.nonLeafBlock(
      this.length,
      this.children.map((c) => c.build()),
      this.level
    );
  }
  buildMap(f) {
    if (void 0 !== this.source) {
      return this.source.map(f);
    }
    return this.context.nonLeafBlock(
      this.length,
      this.children.map((c) => c.buildMap(f)),
      this.level
    );
  }
};

// src/custom/implementation/nonleaf/nonleaf-tree.mts
var import_base6 = require("@rimbu/base");

// src/custom/implementation/tree/operations.mts
var import_base5 = require("@rimbu/base");
var import_common6 = require("@rimbu/common");
var import_stream4 = require("@rimbu/stream");
function treeStream(tree, range, reversed = false) {
  const indexRange = import_common6.IndexRange.getIndicesFor(
    range ?? { start: 0 },
    tree.length
  );
  if (indexRange === "empty")
    return import_stream4.Stream.empty();
  if (indexRange === "all") {
    const rightStream2 = tree.right.stream(reversed);
    const leftStream2 = tree.left.stream(reversed);
    if (null === tree.middle) {
      if (reversed)
        return rightStream2.concat(leftStream2);
      return leftStream2.concat(rightStream2);
    }
    const middleStream2 = tree.middle.stream(reversed);
    if (reversed)
      return rightStream2.concat(middleStream2, leftStream2);
    return leftStream2.concat(middleStream2, rightStream2);
  }
  const [start, end] = indexRange;
  const leftStream = tree.left.streamRange({ start, end }, reversed);
  if (null === tree.middle) {
    const rightStart2 = Math.max(0, start - tree.left.length);
    const rightEnd2 = end - tree.left.length;
    if (rightEnd2 < 0)
      return leftStream;
    const rightStream2 = tree.right.streamRange(
      { start: rightStart2, end: rightEnd2 },
      reversed
    );
    if (reversed)
      return rightStream2.concat(leftStream);
    return leftStream.concat(rightStream2);
  }
  const middleStart = Math.max(0, start - tree.left.length);
  const middleEnd = end - tree.left.length;
  if (middleEnd < 0)
    return leftStream;
  const middleStream = tree.middle.streamRange(
    { start: middleStart, end: middleEnd },
    reversed
  );
  const rightStart = Math.max(0, middleStart - tree.middle.length);
  const rightEnd = middleEnd - tree.middle.length;
  if (rightEnd < 0) {
    if (reversed)
      return middleStream.concat(leftStream);
    return leftStream.concat(middleStream);
  }
  const rightStream = tree.right.streamRange(
    { start: rightStart, end: rightEnd },
    reversed
  );
  if (reversed)
    return rightStream.concat(middleStream, leftStream);
  return leftStream.concat(middleStream, rightStream);
}
function treeGet(tree, index) {
  const middleIndex = index - tree.left.length;
  if (middleIndex < 0) {
    return tree.left.get(index, import_base5.RimbuError.throwInvalidStateError);
  }
  if (null === tree.middle) {
    return tree.right.get(middleIndex, import_base5.RimbuError.throwInvalidStateError);
  }
  const rightIndex = middleIndex - tree.middle.length;
  if (rightIndex < 0)
    return tree.middle.get(middleIndex);
  return tree.right.get(rightIndex, import_base5.RimbuError.throwInvalidStateError);
}
function treePrepend(tree, child) {
  if (tree.left.canAddChild) {
    const newLeft2 = tree.left.prependInternal(child);
    return tree.copy(newLeft2);
  }
  if (null === tree.middle && tree.right.canAddChild) {
    if (tree.context.isReversedLeafBlock(tree.left)) {
      const newLeftChildren2 = import_base5.Arr.splice(tree.left.children, 0, 1);
      newLeftChildren2.push(child);
      const moveRightChild2 = tree.left.children[0];
      const newLeftLength2 = tree.left.length - tree.getChildLength(moveRightChild2) + tree.getChildLength(child);
      const newLeft3 = tree.left.copy(newLeftChildren2, newLeftLength2);
      const newRight2 = tree.right.prependInternal(moveRightChild2);
      return tree.copy(newLeft3, newRight2);
    }
    const newLeftChildren = import_base5.Arr.splice(
      tree.left.children,
      tree.context.maxBlockSize - 1,
      1
    );
    newLeftChildren.unshift(child);
    const moveRightChild = import_base5.Arr.last(tree.left.children);
    const newLeftLength = tree.left.length - tree.getChildLength(moveRightChild) + tree.getChildLength(child);
    const newLeft2 = tree.left.copy(newLeftChildren, newLeftLength);
    const newRight = tree.right.prependInternal(moveRightChild);
    return tree.copy(newLeft2, newRight);
  }
  const newMiddle = tree.prependMiddle(tree.left);
  const newLeft = tree.left.copy([child], tree.getChildLength(child));
  return tree.copy(newLeft, void 0, newMiddle);
}
function treeAppend(tree, child) {
  if (tree.right.canAddChild) {
    const newRight2 = tree.right.appendInternal(child);
    return tree.copy(void 0, newRight2);
  }
  if (null === tree.middle && tree.left.canAddChild) {
    if (tree.context.isReversedLeafBlock(tree.right)) {
      const newRightChildren2 = import_base5.Arr.splice(
        tree.right.children,
        tree.right.children.length - 1,
        1
      );
      newRightChildren2.unshift(child);
      const moveLeftChild2 = import_base5.Arr.last(tree.right.children);
      const newRightLength2 = tree.right.length - tree.getChildLength(moveLeftChild2) + tree.getChildLength(child);
      const newRight3 = tree.right.copy(newRightChildren2, newRightLength2);
      const newLeft2 = tree.left.appendInternal(moveLeftChild2);
      return tree.copy(newLeft2, newRight3);
    }
    const newRightChildren = import_base5.Arr.splice(tree.right.children, 0, 1);
    newRightChildren.push(child);
    const moveLeftChild = tree.right.children[0];
    const newRightLength = tree.right.length - tree.getChildLength(moveLeftChild) + tree.getChildLength(child);
    const newRight2 = tree.right.copy(newRightChildren, newRightLength);
    const newLeft = tree.left.appendInternal(moveLeftChild);
    return tree.copy(newLeft, newRight2);
  }
  const newMiddle = tree.appendMiddle(tree.right);
  const newRight = tree.right.copy([child], tree.getChildLength(child));
  return tree.copy(void 0, newRight, newMiddle);
}
function treeUpdate(tree, index, update) {
  const middleIndex = index - tree.left.length;
  if (middleIndex < 0) {
    const newLeft = tree.left.updateAt(index, update);
    return tree.copy(newLeft);
  }
  if (null === tree.middle) {
    const newRight = tree.right.updateAt(middleIndex, update);
    return tree.copy(void 0, newRight);
  }
  const rightIndex = middleIndex - tree.middle.length;
  if (rightIndex >= 0) {
    const newRight = tree.right.updateAt(rightIndex, update);
    return tree.copy(void 0, newRight);
  }
  const newMiddle = tree.middle.updateAt(middleIndex, update);
  return tree.copy(void 0, void 0, newMiddle);
}
function treeToArray(tree, range, reversed = false) {
  const indexRange = import_common6.IndexRange.getIndicesFor(
    range ?? { start: 0 },
    tree.length
  );
  if (indexRange === "empty")
    return [];
  if (indexRange === "all") {
    const leftArray2 = tree.left.toArray(void 0, reversed);
    const rightArray2 = tree.right.toArray(void 0, reversed);
    if (null === tree.middle) {
      if (reversed)
        return rightArray2.concat(leftArray2);
      return leftArray2.concat(rightArray2);
    }
    const middleArray2 = tree.middle.toArray(void 0, reversed);
    if (reversed)
      return rightArray2.concat(middleArray2, leftArray2);
    return leftArray2.concat(middleArray2, rightArray2);
  }
  const [start, end] = indexRange;
  const leftArray = tree.left.toArray({ start, end }, reversed);
  if (null === tree.middle) {
    const rightStart2 = Math.max(0, start - tree.left.length);
    const rightEnd2 = end - tree.left.length;
    if (rightEnd2 < 0)
      return leftArray;
    const rightArray2 = tree.right.toArray(
      { start: rightStart2, end: rightEnd2 },
      reversed
    );
    if (reversed)
      return rightArray2.concat(leftArray);
    return leftArray.concat(rightArray2);
  }
  const middleStart = Math.max(0, start - tree.left.length);
  const middleEnd = end - tree.left.length;
  if (middleEnd < 0)
    return leftArray;
  const middleArray = tree.middle.toArray(
    { start: middleStart, end: middleEnd },
    reversed
  );
  const rightStart = Math.max(0, middleStart - tree.middle.length);
  const rightEnd = middleEnd - tree.middle.length;
  if (rightEnd < 0) {
    if (reversed)
      return middleArray.concat(leftArray);
    return leftArray.concat(middleArray);
  }
  const rightArray = tree.right.toArray(
    { start: rightStart, end: rightEnd },
    reversed
  );
  if (reversed)
    return rightArray.concat(middleArray, leftArray);
  return leftArray.concat(middleArray, rightArray);
}
function treeForEach(tree, f, state) {
  if (state.halted)
    return;
  tree.left.forEach(f, state);
  if (state.halted)
    return;
  if (null !== tree.middle) {
    tree.middle.forEach(f, state);
  }
  if (state.halted)
    return;
  tree.right.forEach(f, state);
}

// src/custom/implementation/nonleaf/nonleaf-tree.mts
var NonLeafTree = class {
  constructor(context, left, right, middle, level, length = left.length + right.length + (middle?.length ?? 0)) {
    this.context = context;
    this.left = left;
    this.right = right;
    this.middle = middle;
    this.level = level;
    this.length = length;
  }
  getChildLength(child) {
    return child.length;
  }
  copy(left = this.left, right = this.right, middle = this.middle) {
    if (left === this.left && right === this.right && middle === this.middle) {
      return this;
    }
    return this.context.nonLeafTree(left, right, middle, this.level);
  }
  copy2(left, right, middle) {
    return this.context.nonLeafTree(left, right, middle, this.level);
  }
  stream(reversed = false) {
    return treeStream(this, void 0, reversed);
  }
  streamRange(range, reversed = false) {
    return treeStream(this, range, reversed);
  }
  get(index) {
    return treeGet(this, index);
  }
  prepend(child) {
    return treePrepend(this, child);
  }
  append(child) {
    return treeAppend(this, child);
  }
  prependMiddle(child) {
    if (child.level !== this.level) {
      import_base6.RimbuError.throwInvalidStateError();
    }
    return this.middle?.prepend(child) ?? this.context.nonLeafBlock(
      child.length,
      [child],
      this.level + 1
    );
  }
  appendMiddle(child) {
    if (child.level !== this.level) {
      import_base6.RimbuError.throwInvalidStateError();
    }
    return this.middle?.append(child) ?? this.context.nonLeafBlock(
      child.length,
      [child],
      this.level + 1
    );
  }
  dropFirst() {
    const [newLeft, firstChild] = this.left.dropFirst();
    if (null === newLeft) {
      if (null === this.middle) {
        return [this.right, firstChild];
      }
      const [newMiddle, toLeft] = this.middle.dropFirst();
      const newSelf2 = this.copy(toLeft, void 0, newMiddle)._normalize();
      return [newSelf2, firstChild];
    }
    const newSelf = this.copy(newLeft)._normalize();
    return [newSelf, firstChild];
  }
  dropLast() {
    const [newRight, lastChild] = this.right.dropLast();
    if (null === newRight) {
      if (null === this.middle) {
        return [this.left, lastChild];
      }
      const [newMiddle, toRight] = this.middle.dropLast();
      const newSelf2 = this.copy(void 0, toRight, newMiddle)._normalize();
      return [newSelf2, lastChild];
    }
    const newSelf = this.copy(void 0, newRight)._normalize();
    return [newSelf, lastChild];
  }
  takeInternal(amount) {
    const middleAmount = amount - this.left.length;
    if (middleAmount <= 0) {
      return this.left.takeInternal(amount);
    }
    if (null === this.middle) {
      const [newRight, up, upAmount] = this.right.takeInternal(middleAmount);
      if (null === newRight) {
        return [this.left, up, upAmount];
      }
      return [this.left.concat(newRight), up, upAmount];
    }
    const rightAmount = middleAmount - this.middle.length;
    if (rightAmount > 0) {
      const [newRight, up, upAmount] = this.right.takeInternal(rightAmount);
      if (null === newRight) {
        const [newMiddle2, toRight] = this.middle.dropLast();
        const newSelf3 = this.copy(void 0, toRight, newMiddle2)._normalize();
        return [newSelf3, up, upAmount];
      }
      const newSelf2 = this.copy(void 0, newRight)._normalize();
      return [newSelf2, up, upAmount];
    }
    const [newMiddle, upRight] = this.middle.takeInternal(middleAmount);
    const newSelf = this.copy(void 0, upRight, newMiddle)._normalize();
    return newSelf.takeInternal(amount);
  }
  dropInternal(amount) {
    const middleAmount = amount - this.left.length;
    if (null === this.middle) {
      if (middleAmount < 0) {
        const [newLeft, upLeft2, upLeftAmount] = this.left.dropInternal(amount);
        const newSelf2 = null === newLeft ? this.right : newLeft.concat(this.right);
        return [newSelf2, upLeft2, upLeftAmount];
      } else {
        return this.right.dropInternal(middleAmount);
      }
    }
    if (middleAmount < 0) {
      const [newLeft, upLeft2, upLeftAmount] = this.left.dropInternal(amount);
      if (null === newLeft) {
        const [newMiddle2, toLeft] = this.middle.dropFirst();
        const newSelf3 = this.copy(toLeft, void 0, newMiddle2)._normalize();
        return [newSelf3, upLeft2, upLeftAmount];
      }
      const newSelf2 = this.copy(newLeft);
      return [newSelf2, upLeft2, upLeftAmount];
    }
    const rightAmount = middleAmount - this.middle.length;
    if (rightAmount >= 0) {
      return this.right.dropInternal(rightAmount);
    }
    const [newMiddle, upLeft, inUpLeft] = this.middle.dropInternal(middleAmount);
    const newSelf = this.copy(upLeft, void 0, newMiddle)._normalize();
    return newSelf.dropInternal(inUpLeft);
  }
  concat(other) {
    if (this.context.isNonLeafBlock(other)) {
      return this.concatBlock(other);
    }
    if (this.context.isNonLeafTree(other)) {
      return this.concatTree(other);
    }
    import_base6.RimbuError.throwInvalidStateError();
  }
  concatBlock(other) {
    if (other.level !== this.level) {
      import_base6.RimbuError.throwInvalidStateError();
    }
    if (this.right.nrChildren + other.nrChildren <= this.context.maxBlockSize) {
      const newRight2 = this.right.concatChildren(other);
      return this.copy(void 0, newRight2);
    }
    if (this.right.childrenInMin) {
      const newMiddle2 = this.appendMiddle(this.right);
      return this.copy(void 0, other, newMiddle2)._normalize();
    }
    const newRight = this.right.concatChildren(other);
    const newLast = newRight._mutateSplitRight(this.context.maxBlockSize);
    const newMiddle = this.appendMiddle(newRight);
    return this.copy(void 0, newLast, newMiddle)._normalize();
  }
  concatTree(other) {
    if (this.right.nrChildren + other.left.nrChildren <= this.context.maxBlockSize) {
      const joint2 = this.right.concatChildren(other.left);
      const newThisMiddle2 = this.appendMiddle(joint2);
      const newMiddle2 = null === other.middle ? newThisMiddle2 : newThisMiddle2.concat(other.middle);
      return this.copy(void 0, other.right, newMiddle2)._normalize();
    }
    if (this.right.childrenInMin && other.left.childrenInMin) {
      const newThisMiddle2 = this.appendMiddle(this.right).append(other.left);
      const newMiddle2 = null === other.middle ? newThisMiddle2 : newThisMiddle2.concat(other.middle);
      return this.copy(void 0, other.right, newMiddle2)._normalize();
    }
    const joint = this.right.concatChildren(other.left);
    const jointRight = joint._mutateSplitRight();
    const newThisMiddle = this.appendMiddle(joint).append(jointRight);
    const newMiddle = null === other.middle ? newThisMiddle : newThisMiddle.concat(other.middle);
    return this.copy(void 0, other.right, newMiddle)._normalize();
  }
  updateAt(index, update) {
    return treeUpdate(
      this,
      index,
      update
    );
  }
  forEach(f, state) {
    if (state.halted)
      return;
    treeForEach(this, f, state);
  }
  mapPure(mapFun, reversed = false, cacheMap = this.context.createCacheMap()) {
    const cachedThis = cacheMap.get(this);
    if (cachedThis)
      return cachedThis;
    const mappedLeft = this.left.mapPure(mapFun, reversed, cacheMap);
    const mappedMiddle = null === this.middle ? null : this.middle.mapPure(mapFun, reversed, cacheMap);
    const mappedRight = this.right.mapPure(mapFun, reversed, cacheMap);
    const result = reversed ? this.copy2(mappedRight, mappedLeft, mappedMiddle) : this.copy2(mappedLeft, mappedRight, mappedMiddle);
    return cacheMap.setAndReturn(this, result);
  }
  map(mapFun, reversed = false, indexOffset = 0) {
    let offset = indexOffset;
    const left = this.left;
    const middle = this.middle;
    const right = this.right;
    if (reversed) {
      const newLeft2 = right.map(mapFun, true, offset);
      offset += right.length;
      const newMiddle2 = null === middle ? null : middle.map(mapFun, true, offset);
      if (null !== middle)
        offset += middle.length;
      const newRight2 = left.map(mapFun, true, offset);
      return this.copy2(newLeft2, newRight2, newMiddle2);
    }
    const newLeft = left.map(mapFun, false, offset);
    offset += left.length;
    const newMiddle = null === middle ? null : middle.map(mapFun, false, offset);
    if (null !== middle)
      offset += middle.length;
    const newRight = right.map(mapFun, false, offset);
    return this.copy2(newLeft, newRight, newMiddle);
  }
  reversed(cacheMap = this.context.createCacheMap()) {
    const cachedThis = cacheMap.get(this);
    if (cachedThis !== void 0)
      return cachedThis;
    const newMid = this.middle?.reversed(cacheMap) ?? null;
    const newLeft = this.right.reversed(cacheMap);
    const newRight = this.left === this.right ? newLeft : this.left.reversed(cacheMap);
    const reversedThis = this.copy(newLeft, newRight, newMid);
    return cacheMap.setAndReturn(this, reversedThis);
  }
  _normalize() {
    if (null === this.middle) {
      if (this.left.nrChildren + this.right.nrChildren <= this.context.maxBlockSize) {
        return this.left.concatChildren(this.right);
      }
    } else if (this.context.isNonLeafBlock(this.middle)) {
      const firstChild = this.middle.getChild(0);
      if (this.left.nrChildren + firstChild.nrChildren <= this.context.maxBlockSize) {
        const result = this.middle.dropFirst();
        const newMiddle = result[0];
        const block = result[1];
        return this.copy(this.left.concatChildren(block), void 0, newMiddle);
      }
      const lastChild = this.middle.getChild(this.middle.nrChildren - 1);
      if (this.right.nrChildren + lastChild.nrChildren <= this.context.maxBlockSize) {
        const result = this.middle.dropLast();
        const newMiddle = result[0];
        const block = result[1];
        return this.copy(
          void 0,
          block.concatChildren(this.right),
          newMiddle
        );
      }
    }
    return this;
  }
  toArray(range, reversed = false) {
    return treeToArray(this, range, reversed);
  }
  structure() {
    const space = " ".padEnd(this.level * 2);
    return `
${space}<NLTree(${this.level}) len:${this.length}
  l:${this.left.structure()}
  m:${this.middle && this.middle.structure()}
  r:${this.right.structure()}
>`;
  }
  createNonLeafBuilder() {
    return this.context.nonLeafTreeBuilderSource(this);
  }
};

// src/custom/implementation/leaf/leaf-block.mts
var import_base8 = require("@rimbu/base");
var import_common8 = require("@rimbu/common");
var import_stream5 = require("@rimbu/stream");

// src/custom/implementation/leaf/non-empty.mts
var import_base7 = require("@rimbu/base");
var import_set_custom2 = require("@rimbu/collection-types/set-custom");
var import_common7 = require("@rimbu/common");
var import_custom = require("@rimbu/stream/custom");
var ListNonEmptyBase = class extends import_set_custom2.NonEmptyBase {
  [Symbol.iterator]() {
    return this.stream()[Symbol.iterator]();
  }
  get isEmpty() {
    return false;
  }
  nonEmpty() {
    return true;
  }
  assumeNonEmpty() {
    return this;
  }
  asNormal() {
    return this;
  }
  first() {
    return this.get(0, import_base7.RimbuError.throwInvalidStateError);
  }
  last() {
    return this.get(this.length - 1, import_base7.RimbuError.throwInvalidStateError);
  }
  slice(range, reversed) {
    const result = import_common7.IndexRange.getIndicesFor(range, this.length);
    if (result === "all") {
      if (reversed)
        return this.reversed();
      return this;
    }
    if (result === "empty")
      return this.context.empty();
    const [start, end] = result;
    const values = this.drop(start).take(end - start + 1);
    if (!reversed)
      return values;
    return values.reversed();
  }
  sort(comp) {
    const sortedArray = this.toArray().sort(comp?.compare);
    return this.context.from(sortedArray);
  }
  splice({
    index = 0,
    remove = 0,
    insert
  } = {}) {
    if (index < 0) {
      return this.splice({ index: this.length + index, remove, insert });
    }
    if (void 0 === insert) {
      if (remove <= 0)
        return this;
      return this.take(index).concat(this.drop(index + remove));
    }
    if (remove <= 0 && (0, import_custom.isEmptyStreamSourceInstance)(insert))
      return this;
    return this.take(index).concat(insert, this.drop(index + remove));
  }
  insert(index, values) {
    return this.splice({ index, insert: values });
  }
  remove(index, amount = 1) {
    return this.splice({ index, remove: amount });
  }
  repeat(amount) {
    if (amount <= -1)
      return this.reversed().repeat(-amount);
    if (amount <= 1)
      return this;
    const doubleTimes = amount >>> 1;
    const doubleResult = this.concat(this).repeat(doubleTimes);
    const remainTimes = amount % 2;
    if (remainTimes === 0)
      return doubleResult;
    return doubleResult.concat(this);
  }
  rotate(shiftRightAmount) {
    let normalizedAmount = shiftRightAmount % this.length;
    if (normalizedAmount === 0)
      return this;
    if (normalizedAmount < 0)
      normalizedAmount += this.length;
    return this.take(-normalizedAmount).concat(this.drop(-normalizedAmount)).assumeNonEmpty();
  }
  padTo(length, fill, positionPercentage = 0) {
    if (this.length >= length)
      return this;
    const diff = length - this.length;
    const frac = Math.max(0, Math.min(100, positionPercentage)) / 100;
    const frontSize = Math.round(diff * frac);
    const pad = this.context.leafBlock([fill]).repeat(diff);
    return pad.splice({ index: frontSize, insert: this }).assumeNonEmpty();
  }
  filter(pred, range, reversed = false) {
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    const result = this.context.from(stream.filter(pred));
    if (result.length !== this.length)
      return result;
    if (!reversed)
      return this;
    return this.reversed();
  }
  collect(collectFun, range, reversed = false) {
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    return this.context.from(stream.collect(collectFun));
  }
  flatMap(flatMapFun, range, reversed = false) {
    let result = this.context.empty();
    const stream = void 0 === range ? this.stream(reversed) : this.streamRange(range, reversed);
    const iterator = stream[Symbol.iterator]();
    let index = 0;
    const done = Symbol("Done");
    let value;
    while (done !== (value = iterator.fastNext(done))) {
      result = result.concat(flatMapFun(value, index++));
    }
    return result;
  }
  toBuilder() {
    return this.context.createBuilder(this);
  }
  toString() {
    return this.stream().join({ start: "List(", sep: ", ", end: ")" });
  }
  toJSON() {
    return {
      dataType: this.context.typeTag,
      value: this.toArray()
    };
  }
};

// src/custom/implementation/leaf/leaf-block.mts
var LeafBlock = class extends ListNonEmptyBase {
  constructor(context, children) {
    super();
    this.context = context;
    this.children = children;
  }
  get length() {
    return this.children.length;
  }
  get level() {
    return 0;
  }
  copy(children) {
    if (children === this.children)
      return this;
    return this.context.leafBlock(children);
  }
  copy2(children) {
    return this.context.leafBlock(children);
  }
  get mutateChildren() {
    return this.children;
  }
  get childrenInMax() {
    return this.children.length <= this.context.maxBlockSize;
  }
  get childrenInMin() {
    return this.children.length >= this.context.minBlockSize;
  }
  get canAddChild() {
    return this.children.length < this.context.maxBlockSize;
  }
  stream(reversed = false) {
    return import_stream5.Stream.fromArray(
      this.children,
      void 0,
      reversed
    );
  }
  streamRange(range, reversed = false) {
    return import_stream5.Stream.fromArray(
      this.children,
      range,
      reversed
    );
  }
  get(index, otherwise) {
    if (index >= this.length || -index > this.length) {
      return (0, import_common8.OptLazy)(otherwise);
    }
    if (index < 0) {
      return this.get(this.length + index, otherwise);
    }
    return this.children[index];
  }
  prepend(value) {
    if (this.length === 1 && !this.context.isReversedLeafBlock(this)) {
      return this.context.reversedLeaf([this.children[0], value]);
    }
    if (this.canAddChild) {
      return this.prependInternal(value);
    }
    return this.context.leafTree(this.copy([value]), this, null);
  }
  append(value) {
    if (this.canAddChild)
      return this.appendInternal(value);
    return this.context.leafTree(this, this.copy([value]), null);
  }
  prependInternal(value) {
    const newChildren = import_base8.Arr.prepend(this.children, value);
    return this.copy(newChildren);
  }
  appendInternal(value) {
    const newChildren = import_base8.Arr.append(this.children, value);
    return this.copy(newChildren);
  }
  take(amount) {
    if (amount === 0)
      return this.context.empty();
    if (amount >= this.length || -amount > this.length)
      return this;
    if (amount < 0)
      return this.drop(this.length + amount);
    return this.takeChildren(amount);
  }
  drop(amount) {
    if (amount === 0)
      return this;
    if (amount >= this.length || -amount > this.length)
      return this.context.empty();
    if (amount < 0)
      return this.take(this.length + amount);
    return this.dropChildren(amount);
  }
  takeChildren(childAmount) {
    if (childAmount >= this.length)
      return this;
    const newChildren = import_base8.Arr.splice(
      this.children,
      childAmount,
      this.context.maxBlockSize
    );
    return this.copy(newChildren);
  }
  dropChildren(childAmount) {
    if (childAmount <= 0)
      return this;
    const newChildren = import_base8.Arr.splice(this.children, 0, childAmount);
    return this.copy(newChildren);
  }
  concatChildren(other) {
    const addChildren = this.context.isReversedLeafBlock(other) ? import_base8.Arr.reverse(other.children) : other.children;
    const newChildren = this.children.concat(addChildren);
    return this.copy(newChildren);
  }
  concat(...sources) {
    const asList = this.context.from(...sources);
    if (asList.nonEmpty()) {
      if (this.context.isLeafBlock(asList)) {
        if (asList === this && this.children.length > this.context.minBlockSize) {
          return this.context.leafTree(this, this, null);
        }
        return this.concatBlock(asList);
      }
      if (this.context.isLeafTree(asList)) {
        return this.concatTree(asList);
      }
      import_base8.RimbuError.throwInvalidStateError();
    }
    return this;
  }
  concatBlock(other) {
    return this.concatChildren(other)._mutateNormalize();
  }
  concatTree(other) {
    if (this.length + other.left.length <= this.context.maxBlockSize) {
      const newLeft2 = this.concatChildren(other.left);
      return other.copy(newLeft2);
    }
    if (other.left.childrenInMin) {
      const newMiddle2 = other.prependMiddle(other.left);
      return other.copy(this, void 0, newMiddle2);
    }
    const newLeft = this.concatChildren(other.left);
    const newSecond = newLeft._mutateSplitRight(
      newLeft.length - this.context.maxBlockSize
    );
    const newMiddle = other.prependMiddle(newSecond);
    return other.copy(newLeft, void 0, newMiddle);
  }
  updateAt(index, update) {
    if (index >= this.length || -index > this.length)
      return this;
    if (index < 0)
      return this.updateAt(this.length + index, update);
    const newChildren = import_base8.Arr.update(
      this.children,
      index,
      (c) => (0, import_common8.Update)(c, update)
    );
    return this.copy(newChildren);
  }
  forEach(f, state = (0, import_common8.TraverseState)()) {
    if (state.halted)
      return;
    import_base8.Arr.forEach(
      this.children,
      f,
      state,
      this.context.isReversedLeafBlock(this)
    );
  }
  mapPure(mapFun, reversed = false, cacheMap = this.context.createCacheMap()) {
    const currentValue = cacheMap.get(this);
    if (currentValue)
      return currentValue;
    const fn = reversed ? import_base8.Arr.reverseMap : import_base8.Arr.map;
    const newChildren = fn(this.children, mapFun);
    return cacheMap.setAndReturn(this, this.copy2(newChildren));
  }
  map(mapFun, reversed = false, indexOffset = 0) {
    if (reversed) {
      const newChildren2 = import_base8.Arr.reverseMap(this.children, mapFun, indexOffset);
      return this.copy2(newChildren2);
    }
    const newChildren = import_base8.Arr.map(this.children, mapFun, indexOffset);
    return this.copy2(newChildren);
  }
  reversed(cacheMap = this.context.createCacheMap()) {
    if (this.length === 1)
      return this;
    const cachedThis = cacheMap.get(this);
    if (cachedThis !== void 0)
      return cachedThis;
    const reversedThis = this.context.reversedLeaf(this.children);
    return cacheMap.setAndReturn(this, reversedThis);
  }
  _mutateNormalize() {
    if (this.childrenInMax)
      return this;
    const newRight = this._mutateSplitRight();
    return this.context.leafTree(this, newRight, null);
  }
  _mutateSplitRight(childIndex = this.children.length >>> 1) {
    const rightChildren = this.mutateChildren.splice(childIndex);
    return this.copy(rightChildren);
  }
  toArray(range, reversed = false) {
    let result;
    if (void 0 === range)
      result = this.children;
    else {
      const indexRange = import_common8.IndexRange.getIndicesFor(range, this.length);
      if (indexRange === "all")
        result = this.children;
      else if (indexRange === "empty")
        result = [];
      else {
        const [start, end] = indexRange;
        if (!reversed)
          return this.children.slice(start, end + 1);
        return import_base8.Arr.reverse(this.children, start, end);
      }
    }
    if (reversed)
      return import_base8.Arr.reverse(result);
    return result.slice();
  }
  structure() {
    return `<Leaf ${this.length}>`;
  }
  createBlockBuilder() {
    return this.context.leafBlockBuilderSource(this);
  }
};
var ReversedLeafBlock = class extends LeafBlock {
  copy(children) {
    if (children === this.children)
      return this;
    return this.context.reversedLeaf(children);
  }
  copy2(children) {
    return this.context.reversedLeaf(children);
  }
  stream(reversed = false) {
    return import_stream5.Stream.fromArray(
      this.children,
      void 0,
      !reversed
    );
  }
  streamRange(range, reversed = false) {
    const indices = import_common8.IndexRange.getIndicesFor(range, this.length);
    if (indices === "empty")
      return import_stream5.Stream.empty();
    if (indices === "all")
      return this.stream(reversed);
    const start = this.length - 1 - indices[1];
    const end = this.length - 1 - indices[0];
    return import_stream5.Stream.fromArray(this.children, { start, end }, !reversed);
  }
  get(index, otherwise) {
    if (index >= this.length || -index > this.length) {
      return (0, import_common8.OptLazy)(otherwise);
    }
    if (index < 0) {
      return this.get(this.length + index, otherwise);
    }
    return this.children[this.length - 1 - index];
  }
  prependInternal(value) {
    return super.appendInternal(value);
  }
  appendInternal(value) {
    return super.prependInternal(value);
  }
  takeChildren(childAmount) {
    return super.dropChildren(this.length - childAmount);
  }
  dropChildren(childAmount) {
    return super.takeChildren(this.length - childAmount);
  }
  concatChildren(other) {
    if (other.context.isReversedLeafBlock(other)) {
      return this.copy(other.children.concat(this.children));
    }
    return other.copy(import_base8.Arr.reverse(this.children).concat(other.children));
  }
  updateAt(index, update) {
    if (index >= this.length || -index > this.length)
      return this;
    if (index < 0)
      return this.updateAt(this.length + index, update);
    return super.updateAt(this.length - 1 - index, update);
  }
  map(mapFun, reversed = false, indexOffset = 0) {
    if (!reversed) {
      const newChildren2 = import_base8.Arr.reverseMap(this.children, mapFun, indexOffset);
      return super.copy2(newChildren2);
    }
    const newChildren = import_base8.Arr.map(this.children, mapFun, indexOffset);
    return super.copy2(newChildren);
  }
  reversed(cacheMap = this.context.createCacheMap()) {
    if (this.length === 1)
      return this;
    const cachedThis = cacheMap.get(this);
    if (cachedThis !== void 0)
      return cachedThis;
    const reversedThis = this.context.leafBlock(this.children);
    return cacheMap.setAndReturn(this, reversedThis);
  }
  toArray(range, reversed = false) {
    let result;
    if (void 0 === range)
      result = this.children;
    else {
      const indexRange = import_common8.IndexRange.getIndicesFor(range, this.length);
      if (indexRange === "empty")
        return [];
      else if (indexRange === "all")
        result = this.children;
      else {
        const [indexStart, indexEnd] = indexRange;
        const start = this.length - 1 - indexEnd;
        const end = this.length - 1 - indexStart;
        if (!reversed)
          return import_base8.Arr.reverse(this.children, start, end);
        return this.children.slice(start, end + 1);
      }
    }
    if (!reversed)
      return import_base8.Arr.reverse(result);
    return result.slice();
  }
  _mutateSplitRight(childIndex = this.children.length >>> 1) {
    const rightChildren = this.mutateChildren.splice(
      0,
      this.children.length - childIndex
    );
    return this.copy(rightChildren);
  }
  structure() {
    return `<RLeaf ${this.length}>`;
  }
};

// src/custom/implementation/leaf/leaf-tree.mts
var import_base9 = require("@rimbu/base");
var import_common9 = require("@rimbu/common");
var LeafTree = class extends ListNonEmptyBase {
  constructor(context, left, right, middle, length = left.length + right.length + (null === middle ? 0 : middle.length)) {
    super();
    this.context = context;
    this.left = left;
    this.right = right;
    this.middle = middle;
    this.length = length;
  }
  getChildLength() {
    return 1;
  }
  copy(left = this.left, right = this.right, middle = this.middle) {
    if (left === this.left && right === this.right && middle === this.middle) {
      return this;
    }
    return this.context.leafTree(left, right, middle);
  }
  copy2(left, right, middle) {
    return this.context.leafTree(left, right, middle);
  }
  stream(reversed = false) {
    return treeStream(
      this,
      void 0,
      reversed
    );
  }
  streamRange(range, reversed = false) {
    return treeStream(this, range, reversed);
  }
  get(index, otherwise) {
    if (index >= this.length || -index > this.length) {
      return (0, import_common9.OptLazy)(otherwise);
    }
    if (index < 0) {
      return this.get(this.length + index, otherwise);
    }
    return treeGet(this, index);
  }
  prepend(value) {
    return treePrepend(this, value);
  }
  append(value) {
    return treeAppend(this, value);
  }
  prependMiddle(child) {
    return this.middle?.prepend(child) ?? this.context.nonLeafBlock(child.length, [child], 1);
  }
  appendMiddle(child) {
    return this.middle?.append(child) ?? this.context.nonLeafBlock(child.length, [child], 1);
  }
  take(amountInput) {
    const amount = Math.floor(amountInput);
    if (amount === 0)
      return this.context.empty();
    if (amount >= this.length || -amount > this.length)
      return this;
    if (amount < 0)
      return this.drop(this.length + amount);
    const middleAmount = amount - this.left.length;
    if (middleAmount <= 0)
      return this.left.take(amount);
    if (null === this.middle) {
      return this.copy(
        void 0,
        this.right.takeChildren(middleAmount)
      )._normalize();
    }
    const rightAmount = middleAmount - this.middle.length;
    if (rightAmount > 0) {
      const newRight2 = this.right.takeChildren(rightAmount);
      return this.copy(void 0, newRight2)._normalize();
    }
    const [newMiddle, upRight, inUpRight] = this.middle.takeInternal(middleAmount);
    const newRight = upRight.takeChildren(inUpRight);
    return this.copy(void 0, newRight, newMiddle)._normalize();
  }
  drop(amount) {
    if (amount === 0)
      return this;
    if (amount >= this.length || -amount > this.length)
      return this.context.empty();
    if (amount < 0)
      return this.take(this.length + amount);
    const middleAmount = amount - this.left.length;
    if (middleAmount < 0) {
      const newLeft2 = this.left.dropChildren(amount);
      return this.copy(newLeft2)._normalize();
    }
    if (null === this.middle) {
      return this.right.drop(middleAmount);
    }
    const rightAmount = middleAmount - this.middle.length;
    if (rightAmount >= 0) {
      return this.right.drop(rightAmount);
    }
    const [newMiddle, upLeft, inUpLeft] = this.middle.dropInternal(middleAmount);
    const newLeft = upLeft.dropChildren(inUpLeft);
    return this.copy(newLeft, void 0, newMiddle)._normalize();
  }
  concat(...sources) {
    const asList = this.context.from(...sources);
    if (asList.nonEmpty()) {
      if (this.context.isLeafBlock(asList)) {
        return this.concatBlock(asList);
      } else if (this.context.isLeafTree(asList)) {
        return this.concatTree(asList);
      } else {
        import_base9.RimbuError.throwInvalidStateError();
      }
    }
    return this;
  }
  concatBlock(other) {
    if (this.right.length + other.length <= this.context.maxBlockSize) {
      const newRight2 = this.right.concatChildren(other);
      return this.copy(void 0, newRight2);
    }
    if (this.right.childrenInMin) {
      const newMiddle2 = this.appendMiddle(this.right);
      return this.copy(void 0, other, newMiddle2);
    }
    const newRight = this.right.concatChildren(other);
    const newLast = newRight._mutateSplitRight(this.context.maxBlockSize);
    const newMiddle = this.appendMiddle(newRight);
    return this.copy(void 0, newLast, newMiddle);
  }
  concatTree(other) {
    const jointLength = this.right.length + other.left.length;
    if (jointLength < this.context.minBlockSize) {
      if (null === this.middle) {
        const joint3 = this.left.concatChildren(this.right).concatChildren(other.left);
        const toMiddle = joint3._mutateSplitRight(
          joint3.children.length - this.context.maxBlockSize
        );
        const newMiddle3 = other.prependMiddle(toMiddle);
        return other.copy(joint3, void 0, newMiddle3);
      }
      const [newMiddle2, toJoint] = this.middle.dropLast();
      const joint2 = toJoint.concatChildren(this.right).concatChildren(other.left);
      if (joint2.childrenInMax) {
        const m = null === newMiddle2 ? other.prependMiddle(joint2) : newMiddle2.concat(other.prependMiddle(joint2));
        return this.copy(void 0, other.right, m);
      }
      const newOtherLeft = joint2._mutateSplitRight();
      const newMiddle22 = null === newMiddle2 ? other.prependMiddle(newOtherLeft).prepend(joint2) : null === other.middle ? newMiddle2.append(joint2).append(newOtherLeft) : newMiddle2.append(joint2).append(newOtherLeft).concat(other.middle);
      return this.copy(void 0, other.right, newMiddle22);
    }
    if (jointLength <= this.context.maxBlockSize) {
      const joint2 = this.right.concatChildren(other.left);
      const newThisMiddle2 = this.appendMiddle(joint2);
      const newMiddle2 = null === other.middle ? newThisMiddle2 : newThisMiddle2.concat(other.middle);
      return this.copy(void 0, other.right, newMiddle2);
    }
    if (this.right.childrenInMin && other.left.childrenInMin) {
      const newThisMiddle2 = this.appendMiddle(this.right).append(other.left);
      const newMiddle2 = null === other.middle ? newThisMiddle2 : newThisMiddle2.concat(other.middle);
      return this.copy(void 0, other.right, newMiddle2);
    }
    const joint = this.right.concatChildren(other.left);
    const jointRight = joint._mutateSplitRight();
    const newThisMiddle = this.appendMiddle(joint).append(jointRight);
    const newMiddle = null === other.middle ? newThisMiddle : newThisMiddle.concat(other.middle);
    return this.copy(void 0, other.right, newMiddle);
  }
  updateAt(index, update) {
    if (index >= this.length || -index > this.length)
      return this;
    if (index < 0)
      return this.updateAt(this.length + index, update);
    return treeUpdate(this, index, update);
  }
  forEach(f, state = (0, import_common9.TraverseState)()) {
    if (state.halted)
      return;
    treeForEach(this, f, state);
  }
  mapPure(mapFun, reversed = false, cacheMap = this.context.createCacheMap()) {
    const currentValue = cacheMap.get(this);
    if (currentValue)
      return currentValue;
    const mappedLeft = this.left.mapPure(mapFun, reversed, cacheMap);
    const mappedMiddle = null === this.middle ? null : this.middle.mapPure(mapFun, reversed, cacheMap);
    const mappedRight = this.right.mapPure(mapFun, reversed, cacheMap);
    const result = reversed ? this.copy2(mappedRight, mappedLeft, mappedMiddle) : this.copy2(mappedLeft, mappedRight, mappedMiddle);
    return cacheMap.setAndReturn(this, result);
  }
  map(mapFun, reversed = false, indexOffset = 0) {
    let offset = indexOffset;
    if (reversed) {
      const newLeft2 = this.right.map(mapFun, true, offset);
      offset += this.right.length;
      const newMiddle2 = null === this.middle ? null : this.middle.map(mapFun, true, offset);
      if (null !== this.middle)
        offset += this.middle.length;
      const newRight2 = this.left.map(mapFun, true, offset);
      return this.copy2(newLeft2, newRight2, newMiddle2);
    }
    const newLeft = this.left.map(mapFun, false, offset);
    offset += this.left.length;
    const newMiddle = null === this.middle ? null : this.middle.map(mapFun, false, offset);
    if (null !== this.middle)
      offset += this.middle.length;
    const newRight = this.right.map(mapFun, false, offset);
    return this.copy2(newLeft, newRight, newMiddle);
  }
  reversed(cacheMap = this.context.createCacheMap()) {
    const cachedThis = cacheMap.get(this);
    if (cachedThis !== void 0)
      return cachedThis;
    const newMid = this.middle?.reversed(cacheMap) ?? null;
    const newLeft = this.right.reversed(cacheMap);
    const newRight = this.left === this.right ? newLeft : this.left.reversed(cacheMap);
    const reversedThis = this.copy(newLeft, newRight, newMid);
    return cacheMap.setAndReturn(this, reversedThis);
  }
  toArray(range, reversed = false) {
    return treeToArray(this, range, reversed);
  }
  _normalize() {
    if (null === this.middle) {
      if (this.length <= this.context.maxBlockSize) {
        return this.left.concatChildren(this.right);
      }
    } else if (this.context.isNonLeafBlock(this.middle)) {
      if (this.length <= this.context.maxBlockSize) {
        return this.left.concatChildren(this.middle.getChild(0)).concatChildren(this.right);
      }
      const firstChild = this.middle.getChild(0);
      if (this.left.length + firstChild.length <= this.context.maxBlockSize) {
        const result = this.middle.dropFirst();
        const newMiddle = result[0];
        const block = result[1];
        return this.copy(this.left.concatChildren(block), void 0, newMiddle);
      }
      const lastChild = this.middle.getChild(this.middle.nrChildren - 1);
      if (this.right.length + lastChild.length <= this.context.maxBlockSize) {
        const result = this.middle.dropLast();
        const newMiddle = result[0];
        const block = result[1];
        return this.copy(
          void 0,
          block.concatChildren(this.right),
          newMiddle
        );
      }
    }
    return this;
  }
  structure() {
    return `<LeafTree len:${this.length}
 l:${this.left.structure()}
 m: ${this.middle && this.middle.structure()}
 r:${this.right.structure()}
>`;
  }
};

// src/custom/builder/tree/tree-builder.mts
var import_base10 = require("@rimbu/base");
var import_common10 = require("@rimbu/common");
var TreeBuilderBase = class {
  get(index, otherwise) {
    const middleIndex = index - this.left.length;
    if (middleIndex < 0) {
      return this.left.get(index, otherwise);
    }
    const rightIndex = middleIndex - (this.middle?.length ?? 0);
    if (rightIndex >= 0) {
      return this.right.get(rightIndex, otherwise);
    }
    if (void 0 === this.middle) {
      import_base10.RimbuError.throwInvalidStateError();
    }
    return this.middle.get(middleIndex, otherwise);
  }
  updateAt(index, update, otherwise) {
    const middleIndex = index - this.left.length;
    if (middleIndex < 0) {
      return this.left.updateAt(index, update, otherwise);
    }
    const rightIndex = middleIndex - (this.middle?.length ?? 0);
    if (rightIndex >= 0) {
      return this.right.updateAt(rightIndex, update, otherwise);
    }
    if (void 0 === this.middle) {
      import_base10.RimbuError.throwInvalidStateError();
    }
    return this.middle.updateAt(middleIndex, update, otherwise);
  }
  prepend(child) {
    this.length += this.getChildLength(child);
    if (this.left.nrChildren < this.context.maxBlockSize) {
      this.left.prepend(child);
      return;
    }
    if (void 0 !== this.middle) {
      const delta = this.middle.modifyFirstChild(
        (firstChild) => {
          if (firstChild.nrChildren < this.context.maxBlockSize) {
            const shiftChild = this.left.dropLast();
            this.left.prepend(child);
            firstChild.prepend(shiftChild);
            return this.getChildLength(shiftChild);
          }
          return;
        }
      );
      if (void 0 !== delta) {
        return;
      }
    } else if (this.right.nrChildren < this.context.maxBlockSize) {
      const shiftChild = this.left.dropLast();
      this.left.prepend(child);
      this.right.prepend(shiftChild);
      return;
    }
    this.left.prepend(child);
    const toMiddle = this.left.splitRight(1);
    this.prependMiddle(toMiddle);
  }
  append(child) {
    this.length += this.getChildLength(child);
    if (this.right.nrChildren < this.context.maxBlockSize) {
      this.right.append(child);
      return;
    }
    if (void 0 !== this.middle) {
      const delta = this.middle.modifyLastChild(
        (lastChild) => {
          if (lastChild.nrChildren < this.context.maxBlockSize) {
            const shiftChild = this.right.dropFirst();
            this.right.append(child);
            lastChild.append(shiftChild);
            return this.getChildLength(shiftChild);
          }
          return;
        }
      );
      if (void 0 !== delta) {
        return;
      }
    } else if (this.left.nrChildren < this.context.maxBlockSize) {
      const shiftChild = this.right.dropFirst();
      this.right.append(child);
      this.left.append(shiftChild);
      return;
    }
    this.right.append(child);
    const newRight = this.right.splitRight(this.context.maxBlockSize);
    this.appendMiddle(this.right);
    this.right = newRight;
  }
  remove(index) {
    this.length--;
    const middleIndex = index - this.left.length;
    if (middleIndex < 0) {
      const oldValue2 = this.left.remove(index);
      if (this.left.nrChildren >= this.context.minBlockSize) {
        return oldValue2;
      }
      if (void 0 !== this.middle) {
        const delta = this.middle.modifyFirstChild(
          (firstChild) => {
            if (firstChild.nrChildren > this.context.minBlockSize) {
              const shiftChild = firstChild.dropFirst();
              this.left.append(shiftChild);
              return -this.getChildLength(shiftChild);
            }
            return;
          }
        );
        if (void 0 !== delta) {
          return oldValue2;
        }
        const middleFirst = this.middle.dropFirst();
        this.middle = this.middle.normalized();
        this.left.concat(middleFirst);
        return oldValue2;
      } else if (this.right.nrChildren > this.context.minBlockSize) {
        const shiftChild = this.right.dropFirst();
        this.left.append(shiftChild);
        return oldValue2;
      }
      import_base10.RimbuError.throwInvalidStateError();
    }
    const rightIndex = middleIndex - (this.middle?.length ?? 0);
    if (rightIndex >= 0) {
      const oldValue2 = this.right.remove(rightIndex);
      if (this.right.nrChildren >= this.context.minBlockSize) {
        return oldValue2;
      }
      if (void 0 !== this.middle) {
        const delta = this.middle.modifyLastChild(
          (lastChild) => {
            if (lastChild.nrChildren > this.context.minBlockSize) {
              const shiftChild = lastChild.dropLast();
              this.right.prepend(shiftChild);
              return -this.getChildLength(shiftChild);
            }
            return;
          }
        );
        if (void 0 !== delta) {
          return oldValue2;
        }
        const middleLast = this.middle.dropLast();
        this.middle = this.middle.normalized();
        middleLast.concat(this.right);
        this.right = middleLast;
        return oldValue2;
      } else if (this.left.nrChildren > this.context.minBlockSize) {
        const shiftChild = this.left.dropLast();
        this.right.prepend(shiftChild);
        return oldValue2;
      }
      import_base10.RimbuError.throwInvalidStateError();
    }
    if (void 0 === this.middle) {
      import_base10.RimbuError.throwInvalidStateError();
    }
    const oldValue = this.middle.remove(middleIndex);
    this.middle = this.middle.normalized();
    return oldValue;
  }
  insert(index, value) {
    this.length++;
    const middleIndex = index - this.left.length;
    if (middleIndex <= 0) {
      this.left.insert(index, value);
      if (this.left.nrChildren <= this.context.maxBlockSize) {
        return;
      }
      if (void 0 !== this.middle) {
        const delta = this.middle.modifyFirstChild(
          (firstChild) => {
            if (firstChild.nrChildren < this.context.maxBlockSize) {
              const shiftChild = this.left.dropLast();
              firstChild.prepend(shiftChild);
              return this.getChildLength(shiftChild);
            }
            return;
          }
        );
        if (void 0 !== delta) {
          return;
        }
      } else if (this.right.nrChildren < this.context.maxBlockSize) {
        const shiftChild = this.left.dropLast();
        this.right.prepend(shiftChild);
        return;
      }
      const toMiddle = this.left.splitRight();
      this.prependMiddle(toMiddle);
      return;
    }
    const rightIndex = middleIndex - (this.middle?.length ?? 0);
    if (void 0 === this.middle || rightIndex >= 0) {
      this.right.insert(rightIndex, value);
      if (this.right.nrChildren <= this.context.maxBlockSize) {
        return;
      }
      if (void 0 !== this.middle) {
        const delta = this.middle.modifyLastChild(
          (lastChild) => {
            if (lastChild.nrChildren < this.context.maxBlockSize) {
              const shiftChild = this.right.dropFirst();
              lastChild.append(shiftChild);
              return this.getChildLength(shiftChild);
            }
            return;
          }
        );
        if (void 0 !== delta) {
          return;
        }
      } else if (this.left.nrChildren < this.context.maxBlockSize) {
        const shiftChild = this.right.dropFirst();
        this.left.append(shiftChild);
        return;
      }
      const newRight = this.right.splitRight();
      this.appendMiddle(this.right);
      this.right = newRight;
      return;
    }
    this.middle.insert(middleIndex, value);
    this.middle = this.middle.normalized();
  }
  prependMiddle(child) {
    if (void 0 === this.middle) {
      this.middle = this.context.nonLeafBlockBuilder(
        this.level + 1,
        [child],
        child.length
      );
      return;
    }
    if (child.nrChildren >= this.context.minBlockSize) {
      this.middle.prepend(child);
      this.middle = this.middle.normalized();
      return;
    }
    const delta = this.middle.modifyFirstChild((firstMiddleChild2) => {
      if (child.nrChildren + firstMiddleChild2.nrChildren <= this.context.maxBlockSize) {
        firstMiddleChild2.concat(child, true);
        return child.length;
      }
      return;
    });
    if (void 0 !== delta) {
      return;
    }
    const firstMiddleChild = this.middle.dropFirst();
    child.concat(firstMiddleChild);
    const newSecondChild = child.splitRight();
    this.middle.prepend(newSecondChild);
    this.middle.prepend(child);
    this.middle = this.middle.normalized();
  }
  appendMiddle(child) {
    if (void 0 === this.middle) {
      this.middle = this.context.nonLeafBlockBuilder(
        this.level + 1,
        [child],
        child.length
      );
      return;
    }
    if (child.nrChildren >= this.context.minBlockSize) {
      this.middle.append(child);
      this.middle = this.middle.normalized();
      return;
    }
    const delta = this.middle.modifyLastChild((lastMiddleChild2) => {
      if (child.nrChildren + lastMiddleChild2.nrChildren <= this.context.maxBlockSize) {
        lastMiddleChild2.concat(child);
        return child.length;
      }
      return;
    });
    if (void 0 !== delta) {
      return;
    }
    const lastMiddleChild = this.middle.last();
    lastMiddleChild.concat(child);
    const newLast = lastMiddleChild.splitRight();
    this.middle.append(newLast);
    this.middle = this.middle.normalized();
  }
  dropFirst() {
    const first = this.left.dropFirst();
    this.length -= this.getChildLength(first);
    if (this.left.nrChildren >= this.context.minBlockSize) {
      return first;
    }
    if (void 0 !== this.middle) {
      const firstMiddle = this.middle.first();
      if (this.left.nrChildren + firstMiddle.nrChildren <= this.context.maxBlockSize) {
        this.middle.dropFirst();
        this.middle = this.middle.normalized();
        this.left.concat(firstMiddle);
      }
      return first;
    }
    if (this.left.nrChildren + this.right.nrChildren > this.context.maxBlockSize) {
      const shiftChild = this.right.dropFirst();
      this.left.append(shiftChild);
    }
    return first;
  }
  dropLast() {
    const last = this.right.dropLast();
    this.length -= this.getChildLength(last);
    if (this.right.nrChildren >= this.context.minBlockSize) {
      return last;
    }
    if (void 0 !== this.middle) {
      const lastMiddle = this.middle.last();
      if (lastMiddle.nrChildren + this.right.nrChildren <= this.context.maxBlockSize) {
        this.middle.dropLast();
        this.middle = this.middle.normalized();
        this.right.concat(lastMiddle, true);
      }
      return last;
    }
    if (this.left.nrChildren + this.right.nrChildren > this.context.maxBlockSize) {
      const shiftChild = this.left.dropLast();
      this.right.prepend(shiftChild);
    }
    return last;
  }
  forEach(f, state = (0, import_common10.TraverseState)()) {
    if (state.halted)
      return;
    this.left.forEach(f, state);
    if (state.halted)
      return;
    if (void 0 !== this.middle) {
      this.middle.forEach(f, state);
      if (state.halted)
        return;
    }
    this.right.forEach(f, state);
  }
};

// src/custom/builder/leaf/tree-builder.mts
var LeafTreeBuilder = class extends TreeBuilderBase {
  constructor(context, source, _left, _right, _middle, length = source?.length ?? 0) {
    super();
    this.context = context;
    this.source = source;
    this._left = _left;
    this._right = _right;
    this._middle = _middle;
    this.length = length;
  }
  prepareMutate() {
    if (void 0 !== this.source) {
      this._left = this.context.leafBlockBuilderSource(this.source.left);
      this._right = this.context.leafBlockBuilderSource(this.source.right);
      this._middle = this.source.middle?.createNonLeafBuilder?.() ?? void 0;
      this.source = void 0;
    }
  }
  get level() {
    return 0;
  }
  get left() {
    this.prepareMutate();
    return this._left;
  }
  set left(value) {
    this.prepareMutate();
    this._left = value;
  }
  get right() {
    this.prepareMutate();
    return this._right;
  }
  set right(value) {
    this.prepareMutate();
    this._right = value;
  }
  get middle() {
    this.prepareMutate();
    return this._middle;
  }
  set middle(value) {
    this.prepareMutate();
    this._middle = value;
  }
  getChildLength() {
    return 1;
  }
  appendChildren(children, from) {
    if (children.length === 0 || from >= children.length)
      return;
    if (this.right.nrChildren < this.context.maxBlockSize) {
      const items = children.slice(
        from,
        from + this.context.maxBlockSize - this.right.nrChildren
      );
      this.right.children = this.right.children.concat(items);
      this.length += items.length;
      this.appendChildren(children, from + items.length);
      return;
    }
    const block = children.slice(from, from + this.context.maxBlockSize);
    this.appendMiddle(this.right);
    this.right = this.context.leafBlockBuilder(block);
    this.length += block.length;
    this.appendChildren(children, from + block.length);
  }
  normalized() {
    if (this.length <= this.context.maxBlockSize) {
      this.left.concat(this.right);
      return this.left;
    }
    if (void 0 !== this.middle) {
      if (this.middle.length + this.left.length <= this.context.maxBlockSize) {
        this.left.concat(this.middle.first());
        this.middle = void 0;
      } else if (this.middle.length + this.right.length <= this.context.maxBlockSize) {
        const newRight = this.middle.last();
        newRight.concat(this.right);
        this.right = newRight;
        this.middle = void 0;
      }
    }
    return this;
  }
  get(index, otherwise) {
    if (void 0 !== this.source) {
      return this.source.get(index, otherwise);
    }
    return super.get(index, otherwise);
  }
  build() {
    if (void 0 !== this.source) {
      return this.source;
    }
    return this.context.leafTree(
      this.left.build(),
      this.right.build(),
      this.middle?.build?.() ?? null
    );
  }
  buildMap(f) {
    if (void 0 !== this.source) {
      return this.source.map(f);
    }
    return this.context.leafTree(
      this.left.buildMap(f),
      this.right.buildMap(f),
      this.middle?.buildMap?.(f) ?? null
    );
  }
};

// src/custom/builder/nonleaf/tree-builder.mts
var NonLeafTreeBuilder = class extends TreeBuilderBase {
  constructor(context, level, source, _left, _right, _middle, length = source?.length ?? 0) {
    super();
    this.context = context;
    this.level = level;
    this.source = source;
    this._left = _left;
    this._right = _right;
    this._middle = _middle;
    this.length = length;
  }
  prepareMutate() {
    if (void 0 !== this.source) {
      this._left = this.source.left.createBlockBuilder();
      this._right = this.source.right.createBlockBuilder();
      this._middle = null === this.source.middle ? void 0 : this.source.middle.createNonLeafBuilder();
      this.source = void 0;
    }
  }
  get left() {
    this.prepareMutate();
    return this._left;
  }
  set left(value) {
    this.prepareMutate();
    this._left = value;
  }
  get right() {
    this.prepareMutate();
    return this._right;
  }
  set right(value) {
    this.prepareMutate();
    this._right = value;
  }
  get middle() {
    this.prepareMutate();
    return this._middle;
  }
  set middle(value) {
    this.prepareMutate();
    this._middle = value;
  }
  getChildLength(child) {
    return child.length;
  }
  modifyFirstChild(f) {
    const delta = this.left.modifyFirstChild(f);
    if (void 0 !== delta) {
      this.length += delta;
    }
    return delta;
  }
  modifyLastChild(f) {
    const delta = this.right.modifyLastChild(f);
    if (void 0 !== delta) {
      this.length += delta;
    }
    return delta;
  }
  normalized() {
    if (void 0 !== this.middle) {
      return this;
    }
    if (this.left.nrChildren + this.right.nrChildren <= this.context.maxBlockSize) {
      this.left.concat(this.right);
      return this.left;
    }
    return this;
  }
  first() {
    return this.left.first();
  }
  last() {
    return this.right.last();
  }
  get(index, otherwise) {
    if (void 0 !== this.source) {
      return this.source.get(index);
    }
    return super.get(index, otherwise);
  }
  build() {
    if (void 0 !== this.source) {
      return this.source;
    }
    return this.context.nonLeafTree(
      this.left.build(),
      this.right.build(),
      this.middle?.build?.() ?? null,
      this.level
    );
  }
  buildMap(f) {
    if (void 0 !== this.source) {
      return this.source.map(f);
    }
    return this.context.nonLeafTree(
      this.left.buildMap(f),
      this.right.buildMap(f),
      this.middle?.buildMap?.(f) ?? null,
      this.level
    );
  }
};

// src/custom/context.mts
var import_base11 = require("@rimbu/base");
var import_common11 = require("@rimbu/common");
var import_stream6 = require("@rimbu/stream");
var import_custom2 = require("@rimbu/stream/custom");
var ListContext = class {
  constructor(blockSizeBits) {
    this.blockSizeBits = blockSizeBits;
    // prettier-ignore
    this.builder = () => {
      return new GenBuilder(this);
    };
    this._empty = createEmptyList(this);
    // prettier-ignore
    this.empty = () => {
      return this._empty;
    };
    // prettier-ignore
    this.of = (...values) => {
      if (values.length <= this.maxBlockSize) {
        return this.leafBlock(values);
      }
      return this.from(values);
    };
    // prettier-ignore
    this.from = (...sources) => {
      if (sources.length === 1) {
        const source = sources[0];
        if (source.context === this)
          return source;
      }
      let result = null;
      let i = -1;
      const length = sources.length;
      while (++i < length) {
        const source = sources[i];
        if (!(0, import_custom2.isEmptyStreamSourceInstance)(source)) {
          if (source.context === this) {
            if (null === result)
              result = source;
            else
              result = result.concat(source);
          } else {
            const builder = this.builder();
            if (Array.isArray(source))
              builder.appendArray(source);
            else
              builder.appendAll(source);
            if (!builder.isEmpty) {
              const build = builder.build();
              if (null === result)
                result = build;
              else
                result = result.concat(build);
            }
          }
        }
      }
      if (null === result)
        return this.empty();
      return result;
    };
    this.fromString = (...sources) => {
      return this.from(...sources);
    };
    // prettier-ignore
    this.reducer = (source) => {
      return import_common11.Reducer.create(
        () => void 0 === source ? this.builder() : this.from(source).toBuilder(),
        (builder, value) => {
          builder.append(value);
          return builder;
        },
        (builder) => builder.build()
      );
    };
    this.flatten = (source) => this.from(source).flatMap((s) => s);
    this.unzip = (source, length) => {
      const streams = import_stream6.Stream.unzip(source, length);
      return import_stream6.Stream.from(streams).mapPure(this.from);
    };
    if (blockSizeBits < 2) {
      import_base11.RimbuError.throwInvalidUsageError(
        "List: blockSizeBits should be at least 2"
      );
    }
    this.maxBlockSize = 1 << blockSizeBits;
    this.minBlockSize = this.maxBlockSize >>> 1;
  }
  get typeTag() {
    return "List";
  }
  get _types() {
    return void 0;
  }
  createBuilder(source) {
    if (void 0 === source || source.isEmpty)
      return new GenBuilder(this);
    const context = source.context;
    if (context.isLeafBlock(source)) {
      const builder = this.leafBlockBuilderSource(source);
      return new GenBuilder(this, builder);
    }
    if (context.isLeafTree(source)) {
      const builder = this.leafTreeBuilderSource(source);
      return new GenBuilder(this, builder);
    }
    import_base11.RimbuError.throwInvalidStateError();
  }
  leafBlock(children) {
    return new LeafBlock(this, children);
  }
  reversedLeaf(children) {
    return new ReversedLeafBlock(this, children);
  }
  leafTree(left, right, middle) {
    return new LeafTree(this, left, right, middle);
  }
  nonLeafBlock(length, children, level) {
    return new NonLeafBlock(this, length, children, level);
  }
  nonLeafTree(left, right, middle, level) {
    return new NonLeafTree(this, left, right, middle, level);
  }
  leafBlockBuilderSource(source) {
    return new LeafBlockBuilder(this, source);
  }
  leafBlockBuilder(children) {
    return new LeafBlockBuilder(this, void 0, children);
  }
  leafTreeBuilderSource(source) {
    return new LeafTreeBuilder(this, source);
  }
  leafTreeBuilder(left, right, middle, length) {
    return new LeafTreeBuilder(this, void 0, left, right, middle, length);
  }
  nonLeafBlockBuilderSource(source) {
    return new NonLeafBlockBuilder(this, source.level, source);
  }
  nonLeafBlockBuilder(level, children, length) {
    return new NonLeafBlockBuilder(this, level, void 0, children, length);
  }
  nonLeafTreeBuilderSource(source) {
    return new NonLeafTreeBuilder(this, source.level, source);
  }
  nonLeafTreeBuilder(level, left, right, middle, length) {
    return new NonLeafTreeBuilder(
      this,
      level,
      void 0,
      left,
      right,
      middle,
      length
    );
  }
  isLeafBlock(obj) {
    return obj instanceof LeafBlock;
  }
  isReversedLeafBlock(obj) {
    return obj instanceof ReversedLeafBlock;
  }
  isNonLeafBlock(obj) {
    return obj instanceof NonLeafBlock;
  }
  isLeafTree(obj) {
    return obj instanceof LeafTree;
  }
  isNonLeafTree(obj) {
    return obj instanceof NonLeafTree;
  }
  isLeafBlockBuilder(obj) {
    return obj instanceof LeafBlockBuilder;
  }
  isLeafTreeBuilder(obj) {
    return obj instanceof LeafTreeBuilder;
  }
  isNonLeafBlockBuilder(obj) {
    return obj instanceof NonLeafBlockBuilder;
  }
  createCacheMap() {
    return new CacheMap();
  }
};
function createListContext(options) {
  return Object.freeze(new ListContext(options?.blockSizeBits ?? 5));
}

// src/main/interface.mts
var _defaultContext = createListContext();
var List = Object.freeze({
  createContext: createListContext,
  defaultContext() {
    return _defaultContext;
  },
  ..._defaultContext
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  List
});
