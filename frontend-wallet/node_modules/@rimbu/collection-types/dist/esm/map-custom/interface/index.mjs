import { Reducer } from '@rimbu/common';
import { Stream, } from '@rimbu/stream';
import { isEmptyStreamSourceInstance } from '@rimbu/stream/custom';
export var RMapBase;
(function (RMapBase) {
    class ContextBase {
        constructor() {
            this.empty = () => {
                return this._empty;
            };
            this.from = (...sources) => {
                let builder = this.builder();
                let i = -1;
                const length = sources.length;
                while (++i < length) {
                    const source = sources[i];
                    if (isEmptyStreamSourceInstance(source))
                        continue;
                    if (builder.isEmpty &&
                        this.isNonEmptyInstance(source) &&
                        source.context === this) {
                        if (i === length - 1)
                            return source;
                        builder = source.toBuilder();
                        continue;
                    }
                    builder.addEntries(source);
                }
                return builder.build();
            };
            this.of = (...values) => {
                return this.from(values);
            };
            this.reducer = (source) => {
                return Reducer.create(() => undefined === source
                    ? this.builder()
                    : this.from(source).toBuilder(), (builder, entry) => {
                    builder.addEntry(entry);
                    return builder;
                }, (builder) => builder.build());
            };
            this.mergeAllWith = (...sources) => {
                return (fillValue, mergeFun) => {
                    const builder = this.builder();
                    let i = -1;
                    const length = sources.length;
                    while (++i < sources.length) {
                        let entry;
                        const iter = Stream.from(sources[i])[Symbol.iterator]();
                        while (undefined !== (entry = iter.fastNext())) {
                            const key = entry[0];
                            const value = entry[1];
                            const index = i;
                            builder.modifyAt(key, {
                                ifNew() {
                                    const row = Array(length).fill(fillValue);
                                    row[index] = value;
                                    return row;
                                },
                                ifExists(row) {
                                    row[index] = value;
                                    return row;
                                },
                            });
                        }
                    }
                    return builder.buildMapValues((row, key) => mergeFun(key, ...row));
                };
            };
            this.mergeAll = (fillValue, ...sources) => {
                return this.mergeAllWith(...sources)(fillValue, (key, ...values) => values);
            };
            this.mergeWith = (...sources) => {
                // prettier-ignore
                return (mergeFun) => {
                    if (Stream.from(sources).some(isEmptyStreamSourceInstance)) {
                        return this.empty();
                    }
                    const builder = this.builder();
                    let i = -1;
                    const length = sources.length;
                    while (++i < sources.length) {
                        let entry;
                        const iter = Stream.from(sources[i])[Symbol.iterator]();
                        while (undefined !== (entry = iter.fastNext())) {
                            const key = entry[0];
                            const value = entry[1];
                            const index = i;
                            builder.modifyAt(key, {
                                ifNew(nothing) {
                                    if (index > 0)
                                        return nothing;
                                    const row = [value];
                                    return row;
                                },
                                ifExists(row, remove) {
                                    if (row.length !== index)
                                        return remove;
                                    row.push(value);
                                    return row;
                                },
                            });
                        }
                    }
                    // remove all rows that are not full
                    const firstSource = sources[0];
                    let entry;
                    const iter = Stream.from(firstSource)[Symbol.iterator]();
                    while (undefined !== (entry = iter.fastNext())) {
                        const key = entry[0];
                        builder.modifyAt(key, {
                            ifExists(row, remove) {
                                if (row.length !== length)
                                    return remove;
                                return row;
                            },
                        });
                    }
                    return builder.buildMapValues((row, key) => mergeFun(key, ...row));
                };
            };
            this.merge = (...sources) => {
                return this.mergeWith(...sources)((key, ...values) => values);
            };
        }
        get _types() {
            return undefined;
        }
    }
    RMapBase.ContextBase = ContextBase;
})(RMapBase || (RMapBase = {}));
//# sourceMappingURL=index.mjs.map