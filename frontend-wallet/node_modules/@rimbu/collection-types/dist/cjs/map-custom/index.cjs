"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/map-custom/index.mts
var map_custom_exports = {};
__export(map_custom_exports, {
  EmptyBase: () => EmptyBase,
  NonEmptyBase: () => NonEmptyBase,
  RMapBase: () => RMapBase
});
module.exports = __toCommonJS(map_custom_exports);

// src/common/base.mts
var import_base = require("@rimbu/base");
var import_stream = require("@rimbu/stream");
var EmptyBase = class {
  [Symbol.iterator]() {
    return import_stream.Stream.empty()[Symbol.iterator]();
  }
  assumeNonEmpty() {
    import_base.RimbuError.throwEmptyCollectionAssumedNonEmptyError();
  }
  stream() {
    return import_stream.Stream.empty();
  }
  get size() {
    return 0;
  }
  get length() {
    return 0;
  }
  get isEmpty() {
    return true;
  }
  nonEmpty() {
    return false;
  }
  forEach() {
  }
  filter() {
    return this;
  }
  remove() {
    return this;
  }
  toArray() {
    return [];
  }
};
var NonEmptyBase = class {
  [Symbol.iterator]() {
    return this.stream()[Symbol.iterator]();
  }
  get isEmpty() {
    return false;
  }
  nonEmpty() {
    return true;
  }
  assumeNonEmpty() {
    return this;
  }
  asNormal() {
    return this;
  }
};

// src/map-custom/interface/index.mts
var import_common = require("@rimbu/common");
var import_stream2 = require("@rimbu/stream");
var import_custom = require("@rimbu/stream/custom");
var RMapBase;
((RMapBase2) => {
  class ContextBase {
    constructor() {
      this.empty = () => {
        return this._empty;
      };
      this.from = (...sources) => {
        let builder = this.builder();
        let i = -1;
        const length = sources.length;
        while (++i < length) {
          const source = sources[i];
          if ((0, import_custom.isEmptyStreamSourceInstance)(source))
            continue;
          if (builder.isEmpty && this.isNonEmptyInstance(source) && source.context === this) {
            if (i === length - 1)
              return source;
            builder = source.toBuilder();
            continue;
          }
          builder.addEntries(source);
        }
        return builder.build();
      };
      this.of = (...values) => {
        return this.from(values);
      };
      this.reducer = (source) => {
        return import_common.Reducer.create(
          () => void 0 === source ? this.builder() : this.from(source).toBuilder(),
          (builder, entry) => {
            builder.addEntry(entry);
            return builder;
          },
          (builder) => builder.build()
        );
      };
      this.mergeAllWith = (...sources) => {
        return (fillValue, mergeFun) => {
          const builder = this.builder();
          let i = -1;
          const length = sources.length;
          while (++i < sources.length) {
            let entry;
            const iter = import_stream2.Stream.from(sources[i])[Symbol.iterator]();
            while (void 0 !== (entry = iter.fastNext())) {
              const key = entry[0];
              const value = entry[1];
              const index = i;
              builder.modifyAt(key, {
                ifNew() {
                  const row = Array(length).fill(fillValue);
                  row[index] = value;
                  return row;
                },
                ifExists(row) {
                  row[index] = value;
                  return row;
                }
              });
            }
          }
          return builder.buildMapValues(
            (row, key) => mergeFun(key, ...row)
          );
        };
      };
      this.mergeAll = (fillValue, ...sources) => {
        return this.mergeAllWith(...sources)(
          fillValue,
          (key, ...values) => values
        );
      };
      this.mergeWith = (...sources) => {
        return (mergeFun) => {
          if (import_stream2.Stream.from(sources).some(import_custom.isEmptyStreamSourceInstance)) {
            return this.empty();
          }
          const builder = this.builder();
          let i = -1;
          const length = sources.length;
          while (++i < sources.length) {
            let entry2;
            const iter2 = import_stream2.Stream.from(sources[i])[Symbol.iterator]();
            while (void 0 !== (entry2 = iter2.fastNext())) {
              const key = entry2[0];
              const value = entry2[1];
              const index = i;
              builder.modifyAt(key, {
                ifNew(nothing) {
                  if (index > 0)
                    return nothing;
                  const row = [value];
                  return row;
                },
                ifExists(row, remove) {
                  if (row.length !== index)
                    return remove;
                  row.push(value);
                  return row;
                }
              });
            }
          }
          const firstSource = sources[0];
          let entry;
          const iter = import_stream2.Stream.from(firstSource)[Symbol.iterator]();
          while (void 0 !== (entry = iter.fastNext())) {
            const key = entry[0];
            builder.modifyAt(key, {
              ifExists(row, remove) {
                if (row.length !== length)
                  return remove;
                return row;
              }
            });
          }
          return builder.buildMapValues(
            (row, key) => mergeFun(key, ...row)
          );
        };
      };
      this.merge = (...sources) => {
        return this.mergeWith(...sources)(
          (key, ...values) => values
        );
      };
    }
    get _types() {
      return void 0;
    }
  }
  RMapBase2.ContextBase = ContextBase;
})(RMapBase || (RMapBase = {}));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EmptyBase,
  NonEmptyBase,
  RMapBase
});
