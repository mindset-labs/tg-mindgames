import { SigningStargateClientOptions, DeliverTxResponse, StdFee, Account, SignerData } from '@cosmjs/stargate';
export { GasPrice } from '@cosmjs/stargate';
import { SignDoc, TxRaw } from 'cosmjs-types/cosmos/tx/v1beta1/tx';
import { AccountData, DirectSignResponse, EncodeObject, OfflineDirectSigner } from '@cosmjs/proto-signing';
import { Tendermint37Client } from '@cosmjs/tendermint-rpc';
import Long from 'long';
import _m0 from 'protobufjs/minimal';
import { SigningCosmWasmClient } from '@cosmjs/cosmwasm-stargate';
import { StdSignature } from '@cosmjs/amino';

/**
 * Coin defines a token with a denomination and an amount.
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 */
interface Coin {
    denom: string;
    amount: string;
}
declare const Coin: {
    encode(message: Coin, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Coin;
    fromJSON(object: any): Coin;
    toJSON(message: Coin): unknown;
    create<I extends {
        denom?: string | undefined;
        amount?: string | undefined;
    } & {
        denom?: string | undefined;
        amount?: string | undefined;
    } & { [K in Exclude<keyof I, keyof Coin>]: never; }>(base?: I | undefined): Coin;
    fromPartial<I_1 extends {
        denom?: string | undefined;
        amount?: string | undefined;
    } & {
        denom?: string | undefined;
        amount?: string | undefined;
    } & { [K_1 in Exclude<keyof I_1, keyof Coin>]: never; }>(object: I_1): Coin;
};

interface MsgRegisterAccount {
    /** Sender is the actor who signs the message */
    sender: string;
    /** CodeID indicates which wasm binary code is to be used for this contract */
    codeId: Long;
    /** Msg is the JSON-encoded instantiate message for the contract */
    msg: Uint8Array;
    /** Funds are coins to be deposited to the contract on instantiattion */
    funds: Coin[];
    /**
     * Salt is an arbinary value to be used in deriving the account address.
     * Max 64 bytes.
     */
    salt: Uint8Array;
}
declare const MsgRegisterAccount: {
    encode(message: MsgRegisterAccount, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgRegisterAccount;
    fromJSON(object: any): MsgRegisterAccount;
    toJSON(message: MsgRegisterAccount): unknown;
    create<I extends {
        sender?: string | undefined;
        codeId?: string | number | Long | undefined;
        msg?: Uint8Array | undefined;
        funds?: {
            denom?: string | undefined;
            amount?: string | undefined;
        }[] | undefined;
        salt?: Uint8Array | undefined;
    } & {
        sender?: string | undefined;
        codeId?: string | number | (Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long) => Long;
            and: (other: string | number | Long) => Long;
            compare: (other: string | number | Long) => number;
            comp: (other: string | number | Long) => number;
            divide: (divisor: string | number | Long) => Long;
            div: (divisor: string | number | Long) => Long;
            equals: (other: string | number | Long) => boolean;
            eq: (other: string | number | Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long) => boolean;
            gt: (other: string | number | Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long) => boolean;
            gte: (other: string | number | Long) => boolean;
            ge: (other: string | number | Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            eqz: () => boolean;
            lessThan: (other: string | number | Long) => boolean;
            lt: (other: string | number | Long) => boolean;
            lessThanOrEqual: (other: string | number | Long) => boolean;
            lte: (other: string | number | Long) => boolean;
            le: (other: string | number | Long) => boolean;
            modulo: (other: string | number | Long) => Long;
            mod: (other: string | number | Long) => Long;
            rem: (other: string | number | Long) => Long;
            multiply: (multiplier: string | number | Long) => Long;
            mul: (multiplier: string | number | Long) => Long;
            negate: () => Long;
            neg: () => Long;
            not: () => Long;
            countLeadingZeros: () => number;
            clz: () => number;
            countTrailingZeros: () => number;
            ctz: () => number;
            notEquals: (other: string | number | Long) => boolean;
            neq: (other: string | number | Long) => boolean;
            ne: (other: string | number | Long) => boolean;
            or: (other: string | number | Long) => Long;
            shiftLeft: (numBits: number | Long) => Long;
            shl: (numBits: number | Long) => Long;
            shiftRight: (numBits: number | Long) => Long;
            shr: (numBits: number | Long) => Long;
            shiftRightUnsigned: (numBits: number | Long) => Long;
            shru: (numBits: number | Long) => Long;
            shr_u: (numBits: number | Long) => Long;
            rotateLeft: (numBits: number | Long) => Long;
            rotl: (numBits: number | Long) => Long;
            rotateRight: (numBits: number | Long) => Long;
            rotr: (numBits: number | Long) => Long;
            subtract: (subtrahend: string | number | Long) => Long;
            sub: (subtrahend: string | number | Long) => Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long;
            xor: (other: string | number | Long) => Long;
        } & { [K in Exclude<keyof I["codeId"], keyof Long>]: never; }) | undefined;
        msg?: Uint8Array | undefined;
        funds?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_1 in Exclude<keyof I["funds"][number], keyof Coin>]: never; })[] & { [K_2 in Exclude<keyof I["funds"], keyof {
            denom?: string | undefined;
            amount?: string | undefined;
        }[]>]: never; }) | undefined;
        salt?: Uint8Array | undefined;
    } & { [K_3 in Exclude<keyof I, keyof MsgRegisterAccount>]: never; }>(base?: I | undefined): MsgRegisterAccount;
    fromPartial<I_1 extends {
        sender?: string | undefined;
        codeId?: string | number | Long | undefined;
        msg?: Uint8Array | undefined;
        funds?: {
            denom?: string | undefined;
            amount?: string | undefined;
        }[] | undefined;
        salt?: Uint8Array | undefined;
    } & {
        sender?: string | undefined;
        codeId?: string | number | (Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long) => Long;
            and: (other: string | number | Long) => Long;
            compare: (other: string | number | Long) => number;
            comp: (other: string | number | Long) => number;
            divide: (divisor: string | number | Long) => Long;
            div: (divisor: string | number | Long) => Long;
            equals: (other: string | number | Long) => boolean;
            eq: (other: string | number | Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long) => boolean;
            gt: (other: string | number | Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long) => boolean;
            gte: (other: string | number | Long) => boolean;
            ge: (other: string | number | Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            eqz: () => boolean;
            lessThan: (other: string | number | Long) => boolean;
            lt: (other: string | number | Long) => boolean;
            lessThanOrEqual: (other: string | number | Long) => boolean;
            lte: (other: string | number | Long) => boolean;
            le: (other: string | number | Long) => boolean;
            modulo: (other: string | number | Long) => Long;
            mod: (other: string | number | Long) => Long;
            rem: (other: string | number | Long) => Long;
            multiply: (multiplier: string | number | Long) => Long;
            mul: (multiplier: string | number | Long) => Long;
            negate: () => Long;
            neg: () => Long;
            not: () => Long;
            countLeadingZeros: () => number;
            clz: () => number;
            countTrailingZeros: () => number;
            ctz: () => number;
            notEquals: (other: string | number | Long) => boolean;
            neq: (other: string | number | Long) => boolean;
            ne: (other: string | number | Long) => boolean;
            or: (other: string | number | Long) => Long;
            shiftLeft: (numBits: number | Long) => Long;
            shl: (numBits: number | Long) => Long;
            shiftRight: (numBits: number | Long) => Long;
            shr: (numBits: number | Long) => Long;
            shiftRightUnsigned: (numBits: number | Long) => Long;
            shru: (numBits: number | Long) => Long;
            shr_u: (numBits: number | Long) => Long;
            rotateLeft: (numBits: number | Long) => Long;
            rotl: (numBits: number | Long) => Long;
            rotateRight: (numBits: number | Long) => Long;
            rotr: (numBits: number | Long) => Long;
            subtract: (subtrahend: string | number | Long) => Long;
            sub: (subtrahend: string | number | Long) => Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long;
            xor: (other: string | number | Long) => Long;
        } & { [K_4 in Exclude<keyof I_1["codeId"], keyof Long>]: never; }) | undefined;
        msg?: Uint8Array | undefined;
        funds?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_5 in Exclude<keyof I_1["funds"][number], keyof Coin>]: never; })[] & { [K_6 in Exclude<keyof I_1["funds"], keyof {
            denom?: string | undefined;
            amount?: string | undefined;
        }[]>]: never; }) | undefined;
        salt?: Uint8Array | undefined;
    } & { [K_7 in Exclude<keyof I_1, keyof MsgRegisterAccount>]: never; }>(object: I_1): MsgRegisterAccount;
};

declare enum AAAlgo {
    Secp256K1 = "secp256k1",
    secp256k1 = "Secp256K1",
    Ed25519 = "ed25519",
    ed25519 = "Ed25519",
    Sr25519 = "sr25519",
    sr25519 = "Sr25519",
    jwt = "JWT",
    JWT = "jwt",
    ethWallet = "ethWallet",
    ETHWALLET = "EthWallet"
}
interface AddSecp256K1Authenticator {
    add_auth_method: {
        add_authenticator: {
            Secp256K1: {
                id: number;
                pubkey: string;
                signature: string;
            };
        };
    };
}
interface AddEd25519Authenticator {
    add_auth_method: {
        add_authenticator: {
            Ed25519: {
                id: number;
                pubkey: string;
                signature: string;
            };
        };
    };
}
interface AddEthWalletAuthenticator {
    add_auth_method: {
        add_authenticator: {
            EthWallet: {
                id: number;
                address: string;
                signature: string;
            };
        };
    };
}
interface AddJwtAuthenticator {
    add_auth_method: {
        add_authenticator: {
            Jwt: {
                id: number;
                aud: string;
                sub: string;
                token: string;
            };
        };
    };
}
interface RemoveAuthenticator {
    remove_auth_method: {
        id: number;
    };
}
type AddAuthenticator = AddSecp256K1Authenticator | AddEd25519Authenticator | AddEthWalletAuthenticator | AddJwtAuthenticator;

/**
 * @extends AccountData
 */
interface AAccountData extends AccountData {
    readonly authenticatorId: number;
    readonly accountAddress: string;
    readonly aaalgo?: AAAlgo;
}
declare abstract class AASigner {
    abstractAccount: string | undefined;
    accountAuthenticatorIndex: number | undefined;
    constructor(abstractAccount: string);
    /**
     * This method is to be implemented by every class that implements this interface
     * it will be used by the client to create the transaction AA signature
     * required to verify the transaction on the chain
     * This method should return a DirectSignResponse object but only the signature field is required
     * to be set
     * @param _signerAddress the abstract account address to be used as the signer
     * @param signDoc the sign doc to be signed
     * @returns
     */
    signDirect(_signerAddress: string, signDoc: SignDoc): Promise<DirectSignResponse>;
    /**
     * This method is to be implemented by every class that implements this interface
     * it will be used by the client to get the account data of the current abstract account
     * the pubKey of the account data should be set to an empty Uint8Array since it's not required
     * and to declare it an AA
     * @returns {AAccountData} of length 1
     */
    abstract getAccounts(): Promise<readonly AAccountData[]>;
}
declare class AADefaultSigner extends AASigner {
    constructor(abstractAccount: string);
    getAccounts(): Promise<readonly AAccountData[]>;
}

declare class AAClient extends SigningCosmWasmClient {
    abstractSigner: AASigner;
    static connectWithSigner(endpoint: string, signer: AASigner, options?: SigningStargateClientOptions): Promise<AAClient>;
    protected constructor(tmClient: Tendermint37Client | undefined, signer: AASigner, options: SigningStargateClientOptions);
    /**
     * Creates a MsgRegisterAbstractAccount message and broadcasts it
     * @param msg the message to be sent
     * @returns
     */
    registerAbstractAccount(msg: MsgRegisterAccount): Promise<DeliverTxResponse>;
    /**
     * Simulates a transaction to estimate the gas and calculates the default fee.
     *
     * @param {string} sender - The address of the sender.
     * @param {readonly EncodeObject[]} messages - An array of messages to include in the transaction.
     * @param {string | undefined} memo - An optional memo to include in the transaction.
     * @returns {Promise<StdFee>} - The calculated default fee for the transaction.
     */
    private simulateDefaultFee;
    /**
     * Create and a cosmwasm add authenticator msg to the abstract account
     * @param msg the message to be sent
     * @returns
     */
    addAbstractAccountAuthenticator(msg: AddAuthenticator, memo?: string, fee?: StdFee): Promise<DeliverTxResponse>;
    /**
     * Create a cosmwasm remove authenticator msg to the abstract account
     * @param msg the message to be sent
     * @returns
     */
    removeAbstractAccountAuthenticator(msg: RemoveAuthenticator, memo?: string, fee?: StdFee): Promise<DeliverTxResponse>;
    /**
     * Simulates a transaction and returns the gas used.
     *
     * @param {string} signerAddress - The address of the signer.
     * @param {readonly EncodeObject[]} messages - An array of messages to include in the transaction.
     * @param {string | undefined} memo - An optional memo to include in the transaction.
     * @returns {Promise<number>} - The gas used by the simulated transaction.
     * @throws Will throw an error if the account is not found or if the query client cannot be retrieved.
     */
    simulate(signerAddress: string, messages: readonly EncodeObject[], memo: string | undefined): Promise<number>;
    getAccount(searchAddress: string): Promise<Account | null>;
    /**
     * This method is a replacement of the sign method from SigningStargateClient
     * it uses the signDirect method from the custom signer(AASigner) to create the Abstract Account signature
     * required to verify the transaction on the chain and also builds the authInfoBytes using
     * the Abstract Account pubkey type NilPubKey
     * NB: This method is not compatible with regular signers. Use the sign method from SigningStargateClient
     * @param signerAddress // the abstract account address to be used as the signer
     * @param messages // the messages to be signed
     * @param fee
     * @param memo
     * @param explicitSignerData
     * @returns
     */
    sign(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee, memo: string, explicitSignerData?: SignerData): Promise<TxRaw>;
}

type SignArbitraryFn = (chainId: string, signer: string, data: string | Uint8Array) => Promise<StdSignature>;
/**
 * This class is an implementation of the AASigner interface using the DirectSecp256k1HdWallet
 * or any other signer that implements the AASigner interface
 * This class use would generally be with a wallet since it's method of signing is the same as the
 * DirectSecp256k1HdWallet. The only difference is that it makes sure to replace the signer address
 * with a valid wallet address (as to the abstract account address) before signing the transaction.
 *
 * Note: instance variable abstractAccount must be set before any signing
 * @abstractAccount the abstract account address of the signer
 * @signer the signer to be used to sign the transaction
 * @implements AASigner
 */
declare class AADirectSigner extends AASigner {
    signer: OfflineDirectSigner;
    accountAuthenticatorIndex: number;
    indexerUrl: string;
    signArbFn: SignArbitraryFn;
    constructor(initializedSigner: OfflineDirectSigner, abstractAccount: string, accountAuthenticatorIndex: number, signArbFn: SignArbitraryFn, indexerUrl?: string);
    signDirect(signerAddress: string, signDoc: SignDoc): Promise<DirectSignResponse>;
    getAccounts(): Promise<readonly AAccountData[]>;
}

declare class AbstractAccountJWTSigner extends AASigner {
    sessionToken: string | undefined;
    accountAuthenticatorIndex: number;
    indexerUrl: string;
    apiUrl: string;
    constructor(abstractAccount: string, accountAuthenticatorIndex: number, sessionToken?: string, indexerUrl?: string, apiUrl?: string);
    getAccounts(): Promise<readonly AAccountData[]>;
    signDirect(signerAddress: string, // this is the email of the user
    signDoc: SignDoc): Promise<DirectSignResponse>;
    /**
     * This method allows for signing arbitrary messages
     * It does not compose a SignDoc but simply sets the transaction_hash
     * property of the session claims property to the hash of the passed msg
     * @param signerAddress
     * @param message Arbitrary message to be signed
     * @returns
     */
    signDirectArb(message: string): Promise<{
        signature: string;
    }>;
}

/**
 * This class is an implementation of the AASigner interface using the DirectSecp256k1HdWallet
 * or any other signer that implements the AASigner interface
 * This class use would generally be with a wallet since it's method of signing is the same as the
 * DirectSecp256k1HdWallet. The only difference is that it makes sure to replace the signer address
 * with a valid wallet address (as to the abstract account address) before signing the transaction.
 *
 * Note: instance variable abstractAccount must be set before any signing
 * @abstractAccount the abstract account address of the signer
 * @accountAuthenticatorIndex the index of the abstract account authenticator
 * @personalSign callback to the Ethereum signing function
 * @implements AASigner
 */
declare class AAEthSigner extends AASigner {
    accountAuthenticatorIndex: number;
    indexerUrl: string;
    personalSign: any;
    constructor(abstractAccount: string, accountAuthenticatorIndex: number, personalSign: any, indexerUrl?: string);
    signDirect(signerAddress: string, signDoc: SignDoc): Promise<DirectSignResponse>;
    getAccounts(): Promise<readonly AAccountData[]>;
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *     // or ...
 *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
 *       foo = any.unpack(Foo.getDefaultInstance());
 *     }
 *
 *  Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 *  Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := anypb.New(foo)
 *      if err != nil {
 *        ...
 *      }
 *      ...
 *      foo := &pb.Foo{}
 *      if err := any.UnmarshalTo(foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
 * name "y.z".
 *
 * JSON
 * ====
 * The JSON representation of an `Any` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field `@type` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       "@type": "type.googleapis.com/google.profile.Person",
 *       "firstName": <string>,
 *       "lastName": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * `value` which holds the custom JSON in addition to the `@type`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       "@type": "type.googleapis.com/google.protobuf.Duration",
 *       "value": "1.212s"
 *     }
 */
interface Any {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized
     * protocol buffer message. This string must contain at least
     * one "/" character. The last segment of the URL's path must represent
     * the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form
     * (e.g., leading "." is not accepted).
     *
     * In practice, teams usually precompile into the binary all types that they
     * expect it to use in the context of Any. However, for URLs which use the
     * scheme `http`, `https`, or no scheme, one can optionally set up a type
     * server that maps type URLs to message definitions as follows:
     *
     * * If no scheme is provided, `https` is assumed.
     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
     *   value in binary format, or produce an error.
     * * Applications are allowed to cache lookup results based on the
     *   URL, or have them precompiled into a binary to avoid any
     *   lookup. Therefore, binary compatibility needs to be preserved
     *   on changes to types. (Use versioned type names to manage
     *   breaking changes.)
     *
     * Note: this functionality is not currently available in the official
     * protobuf release, and it is not used for type URLs beginning with
     * type.googleapis.com. As of May 2023, there are no widely used type server
     * implementations and no plans to implement one.
     *
     * Schemes other than `http`, `https` (or the empty scheme) might be
     * used with implementation specific semantics.
     */
    typeUrl: string;
    /** Must be a valid serialized protocol buffer of the above specified type. */
    value: Uint8Array;
}
declare const Any: {
    encode(message: Any, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Any;
    fromJSON(object: any): Any;
    toJSON(message: Any): unknown;
    create<I extends {
        typeUrl?: string | undefined;
        value?: Uint8Array | undefined;
    } & {
        typeUrl?: string | undefined;
        value?: Uint8Array | undefined;
    } & { [K in Exclude<keyof I, keyof Any>]: never; }>(base?: I | undefined): Any;
    fromPartial<I_1 extends {
        typeUrl?: string | undefined;
        value?: Uint8Array | undefined;
    } & {
        typeUrl?: string | undefined;
        value?: Uint8Array | undefined;
    } & { [K_1 in Exclude<keyof I_1, keyof Any>]: never; }>(object: I_1): Any;
};

/**
 * Custom implementation of AccountParser. This is supposed to support the most relevant
 * common Cosmos SDK account types and AbstractAccount account types.
 * @param input encoded account from the chain
 * @returns decoded account
 */
declare function customAccountFromAny(input: Any): Account;

export { AAAlgo, AAClient, AADefaultSigner, AADirectSigner, AAEthSigner, AASigner, AAccountData, AbstractAccountJWTSigner, customAccountFromAny };
