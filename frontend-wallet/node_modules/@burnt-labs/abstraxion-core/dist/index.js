'use strict';

var cosmwasmStargate = require('@cosmjs/cosmwasm-stargate');
var stargate = require('@cosmjs/stargate');
var tx$1 = require('cosmjs-types/cosmos/tx/v1beta1/tx');
var tx = require('cosmjs-types/cosmos/authz/v1beta1/tx');
var tendermintRpc = require('@cosmjs/tendermint-rpc');
var signers = require('@burnt-labs/signers');
var constants = require('@burnt-labs/constants');
var buffer = require('buffer');
var protoSigning = require('@cosmjs/proto-signing');
var amino = require('@cosmjs/amino');
var utils = require('@cosmjs/utils');
var crypto$1 = require('@keplr-wallet/crypto');
var crypto = require('@cosmjs/crypto');
var encoding = require('@cosmjs/encoding');
var cosmos = require('@keplr-wallet/cosmos');
var wallet = require('@cosmjs/proto-signing/build/wallet');

// src/GranteeSignerClient.ts
var GranteeSignerClient = class extends cosmwasmStargate.SigningCosmWasmClient {
  granterAddress;
  _granteeAddress;
  _signer;
  _gasPrice;
  _treasury;
  _defaultGasMultiplier = 1.4;
  // cosmjs 0.32.4 default
  get granteeAddress() {
    return this._granteeAddress;
  }
  async getGranteeAccountData() {
    return this._signer.getAccounts().then((accounts) => {
      for (const account of accounts) {
        if (account.address === this._granteeAddress) {
          return account;
        }
      }
    });
  }
  static async connectWithSigner(endpoint, signer, options) {
    const tmClient = await tendermintRpc.Tendermint37Client.connect(endpoint);
    return GranteeSignerClient.createWithSigner(tmClient, signer, options);
  }
  static async createWithSigner(cometClient, signer, options) {
    return new GranteeSignerClient(cometClient, signer, options);
  }
  constructor(cometClient, signer, {
    granterAddress,
    granteeAddress,
    gasPrice,
    treasuryAddress,
    ...options
  }) {
    super(cometClient, signer, { ...options, gasPrice });
    if (granterAddress === void 0) {
      throw new Error("granterAddress is required");
    }
    this.granterAddress = granterAddress;
    if (granteeAddress === void 0) {
      throw new Error("granteeAddress is required");
    }
    this._granteeAddress = granteeAddress;
    this._gasPrice = gasPrice;
    this._treasury = treasuryAddress;
    this._signer = signer;
  }
  async getAccount(searchAddress) {
    const account = await this.forceGetQueryClient().auth.account(searchAddress);
    if (!account) {
      return null;
    }
    return signers.customAccountFromAny(account);
  }
  async signAndBroadcast(signerAddress, messages, fee, memo = "") {
    if (signerAddress === this.granterAddress) {
      signerAddress = this.granteeAddress;
      messages = [
        {
          typeUrl: "/cosmos.authz.v1beta1.MsgExec",
          value: tx.MsgExec.fromPartial({
            grantee: this.granteeAddress,
            msgs: messages.map((msg) => this.registry.encodeAsAny(msg))
          })
        }
      ];
    }
    let usedFee;
    const granter = this._treasury ? this._treasury : this.granterAddress;
    if (fee == "auto" || typeof fee === "number") {
      if (!this._gasPrice) {
        throw new Error(
          "Gas price must be set in the client options when auto gas is used"
        );
      }
      const gasEstimation = await this.simulate(signerAddress, messages, memo);
      const multiplier = typeof fee == "number" ? fee : this._defaultGasMultiplier;
      const calculatedFee = stargate.calculateFee(
        Math.round(gasEstimation * multiplier),
        this._gasPrice
      );
      usedFee = {
        ...calculatedFee,
        granter
      };
    } else {
      usedFee = { ...fee, granter };
    }
    const txRaw = await this.sign(
      signerAddress,
      messages,
      usedFee,
      memo,
      void 0
    );
    const txBytes = tx$1.TxRaw.encode(txRaw).finish();
    return this.broadcastTx(
      txBytes,
      this.broadcastTimeoutMs,
      this.broadcastPollIntervalMs
    );
  }
  async sign(signerAddress, messages, fee, memo, explicitSignerData) {
    if (signerAddress === this.granterAddress) {
      signerAddress = this.granteeAddress;
      messages = [
        {
          typeUrl: "/cosmos.authz.v1beta1.MsgExec",
          value: tx.MsgExec.fromPartial({
            grantee: signerAddress,
            msgs: messages.map((msg) => this.registry.encodeAsAny(msg))
          })
        }
      ];
    }
    return super.sign(signerAddress, messages, fee, memo, explicitSignerData);
  }
};
var serializationTypeV1 = "directsecp256k1hdwallet-v1";
var basicPasswordHashingOptions = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function isDerivationJson(thing) {
  if (!utils.isNonNullObject(thing))
    return false;
  if (typeof thing.hdPath !== "string")
    return false;
  if (typeof thing.prefix !== "string")
    return false;
  return true;
}
var defaultOptions = {
  bip39Password: "",
  hdPaths: [amino.makeCosmoshubPath(0)],
  prefix: "cosmos"
};
var SignArbSecp256k1HdWallet = class {
  /** Base secret */
  secret;
  /** BIP39 seed */
  seed;
  /** Derivation instructions */
  accounts;
  constructor(mnemonic, options) {
    const prefix = options.prefix ?? defaultOptions.prefix;
    const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
    this.secret = mnemonic;
    this.seed = options.seed;
    this.accounts = hdPaths.map((hdPath) => ({
      hdPath,
      prefix
    }));
  }
  static async fromMnemonic(mnemonic, options = {}) {
    const mnemonicChecked = new crypto.EnglishMnemonic(mnemonic);
    const seed = await crypto.Bip39.mnemonicToSeed(
      mnemonicChecked,
      options.bip39Password
    );
    return new SignArbSecp256k1HdWallet(mnemonicChecked, {
      ...options,
      seed
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(length = 12, options = {}) {
    const entropyLength = 4 * Math.floor(11 * length / 33);
    const entropy = crypto.Random.getBytes(entropyLength);
    const mnemonic = crypto.Bip39.encode(entropy);
    return this.fromMnemonic(mnemonic.toString(), options);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password - The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(serialization, password) {
    const root = JSON.parse(serialization);
    if (!utils.isNonNullObject(root))
      throw new Error("Root document is not an object.");
    if (root.type === serializationTypeV1) {
      return this.deserializeTypeV1(serialization, password);
    }
    throw new Error("Unsupported serialization type");
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(serialization, encryptionKey) {
    const root = JSON.parse(serialization);
    if (!utils.isNonNullObject(root))
      throw new Error("Root document is not an object.");
    const untypedRoot = root;
    switch (untypedRoot.type) {
      case serializationTypeV1: {
        const decryptedBytes = await wallet.decrypt(
          encoding.fromBase64(untypedRoot.data),
          encryptionKey,
          untypedRoot.encryption
        );
        const decryptedDocument = JSON.parse(encoding.fromUtf8(decryptedBytes));
        const { mnemonic, accounts } = decryptedDocument;
        utils.assert(typeof mnemonic.data === "string");
        if (!Array.isArray(accounts))
          throw new Error("Property 'accounts' is not an array");
        if (!accounts.every((account) => isDerivationJson(account))) {
          throw new Error("Account is not in the correct format.");
        }
        const firstPrefix = accounts[0].prefix;
        if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
          throw new Error("Accounts do not all have the same prefix");
        }
        const hdPaths = accounts.map(
          ({ hdPath }) => crypto.stringToPath(hdPath)
        );
        return this.fromMnemonic(mnemonic.data, {
          hdPaths,
          prefix: firstPrefix
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(serialization, password) {
    const root = JSON.parse(serialization);
    if (!utils.isNonNullObject(root))
      throw new Error("Root document is not an object.");
    const encryptionKey = await wallet.executeKdf(password, root.kdf);
    return this.deserializeWithEncryptionKey(serialization, encryptionKey);
  }
  async getKeyPair(hdPath) {
    const { privkey } = crypto.Slip10.derivePath(
      crypto.Slip10Curve.Secp256k1,
      this.seed,
      hdPath
    );
    const { pubkey } = await crypto.Secp256k1.makeKeypair(privkey);
    return {
      privkey,
      pubkey: crypto.Secp256k1.compressPubkey(pubkey)
    };
  }
  async executeKdf(password, configuration) {
    switch (configuration.algorithm) {
      case "argon2id": {
        const options = configuration.params;
        if (!crypto.isArgon2idOptions(options))
          throw new Error("Invalid format of argon2id params");
        return crypto.Argon2id.execute(password, wallet.cosmjsSalt, options);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(password) {
    const kdfConfiguration = basicPasswordHashingOptions;
    const encryptionKey = await this.executeKdf(password, kdfConfiguration);
    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
    const dataToEncrypt = {
      mnemonic: this.secret,
      accounts: this.accounts.map(({ hdPath, prefix }) => ({
        hdPath: crypto.pathToString(hdPath),
        prefix
      }))
    };
    const dataToEncryptRaw = encoding.toUtf8(JSON.stringify(dataToEncrypt));
    const encryptionConfiguration = {
      algorithm: wallet.supportedAlgorithms.xchacha20poly1305Ietf
    };
    const encryptedData = await wallet.encrypt(
      dataToEncryptRaw,
      encryptionKey,
      encryptionConfiguration
    );
    const out = {
      type: serializationTypeV1,
      kdf: kdfConfiguration,
      encryption: encryptionConfiguration,
      data: encoding.toBase64(encryptedData)
    };
    return JSON.stringify(out);
  }
  async getAccounts() {
    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
    return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
      algo,
      pubkey,
      address
    }));
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(
      this.accounts.map(async ({ hdPath, prefix }) => {
        const { privkey, pubkey } = await this.getKeyPair(hdPath);
        const address = encoding.toBech32(
          prefix,
          amino.rawSecp256k1PubkeyToRawAddress(pubkey)
        );
        return {
          algo: "secp256k1",
          privkey,
          pubkey,
          address
        };
      })
    );
  }
  async signDirect(signerAddress, signDoc) {
    const accounts = await this.getAccountsWithPrivkeys();
    const account = accounts.find(({ address }) => address === signerAddress);
    if (account === void 0) {
      throw new Error(`Address ${signerAddress} not found in wallet`);
    }
    const { privkey, pubkey } = account;
    const signBytes = protoSigning.makeSignBytes(signDoc);
    const hashedMessage = crypto.sha256(signBytes);
    const signature = await crypto.Secp256k1.createSignature(hashedMessage, privkey);
    const signatureBytes = new Uint8Array([
      ...signature.r(32),
      ...signature.s(32)
    ]);
    const stdSignature = amino.encodeSecp256k1Signature(pubkey, signatureBytes);
    return {
      signed: signDoc,
      signature: stdSignature
    };
  }
  signArb = async (signerAddress, message) => {
    const accounts = await this.getAccountsWithPrivkeys();
    const account = accounts.find(({ address }) => address === signerAddress);
    if (account === void 0) {
      throw new Error(`Address ${signerAddress} not found in wallet`);
    }
    const { privkey } = account;
    const signDoc = cosmos.makeADR36AminoSignDoc(signerAddress, message);
    const serializedSignDoc = cosmos.serializeSignDoc(signDoc);
    const digest = crypto$1.Hash.sha256(serializedSignDoc);
    const cryptoPrivKey = new crypto$1.PrivKeySecp256k1(privkey);
    const signature = cryptoPrivKey.signDigest32(digest);
    return buffer.Buffer.from(
      new Uint8Array([...signature.r, ...signature.s])
    ).toString("base64");
  };
};

// src/AbstraxionAuth.ts
var AbstraxionAuth = class {
  // Config
  rpcUrl;
  restUrl;
  grantContracts;
  stake;
  bank;
  callbackUrl;
  treasury;
  // Signer
  client;
  // Accounts
  abstractAccount;
  // State
  isLoginInProgress = false;
  isLoggedIn = false;
  authStateChangeSubscribers = [];
  /**
   * Creates an instance of the AbstraxionAuth class.
   */
  constructor() {
  }
  /**
   * Updates AbstraxionAuth instance with user config
   *
   * @param {string} rpc - The RPC URL used for communication with the blockchain.
   * @param {string} [restUrl] - The REST URL used for additional communication.
   * @param {ContractGrantDescription[]} [grantContracts] - Contracts for granting permissions.
   * @param {boolean} [stake] - Indicates whether staking is enabled.
   * @param {SpendLimit[]} [bank] - The spend limits for the user.
   * @param {string} callbackUrl - preferred callback url to override default
   * @param {string} treasury - treasury contract instance address
   */
  configureAbstraxionInstance(rpc, restUrl, grantContracts, stake, bank, callbackUrl, treasury) {
    this.rpcUrl = rpc;
    this.restUrl = restUrl;
    this.grantContracts = grantContracts;
    this.stake = stake;
    this.bank = bank;
    this.callbackUrl = callbackUrl;
    this.treasury = treasury;
  }
  /**
   * Subscribes to changes in authentication state.
   * When the authentication state changes, the provided callback function is invoked
   * with the new authentication state (isLoggedIn).
   * Returns an unsubscribe function that can be called to remove the subscription.
   *
   * @param {function} callback - A function to be invoked when the authentication state changes.
   *                             Receives a single parameter, isLoggedIn, indicating whether the user is logged in.
   *                             The callback should accept a boolean parameter.
   * @returns {function} - A function that, when called, removes the subscription to authentication state changes.
   *                      This function should be invoked to clean up the subscription when no longer needed.
   */
  subscribeToAuthStateChange(callback) {
    this.authStateChangeSubscribers.push(callback);
    return () => {
      const index = this.authStateChangeSubscribers.indexOf(callback);
      if (index !== -1) {
        this.authStateChangeSubscribers.splice(index, 1);
      }
    };
  }
  /**
   * Triggers a change in authentication state and notifies all subscribers.
   *
   * @param {boolean} isLoggedIn - The new authentication state, indicating whether the user is logged in.
   */
  triggerAuthStateChange(isLoggedIn) {
    this.isLoggedIn = isLoggedIn;
    this.authStateChangeSubscribers.forEach((callback) => callback(isLoggedIn));
  }
  /**
   * Get the account address of the granter from persisted state.
   *
   * @returns {string} The account address of the granter wallet (XION Meta Account).
   */
  getGranter() {
    const granterAddress = localStorage.getItem("xion-authz-granter-account");
    if (!granterAddress || granterAddress === void 0 || granterAddress === "undefined") {
      return "";
    }
    return granterAddress;
  }
  /**
   * Remove persisted instance of granter account.
   */
  removeGranterAddress() {
    localStorage.removeItem("xion-authz-granter-account");
  }
  /**
   * Set a persisted instance for granter account.
   *
   * @param {string} address - account address of the granter wallet (XION Meta Account).
   */
  setGranter(address) {
    localStorage.setItem("xion-authz-granter-account", address);
  }
  /**
   * Get temp keypair from persisted state.
   */
  async getLocalKeypair() {
    const localKeypair = localStorage.getItem("xion-authz-temp-account");
    if (!localKeypair) {
      return void 0;
    }
    return await SignArbSecp256k1HdWallet.deserialize(
      localKeypair,
      "abstraxion"
    );
  }
  /**
   * Generate a new temp keypair and store in persisted state.
   */
  async generateAndStoreTempAccount() {
    const keypair = await SignArbSecp256k1HdWallet.generate(12, {
      prefix: "xion"
    });
    const serializedKeypair = await keypair.serialize("abstraxion");
    localStorage.setItem("xion-authz-temp-account", serializedKeypair);
    this.removeGranterAddress();
    return keypair;
  }
  /**
   * Get keypair account address.
   */
  async getKeypairAddress() {
    const keypair = await this.getLocalKeypair();
    if (!keypair)
      return "";
    const accounts = await keypair.getAccounts();
    const address = accounts[0].address;
    return address;
  }
  /**
   * Get GranteeSignerClient for the temp keypair.
   */
  async getSigner() {
    try {
      if (this.client) {
        return this.client;
      }
      if (!this.rpcUrl) {
        throw new Error("Configuration not initialized");
      }
      if (!this.abstractAccount) {
        throw new Error("No account found.");
      }
      const granterAddress = this.getGranter();
      if (!granterAddress) {
        throw new Error("No granter found.");
      }
      const granteeAddress = await this.abstractAccount.getAccounts().then((accounts) => {
        if (accounts.length === 0) {
          throw new Error("No account found.");
        }
        return accounts[0].address;
      });
      const directClient = await GranteeSignerClient.connectWithSigner(
        this.rpcUrl,
        this.abstractAccount,
        {
          gasPrice: stargate.GasPrice.fromString("0uxion"),
          granterAddress,
          granteeAddress,
          treasuryAddress: this.treasury
        }
      );
      this.client = directClient;
      return directClient;
    } catch (error) {
      console.warn("Something went wrong getting signer: ", error);
      this.client = void 0;
      throw error;
    }
  }
  /**
   * Get dashboard url and redirect in order to issue claim with XION meta account for local keypair.
   */
  async redirectToDashboard() {
    try {
      if (!this.rpcUrl) {
        throw new Error("AbstraxionAuth needs to be configured.");
      }
      const userAddress = await this.getKeypairAddress();
      const { dashboardUrl } = await constants.fetchConfig(this.rpcUrl);
      this.configureUrlAndRedirect(dashboardUrl, userAddress);
    } catch (error) {
      console.warn(
        "Something went wrong trying to redirect to XION dashboard: ",
        error
      );
    }
  }
  /**
   * Configure URL and redirect page
   */
  configureUrlAndRedirect(dashboardUrl, userAddress) {
    if (typeof window !== "undefined") {
      const currentUrl = this.callbackUrl || window.location.href;
      const urlParams = new URLSearchParams();
      if (this.treasury) {
        urlParams.set("treasury", this.treasury);
      }
      if (this.bank) {
        urlParams.set("bank", JSON.stringify(this.bank));
      }
      if (this.stake) {
        urlParams.set("stake", "true");
      }
      if (this.grantContracts) {
        urlParams.set("contracts", JSON.stringify(this.grantContracts));
      }
      urlParams.set("grantee", userAddress);
      urlParams.set("redirect_uri", currentUrl);
      const queryString = urlParams.toString();
      window.location.href = `${dashboardUrl}?${queryString}`;
    } else {
      console.warn("Window not defined. Cannot redirect to dashboard");
    }
  }
  /**
   * Poll for grants issued to a grantee from a granter.
   *
   * @param {string} grantee - The address of the grantee.
   * @param {string | null} granter - The address of the granter, or null if not available.
   * @returns {Promise<boolean>} A Promise that resolves to true if grants are found, otherwise false.
   * @throws {Error} If the grantee or granter address is invalid, or if maximum retries are exceeded.
   */
  async pollForGrants(grantee, granter) {
    if (!this.rpcUrl) {
      throw new Error("AbstraxionAuth needs to be configured.");
    }
    if (!grantee) {
      throw new Error("No keypair address");
    }
    if (!granter) {
      throw new Error("No granter address");
    }
    const pollBaseUrl = this.restUrl || (await constants.fetchConfig(this.rpcUrl)).restUrl;
    const maxRetries = 5;
    let retries = 0;
    while (retries < maxRetries) {
      try {
        const baseUrl = `${pollBaseUrl}/cosmos/authz/v1beta1/grants`;
        const url = new URL(baseUrl);
        const params = new URLSearchParams({
          grantee,
          granter
        });
        url.search = params.toString();
        const res = await fetch(url, {
          cache: "no-store"
        });
        const data = await res.json();
        if (data.grants.length === 0) {
          console.warn("No grants found.");
          return false;
        }
        const currentTime = (/* @__PURE__ */ new Date()).toISOString();
        const validGrant = data.grants.some((grant) => {
          const { expiration } = grant;
          return !expiration || expiration > currentTime;
        });
        return validGrant;
      } catch (error) {
        console.warn("Error fetching grants: ", error);
        const delay = Math.pow(2, retries) * 1e3;
        await new Promise((resolve) => setTimeout(resolve, delay));
        retries++;
      }
    }
    console.error("Max retries exceeded, giving up.");
    return false;
  }
  /**
   * Wipe persisted state and instance variables.
   */
  logout() {
    localStorage.removeItem("xion-authz-temp-account");
    localStorage.removeItem("xion-authz-granter-account");
    this.abstractAccount = void 0;
    this.triggerAuthStateChange(false);
  }
  /**
   * Authenticates the user based on the presence of a local keypair and a granter address.
   * Also checks if the grant is still valid by verifying the expiration.
   * If valid, sets the abstract account and triggers authentication state change.
   * If expired, clears local state and prompts reauthorization.
   *
   * @returns {Promise<void>} - Resolves if authentication is successful or logs out the user otherwise.
   */
  async authenticate() {
    try {
      const keypair = await this.getLocalKeypair();
      const granter = this.getGranter();
      if (!keypair || !granter) {
        console.warn("Missing keypair or granter, cannot authenticate.");
        return;
      }
      const accounts = await keypair.getAccounts();
      const keypairAddress = accounts[0].address;
      const isGrantValid = await this.pollForGrants(keypairAddress, granter);
      if (isGrantValid) {
        this.abstractAccount = keypair;
        this.triggerAuthStateChange(true);
      } else {
        throw new Error("Grant expired or not found. Logging out.");
      }
    } catch (error) {
      console.error("Error during authentication:", error);
      this.logout();
    }
  }
  /**
   * Initiates the login process for the user.
   * Checks if a local keypair and granter address exist, either from URL parameters or localStorage.
   * If both exist, polls for grants and updates the authentication state if successful.
   * If not, generates a new keypair and redirects to the dashboard for grant issuance.
   *
   * @returns {Promise<void>} - A Promise that resolves once the login process is complete.
   * @throws {Error} - If the login process encounters an error.
   */
  async login() {
    try {
      if (this.isLoginInProgress) {
        console.warn("Login is already in progress.");
        return;
      }
      this.isLoginInProgress = true;
      const keypair = await this.getLocalKeypair();
      const searchParams = new URLSearchParams(window.location.search);
      const granter = this.getGranter() || searchParams.get("granter");
      if (keypair && granter) {
        const accounts = await keypair.getAccounts();
        const keypairAddress = accounts[0].address;
        const pollSuccess = await this.pollForGrants(keypairAddress, granter);
        if (!pollSuccess) {
          throw new Error("Poll was unsuccessful. Please try again");
        }
        this.setGranter(granter);
        this.abstractAccount = keypair;
        this.triggerAuthStateChange(true);
        if (typeof window !== void 0) {
          const currentUrl = new URL(window.location.href);
          currentUrl.searchParams.delete("granted");
          currentUrl.searchParams.delete("granter");
          history.pushState({}, "", currentUrl.href);
        }
      } else {
        await this.newKeypairFlow();
      }
      return;
    } catch (error) {
      console.warn("Something went wrong: ", error);
      throw error;
    } finally {
      this.isLoginInProgress = false;
    }
  }
  /**
   * Initiates the flow to generate a new keypair and redirect to the dashboard for grant issuance.
   */
  async newKeypairFlow() {
    try {
      await this.generateAndStoreTempAccount();
      await this.redirectToDashboard();
    } catch (error) {
      console.warn("Something went wrong: ", error);
      throw error;
    }
  }
};

exports.AbstraxionAuth = AbstraxionAuth;
exports.GranteeSignerClient = GranteeSignerClient;
exports.SignArbSecp256k1HdWallet = SignArbSecp256k1HdWallet;
