import { SigningCosmWasmClient, SigningCosmWasmClientOptions, DeliverTxResponse } from '@cosmjs/cosmwasm-stargate';
import { AccountData, OfflineSigner, EncodeObject } from '@cosmjs/proto-signing';
import { Account, StdFee, SignerData } from '@cosmjs/stargate';
import { TxRaw, SignDoc } from 'cosmjs-types/cosmos/tx/v1beta1/tx';
import { HttpEndpoint, TendermintClient } from '@cosmjs/tendermint-rpc';
import * as _cosmjs_amino from '@cosmjs/amino';
import { KdfConfiguration } from '@cosmjs/amino';
import { EnglishMnemonic, HdPath } from '@cosmjs/crypto';

interface GranteeSignerOptions {
    readonly granterAddress: string;
    readonly granteeAddress: string;
    readonly treasuryAddress?: string;
}
declare class GranteeSignerClient extends SigningCosmWasmClient {
    protected readonly granterAddress: string;
    private readonly _granteeAddress;
    private readonly _signer;
    private readonly _gasPrice?;
    private readonly _treasury?;
    private readonly _defaultGasMultiplier;
    get granteeAddress(): string;
    getGranteeAccountData(): Promise<AccountData | undefined>;
    static connectWithSigner(endpoint: string | HttpEndpoint, signer: OfflineSigner, options: SigningCosmWasmClientOptions & GranteeSignerOptions): Promise<GranteeSignerClient>;
    static createWithSigner(cometClient: TendermintClient, signer: OfflineSigner, options: SigningCosmWasmClientOptions & GranteeSignerOptions): Promise<GranteeSignerClient>;
    protected constructor(cometClient: TendermintClient | undefined, signer: OfflineSigner, { granterAddress, granteeAddress, gasPrice, treasuryAddress, ...options }: SigningCosmWasmClientOptions & GranteeSignerOptions);
    getAccount(searchAddress: string): Promise<Account | null>;
    signAndBroadcast(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee | "auto" | number, memo?: string): Promise<DeliverTxResponse>;
    sign(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee, memo: string, explicitSignerData?: SignerData): Promise<TxRaw>;
}

type SpendLimit = {
    denom: string;
    amount: string;
};
type ContractGrantDescription = string | {
    address: string;
    amounts: SpendLimit[];
};

interface DirectSecp256k1HdWalletOptions {
    /** The password to use when deriving a BIP39 seed from a mnemonic. */
    readonly bip39Password: string;
    /** The BIP-32/SLIP-10 derivation paths. Defaults to the Cosmos Hub/ATOM path `m/44'/118'/0'/0/0`. */
    readonly hdPaths: readonly HdPath[];
    /** The bech32 address prefix (human readable part). Defaults to "cosmos". */
    readonly prefix: string;
}
interface DirectSecp256k1HdWalletConstructorOptions extends Partial<DirectSecp256k1HdWalletOptions> {
    readonly seed: Uint8Array;
}
declare class SignArbSecp256k1HdWallet {
    /** Base secret */
    private readonly secret;
    /** BIP39 seed */
    private readonly seed;
    /** Derivation instructions */
    private readonly accounts;
    protected constructor(mnemonic: EnglishMnemonic, options: DirectSecp256k1HdWalletConstructorOptions);
    static fromMnemonic(mnemonic: string, options?: Partial<DirectSecp256k1HdWalletOptions>): Promise<SignArbSecp256k1HdWallet>;
    /**
     * Generates a new wallet with a BIP39 mnemonic of the given length.
     *
     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
     */
    static generate(length?: number, options?: {}): Promise<SignArbSecp256k1HdWallet>;
    /**
     * Restores a wallet from an encrypted serialization.
     *
     * @param password - The user provided password used to generate an encryption key via a KDF.
     *                 This is not normalized internally (see "Unicode normalization" to learn more).
     */
    static deserialize(serialization: string, password: string): Promise<SignArbSecp256k1HdWallet>;
    /**
     * Restores a wallet from an encrypted serialization.
     *
     * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
     * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
     *
     * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
     * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
     */
    static deserializeWithEncryptionKey(serialization: string, encryptionKey: Uint8Array): Promise<SignArbSecp256k1HdWallet>;
    private static deserializeTypeV1;
    private getKeyPair;
    executeKdf(password: string, configuration: KdfConfiguration): Promise<Uint8Array>;
    /**
     * Generates an encrypted serialization of this wallet.
     *
     * @param password The user provided password used to generate an encryption key via a KDF.
     *                 This is not normalized internally (see "Unicode normalization" to learn more).
     */
    serialize(password: string): Promise<string>;
    /**
     * Generates an encrypted serialization of this wallet.
     *
     * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
     * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
     *
     * The caller is responsible for ensuring the key was derived with the given KDF options. If this
     * is not the case, the wallet cannot be restored with the original password.
     */
    serializeWithEncryptionKey(encryptionKey: Uint8Array, kdfConfiguration: KdfConfiguration): Promise<string>;
    getAccounts(): Promise<readonly AccountData[]>;
    private getAccountsWithPrivkeys;
    signDirect(signerAddress: string, signDoc: SignDoc): Promise<{
        signed: SignDoc;
        signature: _cosmjs_amino.StdSignature;
    }>;
    signArb: (signerAddress: string, message: string | Uint8Array) => Promise<string>;
}

declare class AbstraxionAuth {
    private rpcUrl?;
    private restUrl?;
    grantContracts?: ContractGrantDescription[];
    stake?: boolean;
    bank?: SpendLimit[];
    callbackUrl?: string;
    treasury?: string;
    private client?;
    abstractAccount?: SignArbSecp256k1HdWallet;
    private isLoginInProgress;
    isLoggedIn: boolean;
    authStateChangeSubscribers: ((isLoggedIn: boolean) => void)[];
    /**
     * Creates an instance of the AbstraxionAuth class.
     */
    constructor();
    /**
     * Updates AbstraxionAuth instance with user config
     *
     * @param {string} rpc - The RPC URL used for communication with the blockchain.
     * @param {string} [restUrl] - The REST URL used for additional communication.
     * @param {ContractGrantDescription[]} [grantContracts] - Contracts for granting permissions.
     * @param {boolean} [stake] - Indicates whether staking is enabled.
     * @param {SpendLimit[]} [bank] - The spend limits for the user.
     * @param {string} callbackUrl - preferred callback url to override default
     * @param {string} treasury - treasury contract instance address
     */
    configureAbstraxionInstance(rpc: string, restUrl?: string, grantContracts?: ContractGrantDescription[], stake?: boolean, bank?: SpendLimit[], callbackUrl?: string, treasury?: string): void;
    /**
     * Subscribes to changes in authentication state.
     * When the authentication state changes, the provided callback function is invoked
     * with the new authentication state (isLoggedIn).
     * Returns an unsubscribe function that can be called to remove the subscription.
     *
     * @param {function} callback - A function to be invoked when the authentication state changes.
     *                             Receives a single parameter, isLoggedIn, indicating whether the user is logged in.
     *                             The callback should accept a boolean parameter.
     * @returns {function} - A function that, when called, removes the subscription to authentication state changes.
     *                      This function should be invoked to clean up the subscription when no longer needed.
     */
    subscribeToAuthStateChange(callback: (isLoggedIn: boolean) => void): () => void;
    /**
     * Triggers a change in authentication state and notifies all subscribers.
     *
     * @param {boolean} isLoggedIn - The new authentication state, indicating whether the user is logged in.
     */
    private triggerAuthStateChange;
    /**
     * Get the account address of the granter from persisted state.
     *
     * @returns {string} The account address of the granter wallet (XION Meta Account).
     */
    getGranter(): string;
    /**
     * Remove persisted instance of granter account.
     */
    private removeGranterAddress;
    /**
     * Set a persisted instance for granter account.
     *
     * @param {string} address - account address of the granter wallet (XION Meta Account).
     */
    private setGranter;
    /**
     * Get temp keypair from persisted state.
     */
    getLocalKeypair(): Promise<SignArbSecp256k1HdWallet | undefined>;
    /**
     * Generate a new temp keypair and store in persisted state.
     */
    generateAndStoreTempAccount(): Promise<SignArbSecp256k1HdWallet>;
    /**
     * Get keypair account address.
     */
    getKeypairAddress(): Promise<string>;
    /**
     * Get GranteeSignerClient for the temp keypair.
     */
    getSigner(): Promise<GranteeSignerClient>;
    /**
     * Get dashboard url and redirect in order to issue claim with XION meta account for local keypair.
     */
    redirectToDashboard(): Promise<void>;
    /**
     * Configure URL and redirect page
     */
    private configureUrlAndRedirect;
    /**
     * Poll for grants issued to a grantee from a granter.
     *
     * @param {string} grantee - The address of the grantee.
     * @param {string | null} granter - The address of the granter, or null if not available.
     * @returns {Promise<boolean>} A Promise that resolves to true if grants are found, otherwise false.
     * @throws {Error} If the grantee or granter address is invalid, or if maximum retries are exceeded.
     */
    pollForGrants(grantee: string, granter: string | null): Promise<boolean>;
    /**
     * Wipe persisted state and instance variables.
     */
    logout(): void;
    /**
     * Authenticates the user based on the presence of a local keypair and a granter address.
     * Also checks if the grant is still valid by verifying the expiration.
     * If valid, sets the abstract account and triggers authentication state change.
     * If expired, clears local state and prompts reauthorization.
     *
     * @returns {Promise<void>} - Resolves if authentication is successful or logs out the user otherwise.
     */
    authenticate(): Promise<void>;
    /**
     * Initiates the login process for the user.
     * Checks if a local keypair and granter address exist, either from URL parameters or localStorage.
     * If both exist, polls for grants and updates the authentication state if successful.
     * If not, generates a new keypair and redirects to the dashboard for grant issuance.
     *
     * @returns {Promise<void>} - A Promise that resolves once the login process is complete.
     * @throws {Error} - If the login process encounters an error.
     */
    login(): Promise<void>;
    /**
     * Initiates the flow to generate a new keypair and redirect to the dashboard for grant issuance.
     */
    private newKeypairFlow;
}

export { AbstraxionAuth, GranteeSignerClient, SignArbSecp256k1HdWallet };
